<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bab02d231d5aec93aaadb604dc2b42a8f41da793</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>教程 - Azure  批处理( Batch ) .NET 库入门</source>
          <target state="new">教程 - Azure  批处理( Batch ) .NET 库入门</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解 Azure  批处理( Batch )的基本概念，以及如何使用一个简单方案开发 批处理( Batch )服务</source>
          <target state="new">了解 Azure  批处理( Batch )的基本概念，以及如何使用一个简单方案开发 批处理( Batch )服务</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>适用于 .NET 的 Azure 批处理 ( Batch )库入门</source>
          <target state="new">适用于 .NET 的 Azure 批处理 ( Batch )库入门</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>逐步演示 C# 示例应用程序如何利用 Batch 服务来处理云中的并行工作负荷，以及如何与 <bpt id="p1">[</bpt>Azure 存储空间<ept id="p1">](/documentation/articles/storage-introduction)</ept>交互来暂存和检索文件，从而让你了解 <bpt id="p2">[</bpt>Azure Batch<ept id="p2">][azure_batch]</ept> 和 <bpt id="p3">[</bpt>Batch .NET<ept id="p3">][net_api]</ept> 库的基础知识。了解常见的 Batch 应用程序工作流技术，并基本了解 Batch 的主要组件，例如作业、任务、池和计算节点。</source>
          <target state="new">逐步演示 C# 示例应用程序如何利用 Batch 服务来处理云中的并行工作负荷，以及如何与 <bpt id="p1">[</bpt>Azure 存储空间<ept id="p1">](/documentation/articles/storage-introduction)</ept>交互来暂存和检索文件，从而让你了解 <bpt id="p2">[</bpt>Azure Batch<ept id="p2">][azure_batch]</ept> 和 <bpt id="p3">[</bpt>Batch .NET<ept id="p3">][net_api]</ept> 库的基础知识。了解常见的 Batch 应用程序工作流技术，并基本了解 Batch 的主要组件，例如作业、任务、池和计算节点。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Batch 解决方案工作流（精简）</source>
          <target state="new">Batch 解决方案工作流（精简）</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>先决条件</source>
          <target state="new">先决条件</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>本文假设你已具备 C# 和 Visual Studio 的实践知识，并且你满足下面针对 Azure Batch 和存储服务指定的帐户创建要求。</source>
          <target state="new">本文假设你已具备 C# 和 Visual Studio 的实践知识，并且你满足下面针对 Azure Batch 和存储服务指定的帐户创建要求。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>帐户</source>
          <target state="new">帐户</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Azure 订阅<ept id="p1">**</ept> - 如果你没有 Azure 订阅，只需几分钟就可以通过 <bpt id="p2">[</bpt>Azure 免费试用<ept id="p2">](/pricing/free-trial/)</ept>创建一个免费试用帐户。</source>
          <target state="new"><bpt id="p1">**</bpt>Azure 订阅<ept id="p1">**</ept> - 如果你没有 Azure 订阅，只需几分钟就可以通过 <bpt id="p2">[</bpt>Azure 免费试用<ept id="p2">](/pricing/free-trial/)</ept>创建一个免费试用帐户。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Batch 帐户<ept id="p1">**</ept> - 获取 Azure 订阅后，请参阅<bpt id="p2">[</bpt>创建和管理 Azure Batch 帐户<ept id="p2">](/documentation/articles/batch-account-create-portal)</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>Batch 帐户<ept id="p1">**</ept> - 获取 Azure 订阅后，请参阅<bpt id="p2">[</bpt>创建和管理 Azure Batch 帐户<ept id="p2">](/documentation/articles/batch-account-create-portal)</ept>。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>存储帐户<ept id="p1">**</ept> - 请参阅<bpt id="p2">[</bpt>关于 Azure 存储帐户<ept id="p2">](/documentation/articles/storage-create-storage-account)</ept>中的 <bpt id="p3">*</bpt>创建存储帐户<ept id="p3">*</ept> 部分。</source>
          <target state="new"><bpt id="p1">**</bpt>存储帐户<ept id="p1">**</ept> - 请参阅<bpt id="p2">[</bpt>关于 Azure 存储帐户<ept id="p2">](/documentation/articles/storage-create-storage-account)</ept>中的 <bpt id="p3">*</bpt>创建存储帐户<ept id="p3">*</ept> 部分。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Visual Studio</source>
          <target state="new">Visual Studio</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>必须拥有 <bpt id="p1">**</bpt>Visual Studio 2013 或更高版本<ept id="p1">**</ept>才能构建示例项目。可以在 <bpt id="p2">[</bpt>Visual Studio 2015 产品概述<ept id="p2">][visual_studio]</ept>中找到免费试用版的 Visual Studio。</source>
          <target state="new">必须拥有 <bpt id="p1">**</bpt>Visual Studio 2013 或更高版本<ept id="p1">**</ept>才能构建示例项目。可以在 <bpt id="p2">[</bpt>Visual Studio 2015 产品概述<ept id="p2">][visual_studio]</ept>中找到免费试用版的 Visual Studio。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 代码示例</source>
          <target state="new"><bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 代码示例</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>DotNetTutorial<ept id="p1">][github_dotnettutorial]</ept> 示例是 GitHub 上的 <bpt id="p2">[</bpt>azure-batch-samples<ept id="p2">][github_samples]</ept> 存储库中提供的众多代码示例之一。单击存储库主页上的“下载 ZIP”按钮，或单击“azure-batch-samples-master.zip”直接下载链接即可下载该示例。<bpt id="p3">[</bpt><ept id="p3">][github_samples_zip]</ept>将 ZIP 文件的内容解压缩后，可在以下文件夹中找到该解决方案：</source>
          <target state="new"><bpt id="p1">[</bpt>DotNetTutorial<ept id="p1">][github_dotnettutorial]</ept> 示例是 GitHub 上的 <bpt id="p2">[</bpt>azure-batch-samples<ept id="p2">][github_samples]</ept> 存储库中提供的众多代码示例之一。单击存储库主页上的“下载 ZIP”按钮，或单击“azure-batch-samples-master.zip”直接下载链接即可下载该示例。<bpt id="p3">[</bpt><ept id="p3">][github_samples_zip]</ept>将 ZIP 文件的内容解压缩后，可在以下文件夹中找到该解决方案：</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Azure Batch 资源管理器（可选）</source>
          <target state="new">Azure Batch 资源管理器（可选）</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Azure Batch 资源管理器<ept id="p1">][github_batchexplorer]</ept>是 GitHub 上的 <bpt id="p2">[</bpt>azure-batch-samples<ept id="p2">][github_samples]</ept> 存储库随附的免费实用程序。尽管完成本教程不要求使用 Batch 资源管理器，但我们强烈建议使用它来调试和管理 Batch 帐户中的实体。你可以在 <bpt id="p3">[</bpt>Azure Batch 资源管理器示例演练<ept id="p3">][batch_explorer_blog]</ept>博客文章中了解有关旧版 Batch 资源管理器的信息。</source>
          <target state="new"><bpt id="p1">[</bpt>Azure Batch 资源管理器<ept id="p1">][github_batchexplorer]</ept>是 GitHub 上的 <bpt id="p2">[</bpt>azure-batch-samples<ept id="p2">][github_samples]</ept> 存储库随附的免费实用程序。尽管完成本教程不要求使用 Batch 资源管理器，但我们强烈建议使用它来调试和管理 Batch 帐户中的实体。你可以在 <bpt id="p3">[</bpt>Azure Batch 资源管理器示例演练<ept id="p3">][batch_explorer_blog]</ept>博客文章中了解有关旧版 Batch 资源管理器的信息。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>DotNetTutorial 示例项目概述</source>
          <target state="new">DotNetTutorial 示例项目概述</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 代码示例是由以下两个项目组成的 Visual Studio 2013 解决方案：<bpt id="p2">**</bpt>DotNetTutorial<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>TaskApplication<ept id="p3">**</ept>。</source>
          <target state="new"><bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 代码示例是由以下两个项目组成的 Visual Studio 2013 解决方案：<bpt id="p2">**</bpt>DotNetTutorial<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>TaskApplication<ept id="p3">**</ept>。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>DotNetTutorial<ept id="p1">**</ept> 是与 Batch 和存储服务交互，以在计算节点（虚拟机）上执行并行工作负荷的客户端应用程序。DotNetTutorial 在本地工作站上运行。</source>
          <target state="new"><bpt id="p1">**</bpt>DotNetTutorial<ept id="p1">**</ept> 是与 Batch 和存储服务交互，以在计算节点（虚拟机）上执行并行工作负荷的客户端应用程序。DotNetTutorial 在本地工作站上运行。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>TaskApplication<ept id="p1">**</ept> 是在 Azure 中的计算节点上运行以执行实际工作的可执行文件。在示例中，<ph id="ph1">`TaskApplication.exe`</ph> 将分析从 Azure 存储空间下载的文件（输入文件）中的文本，然后生成一个文本文件（输出文件），其中包含输入文件中最常出现的三个单词的列表。在创建输出文件后，TaskApplication 将该文件上载到 Azure 存储空间，以供客户端应用程序下载。TaskApplication 在 Batch 服务中的多个计算节点上并行运行。</source>
          <target state="new"><bpt id="p1">**</bpt>TaskApplication<ept id="p1">**</ept> 是在 Azure 中的计算节点上运行以执行实际工作的可执行文件。在示例中，<ph id="ph1">`TaskApplication.exe`</ph> 将分析从 Azure 存储空间下载的文件（输入文件）中的文本，然后生成一个文本文件（输出文件），其中包含输入文件中最常出现的三个单词的列表。在创建输出文件后，TaskApplication 将该文件上载到 Azure 存储空间，以供客户端应用程序下载。TaskApplication 在 Batch 服务中的多个计算节点上并行运行。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>下图演示了客户端应用程序 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 执行的主要操作，以及任务执行的应用程序 <bpt id="p2">*</bpt>TaskApplication<ept id="p2">*</ept> 。此基本工作流通常包括使用 Batch 创建的许多计算解决方案。尽管本教程并未演示 Batch 服务提供的每项功能，但几乎每个 Batch 方案都包含类似的过程。</source>
          <target state="new">下图演示了客户端应用程序 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 执行的主要操作，以及任务执行的应用程序 <bpt id="p2">*</bpt>TaskApplication<ept id="p2">*</ept> 。此基本工作流通常包括使用 Batch 创建的许多计算解决方案。尽管本教程并未演示 Batch 服务提供的每项功能，但几乎每个 Batch 方案都包含类似的过程。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Batch 示例工作流</source>
          <target state="new">Batch 示例工作流</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>1.<ept id="p1">**</ept> 在 Azure Blob 存储中创建<bpt id="p2">**</bpt>容器<ept id="p2">**</ept></source>
          <target state="new"><bpt id="p1">**</bpt>1.<ept id="p1">**</ept> 在 Azure Blob 存储中创建<bpt id="p2">**</bpt>容器<ept id="p2">**</ept></target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>2.<ept id="p1">**</ept> 将任务应用程序和输入文件上载到容器</source>
          <target state="new"><bpt id="p1">**</bpt>2.<ept id="p1">**</ept> 将任务应用程序和输入文件上载到容器</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>3.<ept id="p1">**</ept> 创建 Batch <bpt id="p2">**</bpt>池<ept id="p2">**</ept></source>
          <target state="new"><bpt id="p1">**</bpt>3.<ept id="p1">**</ept> 创建 Batch <bpt id="p2">**</bpt>池<ept id="p2">**</ept></target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bpt id="p1">**</bpt>3a.<ept id="p1">**</ept></source>
          <target state="new">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bpt id="p1">**</bpt>3a.<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>池 <bpt id="p1">**</bpt>StartTask<ept id="p1">**</ept> 在节点加入池时将任务二进制文件 (TaskApplication) 下载到节点</source>
          <target state="new">池 <bpt id="p1">**</bpt>StartTask<ept id="p1">**</ept> 在节点加入池时将任务二进制文件 (TaskApplication) 下载到节点</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>4.<ept id="p1">**</ept> 创建 Batch <bpt id="p2">**</bpt>作业<ept id="p2">**</ept></source>
          <target state="new"><bpt id="p1">**</bpt>4.<ept id="p1">**</ept> 创建 Batch <bpt id="p2">**</bpt>作业<ept id="p2">**</ept></target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>5.<ept id="p1">**</ept> 将<bpt id="p2">**</bpt>任务<ept id="p2">**</ept>添加到作业</source>
          <target state="new"><bpt id="p1">**</bpt>5.<ept id="p1">**</ept> 将<bpt id="p2">**</bpt>任务<ept id="p2">**</ept>添加到作业</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bpt id="p1">**</bpt>5a.<ept id="p1">**</ept></source>
          <target state="new">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bpt id="p1">**</bpt>5a.<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>任务计划在节点上执行</source>
          <target state="new">任务计划在节点上执行</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bpt id="p1">**</bpt>5b.<ept id="p1">**</ept></source>
          <target state="new">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bpt id="p1">**</bpt>5b.<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>每项任务从 Azure 存储空间下载其输入数据，然后开始执行</source>
          <target state="new">每项任务从 Azure 存储空间下载其输入数据，然后开始执行</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>6.<ept id="p1">**</ept> 监视任务</source>
          <target state="new"><bpt id="p1">**</bpt>6.<ept id="p1">**</ept> 监视任务</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bpt id="p1">**</bpt>6a.<ept id="p1">**</ept></source>
          <target state="new">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bpt id="p1">**</bpt>6a.<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>当任务完成时，会将其输出数据上载到 Azure 存储空间</source>
          <target state="new">当任务完成时，会将其输出数据上载到 Azure 存储空间</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>7.<ept id="p1">**</ept> 从存储空间下载任务输出</source>
          <target state="new"><bpt id="p1">**</bpt>7.<ept id="p1">**</ept> 从存储空间下载任务输出</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>如前所述，并非每个 Batch 解决方案都会确切地执行这些步骤，并且可能包含更多步骤，但 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 示例应用程序将演示 Batch 方案中的常见过程。</source>
          <target state="new">如前所述，并非每个 Batch 解决方案都会确切地执行这些步骤，并且可能包含更多步骤，但 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 示例应用程序将演示 Batch 方案中的常见过程。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>构建 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 示例项目</source>
          <target state="new">构建 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 示例项目</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>你必须先在 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 项目的 <ph id="ph1">`Program.cs`</ph> 文件中指定 Batch 和存储帐户凭据才能成功运行该示例。如果你尚未这样做，请双击 <ph id="ph2">`DotNetTutorial.sln`</ph> 解决方案文件，或者在 Visual Studio 中使用“文件”&gt;“打开”&gt;“项目/解决方案”菜单，以在 Visual Studio 中打开该解决方案。</source>
          <target state="new">你必须先在 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 项目的 <ph id="ph1">`Program.cs`</ph> 文件中指定 Batch 和存储帐户凭据才能成功运行该示例。如果你尚未这样做，请双击 <ph id="ph2">`DotNetTutorial.sln`</ph> 解决方案文件，或者在 Visual Studio 中使用“文件”&gt;“打开”&gt;“项目/解决方案”菜单，以在 Visual Studio 中打开该解决方案。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>打开 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 项目中的 <ph id="ph1">`Program.cs`</ph>，然后，根据文件顶部附近的指定内容添加你的凭据：</source>
          <target state="new">打开 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 项目中的 <ph id="ph1">`Program.cs`</ph>，然后，根据文件顶部附近的指定内容添加你的凭据：</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>可以在 <bpt id="p1">[</bpt>Azure 门户<ept id="p1">][azure_portal]</ept>中每个服务的帐户边栏选项卡中找到 Batch 和存储帐户凭据：</source>
          <target state="new">可以在 <bpt id="p1">[</bpt>Azure 门户<ept id="p1">][azure_portal]</ept>中每个服务的帐户边栏选项卡中找到 Batch 和存储帐户凭据：</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>门户中的 Batch 凭据</source>
          <target state="new">门户中的 Batch 凭据</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>门户中的存储空间凭据</source>
          <target state="new">门户中的存储空间凭据</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>使用凭据更新项目后，在“解决方案资源管理器”中右键单击该解决方案，然后单击“构建解决方案”。出现提示时，请确认还原任何 NuGet 包。</source>
          <target state="new">使用凭据更新项目后，在“解决方案资源管理器”中右键单击该解决方案，然后单击“构建解决方案”。出现提示时，请确认还原任何 NuGet 包。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> 如果未自动还原 NuGet 包，或者你看到了有关包还原失败的错误，请确保已安装 <bpt id="p1">[</bpt>NuGet 包管理器<ept id="p1">][nuget_packagemgr]</ept>，然后启用遗失包的下载。若要启用包下载，请参阅<bpt id="p2">[</bpt>在构建期间启用包还原<ept id="p2">][nuget_restore]</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> 如果未自动还原 NuGet 包，或者你看到了有关包还原失败的错误，请确保已安装 <bpt id="p1">[</bpt>NuGet 包管理器<ept id="p1">][nuget_packagemgr]</ept>，然后启用遗失包的下载。若要启用包下载，请参阅<bpt id="p2">[</bpt>在构建期间启用包还原<ept id="p2">][nuget_restore]</ept>。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>在以下部分中，我们将示例应用程序细分为用于处理 Batch 服务中工作负荷的多个步骤，并详细讨论这些步骤。建议你在学习本文的余下部分时参考 Visual Studio 中打开的解决方案，因为我们并不会讨论示例中的每一行代码。</source>
          <target state="new">在以下部分中，我们将示例应用程序细分为用于处理 Batch 服务中工作负荷的多个步骤，并详细讨论这些步骤。建议你在学习本文的余下部分时参考 Visual Studio 中打开的解决方案，因为我们并不会讨论示例中的每一行代码。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>导航到 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 项目的 <ph id="ph1">`Program.cs`</ph> 文件中 <ph id="ph2">`MainAsync`</ph> 方法的顶部，开始执行步骤 1。以下每个步骤大致遵循 <ph id="ph3">`MainAsync`</ph> 中方法调用的进度。</source>
          <target state="new">导航到 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 项目的 <ph id="ph1">`Program.cs`</ph> 文件中 <ph id="ph2">`MainAsync`</ph> 方法的顶部，开始执行步骤 1。以下每个步骤大致遵循 <ph id="ph3">`MainAsync`</ph> 中方法调用的进度。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>步骤 1：创建存储容器</source>
          <target state="new">步骤 1：创建存储容器</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>在 Azure 存储空间中创建容器</source>
          <target state="new">在 Azure 存储空间中创建容器</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Batch 包含与 Azure 存储空间进行交互的内置支持，存储帐户中的容器提供可在 Batch 帐户中运行的任务及其所需执行的文件，另外还提供一个位置用于存储任务生成的输出数据。 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 客户端应用程序首先在 <bpt id="p2">[</bpt>Azure Blob 存储<ept id="p2">](./../storage/storage-introduction.md)</ept>中创建三个容器：</source>
          <target state="new">Batch 包含与 Azure 存储空间进行交互的内置支持，存储帐户中的容器提供可在 Batch 帐户中运行的任务及其所需执行的文件，另外还提供一个位置用于存储任务生成的输出数据。 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 客户端应用程序首先在 <bpt id="p2">[</bpt>Azure Blob 存储<ept id="p2">](./../storage/storage-introduction.md)</ept>中创建三个容器：</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>应用程序<ept id="p1">**</ept> - 此容器用于容装任务所要运行的应用程序及其依赖项，例如 DLL。</source>
          <target state="new"><bpt id="p1">**</bpt>应用程序<ept id="p1">**</ept> - 此容器用于容装任务所要运行的应用程序及其依赖项，例如 DLL。</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>输入<ept id="p1">**</ept> - 任务将从 <bpt id="p2">*</bpt>输入<ept id="p2">*</ept> 容器下载所要处理的数据文件。</source>
          <target state="new"><bpt id="p1">**</bpt>输入<ept id="p1">**</ept> - 任务将从 <bpt id="p2">*</bpt>输入<ept id="p2">*</ept> 容器下载所要处理的数据文件。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>输出<ept id="p1">**</ept> - 当任务完成输入文件的处理时，会将其结果上载到 <bpt id="p2">*</bpt>输出<ept id="p2">*</ept> 容器。</source>
          <target state="new"><bpt id="p1">**</bpt>输出<ept id="p1">**</ept> - 当任务完成输入文件的处理时，会将其结果上载到 <bpt id="p2">*</bpt>输出<ept id="p2">*</ept> 容器。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>若要与存储帐户交互并创建容器，可以使用<bpt id="p1">[</bpt>适用于 .NET 的 Azure 存储空间客户端库<ept id="p1">][net_api_storage]</ept>来创建包含 <bpt id="p2">[</bpt>CloudStorageAccount<ept id="p2">][net_cloudstorageaccount]</ept> 的帐户引用，并从中获取 <bpt id="p3">[</bpt>CloudBlobClient<ept id="p3">][net_cloudblobclient]</ept>：</source>
          <target state="new">若要与存储帐户交互并创建容器，可以使用<bpt id="p1">[</bpt>适用于 .NET 的 Azure 存储空间客户端库<ept id="p1">][net_api_storage]</ept>来创建包含 <bpt id="p2">[</bpt>CloudStorageAccount<ept id="p2">][net_cloudstorageaccount]</ept> 的帐户引用，并从中获取 <bpt id="p3">[</bpt>CloudBlobClient<ept id="p3">][net_cloudblobclient]</ept>：</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>我们将在整个应用程序中使用 <ph id="ph1">`blobClient`</ph> 引用，并将它作为参数传递给多个方法。紧接在上述代码的代码块中提供了示例，我们在其中调用 <ph id="ph2">`CreateContainerIfNotExistAsync`</ph> 以实际创建容器。</source>
          <target state="new">我们将在整个应用程序中使用 <ph id="ph1">`blobClient`</ph> 引用，并将它作为参数传递给多个方法。紧接在上述代码的代码块中提供了示例，我们在其中调用 <ph id="ph2">`CreateContainerIfNotExistAsync`</ph> 以实际创建容器。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>创建容器之后，应用程序现在即可上载任务使用的文件。</source>
          <target state="new">创建容器之后，应用程序现在即可上载任务使用的文件。</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> <bpt id="p1">[</bpt>How to use Blob storage from .NET<ept id="p1">](/documentation/articles/storage-dotnet-how-to-use-blobs)</ept> 提供了有关使用 Azure 存储空间容器和 Blob 的概述，当你开始使用 Batch 时，此概述应会出现在阅读列表的顶部附近。</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> <bpt id="p1">[</bpt>How to use Blob storage from .NET<ept id="p1">](/documentation/articles/storage-dotnet-how-to-use-blobs)</ept> 提供了有关使用 Azure 存储空间容器和 Blob 的概述，当你开始使用 Batch 时，此概述应会出现在阅读列表的顶部附近。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>步骤 2：上载任务应用程序和数据文件</source>
          <target state="new">步骤 2：上载任务应用程序和数据文件</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>将任务应用程序和输入（数据）文件上载到容器</source>
          <target state="new">将任务应用程序和输入（数据）文件上载到容器</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>在文件上载操作中， <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 先定义<bpt id="p2">**</bpt>应用程序<ept id="p2">**</ept>和<bpt id="p3">**</bpt>输入<ept id="p3">**</ept>文件在本地计算机上的路径的集合，然后将这些文件上载到上一步骤创建的容器。</source>
          <target state="new">在文件上载操作中， <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 先定义<bpt id="p2">**</bpt>应用程序<ept id="p2">**</ept>和<bpt id="p3">**</bpt>输入<ept id="p3">**</ept>文件在本地计算机上的路径的集合，然后将这些文件上载到上一步骤创建的容器。</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Program.cs`</ph> 中有两个方法涉及到上载过程：</source>
          <target state="new"><ph id="ph1">`Program.cs`</ph> 中有两个方法涉及到上载过程：</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`UploadFilesToContainerAsync`</ph> - 此方法返回 <bpt id="p1">[</bpt>ResourceFile<ept id="p1">][net_resourcefile]</ept> 对象的集合（下面将会介绍），并在内部调用 <ph id="ph2">`UploadFileToContainerAsync`</ph> 以上载在 <bpt id="p2">*</bpt>filePaths<ept id="p2">*</ept> 参数中传入的每个文件。</source>
          <target state="new"><ph id="ph1">`UploadFilesToContainerAsync`</ph> - 此方法返回 <bpt id="p1">[</bpt>ResourceFile<ept id="p1">][net_resourcefile]</ept> 对象的集合（下面将会介绍），并在内部调用 <ph id="ph2">`UploadFileToContainerAsync`</ph> 以上载在 <bpt id="p2">*</bpt>filePaths<ept id="p2">*</ept> 参数中传入的每个文件。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`UploadFileToContainerAsync`</ph> - 这是实际执行文件上载并创建 <bpt id="p1">[</bpt>ResourceFile<ept id="p1">][net_resourcefile]</ept> 对象的方法。上载文件后，它将获取该文件的共享访问签名 (SAS) 并返回代表它的 ResourceFile 对象。下面也会介绍共享访问签名。</source>
          <target state="new"><ph id="ph1">`UploadFileToContainerAsync`</ph> - 这是实际执行文件上载并创建 <bpt id="p1">[</bpt>ResourceFile<ept id="p1">][net_resourcefile]</ept> 对象的方法。上载文件后，它将获取该文件的共享访问签名 (SAS) 并返回代表它的 ResourceFile 对象。下面也会介绍共享访问签名。</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>ResourceFiles</source>
          <target state="new">ResourceFiles</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ResourceFile<ept id="p1">][net_resourcefile]</ept> 提供 Batch 中的任务，以及 Azure 存储空间中将在任务运行之前下载到计算节点的文件的 URL。<bpt id="p2">[</bpt>ResourceFile.BlobSource<ept id="p2">][net_resourcefile_blobsource]</ept> 属性指定 Azure 存储空间中现有文件的完整 URL，该 URL 也可能包含可供安全访问文件的共享访问签名 (SAS)。Batch .NET 中的大多数任务类型都包含 <bpt id="p3">*</bpt>ResourceFiles<ept id="p3">*</ept> 属性，这些类型包括：</source>
          <target state="new"><bpt id="p1">[</bpt>ResourceFile<ept id="p1">][net_resourcefile]</ept> 提供 Batch 中的任务，以及 Azure 存储空间中将在任务运行之前下载到计算节点的文件的 URL。<bpt id="p2">[</bpt>ResourceFile.BlobSource<ept id="p2">][net_resourcefile_blobsource]</ept> 属性指定 Azure 存储空间中现有文件的完整 URL，该 URL 也可能包含可供安全访问文件的共享访问签名 (SAS)。Batch .NET 中的大多数任务类型都包含 <bpt id="p3">*</bpt>ResourceFiles<ept id="p3">*</ept> 属性，这些类型包括：</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>CloudTask</source>
          <target state="new">CloudTask</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>StartTask</source>
          <target state="new">StartTask</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>JobPreparationTask</source>
          <target state="new">JobPreparationTask</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>JobReleaseTask</source>
          <target state="new">JobReleaseTask</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>DotNetTutorial 示例应用程序不使用 JobPreparationTask 或 JobReleaseTask 任务类型，但你可以通过<bpt id="p1">[</bpt>在 Azure Batch 计算节点上运行作业准备和完成任务<ept id="p1">](batch-job-prep-release.md)</ept>来详细了解这些任务类型。</source>
          <target state="new">DotNetTutorial 示例应用程序不使用 JobPreparationTask 或 JobReleaseTask 任务类型，但你可以通过<bpt id="p1">[</bpt>在 Azure Batch 计算节点上运行作业准备和完成任务<ept id="p1">](batch-job-prep-release.md)</ept>来详细了解这些任务类型。</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>共享访问签名 (SAS)</source>
          <target state="new">共享访问签名 (SAS)</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>共享访问签名是一些字符串，包含为 URL 的一部分时，它们可以提供对 Azure 存储空间中容器和 Blob 的安全访问。DotNetTutorial 应用程序使用 Blob 和容器共享访问签名 URL，并演示如何从存储空间服务获取这些 SAS 字符串。</source>
          <target state="new">共享访问签名是一些字符串，包含为 URL 的一部分时，它们可以提供对 Azure 存储空间中容器和 Blob 的安全访问。DotNetTutorial 应用程序使用 Blob 和容器共享访问签名 URL，并演示如何从存储空间服务获取这些 SAS 字符串。</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Blob SAS<ept id="p1">**</ept> - DotNetTutorial 中池的 StartTask 在从存储空间下载应用程序二进制文件和输入数据文件时使用 Blob 共享访问签名（请参阅下面步骤 3）。DotNetTutorial 的 <ph id="ph1">`Program.cs`</ph> 中的 <ph id="ph2">`UploadFileToContainerAsync`</ph> 方法包含通过调用 <bpt id="p2">[</bpt>CloudblobData.GetSharedAccessSignature<ept id="p2">][net_sas_blob]</ept> 获取每个 Blob 的 SAS 的代码。</source>
          <target state="new"><bpt id="p1">**</bpt>Blob SAS<ept id="p1">**</ept> - DotNetTutorial 中池的 StartTask 在从存储空间下载应用程序二进制文件和输入数据文件时使用 Blob 共享访问签名（请参阅下面步骤 3）。DotNetTutorial 的 <ph id="ph1">`Program.cs`</ph> 中的 <ph id="ph2">`UploadFileToContainerAsync`</ph> 方法包含通过调用 <bpt id="p2">[</bpt>CloudblobData.GetSharedAccessSignature<ept id="p2">][net_sas_blob]</ept> 获取每个 Blob 的 SAS 的代码。</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>容器 SAS<ept id="p1">**</ept> - 每个任务在计算节点上完成其工作后，会将其输出文件上载到 Azure 存储空间中的 <bpt id="p2">*</bpt>输出<ept id="p2">*</ept> 容器。为此，TaskApplication 使用容器 SAS，在上载文件时，该 SAS 提供对路径中包含的容器的写访问。获取容器 SAS 与获取 Blob SAS 的方法很类似。在 DotNetTutorial 中，你会发现 <ph id="ph1">`GetContainerSasUrl`</ph> 帮助器方法调用 <bpt id="p3">[</bpt>CloudBlobContainer.GetSharedAccessSignature<ept id="p3">][net_sas_container]</ept> 来实现此目的。你可以在下面的“步骤 6：监视任务”中详细了解 TaskApplication 如何使用容器 SAS。</source>
          <target state="new"><bpt id="p1">**</bpt>容器 SAS<ept id="p1">**</ept> - 每个任务在计算节点上完成其工作后，会将其输出文件上载到 Azure 存储空间中的 <bpt id="p2">*</bpt>输出<ept id="p2">*</ept> 容器。为此，TaskApplication 使用容器 SAS，在上载文件时，该 SAS 提供对路径中包含的容器的写访问。获取容器 SAS 与获取 Blob SAS 的方法很类似。在 DotNetTutorial 中，你会发现 <ph id="ph1">`GetContainerSasUrl`</ph> 帮助器方法调用 <bpt id="p3">[</bpt>CloudBlobContainer.GetSharedAccessSignature<ept id="p3">][net_sas_container]</ept> 来实现此目的。你可以在下面的“步骤 6：监视任务”中详细了解 TaskApplication 如何使用容器 SAS。</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> 请查看有关共享访问签名的两篇系列教程的<bpt id="p1">[</bpt>第 1 部分：了解 SAS 模型<ept id="p1">](./../storage/storage-dotnet-shared-access-signature-part-1.md)</ept>和<bpt id="p2">[</bpt>第 2 部分：创建 SAS 并将其用于 Blob 服务<ept id="p2">](./../storage/storage-dotnet-shared-access-signature-part-2.md)</ept>，以详细了解如何提供对存储帐户中数据的安全访问。</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> 请查看有关共享访问签名的两篇系列教程的<bpt id="p1">[</bpt>第 1 部分：了解 SAS 模型<ept id="p1">](./../storage/storage-dotnet-shared-access-signature-part-1.md)</ept>和<bpt id="p2">[</bpt>第 2 部分：创建 SAS 并将其用于 Blob 服务<ept id="p2">](./../storage/storage-dotnet-shared-access-signature-part-2.md)</ept>，以详细了解如何提供对存储帐户中数据的安全访问。</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>步骤 3：创建 Batch 池</source>
          <target state="new">步骤 3：创建 Batch 池</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>创建 Batch 池</source>
          <target state="new">创建 Batch 池</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>将应用程序和数据文件上载到存储帐户之后， <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 将使用 Batch .NET 库开始与 Batch 服务交互。为此，需要先创建一个 <bpt id="p2">[</bpt>BatchClient<ept id="p2">][net_batchclient]</ept>：</source>
          <target state="new">将应用程序和数据文件上载到存储帐户之后， <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 将使用 Batch .NET 库开始与 Batch 服务交互。为此，需要先创建一个 <bpt id="p2">[</bpt>BatchClient<ept id="p2">][net_batchclient]</ept>：</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>然后，调用 <ph id="ph1">`CreatePoolAsync`</ph> 以在 Batch 帐户中创建计算节点池。<ph id="ph2">`CreatePoolAsync`</ph> 使用 <bpt id="p1">[</bpt>BatchClient.PoolOperations.CreatePool<ept id="p1">][net_pool_create]</ept> 方法在 Batch 服务中实际创建该池。</source>
          <target state="new">然后，调用 <ph id="ph1">`CreatePoolAsync`</ph> 以在 Batch 帐户中创建计算节点池。<ph id="ph2">`CreatePoolAsync`</ph> 使用 <bpt id="p1">[</bpt>BatchClient.PoolOperations.CreatePool<ept id="p1">][net_pool_create]</ept> 方法在 Batch 服务中实际创建该池。</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">[</bpt>CreatePool<ept id="p1">][net_pool_create]</ept> 创建池时，需指定一些参数，例如计算节点数目、<bpt id="p2">[</bpt>节点大小<ept id="p2">](/documentation/articles/cloud-services/cloud-services-sizes-specs.md)</ept>以及节点的<bpt id="p3">[</bpt>操作系统<ept id="p3">](./../cloud-services/cloud-services-guestos-update-matrix.md)</ept>。</source>
          <target state="new">使用 <bpt id="p1">[</bpt>CreatePool<ept id="p1">][net_pool_create]</ept> 创建池时，需指定一些参数，例如计算节点数目、<bpt id="p2">[</bpt>节点大小<ept id="p2">](/documentation/articles/cloud-services/cloud-services-sizes-specs.md)</ept>以及节点的<bpt id="p3">[</bpt>操作系统<ept id="p3">](./../cloud-services/cloud-services-guestos-update-matrix.md)</ept>。</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph> 你需要支付 Batch 中计算资源的费用。若要将费用降到最低，可以在运行示例之前，将 <ph id="ph2">`targetDedicated`</ph> 降为 1。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph> 你需要支付 Batch 中计算资源的费用。若要将费用降到最低，可以在运行示例之前，将 <ph id="ph2">`targetDedicated`</ph> 降为 1。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>你也可以连同这些实体节点属性一起指定池的 <bpt id="p1">[</bpt>StartTask<ept id="p1">][net_pool_starttask]</ept>。StartTask 将在每个节点加入池以及每次重新启动节点时在该节点上运行。StartTask 特别适合用于在任务执行之前在计算节点上安装应用程序。例如，如果任务使用 Python 脚本处理数据，则你可以使用 StartTask 在计算节点上安装 Python。</source>
          <target state="new">你也可以连同这些实体节点属性一起指定池的 <bpt id="p1">[</bpt>StartTask<ept id="p1">][net_pool_starttask]</ept>。StartTask 将在每个节点加入池以及每次重新启动节点时在该节点上运行。StartTask 特别适合用于在任务执行之前在计算节点上安装应用程序。例如，如果任务使用 Python 脚本处理数据，则你可以使用 StartTask 在计算节点上安装 Python。</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>在此示例应用程序中，StartTask 将它从存储空间下载的文件（使用 StartTask 的 <bpt id="p1">*</bpt>ResourceFiles<ept id="p1">*</ept> 属性指定），从 StartTask 工作目录复制到在节点上运行的 <bpt id="p2">*</bpt>所有<ept id="p2">*</ept> 任务可以访问的共享目录。</source>
          <target state="new">在此示例应用程序中，StartTask 将它从存储空间下载的文件（使用 StartTask 的 <bpt id="p1">*</bpt>ResourceFiles<ept id="p1">*</ept> 属性指定），从 StartTask 工作目录复制到在节点上运行的 <bpt id="p2">*</bpt>所有<ept id="p2">*</ept> 任务可以访问的共享目录。</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>此外，在上述代码段中，值得注意的问题是，StartTask 的 <bpt id="p1">*</bpt>CommandLine<ept id="p1">*</ept> 属性中使用了两个环境变量：<ph id="ph1">`%AZ_BATCH_TASK_WORKING_DIR%`</ph> 和 <ph id="ph2">`%AZ_BATCH_NODE_SHARED_DIR%`</ph>。Batch 池中的每个计算节点自动以 Batch 特定的多个环境变量进行配置，任务执行的任何过程都可以访问这些环境变量。</source>
          <target state="new">此外，在上述代码段中，值得注意的问题是，StartTask 的 <bpt id="p1">*</bpt>CommandLine<ept id="p1">*</ept> 属性中使用了两个环境变量：<ph id="ph1">`%AZ_BATCH_TASK_WORKING_DIR%`</ph> 和 <ph id="ph2">`%AZ_BATCH_NODE_SHARED_DIR%`</ph>。Batch 池中的每个计算节点自动以 Batch 特定的多个环境变量进行配置，任务执行的任何过程都可以访问这些环境变量。</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> 若要深入了解 Batch 池中计算节点上可用的环境变量，以及有关任务工作目录的信息，请参阅 <bpt id="p1">[</bpt>Azure Batch 功能概述<ept id="p1">](batch-api-basics.md)</ept>中的<bpt id="p2">**</bpt>任务的环境设置<ept id="p2">**</ept>及<bpt id="p3">**</bpt>文件和目录<ept id="p3">**</ept>部分。</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> 若要深入了解 Batch 池中计算节点上可用的环境变量，以及有关任务工作目录的信息，请参阅 <bpt id="p1">[</bpt>Azure Batch 功能概述<ept id="p1">](batch-api-basics.md)</ept>中的<bpt id="p2">**</bpt>任务的环境设置<ept id="p2">**</ept>及<bpt id="p3">**</bpt>文件和目录<ept id="p3">**</ept>部分。</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>步骤 4：创建 Batch 作业</source>
          <target state="new">步骤 4：创建 Batch 作业</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>创建 Batch 作业</source>
          <target state="new">创建 Batch 作业</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Batch 作业基本上是与计算节点池关联的任务集合，它不仅可用来组织和跟踪相关工作负荷中的任务，也可以实施特定的约束，例如作业（并扩展到其任务）的最大运行时，以及 Batch 帐户中其他作业的相关作业优先级。不过，在此示例中，作业只与步骤 3 中创建的池关联，而没有配置任何其他属性。</source>
          <target state="new">Batch 作业基本上是与计算节点池关联的任务集合，它不仅可用来组织和跟踪相关工作负荷中的任务，也可以实施特定的约束，例如作业（并扩展到其任务）的最大运行时，以及 Batch 帐户中其他作业的相关作业优先级。不过，在此示例中，作业只与步骤 3 中创建的池关联，而没有配置任何其他属性。</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>所有 Batch 作业都与特定的池关联。这种关联指示了要在哪些节点上执行作业的任务。你可以使用 <bpt id="p1">[</bpt>CloudJob.PoolInformation<ept id="p1">][net_job_poolinfo]</ept> 属性来指定此关联，如以下代码段所示。</source>
          <target state="new">所有 Batch 作业都与特定的池关联。这种关联指示了要在哪些节点上执行作业的任务。你可以使用 <bpt id="p1">[</bpt>CloudJob.PoolInformation<ept id="p1">][net_job_poolinfo]</ept> 属性来指定此关联，如以下代码段所示。</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>创建作业后，可以添加任务来执行工作。</source>
          <target state="new">创建作业后，可以添加任务来执行工作。</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>步骤 5：将任务添加到作业</source>
          <target state="new">步骤 5：将任务添加到作业</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><ph id="ph1">![</ph>将任务添加到作业<ph id="ph2">][5]</ph></source>
          <target state="new"><ph id="ph1">![</ph>将任务添加到作业<ph id="ph2">][5]</ph></target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>(1) 将任务添加到作业，(2) 将任务计划为在节点上运行，(3) 任务下载要处理的数据文件</source>
          <target state="new">(1) 将任务添加到作业，(2) 将任务计划为在节点上运行，(3) 任务下载要处理的数据文件</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>若要实际执行工作，必须将任务添加到作业。每个 <bpt id="p1">[</bpt>CloudTask<ept id="p1">][net_task]</ept> 都是使用命令列属性以及任务在其命令行自动运行前下载到节点的 <bpt id="p2">[</bpt>ResourceFiles<ept id="p2">][net_task_resourcefiles]</ept>（如同池的 StartTask）进行配置的。在 <bpt id="p3">*</bpt>DotNetTutorial<ept id="p3">*</ept> 示例项目中，每个任务只处理一个文件，因此其 ResourceFiles 集合只包含单个元素。</source>
          <target state="new">若要实际执行工作，必须将任务添加到作业。每个 <bpt id="p1">[</bpt>CloudTask<ept id="p1">][net_task]</ept> 都是使用命令列属性以及任务在其命令行自动运行前下载到节点的 <bpt id="p2">[</bpt>ResourceFiles<ept id="p2">][net_task_resourcefiles]</ept>（如同池的 StartTask）进行配置的。在 <bpt id="p3">*</bpt>DotNetTutorial<ept id="p3">*</ept> 示例项目中，每个任务只处理一个文件，因此其 ResourceFiles 集合只包含单个元素。</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph> 访问环境变量（例如 <ph id="ph2">`%AZ_BATCH_NODE_SHARED_DIR%`</ph>）或执行在节点的 <ph id="ph3">`PATH`</ph> 中找不到的应用程序时，必须在任务命令行的前面加上 <ph id="ph4">`cmd /c`</ph>，以显式执行命令解释器，并指示它在执行命令之后终止。如果任务在节点的 PATH 中执行应用程序（例如 <bpt id="p1">*</bpt>robocopy.exe<ept id="p1">*</ept> 或 <bpt id="p2">*</bpt>powershell.exe<ept id="p2">*</ept> ），而且未使用任何环境变量，则就不必要满足此要求。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph> 访问环境变量（例如 <ph id="ph2">`%AZ_BATCH_NODE_SHARED_DIR%`</ph>）或执行在节点的 <ph id="ph3">`PATH`</ph> 中找不到的应用程序时，必须在任务命令行的前面加上 <ph id="ph4">`cmd /c`</ph>，以显式执行命令解释器，并指示它在执行命令之后终止。如果任务在节点的 PATH 中执行应用程序（例如 <bpt id="p1">*</bpt>robocopy.exe<ept id="p1">*</ept> 或 <bpt id="p2">*</bpt>powershell.exe<ept id="p2">*</ept> ），而且未使用任何环境变量，则就不必要满足此要求。</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>在上述代码段中的 <ph id="ph1">`foreach`</ph> 循环内，可以看到已构造任务的命令行，因此有三个命令行参数已传递到 <bpt id="p1">*</bpt>TaskApplication.exe<ept id="p1">*</ept> ：</source>
          <target state="new">在上述代码段中的 <ph id="ph1">`foreach`</ph> 循环内，可以看到已构造任务的命令行，因此有三个命令行参数已传递到 <bpt id="p1">*</bpt>TaskApplication.exe<ept id="p1">*</ept> ：</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>第一个参数<ept id="p1">**</ept>是要处理的文件的路径。这是节点上现有文件的本地路径。首次在上述 <ph id="ph1">`UploadFileToContainerAsync`</ph> 中创建 ResourceFile 对象时，文件名用于此属性（做为 ResourceFile 构造函数的参数），这表示可以在与 <bpt id="p2">*</bpt>TaskApplication.exe<ept id="p2">*</ept> 相同的目录中找到该文件。</source>
          <target state="new"><bpt id="p1">**</bpt>第一个参数<ept id="p1">**</ept>是要处理的文件的路径。这是节点上现有文件的本地路径。首次在上述 <ph id="ph1">`UploadFileToContainerAsync`</ph> 中创建 ResourceFile 对象时，文件名用于此属性（做为 ResourceFile 构造函数的参数），这表示可以在与 <bpt id="p2">*</bpt>TaskApplication.exe<ept id="p2">*</ept> 相同的目录中找到该文件。</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>第二个参数<ept id="p1">**</ept>指定应将前 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 个单词写入输出文件。在示例中，此参数已经过硬编码，因此会将前 3 个单词写入输出文件。</source>
          <target state="new"><bpt id="p1">**</bpt>第二个参数<ept id="p1">**</ept>指定应将前 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 个单词写入输出文件。在示例中，此参数已经过硬编码，因此会将前 3 个单词写入输出文件。</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>第三个参数<ept id="p1">**</ept>是共享访问签名 (SAS)，提供对 Azure 存储空间中<bpt id="p2">**</bpt>输出<ept id="p2">**</ept>容器的写访问。 <bpt id="p3">*</bpt>TaskApplication.exe<ept id="p3">*</ept> 将输出文件上载到 Azure 存储空间时，会使用此 SAS URL。你可以在 TaskApplication 项目的 <ph id="ph1">`Program.cs`</ph> 文件的 <ph id="ph2">`UploadFileToContainer`</ph> 方法中找到相关代码：</source>
          <target state="new"><bpt id="p1">**</bpt>第三个参数<ept id="p1">**</ept>是共享访问签名 (SAS)，提供对 Azure 存储空间中<bpt id="p2">**</bpt>输出<ept id="p2">**</ept>容器的写访问。 <bpt id="p3">*</bpt>TaskApplication.exe<ept id="p3">*</ept> 将输出文件上载到 Azure 存储空间时，会使用此 SAS URL。你可以在 TaskApplication 项目的 <ph id="ph1">`Program.cs`</ph> 文件的 <ph id="ph2">`UploadFileToContainer`</ph> 方法中找到相关代码：</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>步骤 6：监视任务</source>
          <target state="new">步骤 6：监视任务</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><ph id="ph1">![</ph>监视任务<ph id="ph2">][6]</ph></source>
          <target state="new"><ph id="ph1">![</ph>监视任务<ph id="ph2">][6]</ph></target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>客户端应用程序将会：(1) 监视任务的完成和成功状态，(2) 监视将结果数据上载到 Azure 存储空间的任务</source>
          <target state="new">客户端应用程序将会：(1) 监视任务的完成和成功状态，(2) 监视将结果数据上载到 Azure 存储空间的任务</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>任务在添加到作业后，将自动排入队列并计划在与作业关联的池中的计算节点上执行。根据你指定的设置，Batch 将为你处理所有任务排队、计划、重试和其他任务管理工作。监视任务执行的方法有许多种 - DotNetTutorial 显示了一个只报告完成状态以及任务或成功状态的简单示例。</source>
          <target state="new">任务在添加到作业后，将自动排入队列并计划在与作业关联的池中的计算节点上执行。根据你指定的设置，Batch 将为你处理所有任务排队、计划、重试和其他任务管理工作。监视任务执行的方法有许多种 - DotNetTutorial 显示了一个只报告完成状态以及任务或成功状态的简单示例。</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>DotNetTutorial 的 <ph id="ph1">`Program.cs`</ph> 中的 <ph id="ph2">`MonitorTasks`</ph> 方法内有三个 Batch .NET 概念值得讨论，下面按出现顺序列出了这些概念：</source>
          <target state="new">DotNetTutorial 的 <ph id="ph1">`Program.cs`</ph> 中的 <ph id="ph2">`MonitorTasks`</ph> 方法内有三个 Batch .NET 概念值得讨论，下面按出现顺序列出了这些概念：</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>ODATADetailLevel<ept id="p1">**</ept> - 必须在列出操作（例如获取作业的任务列表）中指定 <bpt id="p2">[</bpt>ODATADetailLevel<ept id="p2">][net_odatadetaillevel]</ept>，以确保 Batch 应用程序的性能。如果你打算在 Batch 应用程序中进行任何类型的状态监视，请将<bpt id="p3">[</bpt>有效地查询 Azure Batch 服务<ept id="p3">](batch-efficient-list-queries.md)</ept>加入你的阅读列表。</source>
          <target state="new"><bpt id="p1">**</bpt>ODATADetailLevel<ept id="p1">**</ept> - 必须在列出操作（例如获取作业的任务列表）中指定 <bpt id="p2">[</bpt>ODATADetailLevel<ept id="p2">][net_odatadetaillevel]</ept>，以确保 Batch 应用程序的性能。如果你打算在 Batch 应用程序中进行任何类型的状态监视，请将<bpt id="p3">[</bpt>有效地查询 Azure Batch 服务<ept id="p3">](batch-efficient-list-queries.md)</ept>加入你的阅读列表。</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>TaskStateMonitor<ept id="p1">**</ept> - <bpt id="p2">[</bpt>TaskStateMonitor<ept id="p2">][net_taskstatemonitor]</ept> 为 Batch .NET 应用程提供用于监视任务状态的帮助器实用程序。在 <ph id="ph1">`MonitorTasks`</ph> 中， <bpt id="p3">*</bpt>DotNetTutorial<ept id="p3">*</ept> 将等待所有任务在时限内达到 <bpt id="p4">[</bpt>TaskState.Completed<ept id="p4">][net_taskstate]</ept>，然后终止作业。</source>
          <target state="new"><bpt id="p1">**</bpt>TaskStateMonitor<ept id="p1">**</ept> - <bpt id="p2">[</bpt>TaskStateMonitor<ept id="p2">][net_taskstatemonitor]</ept> 为 Batch .NET 应用程提供用于监视任务状态的帮助器实用程序。在 <ph id="ph1">`MonitorTasks`</ph> 中， <bpt id="p3">*</bpt>DotNetTutorial<ept id="p3">*</ept> 将等待所有任务在时限内达到 <bpt id="p4">[</bpt>TaskState.Completed<ept id="p4">][net_taskstate]</ept>，然后终止作业。</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>TerminateJobAsync<ept id="p1">**</ept> - 通过 <bpt id="p2">[</bpt>JobOperations.TerminateJobAsync<ept id="p2">][net_joboperations_terminatejob]</ept> 终止作业（或阻止 JobOperations.TerminateJob）会将该作业标记为已完成。如果 Batch 解决方案使用 <bpt id="p3">[</bpt>JobReleaseTask<ept id="p3">][net_jobreltask]</ept>，则你必须这样做。如<bpt id="p4">[</bpt>作业准备和完成任务<ept id="p4">](batch-job-prep-release)</ept>中所述，这是一种特殊的任务类型。</source>
          <target state="new"><bpt id="p1">**</bpt>TerminateJobAsync<ept id="p1">**</ept> - 通过 <bpt id="p2">[</bpt>JobOperations.TerminateJobAsync<ept id="p2">][net_joboperations_terminatejob]</ept> 终止作业（或阻止 JobOperations.TerminateJob）会将该作业标记为已完成。如果 Batch 解决方案使用 <bpt id="p3">[</bpt>JobReleaseTask<ept id="p3">][net_jobreltask]</ept>，则你必须这样做。如<bpt id="p4">[</bpt>作业准备和完成任务<ept id="p4">](batch-job-prep-release)</ept>中所述，这是一种特殊的任务类型。</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 的 <ph id="ph1">`Program.cs`</ph> 中的 <ph id="ph2">`MonitorTasks`</ph> 方法如下所示：</source>
          <target state="new"><bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 的 <ph id="ph1">`Program.cs`</ph> 中的 <ph id="ph2">`MonitorTasks`</ph> 方法如下所示：</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>步骤 7：下载任务输出</source>
          <target state="new">步骤 7：下载任务输出</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>从存储空间下载任务输出</source>
          <target state="new">从存储空间下载任务输出</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>完成作业后，可以从 Azure 存储空间下载任务的输出。可以在 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 的 <ph id="ph1">`Program.cs`</ph> 中调用 <ph id="ph2">`DownloadBlobsFromContainerAsync`</ph> 来实现此目的：</source>
          <target state="new">完成作业后，可以从 Azure 存储空间下载任务的输出。可以在 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 的 <ph id="ph1">`Program.cs`</ph> 中调用 <ph id="ph2">`DownloadBlobsFromContainerAsync`</ph> 来实现此目的：</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 对 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 应用程序中 <ph id="ph2">`DownloadBlobsFromContainerAsync`</ph> 的调用可以指定应将文件下载到 <ph id="ph3">`%TEMP%`</ph> 文件夹。可以随意修改此输出位置。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 对 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 应用程序中 <ph id="ph2">`DownloadBlobsFromContainerAsync`</ph> 的调用可以指定应将文件下载到 <ph id="ph3">`%TEMP%`</ph> 文件夹。可以随意修改此输出位置。</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>步骤 8：删除容器</source>
          <target state="new">步骤 8：删除容器</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>由于你需要对位于 Azure 存储空间中的数据付费，因此我们建议删除 Batch 作业不再需要的所有 Blob。在 DotNetTutorial 的 <ph id="ph1">`Program.cs`</ph> 中，调用帮助器方法 <ph id="ph2">`DeleteContainerAsync`</ph> 三次即可实现此目的：</source>
          <target state="new">由于你需要对位于 Azure 存储空间中的数据付费，因此我们建议删除 Batch 作业不再需要的所有 Blob。在 DotNetTutorial 的 <ph id="ph1">`Program.cs`</ph> 中，调用帮助器方法 <ph id="ph2">`DeleteContainerAsync`</ph> 三次即可实现此目的：</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>该方法本身只获取对容器的引用，然后调用 <bpt id="p1">[</bpt>CloudBlobContainer.DeleteIfExistsAsync<ept id="p1">][net_container_delete]</ept>：</source>
          <target state="new">该方法本身只获取对容器的引用，然后调用 <bpt id="p1">[</bpt>CloudBlobContainer.DeleteIfExistsAsync<ept id="p1">][net_container_delete]</ept>：</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>步骤 9：删除作业和池</source>
          <target state="new">步骤 9：删除作业和池</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>在最后一个步骤，系统将提示用户删除 DotNetTutorial 应用程序创建的作业和池。尽管你不需要支付作业和任务本身的费用，但 <bpt id="p1">*</bpt>需要<ept id="p1">*</ept> 支付计算节点的费用。因此，我们建议只在必要时才分配节点，并在维护过程中删除未使用的池。</source>
          <target state="new">在最后一个步骤，系统将提示用户删除 DotNetTutorial 应用程序创建的作业和池。尽管你不需要支付作业和任务本身的费用，但 <bpt id="p1">*</bpt>需要<ept id="p1">*</ept> 支付计算节点的费用。因此，我们建议只在必要时才分配节点，并在维护过程中删除未使用的池。</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>BatchClient 的 <bpt id="p1">[</bpt>JobOperations<ept id="p1">][net_joboperations]</ept> 和 <bpt id="p2">[</bpt>PoolOperations<ept id="p2">][net_pooloperations]</ept> 都有对应的删除方法（在用户确认删除时调用）：</source>
          <target state="new">BatchClient 的 <bpt id="p1">[</bpt>JobOperations<ept id="p1">][net_joboperations]</ept> 和 <bpt id="p2">[</bpt>PoolOperations<ept id="p2">][net_pooloperations]</ept> 都有对应的删除方法（在用户确认删除时调用）：</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph> 请记住，你需要支付计算资源的费用，而删除未使用的池可将费用降到最低。另请注意，删除池也会删除该池内的所有计算节点，并且删除池后，将无法恢复节点上的任何数据。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph> 请记住，你需要支付计算资源的费用，而删除未使用的池可将费用降到最低。另请注意，删除池也会删除该池内的所有计算节点，并且删除池后，将无法恢复节点上的任何数据。</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>运行 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 示例</source>
          <target state="new">运行 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 示例</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>当你运行示例应用程序时，控制台输出如下所示。在执行期间启动池的计算节点时，你将会遇到暂停并看到<ph id="ph1">`Awaiting task completion, timeout in 00:30:00...`</ph>。在执行期间和之后，可以使用 <bpt id="p1">[</bpt>Batch 资源管理器<ept id="p1">][github_batchexplorer]</ept>来监视池、计算节点、作业和任务。使用 <bpt id="p2">[</bpt>Azure 门户<ept id="p2">][azure_portal]</ept>或某个可用的 <bpt id="p3">[</bpt>Azure 存储空间资源管理器<ept id="p3">][storage_explorers]</ept>来查看应用程序创建的存储资源（容器和 Blob）。</source>
          <target state="new">当你运行示例应用程序时，控制台输出如下所示。在执行期间启动池的计算节点时，你将会遇到暂停并看到<ph id="ph1">`Awaiting task completion, timeout in 00:30:00...`</ph>。在执行期间和之后，可以使用 <bpt id="p1">[</bpt>Batch 资源管理器<ept id="p1">][github_batchexplorer]</ept>来监视池、计算节点、作业和任务。使用 <bpt id="p2">[</bpt>Azure 门户<ept id="p2">][azure_portal]</ept>或某个可用的 <bpt id="p3">[</bpt>Azure 存储空间资源管理器<ept id="p3">][storage_explorers]</ept>来查看应用程序创建的存储资源（容器和 Blob）。</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>以默认配置运行应用程序时，典型的执行时间<bpt id="p1">**</bpt>大约为 5 分钟<ept id="p1">**</ept>。</source>
          <target state="new">以默认配置运行应用程序时，典型的执行时间<bpt id="p1">**</bpt>大约为 5 分钟<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>你可以随意更改 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>TaskApplication<ept id="p2">*</ept> ，以体验不同的计算方案。尝试将执行延迟添加到 <bpt id="p3">*</bpt>TaskApplication<ept id="p3">*</ept> （例如使用 <bpt id="p4">[</bpt>Thread.Sleep<ept id="p4">][net_thread_sleep]</ept>），以模拟长时间运行的任务并使用 Batch 资源管理器的“热图”功能监视这些任务。尝试添加更多任务，或调整计算节点的数目。添加逻辑来检查并允许使用现有的池加速执行时间（ <bpt id="p5">*</bpt>提示<ept id="p5">*</ept> ：请查看 <bpt id="p6">[</bpt>azure-batch-samples<ept id="p6">][github_samples]</ept> 中 <bpt id="p7">[</bpt>Microsoft.Azure.Batch.Samples.Common<ept id="p7">][github_samples_common]</ept> 项目的 <ph id="ph1">`ArticleHelpers.cs`</ph>）。</source>
          <target state="new">你可以随意更改 <bpt id="p1">*</bpt>DotNetTutorial<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>TaskApplication<ept id="p2">*</ept> ，以体验不同的计算方案。尝试将执行延迟添加到 <bpt id="p3">*</bpt>TaskApplication<ept id="p3">*</ept> （例如使用 <bpt id="p4">[</bpt>Thread.Sleep<ept id="p4">][net_thread_sleep]</ept>），以模拟长时间运行的任务并使用 Batch 资源管理器的“热图”功能监视这些任务。尝试添加更多任务，或调整计算节点的数目。添加逻辑来检查并允许使用现有的池加速执行时间（ <bpt id="p5">*</bpt>提示<ept id="p5">*</ept> ：请查看 <bpt id="p6">[</bpt>azure-batch-samples<ept id="p6">][github_samples]</ept> 中 <bpt id="p7">[</bpt>Microsoft.Azure.Batch.Samples.Common<ept id="p7">][github_samples_common]</ept> 项目的 <ph id="ph1">`ArticleHelpers.cs`</ph>）。</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>熟悉 Batch 解决方案的基本工作流后，接下来可以深入了解 Batch 服务的其他功能。</source>
          <target state="new">熟悉 Batch 解决方案的基本工作流后，接下来可以深入了解 Batch 服务的其他功能。</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Azure Batch 功能概述<ept id="p1">](batch-api-basics.md)</ept> - 此文概述了 Batch 的许多功能，建议 Batch 服务的新手阅读。</source>
          <target state="new"><bpt id="p1">[</bpt>Azure Batch 功能概述<ept id="p1">](batch-api-basics.md)</ept> - 此文概述了 Batch 的许多功能，建议 Batch 服务的新手阅读。</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>从 <bpt id="p1">[</bpt>Batch 学习路径<ept id="p1">][batch_learning_path]</ept>中<bpt id="p2">**</bpt>有关开发的深度知识<ept id="p2">**</ept>下面列出的其他 Batch 开发文章着手。</source>
          <target state="new">从 <bpt id="p1">[</bpt>Batch 学习路径<ept id="p1">][batch_learning_path]</ept>中<bpt id="p2">**</bpt>有关开发的深度知识<ept id="p2">**</ept>下面列出的其他 Batch 开发文章着手。</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>通过 <bpt id="p1">[</bpt>TopNWords<ept id="p1">][github_topnwords]</ept> 示例了解有关使用 Batch 处理“前 N 个单词”工作负荷的不同实现方式。</source>
          <target state="new">通过 <bpt id="p1">[</bpt>TopNWords<ept id="p1">][github_topnwords]</ept> 示例了解有关使用 Batch 处理“前 N 个单词”工作负荷的不同实现方式。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>