<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">eafff7628f59ba4d431bd5bd745133963147734b</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>使用现有的 SQL 数据库和移动服务 .NET 后端生成服务 | Azure</source>
          <target state="new">使用现有的 SQL 数据库和移动服务 .NET 后端生成服务 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何将现有的云或本地 SQL 数据库与基于 .NET 的移动服务结合使用</source>
          <target state="new">了解如何将现有的云或本地 SQL 数据库与基于 .NET 的移动服务结合使用</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>使用现有的 SQL 数据库和移动服务 .NET 后端生成服务</source>
          <target state="new">使用现有的 SQL 数据库和移动服务 .NET 后端生成服务</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;</source>
          <target state="new">&amp;nbsp;</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>移动服务 .NET 后端可方便你利用现有的资产来生成移动服务。（在本地或云中）使用可能已被其他应用程序使用的现有 SQL 数据库让现有数据可供移动客户端使用是特别有趣的方案之一。在此情况下，数据库模型（或<bpt id="p1">*</bpt>架构<ept id="p1">*</ept>）必须保持不变才能使现有方案继续工作。</source>
          <target state="new">移动服务 .NET 后端可方便你利用现有的资产来生成移动服务。（在本地或云中）使用可能已被其他应用程序使用的现有 SQL 数据库让现有数据可供移动客户端使用是特别有趣的方案之一。在此情况下，数据库模型（或<bpt id="p1">*</bpt>架构<ept id="p1">*</ept>）必须保持不变才能使现有方案继续工作。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>探索现有的数据库模型</source>
          <target state="new">探索现有的数据库模型</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>在本教程中，我们将使用以你的移动服务创建的数据库，但不使用创建的默认模型。我们将手动创建任意模型，以代表你可能具有的现有应用程序。有关如何改为连接到本地数据库的完整详细信息，请查看<bpt id="p1">[</bpt>使用混合连接从 Azure 移动服务连接到本地 SQL Server<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-hybrid-connections-get-started)</ept>。</source>
          <target state="new">在本教程中，我们将使用以你的移动服务创建的数据库，但不使用创建的默认模型。我们将手动创建任意模型，以代表你可能具有的现有应用程序。有关如何改为连接到本地数据库的完整详细信息，请查看<bpt id="p1">[</bpt>使用混合连接从 Azure 移动服务连接到本地 SQL Server<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-hybrid-connections-get-started)</ept>。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>首先，请在 <bpt id="p1">**</bpt>Visual Studio 2013 Update 2<ept id="p1">**</ept> 中创建移动服务服务器项目，或使用可在 <bpt id="p2">[</bpt>Azure 经典门户<ept id="p2">](http://manage.windowsazure.cn)</ept>中从服务的“移动服务”选项卡下载的快速入门项目。对于本教程，我们假设你的服务器项目名称为 <bpt id="p3">**</bpt>ShoppingService<ept id="p3">**</ept>。</source>
          <target state="new">首先，请在 <bpt id="p1">**</bpt>Visual Studio 2013 Update 2<ept id="p1">**</ept> 中创建移动服务服务器项目，或使用可在 <bpt id="p2">[</bpt>Azure 经典门户<ept id="p2">](http://manage.windowsazure.cn)</ept>中从服务的“移动服务”选项卡下载的快速入门项目。对于本教程，我们假设你的服务器项目名称为 <bpt id="p3">**</bpt>ShoppingService<ept id="p3">**</ept>。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>Models<ept id="p1">**</ept> 文件夹中创建 <bpt id="p2">**</bpt>Customer.cs<ept id="p2">**</ept> 文件，并使用以下实现。需要将 <bpt id="p3">**</bpt>System.ComponentModel.DataAnnotations<ept id="p3">**</ept> 的程序集引用添加到项目中。</source>
          <target state="new">在 <bpt id="p1">**</bpt>Models<ept id="p1">**</ept> 文件夹中创建 <bpt id="p2">**</bpt>Customer.cs<ept id="p2">**</ept> 文件，并使用以下实现。需要将 <bpt id="p3">**</bpt>System.ComponentModel.DataAnnotations<ept id="p3">**</ept> 的程序集引用添加到项目中。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>Models<ept id="p1">**</ept> 文件夹中创建 <bpt id="p2">**</bpt>Order.cs<ept id="p2">**</ept> 文件，并使用以下实现：</source>
          <target state="new">在 <bpt id="p1">**</bpt>Models<ept id="p1">**</ept> 文件夹中创建 <bpt id="p2">**</bpt>Order.cs<ept id="p2">**</ept> 文件，并使用以下实现：</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>你将会注意到，这两个类存在某种<bpt id="p1">*</bpt>关系<ept id="p1">*</ept>：每个<bpt id="p2">**</bpt>订单<ept id="p2">**</ept>与一个<bpt id="p3">**</bpt>客户<ept id="p3">**</ept>关联，而一个<bpt id="p4">**</bpt>客户<ept id="p4">**</ept>可与多个<bpt id="p5">**</bpt>订单<ept id="p5">**</ept>关联。互有关系在现有数据模型中很常见。</source>
          <target state="new">你将会注意到，这两个类存在某种<bpt id="p1">*</bpt>关系<ept id="p1">*</ept>：每个<bpt id="p2">**</bpt>订单<ept id="p2">**</ept>与一个<bpt id="p3">**</bpt>客户<ept id="p3">**</ept>关联，而一个<bpt id="p4">**</bpt>客户<ept id="p4">**</ept>可与多个<bpt id="p5">**</bpt>订单<ept id="p5">**</ept>关联。互有关系在现有数据模型中很常见。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>Models<ept id="p1">**</ept> 文件夹中创建 <bpt id="p2">**</bpt>ExistingContext.cs<ept id="p2">**</ept> 文件，并按如下所示实现它：</source>
          <target state="new">在 <bpt id="p1">**</bpt>Models<ept id="p1">**</ept> 文件夹中创建 <bpt id="p2">**</bpt>ExistingContext.cs<ept id="p2">**</ept> 文件，并按如下所示实现它：</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>上述结构很接近你可能已用于现有应用程序的现有 Entity Framework 模型。请注意，在此阶段，模型无法以任何方式识别移动服务。</source>
          <target state="new">上述结构很接近你可能已用于现有应用程序的现有 Entity Framework 模型。请注意，在此阶段，模型无法以任何方式识别移动服务。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>为移动服务创建数据传输对象 (DTO)</source>
          <target state="new">为移动服务创建数据传输对象 (DTO)</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>你想要在移动服务中使用的数据模型可能很复杂；其中可能包含数百个具有各种关系的实体。在生成移动应用程序时，我们通常会简化数据模型并消除关系（或手动处理关系），以尽可能减少在应用程序与服务之间来回发送的负载。在本部分中，我们将创建一组简化的对象（称为“数据传输对象”，缩写为“DTO”），并将其映射到你在数据库中拥有的数据，但仅包含移动应用程序所需的最少属性集。</source>
          <target state="new">你想要在移动服务中使用的数据模型可能很复杂；其中可能包含数百个具有各种关系的实体。在生成移动应用程序时，我们通常会简化数据模型并消除关系（或手动处理关系），以尽可能减少在应用程序与服务之间来回发送的负载。在本部分中，我们将创建一组简化的对象（称为“数据传输对象”，缩写为“DTO”），并将其映射到你在数据库中拥有的数据，但仅包含移动应用程序所需的最少属性集。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>在服务项目的 <bpt id="p1">**</bpt>DataObjects<ept id="p1">**</ept> 文件夹中创建 <bpt id="p2">**</bpt>MobileCustomer.cs<ept id="p2">**</ept> 文件，并使用以下实现：</source>
          <target state="new">在服务项目的 <bpt id="p1">**</bpt>DataObjects<ept id="p1">**</ept> 文件夹中创建 <bpt id="p2">**</bpt>MobileCustomer.cs<ept id="p2">**</ept> 文件，并使用以下实现：</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>请注意，此类与模型中的 <bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> 类相类似，差别在于 <bpt id="p2">**</bpt>Order<ept id="p2">**</ept> 的关系属性已删除。若要使对象正常使用移动服务脱机同步，需要使用一组<bpt id="p3">*</bpt>系统属性<ept id="p3">*</ept>来进行乐观并发，因此你会发现，DTO 继承自包含这些属性的 <bpt id="p4">[</bpt><bpt id="p5">**</bpt>EntityData<ept id="p5">**</ept><ept id="p4">](http://msdn.microsoft.com/library/microsoft.windowsazure.mobile.service.entitydata.aspx)</ept>。原始模型中的基于 int 的 <bpt id="p6">**</bpt>CustomerId<ept id="p6">**</ept> 属性将替换为 <bpt id="p7">**</bpt>EntityData<ept id="p7">**</ept> 中基于字符串的 <bpt id="p8">**</bpt>Id<ept id="p8">**</ept> 属性，这将是移动服务使用的 <bpt id="p9">**</bpt>Id<ept id="p9">**</ept>。</source>
          <target state="new">请注意，此类与模型中的 <bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> 类相类似，差别在于 <bpt id="p2">**</bpt>Order<ept id="p2">**</ept> 的关系属性已删除。若要使对象正常使用移动服务脱机同步，需要使用一组<bpt id="p3">*</bpt>系统属性<ept id="p3">*</ept>来进行乐观并发，因此你会发现，DTO 继承自包含这些属性的 <bpt id="p4">[</bpt><bpt id="p5">**</bpt>EntityData<ept id="p5">**</ept><ept id="p4">](http://msdn.microsoft.com/library/microsoft.windowsazure.mobile.service.entitydata.aspx)</ept>。原始模型中的基于 int 的 <bpt id="p6">**</bpt>CustomerId<ept id="p6">**</ept> 属性将替换为 <bpt id="p7">**</bpt>EntityData<ept id="p7">**</ept> 中基于字符串的 <bpt id="p8">**</bpt>Id<ept id="p8">**</ept> 属性，这将是移动服务使用的 <bpt id="p9">**</bpt>Id<ept id="p9">**</ept>。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>在服务项目的 <bpt id="p1">**</bpt>DataObjects<ept id="p1">**</ept> 文件夹中创建 <bpt id="p2">**</bpt>MobileOrder.cs<ept id="p2">**</ept> 文件。</source>
          <target state="new">在服务项目的 <bpt id="p1">**</bpt>DataObjects<ept id="p1">**</ept> 文件夹中创建 <bpt id="p2">**</bpt>MobileOrder.cs<ept id="p2">**</ept> 文件。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> 关系属性已替换为 <bpt id="p2">**</bpt>Customer<ept id="p2">**</ept> 名称，以及可用来为客户端上的关系手动建模的 <bpt id="p3">**</bpt>MobileCustomerId<ept id="p3">**</ept> 属性。现在你可以忽略 <bpt id="p4">**</bpt>CustomerId<ept id="p4">**</ept> 属性，以后才会使用此属性。</source>
          <target state="new"><bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> 关系属性已替换为 <bpt id="p2">**</bpt>Customer<ept id="p2">**</ept> 名称，以及可用来为客户端上的关系手动建模的 <bpt id="p3">**</bpt>MobileCustomerId<ept id="p3">**</ept> 属性。现在你可以忽略 <bpt id="p4">**</bpt>CustomerId<ept id="p4">**</ept> 属性，以后才会使用此属性。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>你可能会发现，在 <bpt id="p1">**</bpt>EntityData<ept id="p1">**</ept> 基类上添加系统属性后，DTO 的属性数目比模型类型还多。显然，需要一个位置来存储这些属性，因此我们将在原始数据库中额外添加一些列。虽然这样会更改数据库，但并不会中断现有的应用程序，因为这些更改只是附加的（将新的列添加到架构）。为此，请将以下语句添加到 <bpt id="p2">**</bpt>Customer.cs<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>Order.cs<ept id="p3">**</ept> 的顶部：</source>
          <target state="new">你可能会发现，在 <bpt id="p1">**</bpt>EntityData<ept id="p1">**</ept> 基类上添加系统属性后，DTO 的属性数目比模型类型还多。显然，需要一个位置来存储这些属性，因此我们将在原始数据库中额外添加一些列。虽然这样会更改数据库，但并不会中断现有的应用程序，因为这些更改只是附加的（将新的列添加到架构）。为此，请将以下语句添加到 <bpt id="p2">**</bpt>Customer.cs<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>Order.cs<ept id="p3">**</ept> 的顶部：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>然后，将这些附加属性添加到每个类：</source>
          <target state="new">然后，将这些附加属性添加到每个类：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>刚刚添加的系统属性具有某些会在数据库操作期间明确发生的内置行为（例如，自动更新创建/更新时间）。若要启用这些行为，我们需要更改 <bpt id="p1">**</bpt>ExistingContext.cs<ept id="p1">**</ept>。在该文件的顶部，添加以下代码：</source>
          <target state="new">刚刚添加的系统属性具有某些会在数据库操作期间明确发生的内置行为（例如，自动更新创建/更新时间）。若要启用这些行为，我们需要更改 <bpt id="p1">**</bpt>ExistingContext.cs<ept id="p1">**</ept>。在该文件的顶部，添加以下代码：</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>然后，在 <bpt id="p1">**</bpt>ExistingContext<ept id="p1">**</ept> 的正文中，重写 <bpt id="p2">[</bpt><bpt id="p3">**</bpt>OnModelCreating<ept id="p3">**</ept><ept id="p2">](http://msdn.microsoft.com/zh-cn/library/system.data.entity.dbcontext.onmodelcreating.aspx)</ept>：</source>
          <target state="new">然后，在 <bpt id="p1">**</bpt>ExistingContext<ept id="p1">**</ept> 的正文中，重写 <bpt id="p2">[</bpt><bpt id="p3">**</bpt>OnModelCreating<ept id="p3">**</ept><ept id="p2">](http://msdn.microsoft.com/zh-cn/library/system.data.entity.dbcontext.onmodelcreating.aspx)</ept>：</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>让我们在数据库中填充一些示例数据。打开文件 <bpt id="p1">**</bpt>WebApiConfig.cs<ept id="p1">**</ept>。创建新的 <bpt id="p2">[</bpt><bpt id="p3">**</bpt>IDatabaseInitializer<ept id="p3">**</ept><ept id="p2">](http://msdn.microsoft.com/zh-cn/library/gg696323.aspx)</ept>，并按如下所示在 <bpt id="p4">**</bpt>Register<ept id="p4">**</ept> 方法中对它进行配置。</source>
          <target state="new">让我们在数据库中填充一些示例数据。打开文件 <bpt id="p1">**</bpt>WebApiConfig.cs<ept id="p1">**</ept>。创建新的 <bpt id="p2">[</bpt><bpt id="p3">**</bpt>IDatabaseInitializer<ept id="p3">**</ept><ept id="p2">](http://msdn.microsoft.com/zh-cn/library/gg696323.aspx)</ept>，并按如下所示在 <bpt id="p4">**</bpt>Register<ept id="p4">**</ept> 方法中对它进行配置。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>在 DTO 与模型之间创建映射</source>
          <target state="new">在 DTO 与模型之间创建映射</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>现在我们已有模型类型 <bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>Order<ept id="p2">**</ept> 以及 DTO <bpt id="p3">**</bpt>MobileCustomer<ept id="p3">**</ept> 和 <bpt id="p4">**</bpt>MobileOrder<ept id="p4">**</ept>，但我们需要指示后端自动在两者之间转换。此时，移动服务依赖于 <bpt id="p5">[</bpt><bpt id="p6">**</bpt>AutoMapper<ept id="p6">**</ept><ept id="p5">](http://automapper.org/)</ept>，这是已在项目中引用的对象关系映射器。</source>
          <target state="new">现在我们已有模型类型 <bpt id="p1">**</bpt>Customer<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>Order<ept id="p2">**</ept> 以及 DTO <bpt id="p3">**</bpt>MobileCustomer<ept id="p3">**</ept> 和 <bpt id="p4">**</bpt>MobileOrder<ept id="p4">**</ept>，但我们需要指示后端自动在两者之间转换。此时，移动服务依赖于 <bpt id="p5">[</bpt><bpt id="p6">**</bpt>AutoMapper<ept id="p6">**</ept><ept id="p5">](http://automapper.org/)</ept>，这是已在项目中引用的对象关系映射器。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>WebApiConfig.cs<ept id="p1">**</ept> 的顶部添加以下代码：</source>
          <target state="new">在 <bpt id="p1">**</bpt>WebApiConfig.cs<ept id="p1">**</ept> 的顶部添加以下代码：</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>若要定义映射，请将以下代码添加到 <bpt id="p1">**</bpt>WebApiConfig<ept id="p1">**</ept> 类的 <bpt id="p2">**</bpt>Register<ept id="p2">**</ept> 方法中。</source>
          <target state="new">若要定义映射，请将以下代码添加到 <bpt id="p1">**</bpt>WebApiConfig<ept id="p1">**</ept> 类的 <bpt id="p2">**</bpt>Register<ept id="p2">**</ept> 方法中。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>AutoMapper 此时会将对象互相映射。将匹配所有具有相应名称的属性，例如，<bpt id="p1">**</bpt>MobileOrder.CustomerId<ept id="p1">**</ept> 将会自动映射到 <bpt id="p2">**</bpt>Order.CustomerId<ept id="p2">**</ept>。可按如下所示配置自定义映射，其中，我们将 <bpt id="p3">**</bpt>MobileCustomerName<ept id="p3">**</ept> 属性映射到 <bpt id="p4">**</bpt>Customer<ept id="p4">**</ept> 关系属性的 <bpt id="p5">**</bpt>Name<ept id="p5">**</ept> 属性。</source>
          <target state="new">AutoMapper 此时会将对象互相映射。将匹配所有具有相应名称的属性，例如，<bpt id="p1">**</bpt>MobileOrder.CustomerId<ept id="p1">**</ept> 将会自动映射到 <bpt id="p2">**</bpt>Order.CustomerId<ept id="p2">**</ept>。可按如下所示配置自定义映射，其中，我们将 <bpt id="p3">**</bpt>MobileCustomerName<ept id="p3">**</ept> 属性映射到 <bpt id="p4">**</bpt>Customer<ept id="p4">**</ept> 关系属性的 <bpt id="p5">**</bpt>Name<ept id="p5">**</ept> 属性。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>实现特定于域的逻辑</source>
          <target state="new">实现特定于域的逻辑</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>下一步是实现 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>MappedEntityDomainManager<ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/zh-cn/library/dn643300.aspx)</ept>，它用作映射的数据存储与要从客户端提供 HTTP 流量的控制器之间的抽象层。我们可以在下一个部分中完全以 DTO 的形式编写控制器，而在此处添加的 <bpt id="p3">**</bpt>MappedEntityDomainManager<ept id="p3">**</ept> 将会处理与原始数据存储之间的通信，同时让我们有地方可以实现其任何特定逻辑。</source>
          <target state="new">下一步是实现 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>MappedEntityDomainManager<ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/zh-cn/library/dn643300.aspx)</ept>，它用作映射的数据存储与要从客户端提供 HTTP 流量的控制器之间的抽象层。我们可以在下一个部分中完全以 DTO 的形式编写控制器，而在此处添加的 <bpt id="p3">**</bpt>MappedEntityDomainManager<ept id="p3">**</ept> 将会处理与原始数据存储之间的通信，同时让我们有地方可以实现其任何特定逻辑。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>将 <bpt id="p1">**</bpt>MobileCustomerDomainManager.cs<ept id="p1">**</ept> 添加到项目的 <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> 文件夹。粘贴以下实现：</source>
          <target state="new">将 <bpt id="p1">**</bpt>MobileCustomerDomainManager.cs<ept id="p1">**</ept> 添加到项目的 <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> 文件夹。粘贴以下实现：</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>此类的重要部分是 <bpt id="p1">**</bpt>GetKey<ept id="p1">**</ept> 方法，将在该方法中指示如何在原始数据模型中查找对象的 ID 属性。</source>
          <target state="new">此类的重要部分是 <bpt id="p1">**</bpt>GetKey<ept id="p1">**</ept> 方法，将在该方法中指示如何在原始数据模型中查找对象的 ID 属性。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>将 <bpt id="p1">**</bpt>MobileOrderDomainManager.cs<ept id="p1">**</ept> 添加到项目的 <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> 文件夹：</source>
          <target state="new">将 <bpt id="p1">**</bpt>MobileOrderDomainManager.cs<ept id="p1">**</ept> 添加到项目的 <bpt id="p2">**</bpt>Models<ept id="p2">**</ept> 文件夹：</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>在此情况下，<bpt id="p1">**</bpt>InsertAsync<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>UpdateAsync<ept id="p2">**</ept> 方法是很值得了解的；我们会在其中强制执行每个 <bpt id="p3">**</bpt>Order<ept id="p3">**</ept> 都需要有一个有效相关 <bpt id="p4">**</bpt>Customer<ept id="p4">**</ept> 的关系。在 <bpt id="p5">**</bpt>InsertAsync<ept id="p5">**</ept> 中，你会看到我们填充 <bpt id="p6">**</bpt>MobileOrder.CustomerId<ept id="p6">**</ept> 属性，此属性映射到 <bpt id="p7">**</bpt>Order.CustomerId<ept id="p7">**</ept> 属性。可以通过查找具有匹配 <bpt id="p8">**</bpt>MobileOrder.MobileCustomerId<ept id="p8">**</ept> 的 <bpt id="p9">**</bpt>Customer<ept id="p9">**</ept> 来获取该值。这是因为，默认情况下，客户端只能识别 <bpt id="p10">**</bpt>Customer<ept id="p10">**</ept> 的移动服务 ID (<bpt id="p11">**</bpt>MobileOrder.MobileCustomerId<ept id="p11">**</ept>)，而此 ID 与将外键 (<bpt id="p12">**</bpt>MobileOrder.CustomerId<ept id="p12">**</ept>) 从 <bpt id="p13">**</bpt>Order<ept id="p13">**</ept> 设为 <bpt id="p14">**</bpt>Customer<ept id="p14">**</ept> 所需的实际主键不同。此 ID 仅在服务内部使用，以提高插入操作的速度。</source>
          <target state="new">在此情况下，<bpt id="p1">**</bpt>InsertAsync<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>UpdateAsync<ept id="p2">**</ept> 方法是很值得了解的；我们会在其中强制执行每个 <bpt id="p3">**</bpt>Order<ept id="p3">**</ept> 都需要有一个有效相关 <bpt id="p4">**</bpt>Customer<ept id="p4">**</ept> 的关系。在 <bpt id="p5">**</bpt>InsertAsync<ept id="p5">**</ept> 中，你会看到我们填充 <bpt id="p6">**</bpt>MobileOrder.CustomerId<ept id="p6">**</ept> 属性，此属性映射到 <bpt id="p7">**</bpt>Order.CustomerId<ept id="p7">**</ept> 属性。可以通过查找具有匹配 <bpt id="p8">**</bpt>MobileOrder.MobileCustomerId<ept id="p8">**</ept> 的 <bpt id="p9">**</bpt>Customer<ept id="p9">**</ept> 来获取该值。这是因为，默认情况下，客户端只能识别 <bpt id="p10">**</bpt>Customer<ept id="p10">**</ept> 的移动服务 ID (<bpt id="p11">**</bpt>MobileOrder.MobileCustomerId<ept id="p11">**</ept>)，而此 ID 与将外键 (<bpt id="p12">**</bpt>MobileOrder.CustomerId<ept id="p12">**</ept>) 从 <bpt id="p13">**</bpt>Order<ept id="p13">**</ept> 设为 <bpt id="p14">**</bpt>Customer<ept id="p14">**</ept> 所需的实际主键不同。此 ID 仅在服务内部使用，以提高插入操作的速度。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>现在我们已可创建控制器，以向客户端公开 DTO。</source>
          <target state="new">现在我们已可创建控制器，以向客户端公开 DTO。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>使用 DTO 实现 TableController</source>
          <target state="new">使用 DTO 实现 TableController</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>Controllers<ept id="p1">**</ept> 文件夹中添加文件 <bpt id="p2">**</bpt>MobileCustomerController.cs<ept id="p2">**</ept>：</source>
          <target state="new">在 <bpt id="p1">**</bpt>Controllers<ept id="p1">**</ept> 文件夹中添加文件 <bpt id="p2">**</bpt>MobileCustomerController.cs<ept id="p2">**</ept>：</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>你将会注意到，其中已使用 AuthorizeLevel 属性来限制对控制器上的插入/更新/删除操作的公共访问。对于这种情况，客户列表是只读的，但我们将允许创建新订单，并将其与现有客户关联。</source>
          <target state="new">你将会注意到，其中已使用 AuthorizeLevel 属性来限制对控制器上的插入/更新/删除操作的公共访问。对于这种情况，客户列表是只读的，但我们将允许创建新订单，并将其与现有客户关联。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>Controllers<ept id="p1">**</ept> 文件夹中添加文件 <bpt id="p2">**</bpt>MobileOrderController.cs<ept id="p2">**</ept>：</source>
          <target state="new">在 <bpt id="p1">**</bpt>Controllers<ept id="p1">**</ept> 文件夹中添加文件 <bpt id="p2">**</bpt>MobileOrderController.cs<ept id="p2">**</ept>：</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>现在，你可以运行服务。按 <bpt id="p1">**</bpt>F5<ept id="p1">**</ept>，然后使用内置于帮助页中的测试客户端来修改数据。</source>
          <target state="new">现在，你可以运行服务。按 <bpt id="p1">**</bpt>F5<ept id="p1">**</ept>，然后使用内置于帮助页中的测试客户端来修改数据。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>请注意，这两个控制器实现独占使用 <bpt id="p1">**</bpt>MobileCustomer<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>MobileOrder<ept id="p2">**</ept>，且不区分基础模型。这些 DTO 已序列化为 JSON，并可用来与所有平台上的移动服务客户端 SDK 交换数据。例如，如果生成 Windows 应用商店应用程序，则相应的客户端类型将如下所示。该类型将与其他客户端平台上的类型相似。</source>
          <target state="new">请注意，这两个控制器实现独占使用 <bpt id="p1">**</bpt>MobileCustomer<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>MobileOrder<ept id="p2">**</ept>，且不区分基础模型。这些 DTO 已序列化为 JSON，并可用来与所有平台上的移动服务客户端 SDK 交换数据。例如，如果生成 Windows 应用商店应用程序，则相应的客户端类型将如下所示。该类型将与其他客户端平台上的类型相似。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>接下来，你可以生成客户端应用程序以访问服务。</source>
          <target state="new">接下来，你可以生成客户端应用程序以访问服务。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>