<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7a031e4d49529a92ab29568ccc5c7132571dc107</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>用于分片的弹性数据库查询（水平分区）| Azure</source>
          <target state="new">用于分片的弹性数据库查询（水平分区）| Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>如何对水平分区设置弹性查询</source>
          <target state="new">如何对水平分区设置弹性查询</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>用于分片的弹性数据库查询（水平分区）</source>
          <target state="new">用于分片的弹性数据库查询（水平分区）</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>本文档说明如何为水平分区方案设置弹性数据库查询以及如何执行查询。有关水平分区方案的定义，请参阅<bpt id="p1">[</bpt>弹性数据库查询概述（预览版）<ept id="p1">](/documentation/articles/sql-database-elastic-query-overview)</ept>。</source>
          <target state="new">本文档说明如何为水平分区方案设置弹性数据库查询以及如何执行查询。有关水平分区方案的定义，请参阅<bpt id="p1">[</bpt>弹性数据库查询概述（预览版）<ept id="p1">](/documentation/articles/sql-database-elastic-query-overview)</ept>。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>跨分片进行查询</source>
          <target state="new">跨分片进行查询</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>该功能是 Azure SQL <bpt id="p1">[</bpt>数据库弹性数据库功能集<ept id="p1">](/documentation/articles/sql-database-elastic-scale-introduction)</ept>的一部分。</source>
          <target state="new">该功能是 Azure SQL <bpt id="p1">[</bpt>数据库弹性数据库功能集<ept id="p1">](/documentation/articles/sql-database-elastic-scale-introduction)</ept>的一部分。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>创建数据库对象</source>
          <target state="new">创建数据库对象</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>弹性数据库查询扩展 T-SQL 语法以引用数据层，这些数据层使用分片（或水平分区）将数据分布到多个数据库上。本部分概述了与分片表上的弹性查询关联的 DDL 语句。这些语句在弹性查询数据库中创建元数据表示形式的分片数据层。运行这些语句的先决条件是使用弹性数据库客户端库创建分片映射。有关详细信息，请参阅<bpt id="p1">[</bpt>分片映射管理<ept id="p1">](/documentation/articles/sql-database-elastic-scale-shard-map-management)</ept>；或使用以下主题中的示例创建一个分片映射：<bpt id="p2">[</bpt>弹性数据库工具入门<ept id="p2">](/documentation/articles/sql-database-elastic-scale-get-started)</ept>。</source>
          <target state="new">弹性数据库查询扩展 T-SQL 语法以引用数据层，这些数据层使用分片（或水平分区）将数据分布到多个数据库上。本部分概述了与分片表上的弹性查询关联的 DDL 语句。这些语句在弹性查询数据库中创建元数据表示形式的分片数据层。运行这些语句的先决条件是使用弹性数据库客户端库创建分片映射。有关详细信息，请参阅<bpt id="p1">[</bpt>分片映射管理<ept id="p1">](/documentation/articles/sql-database-elastic-scale-shard-map-management)</ept>；或使用以下主题中的示例创建一个分片映射：<bpt id="p2">[</bpt>弹性数据库工具入门<ept id="p2">](/documentation/articles/sql-database-elastic-scale-get-started)</ept>。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>定义弹性数据库查询的数据库对象依赖于以下 T-SQL 语句，下面将针对水平分区方案对这些语句进行进一步说明：</source>
          <target state="new">定义弹性数据库查询的数据库对象依赖于以下 T-SQL 语句，下面将针对水平分区方案对这些语句进行进一步说明：</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>CREATE MASTER KEY</source>
          <target state="new">CREATE MASTER KEY</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>CREATE DATABASE SCOPED CREDENTIAL</source>
          <target state="new">CREATE DATABASE SCOPED CREDENTIAL</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>CREATE/DROP EXTERNAL DATA SOURCE</source>
          <target state="new">CREATE/DROP EXTERNAL DATA SOURCE</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>CREATE/DROP EXTERNAL TABLE</source>
          <target state="new">CREATE/DROP EXTERNAL TABLE</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>1\.1 数据库范围的主密钥和凭据</source>
          <target state="new">1\.1 数据库范围的主密钥和凭据</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>凭据表示弹性查询将用于连接到 Azure SQL 数据库中的远程数据库的用户 ID 和密码。若要创建所需的主密钥和凭据，请使用以下语法：</source>
          <target state="new">凭据表示弹性查询将用于连接到 Azure SQL 数据库中的远程数据库的用户 ID 和密码。若要创建所需的主密钥和凭据，请使用以下语法：</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>或者若要删除凭据和密钥，请使用以下语法：</source>
          <target state="new">或者若要删除凭据和密钥，请使用以下语法：</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>注意<ept id="p1">**</ept> 请确保 <bpt id="p2">*</bpt>&lt; username&gt;<ept id="p2">*</ept> 中不包括任何 <bpt id="p3">*</bpt>“@servername”<ept id="p3">*</ept> 后缀。</source>
          <target state="new"><bpt id="p1">**</bpt>注意<ept id="p1">**</ept> 请确保 <bpt id="p2">*</bpt>&lt; username&gt;<ept id="p2">*</ept> 中不包括任何 <bpt id="p3">*</bpt>“@servername”<ept id="p3">*</ept> 后缀。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>1\.2 外部数据源</source>
          <target state="new">1\.2 外部数据源</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>通过定义外部数据源提供有关分片映射和数据层的信息。外部数据源引用分片映射。然后，弹性查询使用外部数据源和基础分片映射枚举参与数据层的数据库。用于创建外部数据源的语法定义如下：</source>
          <target state="new">通过定义外部数据源提供有关分片映射和数据层的信息。外部数据源引用分片映射。然后，弹性查询使用外部数据源和基础分片映射枚举参与数据层的数据库。用于创建外部数据源的语法定义如下：</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>或者若要删除外部数据源：</source>
          <target state="new">或者若要删除外部数据源：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>CREATE/DROP EXTERNAL DATA SOURCE 的权限</source>
          <target state="new">CREATE/DROP EXTERNAL DATA SOURCE 的权限</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>用户必须拥有 ALTER ANY EXTERNAL DATA SOURCE 权限。此权限包含在 ALTER DATABASE 权限中。</source>
          <target state="new">用户必须拥有 ALTER ANY EXTERNAL DATA SOURCE 权限。此权限包含在 ALTER DATABASE 权限中。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>示例</source>
          <target state="new">示例</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>以下示例说明了如何使用 CREATE 语句创建外部数据源。</source>
          <target state="new">以下示例说明了如何使用 CREATE 语句创建外部数据源。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>你可以从以下目录视图检索当前外部数据源的列表：</source>
          <target state="new">你可以从以下目录视图检索当前外部数据源的列表：</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>请注意，在弹性查询处理过程中，相同的凭据用于读取分片映射和访问上分片的数据。</source>
          <target state="new">请注意，在弹性查询处理过程中，相同的凭据用于读取分片映射和访问上分片的数据。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>1\.3 外部表</source>
          <target state="new">1\.3 外部表</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>弹性查询将扩展外部表 DDL 以引用水平分区到多个数据库的外部表。外部表定义涵盖以下方面：</source>
          <target state="new">弹性查询将扩展外部表 DDL 以引用水平分区到多个数据库的外部表。外部表定义涵盖以下方面：</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>架构<ept id="p1">**</ept>：外部表 DDL 定义了你的查询可以使用的架构。外部表定义中提供的架构需要与存储实际数据的分片上的表的架构匹配。</source>
          <target state="new"><bpt id="p1">**</bpt>架构<ept id="p1">**</ept>：外部表 DDL 定义了你的查询可以使用的架构。外部表定义中提供的架构需要与存储实际数据的分片上的表的架构匹配。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>数据分布<ept id="p1">**</ept>：外部表 DDL 定义了用于将数据分布到数据层上的数据分布。请注意 Azure SQL 数据库不会针对分片上的实际分布验证外部表上定义的分布。你负责确保分片上的实际数据分布与外部表定义相匹配。</source>
          <target state="new"><bpt id="p1">**</bpt>数据分布<ept id="p1">**</ept>：外部表 DDL 定义了用于将数据分布到数据层上的数据分布。请注意 Azure SQL 数据库不会针对分片上的实际分布验证外部表上定义的分布。你负责确保分片上的实际数据分布与外部表定义相匹配。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>数据层引用<ept id="p1">**</ept>：外部表 DDL 引用外部数据源。外部数据源指定分片映射，后者为外部表提供在数据层中找到所有数据库所需的信息。</source>
          <target state="new"><bpt id="p1">**</bpt>数据层引用<ept id="p1">**</ept>：外部表 DDL 引用外部数据源。外部数据源指定分片映射，后者为外部表提供在数据层中找到所有数据库所需的信息。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>使用上一节中所述的外部数据源时，用于创建和删除外部表的语法如下：</source>
          <target state="new">使用上一节中所述的外部数据源时，用于创建和删除外部表的语法如下：</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>DATA\_SOURCE 子句定义用于外部表的外部数据源（在水平分区情况下的分片映射）。</source>
          <target state="new">DATA\_SOURCE 子句定义用于外部表的外部数据源（在水平分区情况下的分片映射）。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>使用 SCHEMA\_NAME 和 OBJECT\_NAME 子句可分别将外部表定义映射到分片上不同架构中的表，或映射到具有不同名称的表。如果省略，则假定远程对象的架构是“dbo”，并假定其名称与所定义的外部表名称相同。</source>
          <target state="new">使用 SCHEMA\_NAME 和 OBJECT\_NAME 子句可分别将外部表定义映射到分片上不同架构中的表，或映射到具有不同名称的表。如果省略，则假定远程对象的架构是“dbo”，并假定其名称与所定义的外部表名称相同。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>当远程表的名称已在你要在其中创建外部表的数据库中使用时，SCHEMA\_NAME 和 OBJECT\_NAME 子句特别有用。此问题的一个示例是当你要定义外部表以在扩大的数据层上获取目录视图或 DMV 的聚合视图时。由于目录视图和 DMV 已在本地存在，因此不能在外部表定义中使用其名称。而是改用不同名称，并在 SCHEMA\_NAME 和/或 OBJECT\_NAME 子句中使用目录视图或 DMV 的名称。（请参阅下面的示例。）</source>
          <target state="new">当远程表的名称已在你要在其中创建外部表的数据库中使用时，SCHEMA\_NAME 和 OBJECT\_NAME 子句特别有用。此问题的一个示例是当你要定义外部表以在扩大的数据层上获取目录视图或 DMV 的聚合视图时。由于目录视图和 DMV 已在本地存在，因此不能在外部表定义中使用其名称。而是改用不同名称，并在 SCHEMA\_NAME 和/或 OBJECT\_NAME 子句中使用目录视图或 DMV 的名称。（请参阅下面的示例。）</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>DISTRIBUTION 子句指定用于此表的数据分布：</source>
          <target state="new">DISTRIBUTION 子句指定用于此表的数据分布：</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>SHARDED 表示此表的数据将水平分区到分片映射中的数据库上。数据分布的分区键在 &lt;sharding_column_name&gt; 参数中捕获。</source>
          <target state="new">SHARDED 表示此表的数据将水平分区到分片映射中的数据库上。数据分布的分区键在 &lt;sharding_column_name&gt; 参数中捕获。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>REPLICATED 表示表的相同副本将存在于分片映射中的每个数据库上。Azure SQL 数据库不维护表的副本。你负责确保各数据库上的副本是相同的。</source>
          <target state="new">REPLICATED 表示表的相同副本将存在于分片映射中的每个数据库上。Azure SQL 数据库不维护表的副本。你负责确保各数据库上的副本是相同的。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>ROUND\_ROBIN 表示将使用水平分区对表进行分布。但是，已使用应用程序相关的分布。</source>
          <target state="new">ROUND\_ROBIN 表示将使用水平分区对表进行分布。但是，已使用应用程序相关的分布。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>查询处理器利用 DISTRIBUTION 子句中提供的信息来构建最有效的查询计划。</source>
          <target state="new">查询处理器利用 DISTRIBUTION 子句中提供的信息来构建最有效的查询计划。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>使用以下语句删除外部表：</source>
          <target state="new">使用以下语句删除外部表：</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CREATE/DROP EXTERNAL TABLE 的权限：<ept id="p1">**</ept>需要 ALTER ANY EXTERNAL DATA SOURCE 权限，在引用基础数据源时也需要该权限。</source>
          <target state="new"><bpt id="p1">**</bpt>CREATE/DROP EXTERNAL TABLE 的权限：<ept id="p1">**</ept>需要 ALTER ANY EXTERNAL DATA SOURCE 权限，在引用基础数据源时也需要该权限。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>安全注意事项：<ept id="p1">**</ept>有权访问外部表的用户在使用外部数据源定义中提供的凭据时自动获得对基础远程表的访问权。你应小心管理对外部表的访问权以避免通过外部数据源的凭据意外地提升权限。可以使用常规 SQL 权限来授予或撤消对外部表的访问权，就像它是常规表一样。</source>
          <target state="new"><bpt id="p1">**</bpt>安全注意事项：<ept id="p1">**</ept>有权访问外部表的用户在使用外部数据源定义中提供的凭据时自动获得对基础远程表的访问权。你应小心管理对外部表的访问权以避免通过外部数据源的凭据意外地提升权限。可以使用常规 SQL 权限来授予或撤消对外部表的访问权，就像它是常规表一样。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>示例<ept id="p1">**</ept>：以下示例说明如何创建外部表：</source>
          <target state="new"><bpt id="p1">**</bpt>示例<ept id="p1">**</ept>：以下示例说明如何创建外部表：</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>以下示例演示如何从当前数据库中检索外部表的列表：</source>
          <target state="new">以下示例演示如何从当前数据库中检索外部表的列表：</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>查询</source>
          <target state="new">查询</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>2\.1 完全保真的 T-SQL 查询</source>
          <target state="new">2\.1 完全保真的 T-SQL 查询</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>定义外部数据源和外部表后，现在可以对外部表使用完整的 T-SQL。</source>
          <target state="new">定义外部数据源和外部表后，现在可以对外部表使用完整的 T-SQL。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>水平分区的示例：<ept id="p1">**</ept>下面的查询执行仓库、订单和订单行之间的三向联接，并使用多个聚合和选择性筛选器。它假定进行 (1) 水平分区（分片），(2) 仓库、订单和订单行按仓库 ID 列共享，并且弹性查询可以排列分片上的联接，且并行处理分片上的查询的成本高昂部分。</source>
          <target state="new"><bpt id="p1">**</bpt>水平分区的示例：<ept id="p1">**</ept>下面的查询执行仓库、订单和订单行之间的三向联接，并使用多个聚合和选择性筛选器。它假定进行 (1) 水平分区（分片），(2) 仓库、订单和订单行按仓库 ID 列共享，并且弹性查询可以排列分片上的联接，且并行处理分片上的查询的成本高昂部分。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>2\.2 存储过程 SP\_EXECUTE\_FANOUT</source>
          <target state="new">2\.2 存储过程 SP\_EXECUTE\_FANOUT</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>弹性查询还引入了一个存储过程，以便提供对分片的直接访问。该存储过程名为 sp\_execute\_fanout 并采用以下参数：</source>
          <target state="new">弹性查询还引入了一个存储过程，以便提供对分片的直接访问。该存储过程名为 sp\_execute\_fanout 并采用以下参数：</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>服务器名称 (nvarchar)：托管分片映射的逻辑服务器的完全限定名称。</source>
          <target state="new">服务器名称 (nvarchar)：托管分片映射的逻辑服务器的完全限定名称。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>分片映射数据库名称 (nvarchar)：分片映射数据库的名称。</source>
          <target state="new">分片映射数据库名称 (nvarchar)：分片映射数据库的名称。</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>用户名 (nvarchar)：用于登录到分片映射数据库的用户名。</source>
          <target state="new">用户名 (nvarchar)：用于登录到分片映射数据库的用户名。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>密码 (nvarchar)：用户的密码。</source>
          <target state="new">密码 (nvarchar)：用户的密码。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>分片映射名称 (nvarchar)：要用于查询的分片映射的名称。</source>
          <target state="new">分片映射名称 (nvarchar)：要用于查询的分片映射的名称。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>查询：要在每个分片上执行的 T-SQL 查询。</source>
          <target state="new">查询：要在每个分片上执行的 T-SQL 查询。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>参数声明 (nvarchar) - 可选：在查询参数（如 sp\_executesql）中使用的参数的字符串（包含数据类型定义）。</source>
          <target state="new">参数声明 (nvarchar) - 可选：在查询参数（如 sp\_executesql）中使用的参数的字符串（包含数据类型定义）。</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>参数值列表 - 可选：以逗号分隔的参数值（如 sp\_executesql）的列表</source>
          <target state="new">参数值列表 - 可选：以逗号分隔的参数值（如 sp\_executesql）的列表</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>sp\_execute\_fanout 使用调用参数中提供的分片映射信息在注册到分片映射的所有分片上执行给定的 T-SQL 语句。使用 UNION ALL 语义合并任何结果。结果还包括附加的“virtual”列，其中包含分片名称。</source>
          <target state="new">sp\_execute\_fanout 使用调用参数中提供的分片映射信息在注册到分片映射的所有分片上执行给定的 T-SQL 语句。使用 UNION ALL 语义合并任何结果。结果还包括附加的“virtual”列，其中包含分片名称。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>请注意，使用相同的凭据连接到分片映射数据库和分片。</source>
          <target state="new">请注意，使用相同的凭据连接到分片映射数据库和分片。</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>示例：</source>
          <target state="new">示例：</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>工具的连接</source>
          <target state="new">工具的连接</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>可以使用常规 SQL Server 连接字符串将应用程序、BI 和数据集成工具连接到具有外部表定义的数据库。请确保支持将 SQL Server 用作工具的数据源。然后引用弹性查询数据库就像连接到工具的任何其他 SQL Server 数据库一样，并像使用本地表一样从工具或应用程序使用外部表。</source>
          <target state="new">可以使用常规 SQL Server 连接字符串将应用程序、BI 和数据集成工具连接到具有外部表定义的数据库。请确保支持将 SQL Server 用作工具的数据源。然后引用弹性查询数据库就像连接到工具的任何其他 SQL Server 数据库一样，并像使用本地表一样从工具或应用程序使用外部表。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>最佳实践</source>
          <target state="new">最佳实践</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>确保已向弹性查询终结点数据库授予通过 SQL 数据库防火墙访问分片映射数据库和所有分片的权限。</source>
          <target state="new">确保已向弹性查询终结点数据库授予通过 SQL 数据库防火墙访问分片映射数据库和所有分片的权限。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>弹性查询不验证或强制执行由外部表定义的数据分布。如果实际的数据分布不同于表定义中指定的分布，你的查询可能会产生意外的结果。</source>
          <target state="new">弹性查询不验证或强制执行由外部表定义的数据分布。如果实际的数据分布不同于表定义中指定的分布，你的查询可能会产生意外的结果。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>当分片键上的谓词允许安全地从处理中排除某些分片时，弹性查询当前不执行分片消除。</source>
          <target state="new">当分片键上的谓词允许安全地从处理中排除某些分片时，弹性查询当前不执行分片消除。</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>弹性查询最适合大部分计算可以在分片上完成的查询。使用可以在分片或联接上通过分区键求值的选择性筛选器谓词（可以在所有分片上以分区对齐方式执行），通常可以获得最佳查询性能。其他查询模式可能需要从分片将大量数据加载到头节点并且可能会执行效果不佳</source>
          <target state="new">弹性查询最适合大部分计算可以在分片上完成的查询。使用可以在分片或联接上通过分区键求值的选择性筛选器谓词（可以在所有分片上以分区对齐方式执行），通常可以获得最佳查询性能。其他查询模式可能需要从分片将大量数据加载到头节点并且可能会执行效果不佳</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>