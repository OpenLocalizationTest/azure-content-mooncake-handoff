<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="zh-cn" target-language="en-us">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-f2b4b1a" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ef6ae4f2f144700d17412746bbf9e737b80c0a2f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">articles\websites-dotnet-webjobs-sdk-storage-queues-how-to.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6d53237c4aaef580d681d613e1b1a7591b8fb8c1</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">49bd8d63e4253b3e58fe62f62338052629f7aeb2</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 WebJobs SDK 使用 Azure 队列存储</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何通过 WebJobs SDK 使用 Azure 队列存储。</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>创建和删除队列；插入、扫视、获取和删除队列消息，等等。</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>如何通过 WebJobs SDK 使用 Azure 队列存储</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>概述</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>本指南提供了 C# 代码示例，用于演示如何在 Azure 队列存储服务中使用 Azure WebJobs SDK 版本 1.x。</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>本指南假设你了解<bpt id="p1">[</bpt>如何使用指向存储帐户的连接字符串在 Visual Studio 中创建 WebJob 项目<ept id="p1">](/documentation/articles/websites-dotnet-webjobs-sdk-get-started#configure-storage)</ept>或创建<bpt id="p2">[</bpt>多个存储帐户<ept id="p2">](https://github.com/Azure/azure-webjobs-sdk/blob/master/test/Microsoft.Azure.WebJobs.Host.EndToEndTests/MultipleStorageAccountsEndToEndTests.cs)</ept>。</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>大多数代码段只显示函数，不同于创建 <ph id="ph1">`JobHost`</ph> 对象的代码，如以下示例所示：</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>本指南涉及以下主题：</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>如何在接收队列消息时触发函数</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>字符串队列消息</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>POCO 队列消息</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>异步函数</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>QueueTrigger 属性适用的类型</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>轮询算法</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>多个实例</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>并行执行</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>获取队列或队列消息元数据</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>正常关闭</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>如何在处理队列消息时创建队列消息</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>字符串队列消息</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>POCO 队列消息</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>在异步函数中创建多个消息</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Queue 属性适用的类型</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>在函数正文中使用 WebJobs SDK 属性</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>如何在处理队列消息时读取和写入 Blob</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>字符串队列消息</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>POCO 队列消息</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Blob 属性适用的类型</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>如何处理有害消息</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>自动处理有害消息</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>手动处理有害消息</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>如何设置配置选项</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>在代码中设置 SDK 连接字符串</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>配置 QueueTrigger 设置</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>在代码中设置 WebJobs SDK 构造函数参数的值</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>如何手动触发函数</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>如何写入日志</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>如何处理错误和配置超时</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>如何在收到队列消息时触发函数</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>若要编写在收到队列消息时 WebJobs SDK 调用的函数，请使用 <ph id="ph1">`QueueTrigger`</ph> 属性。</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>该属性构造函数使用一个字符串参数来指定要轮询的队列名称。</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>你也可以<bpt id="p1">[</bpt>动态设置队列名称<ept id="p1">](#config)</ept>。</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>字符串队列消息</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>在下面的示例中，队列中包含一个字符串消息，因此，<ph id="ph1">`QueueTrigger`</ph> 已应用到包含队列消息内容的 <ph id="ph2">`logMessage`</ph> 字符串参数。</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>该函数<bpt id="p1">[</bpt>向仪表板写入一条日志消息<ept id="p1">](#logs)</ept>。</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>除了 <ph id="ph1">`string`</ph> 以外，参数还可以是字节数组、<ph id="ph2">`CloudQueueMessage`</ph> 对象或您定义的 POCO。</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>POCO<bpt id="p1">[</bpt>（普通旧 CLR 对象<ept id="p1">](http://en.wikipedia.org/wiki/Plain_Old_CLR_Object)</ept>）队列消息</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>在下面的示例中，队列消息包含 <ph id="ph1">`BlobInformation`</ph> 对象的 JSON，该对象包含一个 <ph id="ph2">`BlobName`</ph> 属性。</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>SDK 会自动反序列化该对象。</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>SDK 使用 <bpt id="p1">[</bpt>Newtonsoft.Json NuGet 包<ept id="p1">](http://www.nuget.org/packages/Newtonsoft.Json)</ept>序列化和反序列化消息。</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>如果你在不使用 WebJobs SDK 的程序中创建队列消息，则可以如以下示例所示编写代码，以创建 SDK 可以分析的 POCO 队列消息。</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>异步函数</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>以下异步函数<bpt id="p1">[</bpt>将日志写入仪表板<ept id="p1">](#logs)</ept>。</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>异步函数可以采用<bpt id="p1">[</bpt>取消标记<ept id="p1">](http://www.asp.net/mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4#CancelToken)</ept>，如以下用于复制 blob 的示例中所示。</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>（有关 <ph id="ph1">`queueTrigger`</ph> 占位符的说明，请参阅 <bpt id="p1">[</bpt>Blob<ept id="p1">](#blobs)</ept> 部分）。</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>QueueTrigger 属性适用的类型</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>可以对 <ph id="ph1">`QueueTrigger`</ph> 使用以下类型：</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>序列化为 JSON 的 POCO 类型</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>轮询算法</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>SDK 实现了随机指数退让算法，以降低空闲队列轮询对存储事务成本造成的影响。</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>当找到消息时，SDK 将等待两秒钟，然后检查另一条消息；如果未找到消息，它将等待大约四秒，然后重试。</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>如果后续尝试获取队列消息失败，则等待时间会继续增加，直到达到最长等待时间（默认为 1 分钟）。<bpt id="p1">[</bpt>最长等待时间是可配置的<ept id="p1">](#config)</ept>。</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>多个实例</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>如果 Web 应用在多个实例上运行，则每台计算机上都会运行一个连续 Web 作业，并且每台计算机将等待触发器并尝试运行函数。</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>WebJobs SDK 队列触发器会自动阻止函数多次处理队列消息；函数无需编写为幂等函数。</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>但是，如果你想要确保即使有多个主机 Web 应用的实例，也只有一个函数实例运行，可以使用 <ph id="ph1">`Singleton`</ph> 属性。</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>并行执行</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>如果有多个函数在侦听不同的队列，SDK 将在同时接收消息时并行调用这些函数。</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>接收单个队列的多个消息时，也是如此。</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>默认情况下，SDK 每次获取包含 16 个队列消息的批，然后并行执行处理这些消息的函数。<bpt id="p1">[</bpt>批大小是可配置的<ept id="p1">](#config)</ept>。</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>当处理的数量达到批大小的一半时，SDK 将获取另一个批，并开始处理这些消息。</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>因此，每个函数处理的最大并发消息数是批大小的 1.5 倍。</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>此限制分别应用于各个包含 <ph id="ph1">`QueueTrigger`</ph> 属性的函数。</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>如果不希望对队列上收到的消息并行执行，可以将批大小设置为 1。</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>另请参阅 <bpt id="p1">[</bpt>Azure WebJobs SDK 1.1.0 RTM<ept id="p1">](http://azure.microsoft.com/zh-cn/blog/azure-webjobs-sdk-1-1-0-rtm/)</ept> 中的<bpt id="p2">**</bpt>更好地控制队列处理<ept id="p2">**</ept>。</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>获取队列或队列消息元数据</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>你可以通过将参数添加到方法签名来获取以下消息属性：</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>expirationTime</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>insertionTime</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>nextVisibleTime</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>queueTrigger（包含消息文本）</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>id</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>popReceipt</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>dequeueCount</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>如果您想直接使用 Azure 存储 API，则还可以添加 <ph id="ph1">`CloudStorageAccount`</ph> 参数。</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>下面的示例将所有这些元数据写入 INFO 应用程序日志。</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>在该示例中，logMessage 和 queueTrigger 包含队列消息的内容。</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>下面是示例代码编写的示例日志：</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>正常关闭</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>在连续 Web 作业中运行的函数可以接受 <ph id="ph1">`CancellationToken`</ph> 参数，以便操作系统能够在 Web 作业即将终止时通知此函数。</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>你可以使用此通知来确保该函数不会意外终止，导致数据处于不一致状态。</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>下面的示例演示了如何在函数中检查即将发生的 Web 作业终止。</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>注意<ept id="p1">**</ept>：仪表板可能会错误显示已关闭函数的的状态和输出。</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>有关详细信息，请参阅 <bpt id="p1">[</bpt>Web 作业正常关闭<ept id="p1">](http://blog.amitapple.com/post/2014/05/webjobs-graceful-shutdown/#.VCt1GXl0wpR)</ept>。</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>如何在处理队列消息时创建队列消息</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>若要编写用于新建队列消息的函数，请使用 <ph id="ph1">`Queue`</ph> 属性。</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>与 <ph id="ph1">`QueueTrigger`</ph> 一样，你可以传入字符串形式的队列名称，或者<bpt id="p1">[</bpt>动态设置队列名称<ept id="p1">](#config)</ept>。</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>字符串队列消息</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>下面的非异步代码示例在名为“outputqueue”的队列中创建新的队列消息，该消息的内容与名为“inputqueue”的队列中收到的队列消息相同。</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>（对于异步函数，请按照本部分稍后将介绍的方法使用 <ph id="ph1">`IAsyncCollector&lt;T&gt;`</ph>。</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>）</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>POCO<bpt id="p1">[</bpt>（普通旧 CLR 对象<ept id="p1">](http://en.wikipedia.org/wiki/Plain_Old_CLR_Object)</ept>）队列消息</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>若要创建包含 POCO（而不是字符串）的队列消息，请将 POCO 类型作为输出参数传递给 <ph id="ph1">`Queue`</ph> 属性构造函数。</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>SDK 会自动将对象序列化为 JSON。</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>即使对象为 null，也始终会创建队列消息。</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>在异步函数中创建多个消息</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>若要创建多个消息，请设置输出队列 <ph id="ph1">`ICollector&lt;T&gt;`</ph> 或 <ph id="ph2">`IAsyncCollector&lt;T&gt;`</ph> 的参数类型，如以下示例所示。</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>调用 <ph id="ph1">`Add`</ph> 方法时，将立即创建每个队列消息。</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Queue 属性适用的类型</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>可对以下参数类型使用 <ph id="ph1">`Queue`</ph> 属性：</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>（函数结束时，如果参数值为非 null，则创建队列消息）</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>（工作方式类似于 <ph id="ph1">`string`</ph>）</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>（工作方式类似于 <ph id="ph1">`string`</ph>）</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>（一种可序列化类型，如果在函数结束时参数为 null，则创建包含 null 对象的消息）</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>（用于直接通过 Azure 存储 API 手动创建消息）</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>在函数主体中使用 WebJobs SDK 属性</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>如果您需要在使用 <ph id="ph1">`Queue`</ph>、<ph id="ph2">`Blob`</ph> 或 <ph id="ph3">`Table`</ph> 等 WebJobs SDK 属性之前在函数中执行某项操作，则可以使用 <ph id="ph4">`IBinder`</ph> 接口。</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>下面的示例采用一个输入队列消息，并在输出队列中创建具有相同内容的新消息。</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>输出队列名称由函数正文中的代码设置。</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>接口也可以与 <ph id="ph1">`Table`</ph> 和 <ph id="ph2">`Blob`</ph> 属性一起使用。</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>如何在处理队列消息时读取和写入 blob 和表</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>可以使用 <ph id="ph1">`Blob`</ph> 和 <ph id="ph2">`Table`</ph> 属性来读取和写入 blob 和表。</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>本部分中的示例适用于 Blob。</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>有关展示如何在创建或更新 blob 时触发进程的代码示例，请参阅<bpt id="p1">[</bpt>如何结合使用 Azure blob 存储和 WebJobs SDK<ept id="p1">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-blobs-how-to)</ept>；有关用于读取和写入表的代码示例，请参阅<bpt id="p2">[</bpt>如何结合使用 Azure 表存储和 WebJobs SDK<ept id="p2">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-tables-how-to)</ept>。</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>触发 Blob 操作的字符串队列消息</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>对于包含字符串的队列消息，<ph id="ph1">`queueTrigger`</ph> 是占位符，可以用于包含消息内容的 <ph id="ph2">`Blob`</ph> 属性的 <ph id="ph3">`blobPath`</ph> 参数。</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>下面的示例使用 <ph id="ph1">`Stream`</ph> 对象读取和写入 blob。</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>队列消息是位于 textBlobs 容器中的 Blob 名称。</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>将在同一个容器中创建 Blob 的副本，并在其名称后面附加“-new”。</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>属性构造函数采用指定容器和 blob 名称的 <ph id="ph1">`blobPath`</ph> 参数。</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>有关此占位符的详细信息，请参阅<bpt id="p1">[</bpt>如何结合使用 Azure blob 存储和 WebJobs SDK<ept id="p1">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-blobs-how-to)</ept>。</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>当属性修饰 <ph id="ph1">`Stream`</ph> 对象时，另一个构造函数参数会将 <ph id="ph2">`FileAccess`</ph> 模式指定为读取、写入或读取/写入。</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>下面的示例使用 <ph id="ph1">`CloudBlockBlob`</ph> 对象删除 blob。</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>队列消息是 Blob 的名称。</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>POCO<bpt id="p1">[</bpt>（普通旧 CLR 对象<ept id="p1">](http://en.wikipedia.org/wiki/Plain_Old_CLR_Object)</ept>）队列消息</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>对于在队列消息中存储为 JSON 的 POCO，您可以使用占位符来命名 <ph id="ph1">`Queue`</ph> 属性的 <ph id="ph2">`blobPath`</ph> 参数中的对象属性。</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>还可以将<bpt id="p1">[</bpt>队列元数据属性名称<ept id="p1">](#queuemetadata)</ept>用作占位符。</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>下面的示例将 Blob 复制到具有不同扩展名的新 Blob。</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>队列消息是包含 <ph id="ph1">`BlobName`</ph> 和 <ph id="ph2">`BlobNameWithoutExtension`</ph> 属性的 <ph id="ph3">`BlobInformation`</ph> 对象。</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>属性名称用作 <ph id="ph1">`Blob`</ph> 属性的 blob 路径中的占位符。</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>SDK 使用 <bpt id="p1">[</bpt>Newtonsoft.Json NuGet 包<ept id="p1">](http://www.nuget.org/packages/Newtonsoft.Json)</ept>序列化和反序列化消息。</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>如果你在不使用 WebJobs SDK 的程序中创建队列消息，则可以如以下示例所示编写代码，以创建 SDK 可以分析的 POCO 队列消息。</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>如果在将 blob 绑定到对象之前，您需要在函数中执行某项操作，则可以在函数主体中使用属性，<bpt id="p1">[</bpt>如前面的 Queue 属性所示<ept id="p1">](#ibinder)</ept>。</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Blob 属性适用的类型</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>属性适用以下类型：</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>（读取或写入，通过使用 FileAccess 构造函数参数指定）</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>（读取）</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>（写入；仅当字符串参数在函数返回结果时为非 null 的情况下，才创建 blob）</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>POCO（读取）</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>out POCO（写入；始终创建 Blob，如果函数返回时 POCO 参数为 null，则创建 null 对象）</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>（写入）</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>（读取或写入）</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>（读取或写入）</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>（读取或写入）</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>如何处理病毒消息</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>内容导致函数失败的消息称为<bpt id="p1">*</bpt>病毒消息<ept id="p1">*</ept>。</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>当函数失败时，将不删除并最终再次选择队列消息，从而导致周期重复。</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>在达到限制的迭代次数后，SDK 可自动中断周期，你也可以手动中断。</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>自动处理有害消息</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>SDK 在处理一个队列消息时最多会调用某个函数 5 次。</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>如果第五次尝试失败，消息将移到有害队列。<bpt id="p1">[</bpt>最大重试次数可配置<ept id="p1">](#config)</ept>。</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>病毒队列的名称为 <bpt id="p1">*</bpt>{originalqueuename}<ept id="p1">*</ept>-poison。</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>你可以编写一个函数来处理有害队列中的消息，并记录这些消息，或者发送需要注意的通知。</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>在下面的示例中，如果队列消息包含不存在的 blob 名称，则 <ph id="ph1">`CopyBlob`</ph> 函数会失败。</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>在这种情况，消息将从 copyBlobqueue 队列移到 copyBlobqueue-poison 队列。</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>然后，<ph id="ph1">`ProcessPoisonMessage`</ph> 将记录有害消息。</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>下图显示了处理有害消息时这些函数的控制台输出。</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>处理病毒消息时的控制台输出</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>手动处理有害消息</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>您可以向您的函数添加名为 <ph id="ph1">`dequeueCount`</ph> 的 <ph id="ph2">`int`</ph> 参数，获取选择处理某消息的次数。</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>然后，你可以检查函数代码中的取消排队计数，并在处理次数超过阈值时执行自己的有害消息处理，如以下示例中所示。</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>如何设置配置选项</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>您可以使用 <ph id="ph1">`JobHostConfiguration`</ph> 类型设置以下配置选项：</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>在代码中设置 SDK 连接字符串。</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>配置 <ph id="ph1">`QueueTrigger`</ph> 设置，例如最大取消排队计数。</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>从配置中获取队列名称。</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>在代码中设置 SDK 连接字符串</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>在代码中设置 SDK 连接字符串可以在配置文件或环境变量中使用自己的连接字符串名称，如以下示例中所示。</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>配置 QueueTrigger 设置</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>你可以配置以下用于处理队列消息的设置：</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>同时选择的、要并行执行的最大队列消息数（默认值为 16）。</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>在将队列消息发送到有害队列之前要重试的最大次数（默认值为 5）。</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>当队列为空时，再次轮询之前要等待的最长时间（默认值为 1 分钟）。</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>下面的示例演示如何配置这些设置：</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>在代码中设置 WebJobs SDK 构造函数参数的值</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>有时，你想要在代码中指定队列名称、Blob 名称、容器或表名称，而不是进行硬编码。</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>例如，您可能想在配置文件或环境变量中指定 <ph id="ph1">`QueueTrigger`</ph> 的队列名称。</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>为此，您可以向 <ph id="ph1">`JobHostConfiguration`</ph> 类型传递 <ph id="ph2">`NameResolver`</ph> 对象。</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>此时，你可以在 WebJobs SDK 属性构造函数参数中包含以百分号 (%) 括住的特殊占位符，你的 <ph id="ph1">`NameResolver`</ph> 代码将指定要用于取代这些占位符的实际值。</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>例如，假设你要在测试环境中使用名为 logqueuetest 的队列，并在生产环境中使用名为 logqueueprod 的队列。</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>您希望在具有实际队列名称的 <ph id="ph1">`appSettings`</ph> 集合中指定条目名称，而不是硬编码的队列名称。</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>如果 <ph id="ph1">`appSettings`</ph> 键为 logqueue，则函数如以下示例所示。</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>然后，<ph id="ph1">`NameResolver`</ph> 类可以从 <ph id="ph2">`appSettings`</ph> 获取队列名称，如以下示例所示：</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>将 <ph id="ph1">`NameResolver`</ph> 类传入 <ph id="ph2">`JobHost`</ph> 对象，如以下示例中所示。</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>注意：<ept id="p1">**</ept>每次调用函数，都会解析队列名称、表名称和 blob 名称，但 blob 容器名称只会在应用程序启动时进行解析。</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>在作业运行时，您无法更改 blob 容器名称。</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>如何手动触发函数</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>若要手动触发函数，请对 <ph id="ph1">`JobHost`</ph> 对象使用 <ph id="ph2">`Call`</ph> 或 <ph id="ph3">`CallAsync`</ph> 方法，并对函数使用 <ph id="ph4">`NoAutomaticTrigger`</ph> 属性，如以下示例所示。</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>如何写入日志</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>仪表板在两个位置显示日志：针对 Web 作业的页，以及针对特定 Web 作业调用的页。</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>WebJob 页中的日志</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>函数调用页中的日志</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>在函数或 <ph id="ph1">`Main()`</ph> 方法中调用的控制台方法的输出在 Web 作业的仪表板页面上显示，而不是在特定方法调用页面上显示。</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>从方法签名的参数中获取的 TextWriter 对象的输出在方法调用的仪表板页中显示。</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>无法将控制台输出链接到特定的方法调用，因为控制台是单线程的，而许多作业函数可能同时运行。</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>正因如此，SDK 为每个函数调用提供了自身唯一的日志写入器对象。</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>若要写入<bpt id="p1">[</bpt>应用程序跟踪日志<ept id="p1">](/documentation/articles/web-sites-dotnet-troubleshoot-visual-studio#logsoverview)</ept>，请使用 <ph id="ph1">`Console.Out`</ph>（创建标记为 INFO 的日志）和 <ph id="ph2">`Console.Error`</ph>（创建标记为 ERROR 的日志）。</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>或者，您可以使用 <bpt id="p1">[</bpt>Trace 或 TraceSource<ept id="p1">](http://blogs.msdn.com/b/mcsuksoldev/archive/2014/09/04/adding-trace-to-azure-web-sites-and-web-jobs.aspx)</ept>，它除了提供“信息”和“错误”外，还提供“详细”、“警告”和“严重级别”。</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>应用程序跟踪日志将显示在 Web 应用日志文件、Azure 表或 Azure Blob 中，具体取决于你如何配置 Azure Web 应用。</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>与所有控制台输出一样，最近的 100 条应用程序日志也会显示在 Web 作业的仪表板页中，而不是显示在函数调用的页中。</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>仅当程序在 Azure Web 作业中运行（而不是在本地运行或者在其他某个环境中运行）时，控制台输出才显示在仪表板中。</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>为高吞吐量方案禁用仪表板日志记录。</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>默认情况下，SDK 将日志写入存储，此活动会在处理的消息较多时降低性能。</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>若要禁用日志记录，请按以下示例中所示，将仪表板连接字符串设置为 null。</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>下面的示例演示了写入日志的多种方法：</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>在 WebJobs SDK 仪表板中，当您转到特定函数调用页面并单击“切换输出”时，您会看到 <ph id="ph1">`TextWriter`</ph> 对象的输出：</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>单击函数调用链接</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>函数调用页中的日志</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>在 WebJobs SDK 仪表板中，当您转到 Web 作业（而不是函数调用）页面并单击“切换输出”时，您会看到最近的 100 行控制台输出。</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>单击“切换输出”</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>在连续 Web 作业中，应用程序日志显示在 Web 应用文件系统的 /data/jobs/continuous/<bpt id="p1">*</bpt>{webjobname}<ept id="p1">*</ept>/job<ph id="ph1">\_</ph>log.txt 中。</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>在 Azure blob 中，应用程序日志如下所示： 2014-09-26T21:01:13,Information,contosoadsnew,491e54,635473620738373502,0,17404,17,Console.Write - Hello world!, 2014-09-26T21:01:13,Error,contosoadsnew,491e54,635473620738373502,0,17404,19,Console.Error - Hello world!, 2014-09-26T21:01:13,Information,contosoadsnew,491e54,635473620738529920,0,17404,17,Console.Out - Hello world!,</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>在 Azure 表中，<ph id="ph1">`Console.Out`</ph> 和 <ph id="ph2">`Console.Error`</ph> 日志如下所示：</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>表中的信息日志</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>表中的错误日志</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>如果要插入自己的记录器，请参阅<bpt id="p1">[</bpt>此示例<ept id="p1">](http://github.com/Azure/azure-webjobs-sdk-samples/blob/master/BasicSamples/MiscOperations/Program.cs)</ept>。</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>如何处理错误和配置超时</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>WebJobs SDK 还包括 <bpt id="p1">[</bpt>Timeout<ept id="p1">](http://github.com/Azure/azure-webjobs-sdk-samples/blob/master/BasicSamples/MiscOperations/Functions.cs)</ept> 属性，可用于在函数未在指定的时间内完成时取消函数。</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>而且，如果你想要在指定的时间段内发生太多错误时引发警报，可以使用 <ph id="ph1">`ErrorTrigger`</ph> 属性。</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>下面是 <bpt id="p1">[</bpt>ErrorTrigger 示例<ept id="p1">](https://github.com/Azure/azure-webjobs-sdk-extensions/wiki/Error-Monitoring)</ept>。</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>你还可以使用配置开关（可以是应用设置或环境变量名称）动态地禁用和启用函数以控制是否可以触发它们。</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>有关示例代码，请参阅 <bpt id="p1">[</bpt>WebJobs SDK 示例存储库<ept id="p1">](https://github.com/Azure/azure-webjobs-sdk-samples/blob/master/BasicSamples/MiscOperations/Functions.cs)</ept>中的 <ph id="ph1">`Disable`</ph> 属性。</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>本指南提供的代码示例演示了如何处理常见方案以操作 Azure 队列。</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>若要详细了解如何使用 Azure WebJobs 和 WebJobs SDK，请参阅<bpt id="p1">[</bpt>有关 Azure WebJobs 的推荐资源<ept id="p1">](/documentation/articles/websites-webjobs-resources/)</ept>。</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>