<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9997f482207436f4fc94788ef5a9576e65beaf0a</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 PHP 使用表存储 | Azure</source>
          <target state="new">如何通过 PHP 使用表存储 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何通过 PHP 使用表服务来创建和删除表以及插入、删除和查询表。</source>
          <target state="new">了解如何通过 PHP 使用表服务来创建和删除表以及插入、删除和查询表。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何通过 PHP 使用表存储</source>
          <target state="new">如何通过 PHP 使用表存储</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本指南演示如何使用 Azure 表服务执行常见任务。示例是用 PHP 编写的并使用了 <bpt id="p1">[</bpt>Azure SDK for PHP<ept id="p1">][download]</ept>。所涉及的任务包括“创建和删除表以及在表中插入、删除和查询实体”。有关 Azure 表服务的详细信息，请参阅<bpt id="p2">[</bpt>后续步骤<ept id="p2">](#NextSteps)</ept>部分。</source>
          <target state="new">本指南演示如何使用 Azure 表服务执行常见任务。示例是用 PHP 编写的并使用了 <bpt id="p1">[</bpt>Azure SDK for PHP<ept id="p1">][download]</ept>。所涉及的任务包括“创建和删除表以及在表中插入、删除和查询实体”。有关 Azure 表服务的详细信息，请参阅<bpt id="p2">[</bpt>后续步骤<ept id="p2">](#NextSteps)</ept>部分。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>创建 PHP 应用程序</source>
          <target state="new">创建 PHP 应用程序</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>创建访问 Azure 表服务的 PHP 应用程序的唯一要求是从代码中引用 Azure SDK for PHP 中的类。你可以使用任何开发工具（包括“记事本”）创建应用程序。</source>
          <target state="new">创建访问 Azure 表服务的 PHP 应用程序的唯一要求是从代码中引用 Azure SDK for PHP 中的类。你可以使用任何开发工具（包括“记事本”）创建应用程序。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>在本指南中，你将使用表服务功能，这些功能可在 PHP 应用程序中本地调用，或通过在 Azure 的 Web 角色、辅助角色或 Web 应用中运行的代码调用。</source>
          <target state="new">在本指南中，你将使用表服务功能，这些功能可在 PHP 应用程序中本地调用，或通过在 Azure 的 Web 角色、辅助角色或 Web 应用中运行的代码调用。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>获取 Azure 客户端库</source>
          <target state="new">获取 Azure 客户端库</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>配置你的应用程序以访问表服务</source>
          <target state="new">配置你的应用程序以访问表服务</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>若要使用 Azure 表服务 API，你需要：</source>
          <target state="new">若要使用 Azure 表服务 API，你需要：</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">[</bpt>require_once<ept id="p1">][require_once]</ept> 语句引用 autoloader 文件，并</source>
          <target state="new">使用 <bpt id="p1">[</bpt>require_once<ept id="p1">][require_once]</ept> 语句引用 autoloader 文件，并</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>引用可使用的所有类。</source>
          <target state="new">引用可使用的所有类。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>下面的示例演示了如何包括 autoloader 文件并引用 <bpt id="p1">**</bpt>ServicesBuilder<ept id="p1">**</ept> 类。</source>
          <target state="new">下面的示例演示了如何包括 autoloader 文件并引用 <bpt id="p1">**</bpt>ServicesBuilder<ept id="p1">**</ept> 类。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>本示例（以及本文中的其他示例）假定您已通过 Composer 安装用于 Azure 的 PHP 客户端库。如果你已手动安装这些库或将其作为 PEAR 包安装，则需要引用 <ph id="ph2">&lt;code&gt;</ph><ph id="ph3">WindowsAzure.php</ph><ph id="ph4">&lt;/code&gt;</ph> autoloader 文件。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>本示例（以及本文中的其他示例）假定您已通过 Composer 安装用于 Azure 的 PHP 客户端库。如果你已手动安装这些库或将其作为 PEAR 包安装，则需要引用 <ph id="ph2">&lt;code&gt;</ph><ph id="ph3">WindowsAzure.php</ph><ph id="ph4">&lt;/code&gt;</ph> autoloader 文件。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>在下面的示例中，<ph id="ph1">`require_once`</ph> 语句将始终显示，但只会引用执行该示例所需的类。</source>
          <target state="new">在下面的示例中，<ph id="ph1">`require_once`</ph> 语句将始终显示，但只会引用执行该示例所需的类。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>设置 Azure 存储连接</source>
          <target state="new">设置 Azure 存储连接</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>若要实例化 Azure 表服务客户端，你必须首先具有有效的连接字符串。表服务连接字符串的格式为：</source>
          <target state="new">若要实例化 Azure 表服务客户端，你必须首先具有有效的连接字符串。表服务连接字符串的格式为：</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>对于访问实时服务：</source>
          <target state="new">对于访问实时服务：</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>对于访问模拟器存储：</source>
          <target state="new">对于访问模拟器存储：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>若要创建任何 Azure 服务客户端，你将需要使用 <bpt id="p1">**</bpt>ServicesBuilder<ept id="p1">**</ept> 类。你可以：</source>
          <target state="new">若要创建任何 Azure 服务客户端，你将需要使用 <bpt id="p1">**</bpt>ServicesBuilder<ept id="p1">**</ept> 类。你可以：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>将连接字符串直接传递给此类或</source>
          <target state="new">将连接字符串直接传递给此类或</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>CloudConfigurationManager (CCM)<ept id="p1">**</ept> 检查多个外部源以获取连接字符串：</source>
          <target state="new">使用 <bpt id="p1">**</bpt>CloudConfigurationManager (CCM)<ept id="p1">**</ept> 检查多个外部源以获取连接字符串：</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>默认情况下，它附带了对一个外部源的支持 - 环境变量</source>
          <target state="new">默认情况下，它附带了对一个外部源的支持 - 环境变量</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>你可通过扩展 <bpt id="p1">**</bpt>ConnectionStringSource<ept id="p1">**</ept> 类来添加新源</source>
          <target state="new">你可通过扩展 <bpt id="p1">**</bpt>ConnectionStringSource<ept id="p1">**</ept> 类来添加新源</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>在此处列出的示例中，将直接传递连接字符串。</source>
          <target state="new">在此处列出的示例中，将直接传递连接字符串。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>创建表</source>
          <target state="new">创建表</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>利用 <bpt id="p1">**</bpt>TableRestProxy<ept id="p1">**</ept> 对象，可以使用 <bpt id="p2">**</bpt>createTable<ept id="p2">**</ept> 方法创建表。创建表时，可以设置表服务超时。（有关表服务超时的详细信息，请参阅<bpt id="p3">[</bpt>为表服务操作设置超时<ept id="p3">][table-service-timeouts]</ept>。）</source>
          <target state="new">利用 <bpt id="p1">**</bpt>TableRestProxy<ept id="p1">**</ept> 对象，可以使用 <bpt id="p2">**</bpt>createTable<ept id="p2">**</ept> 方法创建表。创建表时，可以设置表服务超时。（有关表服务超时的详细信息，请参阅<bpt id="p3">[</bpt>为表服务操作设置超时<ept id="p3">][table-service-timeouts]</ept>。）</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>有关表名称的限制的信息，请参阅<bpt id="p1">[</bpt>了解表服务数据模型<ept id="p1">][table-data-model]</ept>。</source>
          <target state="new">有关表名称的限制的信息，请参阅<bpt id="p1">[</bpt>了解表服务数据模型<ept id="p1">][table-data-model]</ept>。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>将实体添加到表</source>
          <target state="new">将实体添加到表</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>若要将实体添加到表，请创建一个新的 <bpt id="p1">**</bpt>Entity<ept id="p1">**</ept> 对象并将其传递到 <bpt id="p2">**</bpt>TableRestProxy-&gt;insertEntity<ept id="p2">**</ept>。请注意，在创建实体时，你必须指定 <ph id="ph1">`PartitionKey`</ph> 和 <ph id="ph2">`RowKey`</ph>。这些值是实体的唯一标识符，并且其查询速度比其他实体属性的查询速度快得多。系统使用 <ph id="ph3">`PartitionKey`</ph> 自动将表的实体分发到多个存储节点上。具有相同 <ph id="ph4">`PartitionKey`</ph> 的实体存储在同一个节点上。（对存储在同一节点上的多个实体执行操作要将比对存储在不同节点上的实体执行的操作的效果更佳。） <ph id="ph5">`RowKey`</ph> 是实体在分区中的唯一 ID。</source>
          <target state="new">若要将实体添加到表，请创建一个新的 <bpt id="p1">**</bpt>Entity<ept id="p1">**</ept> 对象并将其传递到 <bpt id="p2">**</bpt>TableRestProxy-&gt;insertEntity<ept id="p2">**</ept>。请注意，在创建实体时，你必须指定 <ph id="ph1">`PartitionKey`</ph> 和 <ph id="ph2">`RowKey`</ph>。这些值是实体的唯一标识符，并且其查询速度比其他实体属性的查询速度快得多。系统使用 <ph id="ph3">`PartitionKey`</ph> 自动将表的实体分发到多个存储节点上。具有相同 <ph id="ph4">`PartitionKey`</ph> 的实体存储在同一个节点上。（对存储在同一节点上的多个实体执行操作要将比对存储在不同节点上的实体执行的操作的效果更佳。） <ph id="ph5">`RowKey`</ph> 是实体在分区中的唯一 ID。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>有关表属性和类型的信息，请参阅<bpt id="p1">[</bpt>了解表服务数据模型<ept id="p1">][table-data-model]</ept>。</source>
          <target state="new">有关表属性和类型的信息，请参阅<bpt id="p1">[</bpt>了解表服务数据模型<ept id="p1">][table-data-model]</ept>。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>TableRestProxy<ept id="p1">**</ept> 类提供了用于插入实体的两个替代方法：<bpt id="p2">**</bpt>insertOrMergeEntity<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>insertOrReplaceEntity<ept id="p3">**</ept>。若要使用这些方法，请创建一个新的 <bpt id="p4">**</bpt>Entity<ept id="p4">**</ept>，并将其作为参数传递到上述任一方法。如果实体不存在，则每种方法都将插入实体。在实体已存在的情况下，如果属性已存在，则 <bpt id="p5">**</bpt>insertOrMergeEntity<ept id="p5">**</ept> 将更新属性值；如果属性不存在，则该方法将添加新属性，而 <bpt id="p6">**</bpt>insertOrReplaceEntity<ept id="p6">**</ept> 将完全替换现有实体。下面的示例演示如何使用 <bpt id="p7">**</bpt>insertOrMergeEntity<ept id="p7">**</ept>。如果实体具有 <ph id="ph1">`PartitionKey`</ph>“tasksSeattle”并且 <ph id="ph2">`RowKey`</ph>“1”不存在，则将插入该实体。但是，如果之前已插入该实体（如上面的示例所示），则将更新 <ph id="ph3">`DueDate`</ph> 属性并添加 <ph id="ph4">`Status`</ph> 属性。系统还将更新 <ph id="ph5">`Description`</ph> 和 <ph id="ph6">`Location`</ph> 属性，但使用的值实际上会使其保持不变。如果后面两个属性不是如示例中所示添加的，但已存在于目标实体上，则其现有值将保持不变。</source>
          <target state="new"><bpt id="p1">**</bpt>TableRestProxy<ept id="p1">**</ept> 类提供了用于插入实体的两个替代方法：<bpt id="p2">**</bpt>insertOrMergeEntity<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>insertOrReplaceEntity<ept id="p3">**</ept>。若要使用这些方法，请创建一个新的 <bpt id="p4">**</bpt>Entity<ept id="p4">**</ept>，并将其作为参数传递到上述任一方法。如果实体不存在，则每种方法都将插入实体。在实体已存在的情况下，如果属性已存在，则 <bpt id="p5">**</bpt>insertOrMergeEntity<ept id="p5">**</ept> 将更新属性值；如果属性不存在，则该方法将添加新属性，而 <bpt id="p6">**</bpt>insertOrReplaceEntity<ept id="p6">**</ept> 将完全替换现有实体。下面的示例演示如何使用 <bpt id="p7">**</bpt>insertOrMergeEntity<ept id="p7">**</ept>。如果实体具有 <ph id="ph1">`PartitionKey`</ph>“tasksSeattle”并且 <ph id="ph2">`RowKey`</ph>“1”不存在，则将插入该实体。但是，如果之前已插入该实体（如上面的示例所示），则将更新 <ph id="ph3">`DueDate`</ph> 属性并添加 <ph id="ph4">`Status`</ph> 属性。系统还将更新 <ph id="ph5">`Description`</ph> 和 <ph id="ph6">`Location`</ph> 属性，但使用的值实际上会使其保持不变。如果后面两个属性不是如示例中所示添加的，但已存在于目标实体上，则其现有值将保持不变。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>检索单个实体</source>
          <target state="new">检索单个实体</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>利用 <bpt id="p1">**</bpt>TableRestProxy-&gt;getEntity<ept id="p1">**</ept> 方法，可以通过查询实体的 <ph id="ph1">`PartitionKey`</ph> 和 <ph id="ph2">`RowKey`</ph> 来检索它。在以下示例中，分区键 <ph id="ph3">`tasksSeattle`</ph> 和行键 <ph id="ph4">`1`</ph> 传递给 <bpt id="p2">**</bpt>getEntity<ept id="p2">**</ept> 方法。</source>
          <target state="new">利用 <bpt id="p1">**</bpt>TableRestProxy-&gt;getEntity<ept id="p1">**</ept> 方法，可以通过查询实体的 <ph id="ph1">`PartitionKey`</ph> 和 <ph id="ph2">`RowKey`</ph> 来检索它。在以下示例中，分区键 <ph id="ph3">`tasksSeattle`</ph> 和行键 <ph id="ph4">`1`</ph> 传递给 <bpt id="p2">**</bpt>getEntity<ept id="p2">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>检索分区中的所有实体</source>
          <target state="new">检索分区中的所有实体</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>使用筛选器来构造实体查询（有关详细信息，请参阅<bpt id="p1">[</bpt>查询表和实体<ept id="p1">][filters]</ept>）。若要检索分区中的所有实体，请使用筛选器“PartitionKey eq <bpt id="p2">*</bpt>partition\_name<ept id="p2">*</ept>”。下面的示例演示如何通过将筛选器传递到 <bpt id="p3">**</bpt>queryEntities<ept id="p3">**</ept> 方法来检索 <ph id="ph1">`tasksSeattle`</ph> 分区中的所有实体。</source>
          <target state="new">使用筛选器来构造实体查询（有关详细信息，请参阅<bpt id="p1">[</bpt>查询表和实体<ept id="p1">][filters]</ept>）。若要检索分区中的所有实体，请使用筛选器“PartitionKey eq <bpt id="p2">*</bpt>partition\_name<ept id="p2">*</ept>”。下面的示例演示如何通过将筛选器传递到 <bpt id="p3">**</bpt>queryEntities<ept id="p3">**</ept> 方法来检索 <ph id="ph1">`tasksSeattle`</ph> 分区中的所有实体。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>检索分区中的一部分实体</source>
          <target state="new">检索分区中的一部分实体</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>可以使用上一示例中使用的同一模式来检索分区中的部分实体。您检索的部分实体将由您使用的筛选器确定（有关详细信息，请参阅<bpt id="p1">[</bpt>查询表和实体<ept id="p1">][filters]</ept>）。下面的示例演示如何使用筛选器检索具有特定的 <ph id="ph1">`Location`</ph> 和早于指定日期 <ph id="ph2">`DueDate`</ph> 的所有实体。</source>
          <target state="new">可以使用上一示例中使用的同一模式来检索分区中的部分实体。您检索的部分实体将由您使用的筛选器确定（有关详细信息，请参阅<bpt id="p1">[</bpt>查询表和实体<ept id="p1">][filters]</ept>）。下面的示例演示如何使用筛选器检索具有特定的 <ph id="ph1">`Location`</ph> 和早于指定日期 <ph id="ph2">`DueDate`</ph> 的所有实体。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>检索一部分实体属性</source>
          <target state="new">检索一部分实体属性</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>查询可检索一部分实体属性。此方法称为“投影”，可减少带宽并提高查询性能，尤其适用于大型实体。若要指定要检索的属性，请将该属性的名称传递到 <bpt id="p1">**</bpt>Query-&gt;addSelectField<ept id="p1">**</ept> 方法。可以多次调用此方法来添加更多属性。执行 <bpt id="p2">**</bpt>TableRestProxy-&gt;queryEntities<ept id="p2">**</ept> 后，返回的实体将仅具有选定的属性。（若要返回一部分表实体，请使用上述查询中所示的筛选器。）</source>
          <target state="new">查询可检索一部分实体属性。此方法称为“投影”，可减少带宽并提高查询性能，尤其适用于大型实体。若要指定要检索的属性，请将该属性的名称传递到 <bpt id="p1">**</bpt>Query-&gt;addSelectField<ept id="p1">**</ept> 方法。可以多次调用此方法来添加更多属性。执行 <bpt id="p2">**</bpt>TableRestProxy-&gt;queryEntities<ept id="p2">**</ept> 后，返回的实体将仅具有选定的属性。（若要返回一部分表实体，请使用上述查询中所示的筛选器。）</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>更新实体</source>
          <target state="new">更新实体</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>可通过对现有实体使用 <bpt id="p1">**</bpt>Entity-&gt;setProperty<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>Entity-&gt;addProperty<ept id="p2">**</ept> 方法并调用 <bpt id="p3">**</bpt>TableRestProxy-&gt;updateEntity<ept id="p3">**</ept> 来更新该实体。下面的示例将检索一个实体、修改一个属性、删除另一个属性并添加一个新属性。请注意，通过将属性的值设为 <bpt id="p4">**</bpt>null<ept id="p4">**</ept> 可删除该属性。</source>
          <target state="new">可通过对现有实体使用 <bpt id="p1">**</bpt>Entity-&gt;setProperty<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>Entity-&gt;addProperty<ept id="p2">**</ept> 方法并调用 <bpt id="p3">**</bpt>TableRestProxy-&gt;updateEntity<ept id="p3">**</ept> 来更新该实体。下面的示例将检索一个实体、修改一个属性、删除另一个属性并添加一个新属性。请注意，通过将属性的值设为 <bpt id="p4">**</bpt>null<ept id="p4">**</ept> 可删除该属性。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>删除实体</source>
          <target state="new">删除实体</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>若要删除实体，请将表名称以及实体的 <ph id="ph1">`PartitionKey`</ph> 和 <ph id="ph2">`RowKey`</ph> 传递到 <bpt id="p1">**</bpt>TableRestProxy-&gt;deleteEntity<ept id="p1">**</ept> 方法。</source>
          <target state="new">若要删除实体，请将表名称以及实体的 <ph id="ph1">`PartitionKey`</ph> 和 <ph id="ph2">`RowKey`</ph> 传递到 <bpt id="p1">**</bpt>TableRestProxy-&gt;deleteEntity<ept id="p1">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>请注意，为了进行并发检查，可以使用 <bpt id="p1">**</bpt>DeleteEntityOptions-&gt;setEtag<ept id="p1">**</ept> 方法并将 <bpt id="p2">**</bpt>DeleteEntityOptions<ept id="p2">**</ept> 对象作为第四个参数传递到 <bpt id="p3">**</bpt>deleteEntity<ept id="p3">**</ept>，来为要删除的实体设置 Etag。</source>
          <target state="new">请注意，为了进行并发检查，可以使用 <bpt id="p1">**</bpt>DeleteEntityOptions-&gt;setEtag<ept id="p1">**</ept> 方法并将 <bpt id="p2">**</bpt>DeleteEntityOptions<ept id="p2">**</ept> 对象作为第四个参数传递到 <bpt id="p3">**</bpt>deleteEntity<ept id="p3">**</ept>，来为要删除的实体设置 Etag。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>对表操作进行批处理</source>
          <target state="new">对表操作进行批处理</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>利用 <bpt id="p1">**</bpt>TableRestProxy-&gt;batch<ept id="p1">**</ept> 方法，你可以通过一个请求执行多个操作。此处的模式涉及将操作添加到 <bpt id="p2">**</bpt>BatchRequest<ept id="p2">**</ept> 对象，然后将 <bpt id="p3">**</bpt>BatchRequest<ept id="p3">**</ept> 对象传递到 <bpt id="p4">**</bpt>TableRestProxy-&gt;batch<ept id="p4">**</ept> 方法。若要将操作添加到 <bpt id="p5">**</bpt>BatchRequest<ept id="p5">**</ept> 对象，可以多次调用以下任一方法：</source>
          <target state="new">利用 <bpt id="p1">**</bpt>TableRestProxy-&gt;batch<ept id="p1">**</ept> 方法，你可以通过一个请求执行多个操作。此处的模式涉及将操作添加到 <bpt id="p2">**</bpt>BatchRequest<ept id="p2">**</ept> 对象，然后将 <bpt id="p3">**</bpt>BatchRequest<ept id="p3">**</ept> 对象传递到 <bpt id="p4">**</bpt>TableRestProxy-&gt;batch<ept id="p4">**</ept> 方法。若要将操作添加到 <bpt id="p5">**</bpt>BatchRequest<ept id="p5">**</ept> 对象，可以多次调用以下任一方法：</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>addInsertEntity<ept id="p1">**</ept>（添加 insertEntity 操作）</source>
          <target state="new"><bpt id="p1">**</bpt>addInsertEntity<ept id="p1">**</ept>（添加 insertEntity 操作）</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>addUpdateEntity<ept id="p1">**</ept>（添加 updateEntity 操作）</source>
          <target state="new"><bpt id="p1">**</bpt>addUpdateEntity<ept id="p1">**</ept>（添加 updateEntity 操作）</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>addMergeEntity<ept id="p1">**</ept>（添加 mergeEntity 操作）</source>
          <target state="new"><bpt id="p1">**</bpt>addMergeEntity<ept id="p1">**</ept>（添加 mergeEntity 操作）</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>addInsertOrReplaceEntity<ept id="p1">**</ept>（添加 insertOrReplaceEntity 操作）</source>
          <target state="new"><bpt id="p1">**</bpt>addInsertOrReplaceEntity<ept id="p1">**</ept>（添加 insertOrReplaceEntity 操作）</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>addInsertOrMergeEntity<ept id="p1">**</ept>（添加 insertOrMergeEntity 操作）</source>
          <target state="new"><bpt id="p1">**</bpt>addInsertOrMergeEntity<ept id="p1">**</ept>（添加 insertOrMergeEntity 操作）</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>addDeleteEntity<ept id="p1">**</ept>（添加 deleteEntity 操作）</source>
          <target state="new"><bpt id="p1">**</bpt>addDeleteEntity<ept id="p1">**</ept>（添加 deleteEntity 操作）</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>下面的示例演示了如何通过单个请求执行 <bpt id="p1">**</bpt>insertEntity<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>deleteEntity<ept id="p2">**</ept> 操作：</source>
          <target state="new">下面的示例演示了如何通过单个请求执行 <bpt id="p1">**</bpt>insertEntity<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>deleteEntity<ept id="p2">**</ept> 操作：</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>有关对表操作进行批处理的详细信息，请参阅<bpt id="p1">[</bpt>执行实体组事务<ept id="p1">][entity-group-transactions]</ept>。</source>
          <target state="new">有关对表操作进行批处理的详细信息，请参阅<bpt id="p1">[</bpt>执行实体组事务<ept id="p1">][entity-group-transactions]</ept>。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>删除表</source>
          <target state="new">删除表</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>最后，若要删除表，请将表名传递到 <bpt id="p1">**</bpt>TableRestProxy-&gt;deleteTable<ept id="p1">**</ept> 方法。</source>
          <target state="new">最后，若要删除表，请将表名传递到 <bpt id="p1">**</bpt>TableRestProxy-&gt;deleteTable<ept id="p1">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>现在，您已了解了 Azure 表服务的基础知识，单击下面的链接可了解有关更复杂的存储任务的详细信息。</source>
          <target state="new">现在，您已了解了 Azure 表服务的基础知识，单击下面的链接可了解有关更复杂的存储任务的详细信息。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>访问 <bpt id="p1">[</bpt>Azure 存储空间团队博客<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/)</ept></source>
          <target state="new">访问 <bpt id="p1">[</bpt>Azure 存储空间团队博客<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/)</ept></target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>有关详细信息，另请参阅 <bpt id="p1">[</bpt>PHP 开发人员中心<ept id="p1">](/develop/php/)</ept>。</source>
          <target state="new">有关详细信息，另请参阅 <bpt id="p1">[</bpt>PHP 开发人员中心<ept id="p1">](/develop/php/)</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>