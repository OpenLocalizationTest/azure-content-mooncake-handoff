<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a04b27a7e1fe32ca4f81d5c09c777068f9db81e9</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 Node.js 使用表存储 | Azure</source>
          <target state="new">如何通过 Node.js 使用表存储 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何使用 Azure 表存储。代码示例使用 Node.js API 编写。</source>
          <target state="new">了解如何使用 Azure 表存储。代码示例使用 Node.js API 编写。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何通过 Node.js 使用 Azure 表存储</source>
          <target state="new">如何通过 Node.js 使用 Azure 表存储</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本主题将演示如何使用 Node.js 应用程序中的 Azure 表服务执行常见方案。</source>
          <target state="new">本主题将演示如何使用 Node.js 应用程序中的 Azure 表服务执行常见方案。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>本主题中的代码示例假定您已有 Node.js 应用程序。有关在 Azure 中创建 Node.js 应用程序的信息，请参阅以下任何主题：</source>
          <target state="new">本主题中的代码示例假定您已有 Node.js 应用程序。有关在 Azure 中创建 Node.js 应用程序的信息，请参阅以下任何主题：</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>[构建 Node.js Web 应用并部署到 Azure][创建 Node.js 应用程序并将其部署到 Azure Web 应用]。</source>
          <target state="new">[构建 Node.js Web 应用并部署到 Azure][创建 Node.js 应用程序并将其部署到 Azure Web 应用]。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>使用 WebMatrix 构建 Node.js Web 应用并部署到 Azure</source>
          <target state="new">使用 WebMatrix 构建 Node.js Web 应用并部署到 Azure</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>[构建 Node.js 应用程序并将其部署到 Azure 云服务][Node.js Cloud Service]（使用 Windows PowerShell）</source>
          <target state="new">[构建 Node.js 应用程序并将其部署到 Azure 云服务][Node.js Cloud Service]（使用 Windows PowerShell）</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>创建用于访问 Azure 存储的应用程序</source>
          <target state="new">创建用于访问 Azure 存储的应用程序</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>若要使用 Azure 存储空间，你需要 Azure Storage SDK for Node.js，其中包括一组便于与存储 REST 服务进行通信的库。</source>
          <target state="new">若要使用 Azure 存储空间，你需要 Azure Storage SDK for Node.js，其中包括一组便于与存储 REST 服务进行通信的库。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>使用 Node 包管理器 (NPM) 安装该程序包</source>
          <target state="new">使用 Node 包管理器 (NPM) 安装该程序包</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>PowerShell<ept id="p1">**</ept> (Windows)、<bpt id="p2">**</bpt>Terminal<ept id="p2">**</ept> (Mac) 或 <bpt id="p3">**</bpt>Bash<ept id="p3">**</ept> (Unix) 等命令行界面导航到您在其中创建了应用程序的文件夹。</source>
          <target state="new">使用 <bpt id="p1">**</bpt>PowerShell<ept id="p1">**</ept> (Windows)、<bpt id="p2">**</bpt>Terminal<ept id="p2">**</ept> (Mac) 或 <bpt id="p3">**</bpt>Bash<ept id="p3">**</ept> (Unix) 等命令行界面导航到您在其中创建了应用程序的文件夹。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>在命令窗口中键入 <bpt id="p1">**</bpt>npm install azure-storage<ept id="p1">**</ept>。该命令的输出类似于以下示例。</source>
          <target state="new">在命令窗口中键入 <bpt id="p1">**</bpt>npm install azure-storage<ept id="p1">**</ept>。该命令的输出类似于以下示例。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>可以手动运行 <bpt id="p1">**</bpt>ls<ept id="p1">**</ept> 命令来验证是否创建了 <bpt id="p2">**</bpt>node_modules<ept id="p2">**</ept> 文件夹。在该文件夹中，您将找到 <bpt id="p3">**</bpt>azure-storage<ept id="p3">**</ept> 包，其中包含访问存储所需的库。</source>
          <target state="new">可以手动运行 <bpt id="p1">**</bpt>ls<ept id="p1">**</ept> 命令来验证是否创建了 <bpt id="p2">**</bpt>node_modules<ept id="p2">**</ept> 文件夹。在该文件夹中，您将找到 <bpt id="p3">**</bpt>azure-storage<ept id="p3">**</ept> 包，其中包含访问存储所需的库。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>导入包</source>
          <target state="new">导入包</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>将以下代码添加到您的应用程序中的 <bpt id="p1">**</bpt>server.js<ept id="p1">**</ept> 文件的顶部：</source>
          <target state="new">将以下代码添加到您的应用程序中的 <bpt id="p1">**</bpt>server.js<ept id="p1">**</ept> 文件的顶部：</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>设置 Azure 存储连接</source>
          <target state="new">设置 Azure 存储连接</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Azure 模块将读取环境变量 AZURE_STORAGE_ACCOUNT 和 AZURE_STORAGE_ACCESS_KEY 或 AZURE_STORAGE_CONNECTION_STRING 以获取连接到您的 Azure 存储帐户所需的信息。如果未设置这些环境变量，则必须在调用 <bpt id="p1">**</bpt>TableService<ept id="p1">**</ept> 时指定帐户信息。</source>
          <target state="new">Azure 模块将读取环境变量 AZURE_STORAGE_ACCOUNT 和 AZURE_STORAGE_ACCESS_KEY 或 AZURE_STORAGE_CONNECTION_STRING 以获取连接到您的 Azure 存储帐户所需的信息。如果未设置这些环境变量，则必须在调用 <bpt id="p1">**</bpt>TableService<ept id="p1">**</ept> 时指定帐户信息。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>有关在管理门户中为 Azure Web 应用设置环境变量的示例，请参阅<bpt id="p1">[</bpt><ept id="p1">使用存储构建 Node.js Web 应用]</ept></source>
          <target state="new">有关在管理门户中为 Azure Web 应用设置环境变量的示例，请参阅<bpt id="p1">[</bpt><ept id="p1">使用存储构建 Node.js Web 应用]</ept></target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>创建表</source>
          <target state="new">创建表</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>下面的代码创建 <bpt id="p1">**</bpt>TableService<ept id="p1">**</ept> 对象并使用它来创建一个新表。将以下代码添加到 <bpt id="p2">**</bpt>server.js<ept id="p2">**</ept> 的顶部附近。</source>
          <target state="new">下面的代码创建 <bpt id="p1">**</bpt>TableService<ept id="p1">**</ept> 对象并使用它来创建一个新表。将以下代码添加到 <bpt id="p2">**</bpt>server.js<ept id="p2">**</ept> 的顶部附近。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>调用 <bpt id="p1">**</bpt>createTableIfNotExists<ept id="p1">**</ept> 将创建具有指定名称的一个新表（如果该表尚不存在）。下面的示例将创建一个名为“mytable”的新表（如果该表尚不存在）：</source>
          <target state="new">调用 <bpt id="p1">**</bpt>createTableIfNotExists<ept id="p1">**</ept> 将创建具有指定名称的一个新表（如果该表尚不存在）。下面的示例将创建一个名为“mytable”的新表（如果该表尚不存在）：</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`result`</ph> 将为 <ph id="ph2">`true`</ph>（如果创建了新表），或者为 <ph id="ph3">`false`</ph>（如果表已存在）。<ph id="ph4">`response`</ph> 将包含有关该请求的信息。</source>
          <target state="new"><ph id="ph1">`result`</ph> 将为 <ph id="ph2">`true`</ph>（如果创建了新表），或者为 <ph id="ph3">`false`</ph>（如果表已存在）。<ph id="ph4">`response`</ph> 将包含有关该请求的信息。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>筛选器</source>
          <target state="new">筛选器</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>可选的筛选操作可应用于使用 <bpt id="p1">**</bpt>TableService<ept id="p1">**</ept> 执行的操作。筛选操作可包括日志记录、自动重试等。筛选器是实现具有签名的方法的对象：</source>
          <target state="new">可选的筛选操作可应用于使用 <bpt id="p1">**</bpt>TableService<ept id="p1">**</ept> 执行的操作。筛选操作可包括日志记录、自动重试等。筛选器是实现具有签名的方法的对象：</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>在对请求选项执行预处理后，该方法需要调用“next”并且传递具有以下签名的回调：</source>
          <target state="new">在对请求选项执行预处理后，该方法需要调用“next”并且传递具有以下签名的回调：</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>在此回调中并且在处理 returnObject（来自对服务器请求的响应）后，回调需要调用 next（如果它存在，以便继续处理其他筛选器）或只调用 finalCallback 以便结束服务调用。</source>
          <target state="new">在此回调中并且在处理 returnObject（来自对服务器请求的响应）后，回调需要调用 next（如果它存在，以便继续处理其他筛选器）或只调用 finalCallback 以便结束服务调用。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Azure SDK for Node.js 中附带了两个实现了重试逻辑的筛选器，分别是 <bpt id="p1">**</bpt>ExponentialRetryPolicyFilter<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>LinearRetryPolicyFilter<ept id="p2">**</ept>。以下代码将创建使用 <bpt id="p3">**</bpt>ExponentialRetryPolicyFilter<ept id="p3">**</ept> 的 <bpt id="p4">**</bpt>TableService<ept id="p4">**</ept> 对象:</source>
          <target state="new">Azure SDK for Node.js 中附带了两个实现了重试逻辑的筛选器，分别是 <bpt id="p1">**</bpt>ExponentialRetryPolicyFilter<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>LinearRetryPolicyFilter<ept id="p2">**</ept>。以下代码将创建使用 <bpt id="p3">**</bpt>ExponentialRetryPolicyFilter<ept id="p3">**</ept> 的 <bpt id="p4">**</bpt>TableService<ept id="p4">**</ept> 对象:</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>将实体添加到表</source>
          <target state="new">将实体添加到表</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>若要添加实体，首先创建定义实体属性的对象。所有实体都必须都包含 <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>，它们是实体的唯一标识符。</source>
          <target state="new">若要添加实体，首先创建定义实体属性的对象。所有实体都必须都包含 <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>，它们是实体的唯一标识符。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> - 确定实体存储在其中的分区</source>
          <target state="new"><bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> - 确定实体存储在其中的分区</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> - 唯一标识分区内的实体</source>
          <target state="new"><bpt id="p1">**</bpt>RowKey<ept id="p1">**</ept> - 唯一标识分区内的实体</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> 都必须是字符串值。有关详细信息，请参阅<bpt id="p3">[</bpt>了解表服务数据模型<ept id="p3">](http://msdn.microsoft.com/zh-cn/library/azure/dd179338.aspx)</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> 都必须是字符串值。有关详细信息，请参阅<bpt id="p3">[</bpt>了解表服务数据模型<ept id="p3">](http://msdn.microsoft.com/zh-cn/library/azure/dd179338.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>下面是如何定义实体的示例。请注意，<bpt id="p1">**</bpt>dueDate<ept id="p1">**</ept> 被定义为一种类型的 <bpt id="p2">**</bpt>Edm.DateTime<ept id="p2">**</ept>。可以选择性地指定类型。如果未指定类型，系统会进行推断。</source>
          <target state="new">下面是如何定义实体的示例。请注意，<bpt id="p1">**</bpt>dueDate<ept id="p1">**</ept> 被定义为一种类型的 <bpt id="p2">**</bpt>Edm.DateTime<ept id="p2">**</ept>。可以选择性地指定类型。如果未指定类型，系统会进行推断。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 每个记录还有一个“时间戳”字段，在插入或更新实体时，Azure 会设置该字段。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 每个记录还有一个“时间戳”字段，在插入或更新实体时，Azure 会设置该字段。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>您还可以使用 <bpt id="p1">**</bpt>entityGenerator<ept id="p1">**</ept> 来创建实体。下面的示例使用 <bpt id="p2">**</bpt>entityGenerator<ept id="p2">**</ept> 来创建相同的任务实体。</source>
          <target state="new">您还可以使用 <bpt id="p1">**</bpt>entityGenerator<ept id="p1">**</ept> 来创建实体。下面的示例使用 <bpt id="p2">**</bpt>entityGenerator<ept id="p2">**</ept> 来创建相同的任务实体。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>要将实体添加到表中，应将实体对象传递给 <bpt id="p1">**</bpt>insertEntity<ept id="p1">**</ept> 方法。</source>
          <target state="new">要将实体添加到表中，应将实体对象传递给 <bpt id="p1">**</bpt>insertEntity<ept id="p1">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>如果操作成功，<ph id="ph1">`result`</ph> 将包含插入的记录的 <bpt id="p1">[</bpt>ETag<ept id="p1">](http://zh.wikipedia.org/wiki/HTTP_ETag)</ept>，而 <ph id="ph2">`response`</ph> 将包含有关操作的信息。</source>
          <target state="new">如果操作成功，<ph id="ph1">`result`</ph> 将包含插入的记录的 <bpt id="p1">[</bpt>ETag<ept id="p1">](http://zh.wikipedia.org/wiki/HTTP_ETag)</ept>，而 <ph id="ph2">`response`</ph> 将包含有关操作的信息。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>示例响应:</source>
          <target state="new">示例响应:</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 默认情况下，<bpt id="p1">**</bpt>insertEntity<ept id="p1">**</ept> 不会在 <ph id="ph2">`response`</ph> 信息中返回插入的实体。如果您计划对此实体执行其他操作，或者希望对信息进行缓存，则可在 <ph id="ph3">`result`</ph> 中返回该实体。您可以通过启用 <bpt id="p2">**</bpt>echoContent<ept id="p2">**</ept> 来执行此操作，如下所示：</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 默认情况下，<bpt id="p1">**</bpt>insertEntity<ept id="p1">**</ept> 不会在 <ph id="ph2">`response`</ph> 信息中返回插入的实体。如果您计划对此实体执行其他操作，或者希望对信息进行缓存，则可在 <ph id="ph3">`result`</ph> 中返回该实体。您可以通过启用 <bpt id="p2">**</bpt>echoContent<ept id="p2">**</ept> 来执行此操作，如下所示：</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>更新实体</source>
          <target state="new">更新实体</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>可使用多种方法来更新现有实体：</source>
          <target state="new">可使用多种方法来更新现有实体：</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>updateEntity<ept id="p1">**</ept> - 通过替换现有实体来更新现有实体</source>
          <target state="new"><bpt id="p1">**</bpt>updateEntity<ept id="p1">**</ept> - 通过替换现有实体来更新现有实体</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>mergeEntity<ept id="p1">**</ept> - 通过将新属性值合并到现有实体来更新现有实体</source>
          <target state="new"><bpt id="p1">**</bpt>mergeEntity<ept id="p1">**</ept> - 通过将新属性值合并到现有实体来更新现有实体</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>insertOrReplaceEntity<ept id="p1">**</ept> - 通过替换现有实体来更新现有实体。如果不存在实体，将插入一个新实体</source>
          <target state="new"><bpt id="p1">**</bpt>insertOrReplaceEntity<ept id="p1">**</ept> - 通过替换现有实体来更新现有实体。如果不存在实体，将插入一个新实体</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>insertOrMergeEntity<ept id="p1">**</ept> - 通过将新属性值合并到现有实体来更新现有实体。如果不存在实体，将插入一个新实体</source>
          <target state="new"><bpt id="p1">**</bpt>insertOrMergeEntity<ept id="p1">**</ept> - 通过将新属性值合并到现有实体来更新现有实体。如果不存在实体，将插入一个新实体</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>以下示例演示了使用 <bpt id="p1">**</bpt>updateEntity<ept id="p1">**</ept> 更新实体：</source>
          <target state="new">以下示例演示了使用 <bpt id="p1">**</bpt>updateEntity<ept id="p1">**</ept> 更新实体：</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 默认情况下，更新某个实体时，不会查看要更新的数据是否曾被其他进程更新过。若要支持并发更新，请执行以下步骤：</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 默认情况下，更新某个实体时，不会查看要更新的数据是否曾被其他进程更新过。若要支持并发更新，请执行以下步骤：</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>获取要更新的对象的 ETag。对于任何实体相关操作，该 ETag 将在 <ph id="ph1">`response`</ph> 中返回，并且可通过 <ph id="ph2">`response['.metadata'].etag`</ph> 检索。</source>
          <target state="new">获取要更新的对象的 ETag。对于任何实体相关操作，该 ETag 将在 <ph id="ph1">`response`</ph> 中返回，并且可通过 <ph id="ph2">`response['.metadata'].etag`</ph> 检索。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>对某个实体执行更新操作时，请将以前检索的 ETag 信息添加到新的实体。例如：</source>
          <target state="new">对某个实体执行更新操作时，请将以前检索的 ETag 信息添加到新的实体。例如：</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>执行更新操作。如果实体在您检索 ETag 值后已被修改，例如被应用程序的其他实例修改，则会返回一条 <ph id="ph1">`error`</ph>，指出未满足请求中指定的更新条件。</source>
          <target state="new">执行更新操作。如果实体在您检索 ETag 值后已被修改，例如被应用程序的其他实例修改，则会返回一条 <ph id="ph1">`error`</ph>，指出未满足请求中指定的更新条件。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>对于 <bpt id="p1">**</bpt>updateEntity<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>mergeEntity<ept id="p2">**</ept>，如果待更新的实体不存在，则更新操作将失败。因此，如果您希望存储某个实体而不考虑它是否已存在，请使用 <bpt id="p3">**</bpt>insertOrReplaceEntity<ept id="p3">**</ept> 或 <bpt id="p4">**</bpt>insertOrMergeEntity<ept id="p4">**</ept>。</source>
          <target state="new">对于 <bpt id="p1">**</bpt>updateEntity<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>mergeEntity<ept id="p2">**</ept>，如果待更新的实体不存在，则更新操作将失败。因此，如果您希望存储某个实体而不考虑它是否已存在，请使用 <bpt id="p3">**</bpt>insertOrReplaceEntity<ept id="p3">**</ept> 或 <bpt id="p4">**</bpt>insertOrMergeEntity<ept id="p4">**</ept>。</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>如果更新操作成功，则 <ph id="ph1">`result`</ph> 会包含所更新实体的 <bpt id="p1">**</bpt>Etag<ept id="p1">**</ept>。</source>
          <target state="new">如果更新操作成功，则 <ph id="ph1">`result`</ph> 会包含所更新实体的 <bpt id="p1">**</bpt>Etag<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>使用实体组</source>
          <target state="new">使用实体组</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>有时，有必要成批地同时提交多项操作以确保通过服务器进行原子处理。使用 <bpt id="p1">**</bpt>TableBatch<ept id="p1">**</ept> 类来创建一个批处理，然后使用 <bpt id="p2">**</bpt>TableService<ept id="p2">**</ept> 的 <bpt id="p3">**</bpt>executeBatch<ept id="p3">**</ept> 方法来执行批处理操作。</source>
          <target state="new">有时，有必要成批地同时提交多项操作以确保通过服务器进行原子处理。使用 <bpt id="p1">**</bpt>TableBatch<ept id="p1">**</ept> 类来创建一个批处理，然后使用 <bpt id="p2">**</bpt>TableService<ept id="p2">**</ept> 的 <bpt id="p3">**</bpt>executeBatch<ept id="p3">**</ept> 方法来执行批处理操作。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>下面的示例演示了在一个批次中提交两个实体：</source>
          <target state="new">下面的示例演示了在一个批次中提交两个实体：</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>对于成功的批处理操作，<ph id="ph1">`result`</ph> 将包含批处理中每个操作的信息。</source>
          <target state="new">对于成功的批处理操作，<ph id="ph1">`result`</ph> 将包含批处理中每个操作的信息。</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>使用批处理操作</source>
          <target state="new">使用批处理操作</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>可以通过查看 <ph id="ph1">`operations`</ph> 属性来检查添加到批处理中的操作。你可以使用以下方法来处理操作：</source>
          <target state="new">可以通过查看 <ph id="ph1">`operations`</ph> 属性来检查添加到批处理中的操作。你可以使用以下方法来处理操作：</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>clear<ept id="p1">**</ept> - 清除批处理中的所有操作</source>
          <target state="new"><bpt id="p1">**</bpt>clear<ept id="p1">**</ept> - 清除批处理中的所有操作</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>getOperations<ept id="p1">**</ept> - 获取批处理的操作</source>
          <target state="new"><bpt id="p1">**</bpt>getOperations<ept id="p1">**</ept> - 获取批处理的操作</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>hasOperations<ept id="p1">**</ept> - 如果批处理包含操作，则返回 true</source>
          <target state="new"><bpt id="p1">**</bpt>hasOperations<ept id="p1">**</ept> - 如果批处理包含操作，则返回 true</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>removeOperations<ept id="p1">**</ept> - 删除操作</source>
          <target state="new"><bpt id="p1">**</bpt>removeOperations<ept id="p1">**</ept> - 删除操作</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>size<ept id="p1">**</ept> - 返回批处理中操作的数目</source>
          <target state="new"><bpt id="p1">**</bpt>size<ept id="p1">**</ept> - 返回批处理中操作的数目</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>通过键检索实体</source>
          <target state="new">通过键检索实体</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>如果您想要返回基于 <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> 的特定实体，请使用 <bpt id="p3">**</bpt>retrieveEntity<ept id="p3">**</ept> 方法。</source>
          <target state="new">如果您想要返回基于 <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> 的特定实体，请使用 <bpt id="p3">**</bpt>retrieveEntity<ept id="p3">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>此操作完成后，<ph id="ph1">`result`</ph> 将包含该实体。</source>
          <target state="new">此操作完成后，<ph id="ph1">`result`</ph> 将包含该实体。</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>查询实体集</source>
          <target state="new">查询实体集</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>若要查询表，请使用 <bpt id="p1">**</bpt>TableQuery<ept id="p1">**</ept> 对象生成一个使用以下子句的查询：</source>
          <target state="new">若要查询表，请使用 <bpt id="p1">**</bpt>TableQuery<ept id="p1">**</ept> 对象生成一个使用以下子句的查询：</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>select<ept id="p1">**</ept> - 将要从查询返回的字段</source>
          <target state="new"><bpt id="p1">**</bpt>select<ept id="p1">**</ept> - 将要从查询返回的字段</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>where<ept id="p1">**</ept> - where 子句</source>
          <target state="new"><bpt id="p1">**</bpt>where<ept id="p1">**</ept> - where 子句</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>and<ept id="p1">**</ept> - 一个 <ph id="ph1">`and`</ph> where 条件</source>
          <target state="new"><bpt id="p1">**</bpt>and<ept id="p1">**</ept> - 一个 <ph id="ph1">`and`</ph> where 条件</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>or<ept id="p1">**</ept> - 一个 <ph id="ph1">`or`</ph> where 条件</source>
          <target state="new"><bpt id="p1">**</bpt>or<ept id="p1">**</ept> - 一个 <ph id="ph1">`or`</ph> where 条件</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>top<ept id="p1">**</ept> - 要提取的项数</source>
          <target state="new"><bpt id="p1">**</bpt>top<ept id="p1">**</ept> - 要提取的项数</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>以下示例生成的查询将返回 PartitionKey 为“hometasks”的前五项。</source>
          <target state="new">以下示例生成的查询将返回 PartitionKey 为“hometasks”的前五项。</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>由于未使用 <bpt id="p1">**</bpt>select<ept id="p1">**</ept>，因此将返回所有字段。若要对表执行查询，请使用 <bpt id="p2">**</bpt>queryEntities<ept id="p2">**</ept>。下面的示例使用此查询来返回“mytable”中的实体。</source>
          <target state="new">由于未使用 <bpt id="p1">**</bpt>select<ept id="p1">**</ept>，因此将返回所有字段。若要对表执行查询，请使用 <bpt id="p2">**</bpt>queryEntities<ept id="p2">**</ept>。下面的示例使用此查询来返回“mytable”中的实体。</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>如果成功，<ph id="ph1">`result.entries`</ph> 将包含与查询匹配的一组实体。如果查询无法返回所有实体，<ph id="ph2">`result.continuationToken`</ph> 就不会是 <bpt id="p1">*</bpt>null<ept id="p1">*</ept> ，因此可用作 <bpt id="p2">**</bpt>queryEntities<ept id="p2">**</ept> 的第三个参数来检索更多结果。对于初始查询，请为第三个参数使用 <bpt id="p3">*</bpt>null<ept id="p3">*</ept> 。</source>
          <target state="new">如果成功，<ph id="ph1">`result.entries`</ph> 将包含与查询匹配的一组实体。如果查询无法返回所有实体，<ph id="ph2">`result.continuationToken`</ph> 就不会是 <bpt id="p1">*</bpt>null<ept id="p1">*</ept> ，因此可用作 <bpt id="p2">**</bpt>queryEntities<ept id="p2">**</ept> 的第三个参数来检索更多结果。对于初始查询，请为第三个参数使用 <bpt id="p3">*</bpt>null<ept id="p3">*</ept> 。</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>查询一部分实体属性</source>
          <target state="new">查询一部分实体属性</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>对表的查询可以只检索实体中的少数几个字段。这可以减少带宽并提高查询性能，尤其适用于大型实体。使用 <bpt id="p1">**</bpt>select<ept id="p1">**</ept> 子句并传递要返回的字段的名称。例如，下面的查询将只返回 <bpt id="p2">**</bpt>description<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>dueDate<ept id="p3">**</ept> 字段。</source>
          <target state="new">对表的查询可以只检索实体中的少数几个字段。这可以减少带宽并提高查询性能，尤其适用于大型实体。使用 <bpt id="p1">**</bpt>select<ept id="p1">**</ept> 子句并传递要返回的字段的名称。例如，下面的查询将只返回 <bpt id="p2">**</bpt>description<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>dueDate<ept id="p3">**</ept> 字段。</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>删除实体</source>
          <target state="new">删除实体</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>可以使用实体的分区键和行键删除实体。在本例中，<bpt id="p1">**</bpt>task1<ept id="p1">**</ept> 对象包含要删除的实体的 <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>PartitionKey<ept id="p3">**</ept> 值。然后，该对象被传递给 <bpt id="p4">**</bpt>deleteEntity<ept id="p4">**</ept> 方法。</source>
          <target state="new">可以使用实体的分区键和行键删除实体。在本例中，<bpt id="p1">**</bpt>task1<ept id="p1">**</ept> 对象包含要删除的实体的 <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>PartitionKey<ept id="p3">**</ept> 值。然后，该对象被传递给 <bpt id="p4">**</bpt>deleteEntity<ept id="p4">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 考虑在删除项时使用 ETag，以确保项尚未被其他进程修改。请参阅<bpt id="p1">[</bpt>更新实体<ept id="p1">](#update-an-entity)</ept>了解如何使用 ETag。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 考虑在删除项时使用 ETag，以确保项尚未被其他进程修改。请参阅<bpt id="p1">[</bpt>更新实体<ept id="p1">](#update-an-entity)</ept>了解如何使用 ETag。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>删除表</source>
          <target state="new">删除表</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>以下代码从存储帐户中删除一个表。</source>
          <target state="new">以下代码从存储帐户中删除一个表。</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>如果您不确定表是否存在，则使用 <bpt id="p1">**</bpt>deleteTableIfExists<ept id="p1">**</ept>。</source>
          <target state="new">如果您不确定表是否存在，则使用 <bpt id="p1">**</bpt>deleteTableIfExists<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>使用继续标记</source>
          <target state="new">使用继续标记</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>在所查询的表有大量的结果时，请查找继续标记。如果您在生成时不能识别何时存在继续标记，可能存在大量您未意识到的数据可用于查询。</source>
          <target state="new">在所查询的表有大量的结果时，请查找继续标记。如果您在生成时不能识别何时存在继续标记，可能存在大量您未意识到的数据可用于查询。</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>查询实体在存在此类标记期间设置 <ph id="ph1">`continuationToken`</ph> 属性，返回结果对象。然后可以在执行查询时使用它，以继续在分区和表实体间移动。</source>
          <target state="new">查询实体在存在此类标记期间设置 <ph id="ph1">`continuationToken`</ph> 属性，返回结果对象。然后可以在执行查询时使用它，以继续在分区和表实体间移动。</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>在查询时，在查询对象实例和回调函数之间可能会提供继续标记参数：</source>
          <target state="new">在查询时，在查询对象实例和回调函数之间可能会提供继续标记参数：</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>如果你检查 <ph id="ph1">`continuationToken`</ph> 对象，你会发现 <ph id="ph2">`nextPartitionKey`</ph>、<ph id="ph3">`nextRowKey`</ph> 和 <ph id="ph4">`targetLocation`</ph> 等属性可用于循环访问所有结果。</source>
          <target state="new">如果你检查 <ph id="ph1">`continuationToken`</ph> 对象，你会发现 <ph id="ph2">`nextPartitionKey`</ph>、<ph id="ph3">`nextRowKey`</ph> 和 <ph id="ph4">`targetLocation`</ph> 等属性可用于循环访问所有结果。</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>在 GitHub 上的 Azure 存储 Node.js 存储库中还有一个继续样本。查找 <ph id="ph1">`examples/samples/continuationsample.js`</ph>。</source>
          <target state="new">在 GitHub 上的 Azure 存储 Node.js 存储库中还有一个继续样本。查找 <ph id="ph1">`examples/samples/continuationsample.js`</ph>。</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>使用共享访问签名</source>
          <target state="new">使用共享访问签名</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>共享访问签名 (SAS) 是一种安全的方法，用于对表进行细致访问而无需提供你的存储帐户名或密钥。通常使用 SAS 来提供对你的数据的有限访问权限，例如允许移动应用程序查询记录。</source>
          <target state="new">共享访问签名 (SAS) 是一种安全的方法，用于对表进行细致访问而无需提供你的存储帐户名或密钥。通常使用 SAS 来提供对你的数据的有限访问权限，例如允许移动应用程序查询记录。</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>受信任的应用程序（例如基于云的服务）可使用 <bpt id="p1">**</bpt>TableService<ept id="p1">**</ept> 的 <bpt id="p2">**</bpt>generateSharedAccessSignature<ept id="p2">**</ept> 生成 SAS，然后将其提供给不受信任的或不完全受信任的应用程序，例如移动应用。SAS 可使用策略生成，该策略描述了 SAS 的生效日期和失效日期，以及授予 SAS 持有者的访问级别。</source>
          <target state="new">受信任的应用程序（例如基于云的服务）可使用 <bpt id="p1">**</bpt>TableService<ept id="p1">**</ept> 的 <bpt id="p2">**</bpt>generateSharedAccessSignature<ept id="p2">**</ept> 生成 SAS，然后将其提供给不受信任的或不完全受信任的应用程序，例如移动应用。SAS 可使用策略生成，该策略描述了 SAS 的生效日期和失效日期，以及授予 SAS 持有者的访问级别。</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>下面的示例生成了一个新的共享访问策略，该策略将允许 SAS 持有者查询 ('r') 表，在创建后 100 分钟过期。</source>
          <target state="new">下面的示例生成了一个新的共享访问策略，该策略将允许 SAS 持有者查询 ('r') 表，在创建后 100 分钟过期。</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>请注意，还必须提供主机信息，因为 SAS 持有者尝试访问表时，必须提供该信息。</source>
          <target state="new">请注意，还必须提供主机信息，因为 SAS 持有者尝试访问表时，必须提供该信息。</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>然后，客户端应用程序将 SAS 用于 <bpt id="p1">**</bpt>TableServiceWithSAS<ept id="p1">**</ept>，以便针对表执行操作。下面的示例连接到该表，并执行一个查询。</source>
          <target state="new">然后，客户端应用程序将 SAS 用于 <bpt id="p1">**</bpt>TableServiceWithSAS<ept id="p1">**</ept>，以便针对表执行操作。下面的示例连接到该表，并执行一个查询。</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>由于 SAS 在生成时只具有查询访问权限，因此如果尝试插入、更新或删除实体，则会返回错误。</source>
          <target state="new">由于 SAS 在生成时只具有查询访问权限，因此如果尝试插入、更新或删除实体，则会返回错误。</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>访问控制列表</source>
          <target state="new">访问控制列表</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>你还可以使用访问控制列表 (ACL) 为 SAS 设置访问策略。如果你希望允许多个客户端访问某个表，但为每个客户端提供了不同的访问策略，则访问控制列表会很有用。</source>
          <target state="new">你还可以使用访问控制列表 (ACL) 为 SAS 设置访问策略。如果你希望允许多个客户端访问某个表，但为每个客户端提供了不同的访问策略，则访问控制列表会很有用。</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>ACL 是使用一组访问策略实施的，每个策略都有一个关联的 ID。以下示例定义了两个策略，一个用于“user1”，一个用于“user2”：</source>
          <target state="new">ACL 是使用一组访问策略实施的，每个策略都有一个关联的 ID。以下示例定义了两个策略，一个用于“user1”，一个用于“user2”：</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>以下示例获取 <bpt id="p1">**</bpt>hometasks<ept id="p1">**</ept> 表的当前 ACL，然后使用 <bpt id="p2">**</bpt>setTableAcl<ept id="p2">**</ept> 添加新策略。此方法具有以下用途：</source>
          <target state="new">以下示例获取 <bpt id="p1">**</bpt>hometasks<ept id="p1">**</ept> 表的当前 ACL，然后使用 <bpt id="p2">**</bpt>setTableAcl<ept id="p2">**</ept> 添加新策略。此方法具有以下用途：</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>设置 ACL 后，你可以根据某个策略的 ID 创建 SAS。以下示例为“user2”创建新的 SAS：</source>
          <target state="new">设置 ACL 后，你可以根据某个策略的 ID 创建 SAS。以下示例为“user2”创建新的 SAS：</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>有关详细信息，请参阅以下资源。</source>
          <target state="new">有关详细信息，请参阅以下资源。</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>[Azure 存储团队博客][]。</source>
          <target state="new">[Azure 存储团队博客][]。</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>GitHub 上的 <bpt id="p1">[</bpt>Azure Storage SDK for Node<ept id="p1">][]</ept> 存储库。</source>
          <target state="new">GitHub 上的 <bpt id="p1">[</bpt>Azure Storage SDK for Node<ept id="p1">][]</ept> 存储库。</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Node.js 开发人员中心</source>
          <target state="new">Node.js 开发人员中心</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>