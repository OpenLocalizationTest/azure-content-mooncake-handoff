<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">88af7d322bf7943d9c794aa053a75559533d5d1d</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 Java 使用服务总线主题 | Microsoft Azure</source>
          <target state="new">如何通过 Java 使用服务总线主题 | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何在 Azure 中使用 Service Bus 主题和订阅。代码示例是针对 Java 应用程序编写的。</source>
          <target state="new">了解如何在 Azure 中使用 Service Bus 主题和订阅。代码示例是针对 Java 应用程序编写的。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何使用服务总线主题和订阅</source>
          <target state="new">如何使用服务总线主题和订阅</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>本指南介绍如何使用服务总线主题和订阅。这些示例是采用 Java 编写的并且使用了 <bpt id="p1">[</bpt>Azure SDK for Java<ept id="p1">][]</ept>。涉及的任务包括<bpt id="p2">**</bpt>创建主题和订阅<ept id="p2">**</ept>、<bpt id="p3">**</bpt>创建订阅筛选器<ept id="p3">**</ept>、<bpt id="p4">**</bpt>将消息发送到主题<ept id="p4">**</ept>、<bpt id="p5">**</bpt>从订阅接收消息<ept id="p5">**</ept>以及<bpt id="p6">**</bpt>删除主题和订阅<ept id="p6">**</ept>。</source>
          <target state="new">本指南介绍如何使用服务总线主题和订阅。这些示例是采用 Java 编写的并且使用了 <bpt id="p1">[</bpt>Azure SDK for Java<ept id="p1">][]</ept>。涉及的任务包括<bpt id="p2">**</bpt>创建主题和订阅<ept id="p2">**</ept>、<bpt id="p3">**</bpt>创建订阅筛选器<ept id="p3">**</ept>、<bpt id="p4">**</bpt>将消息发送到主题<ept id="p4">**</ept>、<bpt id="p5">**</bpt>从订阅接收消息<ept id="p5">**</ept>以及<bpt id="p6">**</bpt>删除主题和订阅<ept id="p6">**</ept>。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>配置应用程序以使用 Service Bus</source>
          <target state="new">配置应用程序以使用 Service Bus</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>在生成本示例之前，请确保已安装 <bpt id="p1">[</bpt>Azure SDK for Java<ept id="p1">][]</ept>。如果使用了 Eclipse，则可以安装包含 Azure SDK for Java 的 <bpt id="p2">[</bpt>Azure Toolkit for Eclipse<ept id="p2">][]</ept>。然后，你可以将 <bpt id="p3">**</bpt>Microsoft Azure Libraries for Java<ept id="p3">**</ept> 添加到你的项目：</source>
          <target state="new">在生成本示例之前，请确保已安装 <bpt id="p1">[</bpt>Azure SDK for Java<ept id="p1">][]</ept>。如果使用了 Eclipse，则可以安装包含 Azure SDK for Java 的 <bpt id="p2">[</bpt>Azure Toolkit for Eclipse<ept id="p2">][]</ept>。然后，你可以将 <bpt id="p3">**</bpt>Microsoft Azure Libraries for Java<ept id="p3">**</ept> 添加到你的项目：</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>将以下导入语句添加到 Java 文件顶部：</source>
          <target state="new">将以下导入语句添加到 Java 文件顶部：</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>向您的生成路径添加 Azure Libraries for Java，并将其包含在您的项目部署程序集中。</source>
          <target state="new">向您的生成路径添加 Azure Libraries for Java，并将其包含在您的项目部署程序集中。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>创建主题</source>
          <target state="new">创建主题</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>服务总线主题的管理操作可通过 <bpt id="p1">**</bpt>ServiceBusContract<ept id="p1">**</ept> 类执行。<bpt id="p2">**</bpt>ServiceBusContract<ept id="p2">**</ept> 对象是使用封装了 SAS 令牌及用于管理它的权限的适当配置构造的，而 <bpt id="p3">**</bpt>ServiceBusContract<ept id="p3">**</ept> 类是与 Azure 进行通信的单一点。</source>
          <target state="new">服务总线主题的管理操作可通过 <bpt id="p1">**</bpt>ServiceBusContract<ept id="p1">**</ept> 类执行。<bpt id="p2">**</bpt>ServiceBusContract<ept id="p2">**</ept> 对象是使用封装了 SAS 令牌及用于管理它的权限的适当配置构造的，而 <bpt id="p3">**</bpt>ServiceBusContract<ept id="p3">**</ept> 类是与 Azure 进行通信的单一点。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 类提供了创建、枚举和删除主题的方法。以下示例演示了如何通过名为 <ph id="ph1">`HowToSample`</ph> 的命名空间，使用 <bpt id="p2">**</bpt>ServiceBusService<ept id="p2">**</ept> 对象创建名为 <ph id="ph2">`TestTopic`</ph> 的主题：</source>
          <target state="new"><bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 类提供了创建、枚举和删除主题的方法。以下示例演示了如何通过名为 <ph id="ph1">`HowToSample`</ph> 的命名空间，使用 <bpt id="p2">**</bpt>ServiceBusService<ept id="p2">**</ept> 对象创建名为 <ph id="ph2">`TestTopic`</ph> 的主题：</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>可对 <bpt id="p1">**</bpt>TopicInfo<ept id="p1">**</ept> 执行某些方法，以调整主题的属性（例如，将默认的生存时间 (TTL) 值设置为应用于发送到主题的消息）。以下示例演示了如何创建最大大小为 5 GB 且名为 <ph id="ph1">`TestTopic`</ph> 的主题：</source>
          <target state="new">可对 <bpt id="p1">**</bpt>TopicInfo<ept id="p1">**</ept> 执行某些方法，以调整主题的属性（例如，将默认的生存时间 (TTL) 值设置为应用于发送到主题的消息）。以下示例演示了如何创建最大大小为 5 GB 且名为 <ph id="ph1">`TestTopic`</ph> 的主题：</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>请注意，你可以对 <bpt id="p1">**</bpt>ServiceBusContract<ept id="p1">**</ept> 对象使用 <bpt id="p2">**</bpt>listTopics<ept id="p2">**</ept> 方法来检查具有指定名称的主题在某个服务命名空间中是否已存在。</source>
          <target state="new">请注意，你可以对 <bpt id="p1">**</bpt>ServiceBusContract<ept id="p1">**</ept> 对象使用 <bpt id="p2">**</bpt>listTopics<ept id="p2">**</ept> 方法来检查具有指定名称的主题在某个服务命名空间中是否已存在。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>创建订阅</source>
          <target state="new">创建订阅</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>主题订阅也是使用 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 类创建的。订阅已命名，并且具有一个限制传递到订阅的虚拟队列的消息集的可选筛选器。</source>
          <target state="new">主题订阅也是使用 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 类创建的。订阅已命名，并且具有一个限制传递到订阅的虚拟队列的消息集的可选筛选器。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>创建具有默认 (MatchAll) 筛选器的订阅</source>
          <target state="new">创建具有默认 (MatchAll) 筛选器的订阅</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MatchAll<ept id="p1">**</ept> 筛选器是默认筛选器，在创建新订阅时未指定筛选器的情况下使用。使用 <bpt id="p2">**</bpt>MatchAll<ept id="p2">**</ept> 筛选器时，发布到主题的所有消息都将置于订阅的虚拟队列中。以下示例创建名为“AllMessages”的订阅，并使用默认的 <bpt id="p3">**</bpt>MatchAll<ept id="p3">**</ept> 筛选器。</source>
          <target state="new"><bpt id="p1">**</bpt>MatchAll<ept id="p1">**</ept> 筛选器是默认筛选器，在创建新订阅时未指定筛选器的情况下使用。使用 <bpt id="p2">**</bpt>MatchAll<ept id="p2">**</ept> 筛选器时，发布到主题的所有消息都将置于订阅的虚拟队列中。以下示例创建名为“AllMessages”的订阅，并使用默认的 <bpt id="p3">**</bpt>MatchAll<ept id="p3">**</ept> 筛选器。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>创建具有筛选器的订阅</source>
          <target state="new">创建具有筛选器的订阅</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>还可以设置筛选器，以确定发送到主题的哪些消息应该在特定主题订阅中显示。</source>
          <target state="new">还可以设置筛选器，以确定发送到主题的哪些消息应该在特定主题订阅中显示。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>订阅支持的最灵活的一种筛选器是 <bpt id="p1">[</bpt>SqlFilter<ept id="p1">][]</ept>，它实现了一部分 SQL92 功能。SQL 筛选器将对发布到主题的消息的属性进行操作。有关可用于 SQL 筛选器的表达式的更多详细信息，请参阅 <bpt id="p2">[</bpt>SqlFilter.SqlExpression<ept id="p2">][]</ept> 语法。</source>
          <target state="new">订阅支持的最灵活的一种筛选器是 <bpt id="p1">[</bpt>SqlFilter<ept id="p1">][]</ept>，它实现了一部分 SQL92 功能。SQL 筛选器将对发布到主题的消息的属性进行操作。有关可用于 SQL 筛选器的表达式的更多详细信息，请参阅 <bpt id="p2">[</bpt>SqlFilter.SqlExpression<ept id="p2">][]</ept> 语法。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>以下示例创建了一个名为 <ph id="ph1">`HighMessages`</ph> 的订阅（带有只选择自定义 <bpt id="p1">**</bpt>MessageNumber<ept id="p1">**</ept> 属性大于 3 的消息的 <bpt id="p2">[</bpt>SqlFilter<ept id="p2">][]</ept> 对象）：</source>
          <target state="new">以下示例创建了一个名为 <ph id="ph1">`HighMessages`</ph> 的订阅（带有只选择自定义 <bpt id="p1">**</bpt>MessageNumber<ept id="p1">**</ept> 属性大于 3 的消息的 <bpt id="p2">[</bpt>SqlFilter<ept id="p2">][]</ept> 对象）：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>类似地，以下示例创建一个名为 <ph id="ph1">`LowMessages`</ph> 的订阅，其 <bpt id="p1">[</bpt>SqlFilter<ept id="p1">][]</ept> 对象只选择 <bpt id="p2">**</bpt>MessageNumber<ept id="p2">**</ept> 属性小于或等于 3 的消息：</source>
          <target state="new">类似地，以下示例创建一个名为 <ph id="ph1">`LowMessages`</ph> 的订阅，其 <bpt id="p1">[</bpt>SqlFilter<ept id="p1">][]</ept> 对象只选择 <bpt id="p2">**</bpt>MessageNumber<ept id="p2">**</ept> 属性小于或等于 3 的消息：</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>现在，当消息发送到 <ph id="ph1">`TestTopic`</ph> 时，它始终会传送给订阅了 <ph id="ph2">`AllMessages`</ph> 订阅的接收者，并且选择性地传送给订阅了 <ph id="ph3">`HighMessages`</ph> 和 <ph id="ph4">`LowMessages`</ph> 订阅的接收者（具体取决于消息内容）。</source>
          <target state="new">现在，当消息发送到 <ph id="ph1">`TestTopic`</ph> 时，它始终会传送给订阅了 <ph id="ph2">`AllMessages`</ph> 订阅的接收者，并且选择性地传送给订阅了 <ph id="ph3">`HighMessages`</ph> 和 <ph id="ph4">`LowMessages`</ph> 订阅的接收者（具体取决于消息内容）。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>将消息发送到主题</source>
          <target state="new">将消息发送到主题</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>若要将消息发送到服务总线主题，你的应用程序将获得 <bpt id="p1">**</bpt>ServiceBusContract<ept id="p1">**</ept> 对象。以下代码演示了如何将消息发送到前面在 <ph id="ph1">`HowToSample`</ph> 命名空间中创建的 <ph id="ph2">`TestTopic`</ph> 主题：</source>
          <target state="new">若要将消息发送到服务总线主题，你的应用程序将获得 <bpt id="p1">**</bpt>ServiceBusContract<ept id="p1">**</ept> 对象。以下代码演示了如何将消息发送到前面在 <ph id="ph1">`HowToSample`</ph> 命名空间中创建的 <ph id="ph2">`TestTopic`</ph> 主题：</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>发送到服务总线主题的消息是 <bpt id="p1">[</bpt>BrokeredMessage<ept id="p1">][]</ept> 类的实例。<bpt id="p2">[</bpt>BrokeredMessage<ept id="p2">][]</ept>* 对象包含一组标准方法（如 <bpt id="p3">**</bpt>setLabel<ept id="p3">**</ept> 和 <bpt id="p4">**</bpt>TimeToLive<ept id="p4">**</ept>）、一个用来保存自定义应用程序特定属性的字典和大量任意的应用程序数据。应用程序可通过将任何可序列化对象传入到 <bpt id="p5">[</bpt>BrokeredMessage<ept id="p5">][]</ept> 的构造函数中来设置消息的正文，然后将使用适当的 <bpt id="p6">**</bpt>DataContractSerializer<ept id="p6">**</ept> 序列化对象。或者，也可以提供 <bpt id="p7">**</bpt>java.io.InputStream<ept id="p7">**</ept>。</source>
          <target state="new">发送到服务总线主题的消息是 <bpt id="p1">[</bpt>BrokeredMessage<ept id="p1">][]</ept> 类的实例。<bpt id="p2">[</bpt>BrokeredMessage<ept id="p2">][]</ept>* 对象包含一组标准方法（如 <bpt id="p3">**</bpt>setLabel<ept id="p3">**</ept> 和 <bpt id="p4">**</bpt>TimeToLive<ept id="p4">**</ept>）、一个用来保存自定义应用程序特定属性的字典和大量任意的应用程序数据。应用程序可通过将任何可序列化对象传入到 <bpt id="p5">[</bpt>BrokeredMessage<ept id="p5">][]</ept> 的构造函数中来设置消息的正文，然后将使用适当的 <bpt id="p6">**</bpt>DataContractSerializer<ept id="p6">**</ept> 序列化对象。或者，也可以提供 <bpt id="p7">**</bpt>java.io.InputStream<ept id="p7">**</ept>。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>以下示例演示了如何将五条测试消息发送到我们在前面的代码段中获得的 <ph id="ph1">`TestTopic`</ph> <bpt id="p1">**</bpt>MessageSender<ept id="p1">**</ept>。请注意每条消息的 <bpt id="p2">**</bpt>MessageNumber<ept id="p2">**</ept> 属性值如何随循环迭代而变化（这将确定接收消息的订阅）：</source>
          <target state="new">以下示例演示了如何将五条测试消息发送到我们在前面的代码段中获得的 <ph id="ph1">`TestTopic`</ph> <bpt id="p1">**</bpt>MessageSender<ept id="p1">**</ept>。请注意每条消息的 <bpt id="p2">**</bpt>MessageNumber<ept id="p2">**</ept> 属性值如何随循环迭代而变化（这将确定接收消息的订阅）：</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Service Bus 主题支持最大为 256 MB 的消息（标头最大为 64 MB，其中包括标准和自定义应用程序属性）。一个主题中包含的消息数量不受限制，但消息的总大小受限制。此主题大小是在创建时定义的，上限为 5 GB。</source>
          <target state="new">Service Bus 主题支持最大为 256 MB 的消息（标头最大为 64 MB，其中包括标准和自定义应用程序属性）。一个主题中包含的消息数量不受限制，但消息的总大小受限制。此主题大小是在创建时定义的，上限为 5 GB。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>如何从订阅接收消息</source>
          <target state="new">如何从订阅接收消息</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>从订阅接收消息的主要方法是使用 <bpt id="p1">**</bpt>ServiceBusContract<ept id="p1">**</ept> 对象。收到的消息可在两种不同模式下工作：<bpt id="p2">**</bpt>ReceiveAndDelete<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>PeekLock<ept id="p3">**</ept>。</source>
          <target state="new">从订阅接收消息的主要方法是使用 <bpt id="p1">**</bpt>ServiceBusContract<ept id="p1">**</ept> 对象。收到的消息可在两种不同模式下工作：<bpt id="p2">**</bpt>ReceiveAndDelete<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>PeekLock<ept id="p3">**</ept>。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>当使用 <bpt id="p1">**</bpt>ReceiveAndDelete<ept id="p1">**</ept> 模式时，接收是一个单次操作。即，当服务总线接收到对消息的读取请求时，它会将该消息标记为“已使用”并将其返回给应用程序。<bpt id="p2">**</bpt>ReceiveAndDelete<ept id="p2">**</ept> 模式是最简单的模式，最适合应用程序允许出现故障时不处理消息的方案。为了理解这一点，可以考虑这样一种情形：使用方发出接收请求，但在处理该请求前发生了崩溃。由于 Service Bus 会将消息标记为“将使用”，因此当应用程序重启并重新开始使用消息时，它会丢失在发生崩溃前使用的消息。</source>
          <target state="new">当使用 <bpt id="p1">**</bpt>ReceiveAndDelete<ept id="p1">**</ept> 模式时，接收是一个单次操作。即，当服务总线接收到对消息的读取请求时，它会将该消息标记为“已使用”并将其返回给应用程序。<bpt id="p2">**</bpt>ReceiveAndDelete<ept id="p2">**</ept> 模式是最简单的模式，最适合应用程序允许出现故障时不处理消息的方案。为了理解这一点，可以考虑这样一种情形：使用方发出接收请求，但在处理该请求前发生了崩溃。由于 Service Bus 会将消息标记为“将使用”，因此当应用程序重启并重新开始使用消息时，它会丢失在发生崩溃前使用的消息。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>PeekLock<ept id="p1">**</ept> 模式下，接收变成了一个两阶段操作，从而有可能支持无法允许遗漏消息的应用程序。当 Service Bus 收到请求时，它会查找下一条要使用的消息，锁定该消息以防其他使用者接收，然后将该消息返回到应用程序。应用程序完成消息处理（或可靠地存储消息以供将来处理）后，它将通过对收到的消息调用 <bpt id="p2">**</bpt>Delete<ept id="p2">**</ept> 完成接收过程的第二个阶段。当服务总线发现 <bpt id="p3">**</bpt>Delete<ept id="p3">**</ept> 调用时，它会将消息标记为“已使用”并将其从主题中删除。</source>
          <target state="new">在 <bpt id="p1">**</bpt>PeekLock<ept id="p1">**</ept> 模式下，接收变成了一个两阶段操作，从而有可能支持无法允许遗漏消息的应用程序。当 Service Bus 收到请求时，它会查找下一条要使用的消息，锁定该消息以防其他使用者接收，然后将该消息返回到应用程序。应用程序完成消息处理（或可靠地存储消息以供将来处理）后，它将通过对收到的消息调用 <bpt id="p2">**</bpt>Delete<ept id="p2">**</ept> 完成接收过程的第二个阶段。当服务总线发现 <bpt id="p3">**</bpt>Delete<ept id="p3">**</ept> 调用时，它会将消息标记为“已使用”并将其从主题中删除。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>以下示例演示了如何使用 <bpt id="p1">**</bpt>PeekLock<ept id="p1">**</ept> 模式（非默认模式）接收和处理消息。以下示例执行一个循环并处理“HighMessages”订阅中的消息，然后在处理完所有消息后退出循环（或者，可将其设置为等待新消息）。</source>
          <target state="new">以下示例演示了如何使用 <bpt id="p1">**</bpt>PeekLock<ept id="p1">**</ept> 模式（非默认模式）接收和处理消息。以下示例执行一个循环并处理“HighMessages”订阅中的消息，然后在处理完所有消息后退出循环（或者，可将其设置为等待新消息）。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>如何处理应用程序崩溃和不可读消息</source>
          <target state="new">如何处理应用程序崩溃和不可读消息</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Service Bus 提供了相关功能来帮助你轻松地从应用程序错误或消息处理问题中恢复。如果接收方应用程序出于某种原因无法处理消息，它可以对收到的消息调用 <bpt id="p1">**</bpt>unlockMessage<ept id="p1">**</ept> 方法（而不是 <bpt id="p2">**</bpt>deleteMessage<ept id="p2">**</ept> 方法）。这将导致 Service Bus 解锁主题中的消息并使它能够由同一使用方应用程序或其他使用方应用程序再次接收。</source>
          <target state="new">Service Bus 提供了相关功能来帮助你轻松地从应用程序错误或消息处理问题中恢复。如果接收方应用程序出于某种原因无法处理消息，它可以对收到的消息调用 <bpt id="p1">**</bpt>unlockMessage<ept id="p1">**</ept> 方法（而不是 <bpt id="p2">**</bpt>deleteMessage<ept id="p2">**</ept> 方法）。这将导致 Service Bus 解锁主题中的消息并使它能够由同一使用方应用程序或其他使用方应用程序再次接收。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>还存在与主题中锁定的消息关联的超时，如果应用程序未能在锁定超时过期前处理消息（例如，如果应用程序崩溃），则 Service Bus 将自动解锁该消息并使它能够再次被接收。</source>
          <target state="new">还存在与主题中锁定的消息关联的超时，如果应用程序未能在锁定超时过期前处理消息（例如，如果应用程序崩溃），则 Service Bus 将自动解锁该消息并使它能够再次被接收。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>如果在处理消息之后，发出 <bpt id="p1">**</bpt>deleteMessage<ept id="p1">**</ept> 请求之前应用程序发生崩溃，该消息将在应用程序重新启动时重新传送给它。此情况通常称作<bpt id="p2">**</bpt>至少处理一次<ept id="p2">**</ept>，即每条消息将至少被处理一次，但在某些情况下，同一消息可能会被重新传送如果方案无法容忍重复处理，则应用程序开发人员应向其应用程序添加更多逻辑以处理重复消息传送。通常可使用消息的 <bpt id="p3">**</bpt>getMessageId<ept id="p3">**</ept> 方法实现此操作，这在多个传送尝试中保持不变。</source>
          <target state="new">如果在处理消息之后，发出 <bpt id="p1">**</bpt>deleteMessage<ept id="p1">**</ept> 请求之前应用程序发生崩溃，该消息将在应用程序重新启动时重新传送给它。此情况通常称作<bpt id="p2">**</bpt>至少处理一次<ept id="p2">**</ept>，即每条消息将至少被处理一次，但在某些情况下，同一消息可能会被重新传送如果方案无法容忍重复处理，则应用程序开发人员应向其应用程序添加更多逻辑以处理重复消息传送。通常可使用消息的 <bpt id="p3">**</bpt>getMessageId<ept id="p3">**</ept> 方法实现此操作，这在多个传送尝试中保持不变。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>删除主题和订阅</source>
          <target state="new">删除主题和订阅</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>删除主题和订阅的主要方法是使用 <bpt id="p1">**</bpt>ServiceBusContract<ept id="p1">**</ept> 对象。删除某个主题也会删除向该主题注册的所有订阅。也可以单独删除订阅。</source>
          <target state="new">删除主题和订阅的主要方法是使用 <bpt id="p1">**</bpt>ServiceBusContract<ept id="p1">**</ept> 对象。删除某个主题也会删除向该主题注册的所有订阅。也可以单独删除订阅。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>现在，你已了解 Service Bus 队列的基础知识，请参阅<bpt id="p1">[</bpt>服务总线队列、主题和订阅<ept id="p1">][]</ept>以了解详细信息。</source>
          <target state="new">现在，你已了解 Service Bus 队列的基础知识，请参阅<bpt id="p1">[</bpt>服务总线队列、主题和订阅<ept id="p1">][]</ept>以了解详细信息。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>