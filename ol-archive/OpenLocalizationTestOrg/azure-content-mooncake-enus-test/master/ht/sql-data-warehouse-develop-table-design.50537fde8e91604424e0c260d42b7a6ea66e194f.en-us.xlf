<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5454fb1b7f0059f17b3ffc21f8a9187d33a13eab</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>SQL 数据仓库中的表设计 | Azure</source>
          <target state="new">SQL 数据仓库中的表设计 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>有关在开发解决方案时于 Azure SQL 数据仓库中设计表的技巧。</source>
          <target state="new">有关在开发解决方案时于 Azure SQL 数据仓库中设计表的技巧。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>SQL 数据仓库中的表设计</source>
          <target state="new">SQL 数据仓库中的表设计</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>SQL 数据仓库是一种大规模并行处理 (MPP) 分布式数据库系统。它将数据存储在许多不同的位置（称为<bpt id="p1">**</bpt>分布区<ept id="p1">**</ept>）。每个<bpt id="p2">**</bpt>分布区<ept id="p2">**</ept>类似于一个桶，可在数据仓库中存储唯一的数据子集。通过将数据和处理能力分布于多个节点，SQL 数据仓库能够提供极大的缩放性 — 远超任何单一系统。</source>
          <target state="new">SQL 数据仓库是一种大规模并行处理 (MPP) 分布式数据库系统。它将数据存储在许多不同的位置（称为<bpt id="p1">**</bpt>分布区<ept id="p1">**</ept>）。每个<bpt id="p2">**</bpt>分布区<ept id="p2">**</ept>类似于一个桶，可在数据仓库中存储唯一的数据子集。通过将数据和处理能力分布于多个节点，SQL 数据仓库能够提供极大的缩放性 — 远超任何单一系统。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>在 SQL 数据仓库中创建表时，表实际上分布在所有的分布区。</source>
          <target state="new">在 SQL 数据仓库中创建表时，表实际上分布在所有的分布区。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>本文包括以下主题：</source>
          <target state="new">本文包括以下主题：</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>支持的数据类型</source>
          <target state="new">支持的数据类型</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>数据分布原则</source>
          <target state="new">数据分布原则</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>轮循机制分布</source>
          <target state="new">轮循机制分布</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>哈希分布</source>
          <target state="new">哈希分布</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>表分区</source>
          <target state="new">表分区</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>统计信息</source>
          <target state="new">统计信息</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>不支持的功能</source>
          <target state="new">不支持的功能</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>支持的数据类型</source>
          <target state="new">支持的数据类型</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>SQL 数据仓库支持常见的业务数据类型：</source>
          <target state="new">SQL 数据仓库支持常见的业务数据类型：</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>bigint</source>
          <target state="new">bigint</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>binary</source>
          <target state="new">binary</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>bit</source>
          <target state="new">bit</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>char</source>
          <target state="new">char</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>日期</source>
          <target state="new">日期</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>datetime</source>
          <target state="new">datetime</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>datetime2</source>
          <target state="new">datetime2</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>datetimeoffset</source>
          <target state="new">datetimeoffset</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>decimal</source>
          <target state="new">decimal</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>float</source>
          <target state="new">float</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>int</source>
          <target state="new">int</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>money</source>
          <target state="new">money</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>nchar</source>
          <target state="new">nchar</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>nvarchar</source>
          <target state="new">nvarchar</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>real</source>
          <target state="new">real</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>smalldatetime</source>
          <target state="new">smalldatetime</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>smallint</source>
          <target state="new">smallint</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>smallmoney</source>
          <target state="new">smallmoney</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>time</source>
          <target state="new">time</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>tinyint</source>
          <target state="new">tinyint</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>varbinary</source>
          <target state="new">varbinary</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>varchar</source>
          <target state="new">varchar</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>你可以使用以下查询来识别数据仓库中包含不兼容类型的列：</source>
          <target state="new">你可以使用以下查询来识别数据仓库中包含不兼容类型的列：</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>该查询包含任何不支持的用户定义数据类型。</source>
          <target state="new">该查询包含任何不支持的用户定义数据类型。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>以下是一些可用于取代不支持的数据类型的替代方案。</source>
          <target state="new">以下是一些可用于取代不支持的数据类型的替代方案。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>不要使用：</source>
          <target state="new">不要使用：</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>geometry<ept id="p1">**</ept>，而要使用 varbinary 类型</source>
          <target state="new"><bpt id="p1">**</bpt>geometry<ept id="p1">**</ept>，而要使用 varbinary 类型</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>geography<ept id="p1">**</ept>，而要使用 varbinary 类型</source>
          <target state="new"><bpt id="p1">**</bpt>geography<ept id="p1">**</ept>，而要使用 varbinary 类型</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>hierarchyid<ept id="p1">**</ept>，CLR 类型不是本机的</source>
          <target state="new"><bpt id="p1">**</bpt>hierarchyid<ept id="p1">**</ept>，CLR 类型不是本机的</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>image<ept id="p1">**</ept>、<bpt id="p2">**</bpt>text<ept id="p2">**</ept>、<bpt id="p3">**</bpt>ntext<ept id="p3">**</ept>（基于文本），而要使用 varchar/nvarchar（越小越好）</source>
          <target state="new"><bpt id="p1">**</bpt>image<ept id="p1">**</ept>、<bpt id="p2">**</bpt>text<ept id="p2">**</ept>、<bpt id="p3">**</bpt>ntext<ept id="p3">**</ept>（基于文本），而要使用 varchar/nvarchar（越小越好）</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>nvarchar(max)<ept id="p1">**</ept>，而要使用 nvarchar(4000) 或更小，以改善性能</source>
          <target state="new"><bpt id="p1">**</bpt>nvarchar(max)<ept id="p1">**</ept>，而要使用 nvarchar(4000) 或更小，以改善性能</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>numeric<ept id="p1">**</ept>，而要使用 decimal</source>
          <target state="new"><bpt id="p1">**</bpt>numeric<ept id="p1">**</ept>，而要使用 decimal</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>sql\_variant<ept id="p1">**</ept>，将列拆分成多个强类型化列</source>
          <target state="new"><bpt id="p1">**</bpt>sql\_variant<ept id="p1">**</ept>，将列拆分成多个强类型化列</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>sysname<ept id="p1">**</ept>，而要使用 nvarchar(128)</source>
          <target state="new"><bpt id="p1">**</bpt>sysname<ept id="p1">**</ept>，而要使用 nvarchar(128)</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>table<ept id="p1">**</ept>，转换成暂时表</source>
          <target state="new"><bpt id="p1">**</bpt>table<ept id="p1">**</ept>，转换成暂时表</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>timestamp<ept id="p1">**</ept>，修改代码以使用 datetime2 和 <ph id="ph1">`CURRENT_TIMESTAMP`</ph> 函数。请注意，不能使用 current\_timestamp 作为默认约束，因为值不会自动更新。如果需要从 timestamp 类型化列迁移 rowversion 值，请对 NOT NULL 或 NULL 行版本值使用 BINARY(8) 或 VARBINARY(8)。</source>
          <target state="new"><bpt id="p1">**</bpt>timestamp<ept id="p1">**</ept>，修改代码以使用 datetime2 和 <ph id="ph1">`CURRENT_TIMESTAMP`</ph> 函数。请注意，不能使用 current\_timestamp 作为默认约束，因为值不会自动更新。如果需要从 timestamp 类型化列迁移 rowversion 值，请对 NOT NULL 或 NULL 行版本值使用 BINARY(8) 或 VARBINARY(8)。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>varchar(max)<ept id="p1">**</ept>，而要使用 varchar(8000) 或更小，以改善性能</source>
          <target state="new"><bpt id="p1">**</bpt>varchar(max)<ept id="p1">**</ept>，而要使用 varchar(8000) 或更小，以改善性能</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>uniqueidentifier<ept id="p1">**</ept>，而要使用 varbinary(8)</source>
          <target state="new"><bpt id="p1">**</bpt>uniqueidentifier<ept id="p1">**</ept>，而要使用 varbinary(8)</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>用户定义的类型<ept id="p1">**</ept>，尽可能转换回本机类型</source>
          <target state="new"><bpt id="p1">**</bpt>用户定义的类型<ept id="p1">**</ept>，尽可能转换回本机类型</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>xml<ept id="p1">**</ept>，而要使用 varchar(8000) 或更小，以改善性能 - 根据需要在列间拆分</source>
          <target state="new"><bpt id="p1">**</bpt>xml<ept id="p1">**</ept>，而要使用 varchar(8000) 或更小，以改善性能 - 根据需要在列间拆分</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>部分支持：</source>
          <target state="new">部分支持：</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>默认约束仅支持文本和常量。不支持非确定性表达式或函数，例如 <ph id="ph1">`GETDATE()`</ph> 或 <ph id="ph2">`CURRENT_TIMESTAMP`</ph>。</source>
          <target state="new">默认约束仅支持文本和常量。不支持非确定性表达式或函数，例如 <ph id="ph1">`GETDATE()`</ph> 或 <ph id="ph2">`CURRENT_TIMESTAMP`</ph>。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>定义表，使最大可能的行大小（包括可变长度列的完整长度）不超过 32,767 个字节。虽然定义的行可以包含超过此数据的可变长度数据，但数据将无法插入表。此外，还请限制可变长度列的大小，以便运行查询时有更大的吞吐量。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>定义表，使最大可能的行大小（包括可变长度列的完整长度）不超过 32,767 个字节。虽然定义的行可以包含超过此数据的可变长度数据，但数据将无法插入表。此外，还请限制可变长度列的大小，以便运行查询时有更大的吞吐量。</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>数据分布原则</source>
          <target state="new">数据分布原则</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>有两个选项可在 SQL 数据仓库中分布数据：</source>
          <target state="new">有两个选项可在 SQL 数据仓库中分布数据：</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>均衡随机分布数据</source>
          <target state="new">均衡随机分布数据</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>根据单个列中的哈希值分布数据</source>
          <target state="new">根据单个列中的哈希值分布数据</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>在表级别决定数据分布。分布所有表。在 SQL 数据仓库数据库中分配每个表的分布。</source>
          <target state="new">在表级别决定数据分布。分布所有表。在 SQL 数据仓库数据库中分配每个表的分布。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>第一个选项就是所谓的<bpt id="p1">**</bpt>轮询机制<ept id="p1">**</ept>分布 - 有时称为随机哈希。可以将此选项视为默认或防故障选项。</source>
          <target state="new">第一个选项就是所谓的<bpt id="p1">**</bpt>轮询机制<ept id="p1">**</ept>分布 - 有时称为随机哈希。可以将此选项视为默认或防故障选项。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>第二个选项称为<bpt id="p1">**</bpt>哈希<ept id="p1">**</ept>分布。可以将它视为数据分布的优化形式。当表群集共享通用的联接和/或聚合条件时，经常使用此选项。</source>
          <target state="new">第二个选项称为<bpt id="p1">**</bpt>哈希<ept id="p1">**</ept>分布。可以将它视为数据分布的优化形式。当表群集共享通用的联接和/或聚合条件时，经常使用此选项。</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>轮循机制分布</source>
          <target state="new">轮循机制分布</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>轮循机制分布是尽可能让数据平均分布在所有分布区中的方法。包含行的缓冲区依次分配（因此名为轮循机制）到每个分布。该过程将不断重复，直到分配了所有数据缓冲区为止。数据不会在轮循机制分布式表中进行排序。出于此原因，轮循机制分布有时称为随机哈希。数据尽可能地平均分布在所有分布区中。</source>
          <target state="new">轮循机制分布是尽可能让数据平均分布在所有分布区中的方法。包含行的缓冲区依次分配（因此名为轮循机制）到每个分布。该过程将不断重复，直到分配了所有数据缓冲区为止。数据不会在轮循机制分布式表中进行排序。出于此原因，轮循机制分布有时称为随机哈希。数据尽可能地平均分布在所有分布区中。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>以下是轮循机制分布式表的示例：</source>
          <target state="new">以下是轮循机制分布式表的示例：</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>以下同样是轮循机制分布式表的一个示例：</source>
          <target state="new">以下同样是轮循机制分布式表的一个示例：</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>请注意，上述第二个示例并未提到分布键。轮循机制是默认设置，因此不是绝对必要的。但是，最好是明确分布方式，因为这可以在审查表设计时，确保你的同事知道你的意图。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>请注意，上述第二个示例并未提到分布键。轮循机制是默认设置，因此不是绝对必要的。但是，最好是明确分布方式，因为这可以在审查表设计时，确保你的同事知道你的意图。</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>没有明显的键列可哈希数据时，通常使用此表类型。较小或较不重要的表（其移动成本可能不是很高）也可以使用此表类型。</source>
          <target state="new">没有明显的键列可哈希数据时，通常使用此表类型。较小或较不重要的表（其移动成本可能不是很高）也可以使用此表类型。</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>将数据载入轮循机制分布式表通常比载入哈希分布式表更快。使用轮循机制分布式表，加载前不需要了解数据或执行哈希。出于此原因，轮循机制表通常具有良好的加载目标。</source>
          <target state="new">将数据载入轮循机制分布式表通常比载入哈希分布式表更快。使用轮循机制分布式表，加载前不需要了解数据或执行哈希。出于此原因，轮循机制表通常具有良好的加载目标。</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>将数据进行轮循机制分布后，数据将在<bpt id="p1">*</bpt>缓冲区<ept id="p1">*</ept>级别分配到分布区。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>将数据进行轮循机制分布后，数据将在<bpt id="p1">*</bpt>缓冲区<ept id="p1">*</ept>级别分配到分布区。</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>建议</source>
          <target state="new">建议</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>在以下情况下，请考虑对表使用轮循机制分布：</source>
          <target state="new">在以下情况下，请考虑对表使用轮循机制分布：</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>没有明显的联接键时</source>
          <target state="new">没有明显的联接键时</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>不知道候选哈希分布键时</source>
          <target state="new">不知道候选哈希分布键时</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>表没有与其他表共享通用的联接键时</source>
          <target state="new">表没有与其他表共享通用的联接键时</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>该联接比查询中的其他联接更不重要时</source>
          <target state="new">该联接比查询中的其他联接更不重要时</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>该表是初始加载表时</source>
          <target state="new">该表是初始加载表时</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>哈希分布</source>
          <target state="new">哈希分布</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>哈希分布使用内部函数通过哈希单个列来将数据集分布到各个分布区。哈希数据后，将数据分配到分布区不遵循明确的顺序。但是，哈希本身是确定性的过程。这使哈希结果变得可预测。例如，哈希包含值 10 的整数列时，始终会生成相同的哈希值。这意味着，<bpt id="p1">***</bpt>任何<ept id="p1">***</ept>包含值 10 的哈希整数列最终都会分配到相同的分布区。这一点适用于所有表。</source>
          <target state="new">哈希分布使用内部函数通过哈希单个列来将数据集分布到各个分布区。哈希数据后，将数据分配到分布区不遵循明确的顺序。但是，哈希本身是确定性的过程。这使哈希结果变得可预测。例如，哈希包含值 10 的整数列时，始终会生成相同的哈希值。这意味着，<bpt id="p1">***</bpt>任何<ept id="p1">***</ept>包含值 10 的哈希整数列最终都会分配到相同的分布区。这一点适用于所有表。</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>哈希可预测性非常重要。也就是说，分布数据的哈希可能使读取数据和将表联接在一起时的性能得到改进。</source>
          <target state="new">哈希可预测性非常重要。也就是说，分布数据的哈希可能使读取数据和将表联接在一起时的性能得到改进。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>如下所示，哈希分布对查询优化非常有用。这就是它为何被视为数据分布优化形式的原因。</source>
          <target state="new">如下所示，哈希分布对查询优化非常有用。这就是它为何被视为数据分布优化形式的原因。</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>请记住！ 哈希不是基于数据值，而是基于要哈希的数据类型。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>请记住！ 哈希不是基于数据值，而是基于要哈希的数据类型。</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>以下是根据 ProductKey 进行哈希分布的表。</source>
          <target state="new">以下是根据 ProductKey 进行哈希分布的表。</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>将数据进行哈希分布后，数据将在行级别分配到分布区。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>将数据进行哈希分布后，数据将在行级别分配到分布区。</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>表分区</source>
          <target state="new">表分区</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>支持并且可轻松定义表分区。</source>
          <target state="new">支持并且可轻松定义表分区。</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>SQL 数据仓库分区的 <ph id="ph1">`CREATE TABLE`</ph> 命令示例：</source>
          <target state="new">SQL 数据仓库分区的 <ph id="ph1">`CREATE TABLE`</ph> 命令示例：</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>请注意，定义中没有数据分区函数或方案。所有这些信息都是在创建表时处理。你只需识别即将成为分区键的列的边界点。</source>
          <target state="new">请注意，定义中没有数据分区函数或方案。所有这些信息都是在创建表时处理。你只需识别即将成为分区键的列的边界点。</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>统计信息</source>
          <target state="new">统计信息</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>当用户查询表时，SQL 数据仓库将使用分布式查询优化器来创建适当的查询计划。创建后，查询计划将提供数据库用于访问数据和履行用户请求的策略与方法。SQL 数据仓库的查询优化器基于成本。换句话说，它根据相对成本来比较各种选项（计划）并选择最有效率的可用计划。因此，SQL 数据仓库需要大量信息才能做出基于成本的明智决策。它保留有关表（表大小）的统计信息，在数据库对象中称为 <ph id="ph1">`STATISTICS`</ph>。</source>
          <target state="new">当用户查询表时，SQL 数据仓库将使用分布式查询优化器来创建适当的查询计划。创建后，查询计划将提供数据库用于访问数据和履行用户请求的策略与方法。SQL 数据仓库的查询优化器基于成本。换句话说，它根据相对成本来比较各种选项（计划）并选择最有效率的可用计划。因此，SQL 数据仓库需要大量信息才能做出基于成本的明智决策。它保留有关表（表大小）的统计信息，在数据库对象中称为 <ph id="ph1">`STATISTICS`</ph>。</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>统计信息针对索引或表的单个或多个列保留。这些数据可将值的基数和选择性相关重要信息提供给基于成本的优化器。当优化器需要评估查询中的 JOIN、GROUP BY、HAVING 和 WHERE 子句时，这些数据特别有用。因此，这些统计信息对象包含的信息一定要<bpt id="p1">*</bpt>准确<ept id="p1">*</ept>反映表的当前状态。请务必知道，成本的准确性非常重要。如果统计信息准确反映了表的状态，则可以比较计划以找出最低的成本。如果统计信息不准确，SQL 数据仓库可能会选择错误的计划。</source>
          <target state="new">统计信息针对索引或表的单个或多个列保留。这些数据可将值的基数和选择性相关重要信息提供给基于成本的优化器。当优化器需要评估查询中的 JOIN、GROUP BY、HAVING 和 WHERE 子句时，这些数据特别有用。因此，这些统计信息对象包含的信息一定要<bpt id="p1">*</bpt>准确<ept id="p1">*</ept>反映表的当前状态。请务必知道，成本的准确性非常重要。如果统计信息准确反映了表的状态，则可以比较计划以找出最低的成本。如果统计信息不准确，SQL 数据仓库可能会选择错误的计划。</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>SQL 数据仓库中的列级统计信息由用户定义。</source>
          <target state="new">SQL 数据仓库中的列级统计信息由用户定义。</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>换句话说，我们必须自行创建这些统计信息。我们刚才知道，这件事不容忽视。这是 SQL Server 与 SQL 数据仓库间的重要差异。查询列时，SQL Server 会自动创建统计信息。默认情况下，SQL Server 还会自动更新这些统计信息。但是，在 SQL 数据仓库中，需要手动创建和管理统计信息。</source>
          <target state="new">换句话说，我们必须自行创建这些统计信息。我们刚才知道，这件事不容忽视。这是 SQL Server 与 SQL 数据仓库间的重要差异。查询列时，SQL Server 会自动创建统计信息。默认情况下，SQL Server 还会自动更新这些统计信息。但是，在 SQL 数据仓库中，需要手动创建和管理统计信息。</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>建议</source>
          <target state="new">建议</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>生成统计信息时，请遵循以下建议：</source>
          <target state="new">生成统计信息时，请遵循以下建议：</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>对 <ph id="ph1">`WHERE`</ph>、<ph id="ph2">`JOIN`</ph>、<ph id="ph3">`GROUP BY`</ph>、<ph id="ph4">`ORDER BY`</ph> 和 <ph id="ph5">`DISTINCT`</ph> 子句使用的列，请创建单列统计信息</source>
          <target state="new">对 <ph id="ph1">`WHERE`</ph>、<ph id="ph2">`JOIN`</ph>、<ph id="ph3">`GROUP BY`</ph>、<ph id="ph4">`ORDER BY`</ph> 和 <ph id="ph5">`DISTINCT`</ph> 子句使用的列，请创建单列统计信息</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>生成复合子句的多列统计信息</source>
          <target state="new">生成复合子句的多列统计信息</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>定期更新统计信息。请记住，此操作不会自动完成！</source>
          <target state="new">定期更新统计信息。请记住，此操作不会自动完成！</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>SQL Server 数据仓库通常完全依赖 <ph id="ph2">`AUTOSTATS`</ph> 来保持列统计信息的最新状态。对于 SQL Server 数据仓库而言，这不是最佳实践。20% 的变化率将触发 <ph id="ph3">`AUTOSTATS`</ph>，这对于包含数百万或数十亿行的大型事实表而言可能不太足够。因此，最好随时掌握统计信息更新，以确保统计信息能准确地反映表的基数。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>SQL Server 数据仓库通常完全依赖 <ph id="ph2">`AUTOSTATS`</ph> 来保持列统计信息的最新状态。对于 SQL Server 数据仓库而言，这不是最佳实践。20% 的变化率将触发 <ph id="ph3">`AUTOSTATS`</ph>，这对于包含数百万或数十亿行的大型事实表而言可能不太足够。因此，最好随时掌握统计信息更新，以确保统计信息能准确地反映表的基数。</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>不支持的功能</source>
          <target state="new">不支持的功能</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>SQL 数据仓库不使用或不支持以下功能：</source>
          <target state="new">SQL 数据仓库不使用或不支持以下功能：</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>主键</source>
          <target state="new">主键</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>外键</source>
          <target state="new">外键</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>检查约束</source>
          <target state="new">检查约束</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>唯一约束</source>
          <target state="new">唯一约束</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>唯一索引</source>
          <target state="new">唯一索引</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>计算列</source>
          <target state="new">计算列</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>稀疏列</source>
          <target state="new">稀疏列</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>用户定义的类型</source>
          <target state="new">用户定义的类型</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>索引视图</source>
          <target state="new">索引视图</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>标识</source>
          <target state="new">标识</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>序列</source>
          <target state="new">序列</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>触发器</source>
          <target state="new">触发器</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>同义词</source>
          <target state="new">同义词</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>有关更多开发技巧，请参阅<bpt id="p1">[</bpt>开发概述<ept id="p1">][]</ept>。</source>
          <target state="new">有关更多开发技巧，请参阅<bpt id="p1">[</bpt>开发概述<ept id="p1">][]</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>