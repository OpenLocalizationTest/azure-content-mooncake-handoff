<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4c8c50ec7fd92a039de45e5388d7f24c385c7387</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 PHP 使用队列存储 | Azure</source>
          <target state="new">如何通过 PHP 使用队列存储 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何使用 Azure 队列存储服务创建和删除队列，以及插入、获取和删除消息。示例用 PHP 编写。</source>
          <target state="new">了解如何使用 Azure 队列存储服务创建和删除队列，以及插入、获取和删除消息。示例用 PHP 编写。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何通过 PHP 使用队列存储</source>
          <target state="new">如何通过 PHP 使用队列存储</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本指南将演示如何使用 Azure 队列存储服务执行常见方案。这些示例使用来自 Windows SDK for PHP 中的类编写。介绍的方案包括插入、扫视、获取和删除队列消息以及创建和删除队列。</source>
          <target state="new">本指南将演示如何使用 Azure 队列存储服务执行常见方案。这些示例使用来自 Windows SDK for PHP 中的类编写。介绍的方案包括插入、扫视、获取和删除队列消息以及创建和删除队列。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>创建 PHP 应用程序</source>
          <target state="new">创建 PHP 应用程序</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>创建访问 Azure 队列存储的 PHP 应用程序的唯一要求是从代码中引用 Azure SDK for PHP 中的类。你可以使用任何开发工具（包括“记事本”）创建应用程序。</source>
          <target state="new">创建访问 Azure 队列存储的 PHP 应用程序的唯一要求是从代码中引用 Azure SDK for PHP 中的类。你可以使用任何开发工具（包括“记事本”）创建应用程序。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>在本指南中，你将使用队列存储功能，这些功能可在 PHP 应用程序中本地调用，或通过在 Azure 的 Web 角色、辅助角色或 Web 应用中运行的代码调用。</source>
          <target state="new">在本指南中，你将使用队列存储功能，这些功能可在 PHP 应用程序中本地调用，或通过在 Azure 的 Web 角色、辅助角色或 Web 应用中运行的代码调用。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>获取 Azure 客户端库</source>
          <target state="new">获取 Azure 客户端库</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>配置应用程序以访问队列存储</source>
          <target state="new">配置应用程序以访问队列存储</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>若要使用 Azure 队列存储 API，你需要：</source>
          <target state="new">若要使用 Azure 队列存储 API，你需要：</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>通过使用 <bpt id="p1">[</bpt>require_once<ept id="p1">][require_once]</ept> 语句引用 autoloader 文件。</source>
          <target state="new">通过使用 <bpt id="p1">[</bpt>require_once<ept id="p1">][require_once]</ept> 语句引用 autoloader 文件。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>引用可使用的所有类。</source>
          <target state="new">引用可使用的所有类。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>下面的示例演示了如何包括 autoloader 文件并引用 <bpt id="p1">**</bpt>ServicesBuilder<ept id="p1">**</ept> 类。</source>
          <target state="new">下面的示例演示了如何包括 autoloader 文件并引用 <bpt id="p1">**</bpt>ServicesBuilder<ept id="p1">**</ept> 类。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 本示例（以及本文中的其他示例）假定你已通过 Composer 安装用于 Azure 的 PHP 客户端库。如果你已手动安装这些库或将其作为 PEAR 包安装，则需要引用 <ph id="ph2">`WindowsAzure.php`</ph> autoloader 文件。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 本示例（以及本文中的其他示例）假定你已通过 Composer 安装用于 Azure 的 PHP 客户端库。如果你已手动安装这些库或将其作为 PEAR 包安装，则需要引用 <ph id="ph2">`WindowsAzure.php`</ph> autoloader 文件。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>在下面的示例中，<ph id="ph1">`require_once`</ph> 语句将始终显示，但只会引用执行该示例所需的类。</source>
          <target state="new">在下面的示例中，<ph id="ph1">`require_once`</ph> 语句将始终显示，但只会引用执行该示例所需的类。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>设置 Azure 存储连接</source>
          <target state="new">设置 Azure 存储连接</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>若要实例化 Azure 队列存储客户端，你必须首先具有有效的连接字符串。队列服务连接字符串的格式如下。</source>
          <target state="new">若要实例化 Azure 队列存储客户端，你必须首先具有有效的连接字符串。队列服务连接字符串的格式如下。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>对于访问实时服务：</source>
          <target state="new">对于访问实时服务：</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>对于访问模拟器存储：</source>
          <target state="new">对于访问模拟器存储：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>若要创建任何 Azure 服务客户端，你将需要使用 <bpt id="p1">**</bpt>ServicesBuilder<ept id="p1">**</ept> 类。你可以使用以下方法之一：</source>
          <target state="new">若要创建任何 Azure 服务客户端，你将需要使用 <bpt id="p1">**</bpt>ServicesBuilder<ept id="p1">**</ept> 类。你可以使用以下方法之一：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>将连接字符串直接传递给它。</source>
          <target state="new">将连接字符串直接传递给它。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>CloudConfigurationManager (CCM)<ept id="p1">**</ept> 检查多个外部源以获取连接字符串：</source>
          <target state="new">使用 <bpt id="p1">**</bpt>CloudConfigurationManager (CCM)<ept id="p1">**</ept> 检查多个外部源以获取连接字符串：</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>默认情况下，它附带了对一个外部源的支持 - 环境变量</source>
          <target state="new">默认情况下，它附带了对一个外部源的支持 - 环境变量</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>您可通过扩展 <bpt id="p1">**</bpt>ConnectionStringSource<ept id="p1">**</ept> 类来添加新源。</source>
          <target state="new">您可通过扩展 <bpt id="p1">**</bpt>ConnectionStringSource<ept id="p1">**</ept> 类来添加新源。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>在此处列出的示例中，将直接传递连接字符串。</source>
          <target state="new">在此处列出的示例中，将直接传递连接字符串。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>创建队列</source>
          <target state="new">创建队列</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>一个 <bpt id="p1">**</bpt>QueueRestProxy<ept id="p1">**</ept> 对象，让你可以通过使用 <bpt id="p2">**</bpt>createQueue<ept id="p2">**</ept> 方法创建队列。创建队列时，可以在该队列上设置选项，但此操作不是必需的。（下面的示例演示了如何在队列上设置元数据。）</source>
          <target state="new">一个 <bpt id="p1">**</bpt>QueueRestProxy<ept id="p1">**</ept> 对象，让你可以通过使用 <bpt id="p2">**</bpt>createQueue<ept id="p2">**</ept> 方法创建队列。创建队列时，可以在该队列上设置选项，但此操作不是必需的。（下面的示例演示了如何在队列上设置元数据。）</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>您不应依赖元数据密钥的区分大小写。所有密钥都是采用小写形式从服务中读取的。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>您不应依赖元数据密钥的区分大小写。所有密钥都是采用小写形式从服务中读取的。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>向队列添加消息</source>
          <target state="new">向队列添加消息</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>若要将消息添加到队列，请使用 <bpt id="p1">**</bpt>QueueRestProxy-&gt;createMessage<ept id="p1">**</ept>。此方法接受队列名称、消息文本和消息选项（这些都是可选的）。</source>
          <target state="new">若要将消息添加到队列，请使用 <bpt id="p1">**</bpt>QueueRestProxy-&gt;createMessage<ept id="p1">**</ept>。此方法接受队列名称、消息文本和消息选项（这些都是可选的）。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>扫视下一条消息</source>
          <target state="new">扫视下一条消息</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>通过调用 <bpt id="p1">**</bpt>QueueRestProxy-&gt;peekMessages<ept id="p1">**</ept>，可以扫视队列前面的消息，而不会从队列中将其删除。默认情况下，<bpt id="p2">**</bpt>peekMessage<ept id="p2">**</ept> 方法将返回单个消息，但你可以使用 <bpt id="p3">**</bpt>PeekMessagesOptions-&gt;setNumberOfMessages<ept id="p3">**</ept> 方法更改该值。</source>
          <target state="new">通过调用 <bpt id="p1">**</bpt>QueueRestProxy-&gt;peekMessages<ept id="p1">**</ept>，可以扫视队列前面的消息，而不会从队列中将其删除。默认情况下，<bpt id="p2">**</bpt>peekMessage<ept id="p2">**</ept> 方法将返回单个消息，但你可以使用 <bpt id="p3">**</bpt>PeekMessagesOptions-&gt;setNumberOfMessages<ept id="p3">**</ept> 方法更改该值。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>取消对下一条消息的排队</source>
          <target state="new">取消对下一条消息的排队</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>你的代码分两步从队列中删除消息。首先，调用 <bpt id="p1">**</bpt>queuerestproxy-&gt;listmessages<ept id="p1">**</ept>，这将使消息对从队列中读取的任何其他代码不可见。默认情况下，此消息将持续 30 秒不可见。（如果在此时段内未删除该消息，则它将变得在队列上再次可见）。 若要从队列中删除消息，你必须调用 <bpt id="p2">**</bpt>QueueRestProxy-&gt;deleteMessage<ept id="p2">**</ept>。此删除消息的两步过程可确保当您的代码因硬件或软件故障而无法处理消息时，您的其他代码实例可以获取同一消息并重试。你的代码在处理消息后会立即调用 <bpt id="p3">**</bpt>deleteMessage<ept id="p3">**</ept>。</source>
          <target state="new">你的代码分两步从队列中删除消息。首先，调用 <bpt id="p1">**</bpt>queuerestproxy-&gt;listmessages<ept id="p1">**</ept>，这将使消息对从队列中读取的任何其他代码不可见。默认情况下，此消息将持续 30 秒不可见。（如果在此时段内未删除该消息，则它将变得在队列上再次可见）。 若要从队列中删除消息，你必须调用 <bpt id="p2">**</bpt>QueueRestProxy-&gt;deleteMessage<ept id="p2">**</ept>。此删除消息的两步过程可确保当您的代码因硬件或软件故障而无法处理消息时，您的其他代码实例可以获取同一消息并重试。你的代码在处理消息后会立即调用 <bpt id="p3">**</bpt>deleteMessage<ept id="p3">**</ept>。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>更改已排队消息的内容</source>
          <target state="new">更改已排队消息的内容</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>可以通过调用 <bpt id="p1">**</bpt>QueueRestProxy-&gt;updateMessage<ept id="p1">**</ept> 来更改队列中已就位消息的内容。如果消息表示工作任务，则你可以使用此功能来更新该工作任务的状态。以下代码使用新内容更新队列消息，并将可见性超时设置为再延长 60 秒。这将保存与消息关联的工作的状态，并额外为客户端提供一分钟的时间来继续处理消息。可使用此方法跟踪队列消息上的多步骤工作流，即使处理步骤因硬件或软件故障而失败，也无需从头开始操作。通常，你还可以保留重试计数，如果某条消息的重试次数超过 <bpt id="p2">*</bpt>n<ept id="p2">*</ept>，你将删除此消息。这可避免每次处理某条消息时都触发应用程序错误。</source>
          <target state="new">可以通过调用 <bpt id="p1">**</bpt>QueueRestProxy-&gt;updateMessage<ept id="p1">**</ept> 来更改队列中已就位消息的内容。如果消息表示工作任务，则你可以使用此功能来更新该工作任务的状态。以下代码使用新内容更新队列消息，并将可见性超时设置为再延长 60 秒。这将保存与消息关联的工作的状态，并额外为客户端提供一分钟的时间来继续处理消息。可使用此方法跟踪队列消息上的多步骤工作流，即使处理步骤因硬件或软件故障而失败，也无需从头开始操作。通常，你还可以保留重试计数，如果某条消息的重试次数超过 <bpt id="p2">*</bpt>n<ept id="p2">*</ept>，你将删除此消息。这可避免每次处理某条消息时都触发应用程序错误。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>用于取消对消息进行排队的其他选项</source>
          <target state="new">用于取消对消息进行排队的其他选项</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>你可以通过两种方式自定义队列中的消息检索。首先，你可以获取一批消息（最多 32 个）。其次，你可以设置更长或更短的可见超时，从而允许你的代码使用更多或更少的时间来彻底处理每条消息。以下代码示例使用 <bpt id="p1">**</bpt>getMessages<ept id="p1">**</ept> 方法在一次调用中获取 16 条消息。然后，它会使用 <bpt id="p2">**</bpt>for<ept id="p2">**</ept> 循环处理每条消息。它还将每条消息的不可见超时时间设置为 5 分钟。</source>
          <target state="new">你可以通过两种方式自定义队列中的消息检索。首先，你可以获取一批消息（最多 32 个）。其次，你可以设置更长或更短的可见超时，从而允许你的代码使用更多或更少的时间来彻底处理每条消息。以下代码示例使用 <bpt id="p1">**</bpt>getMessages<ept id="p1">**</ept> 方法在一次调用中获取 16 条消息。然后，它会使用 <bpt id="p2">**</bpt>for<ept id="p2">**</ept> 循环处理每条消息。它还将每条消息的不可见超时时间设置为 5 分钟。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>获取队列长度</source>
          <target state="new">获取队列长度</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>你可以获取队列中消息的估计数。<bpt id="p1">**</bpt>QueueRestProxy-&gt;getQueueMetadata<ept id="p1">**</ept> 方法要求队列服务返回有关队列的元数据。对返回的对象调用 <bpt id="p2">**</bpt>getApproximateMessageCount<ept id="p2">**</ept> 方法将提供队列中消息的计数。此计数仅为近似值，因为只能在队列服务响应您的请求后添加或删除消息。</source>
          <target state="new">你可以获取队列中消息的估计数。<bpt id="p1">**</bpt>QueueRestProxy-&gt;getQueueMetadata<ept id="p1">**</ept> 方法要求队列服务返回有关队列的元数据。对返回的对象调用 <bpt id="p2">**</bpt>getApproximateMessageCount<ept id="p2">**</ept> 方法将提供队列中消息的计数。此计数仅为近似值，因为只能在队列服务响应您的请求后添加或删除消息。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>删除队列</source>
          <target state="new">删除队列</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>若要删除队列及其包含的所有消息，请调用 <bpt id="p1">**</bpt>QueueRestProxy-&gt;deleteQueue<ept id="p1">**</ept> 方法。</source>
          <target state="new">若要删除队列及其包含的所有消息，请调用 <bpt id="p1">**</bpt>QueueRestProxy-&gt;deleteQueue<ept id="p1">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>现在，你已了解有关 Azure 队列存储的基础知识，可单击下面的链接来了解更复杂的存储任务。</source>
          <target state="new">现在，你已了解有关 Azure 队列存储的基础知识，可单击下面的链接来了解更复杂的存储任务。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>访问 <bpt id="p1">[</bpt>Azure 存储空间团队博客<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/)</ept>。</source>
          <target state="new">访问 <bpt id="p1">[</bpt>Azure 存储空间团队博客<ept id="p1">](http://blogs.msdn.com/b/windowsazurestorage/)</ept>。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>有关详细信息，另请参阅 <bpt id="p1">[</bpt>PHP 开发人员中心<ept id="p1">](/develop/php/)</ept>。</source>
          <target state="new">有关详细信息，另请参阅 <bpt id="p1">[</bpt>PHP 开发人员中心<ept id="p1">](/develop/php/)</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>