<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">45505a48a2f7fa43de915b220bcb10ba0df34253</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>将 docker-machine 与 Azure 一起使用 | Azure</source>
          <target state="new">将 docker-machine 与 Azure 一起使用 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>演示如何使用经典部署模型在 Azure 上启动和运行 Ubuntu 上的 Docker 计算机。</source>
          <target state="new">演示如何使用经典部署模型在 Azure 上启动和运行 Ubuntu 上的 Docker 计算机。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何将 docker-machine 与 Azure 一起使用</source>
          <target state="new">如何将 docker-machine 与 Azure 一起使用</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>本主题介绍如何将 <bpt id="p1">[</bpt>Docker<ept id="p1">](https://www.docker.com/)</ept> 与<bpt id="p2">[</bpt>计算机<ept id="p2">](https://github.com/docker/machine)</ept>和 <bpt id="p3">[</bpt>Azure CLI<ept id="p3">](https://github.com/Azure/azure-xplat-cli)</ept> 结合使用来创建 Azure 虚拟机，以便快速轻松地从运行 Ubuntu 的计算机管理 Linux 容器。为了演示，本教程将说明如何同时部署 <bpt id="p4">[</bpt>busybox Docker Hub 映像<ept id="p4">](https://registry.hub.docker.com/_/busybox/)</ept>和 <bpt id="p5">[</bpt>nginx Docker Hub 映像<ept id="p5">](https://registry.hub.docker.com/_/nginx/)</ept>，并配置容器将 Web 请求路由到 nginx 容器。（Docker <bpt id="p6">**</bpt>计算机<ept id="p6">**</ept>文档介绍如何针对其他平台修改这些说明。）</source>
          <target state="new">本主题介绍如何将 <bpt id="p1">[</bpt>Docker<ept id="p1">](https://www.docker.com/)</ept> 与<bpt id="p2">[</bpt>计算机<ept id="p2">](https://github.com/docker/machine)</ept>和 <bpt id="p3">[</bpt>Azure CLI<ept id="p3">](https://github.com/Azure/azure-xplat-cli)</ept> 结合使用来创建 Azure 虚拟机，以便快速轻松地从运行 Ubuntu 的计算机管理 Linux 容器。为了演示，本教程将说明如何同时部署 <bpt id="p4">[</bpt>busybox Docker Hub 映像<ept id="p4">](https://registry.hub.docker.com/_/busybox/)</ept>和 <bpt id="p5">[</bpt>nginx Docker Hub 映像<ept id="p5">](https://registry.hub.docker.com/_/nginx/)</ept>，并配置容器将 Web 请求路由到 nginx 容器。（Docker <bpt id="p6">**</bpt>计算机<ept id="p6">**</ept>文档介绍如何针对其他平台修改这些说明。）</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>[AZURE.INCLUDE <bpt id="p1">[</bpt>了解部署模型<ept id="p1">](../includes/learn-about-deployment-models-classic-include.md)</ept>]资源管理器模型。</source>
          <target state="new">[AZURE.INCLUDE <bpt id="p1">[</bpt>了解部署模型<ept id="p1">](../includes/learn-about-deployment-models-classic-include.md)</ept>]资源管理器模型。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>完成本教程有一些先决条件。你将需要安装以下项：</source>
          <target state="new">完成本教程有一些先决条件。你将需要安装以下项：</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>npm<ept id="p1">](https://docs.npmjs.com/)</ept> 和 <bpt id="p2">[</bpt>Node.js<ept id="p2">](http://nodejs.org/)</ept></source>
          <target state="new"><bpt id="p1">[</bpt>npm<ept id="p1">](https://docs.npmjs.com/)</ept> 和 <bpt id="p2">[</bpt>Node.js<ept id="p2">](http://nodejs.org/)</ept></target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Azure CLI</source>
          <target state="new">Azure CLI</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Docker 客户端</source>
          <target state="new">Docker 客户端</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>如果按此顺序安装这些项，Ubuntu 计算机就会具备使用本教程的条件。（本教程应在很大程度上也适用于任何其他基于 dpkg 的发行版本，例如 Debian。如果你发现额外的要求或步骤，请在评论中让我们知道。）</source>
          <target state="new">如果按此顺序安装这些项，Ubuntu 计算机就会具备使用本教程的条件。（本教程应在很大程度上也适用于任何其他基于 dpkg 的发行版本，例如 Debian。如果你发现额外的要求或步骤，请在评论中让我们知道。）</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>获取 docker-machine - 或生成它</source>
          <target state="new">获取 docker-machine - 或生成它</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>熟悉 <bpt id="p1">**</bpt>docker-machine<ept id="p1">**</ept> 的最快方法是直接从<bpt id="p2">[</bpt>版本共享<ept id="p2">](https://github.com/docker/machine/releases)</ept>下载相应的发行版。本教程中的客户端计算机在 x64 计算机上运行 Ubuntu，因此 <bpt id="p3">**</bpt>docker-machine\_linux amd64<ept id="p3">**</ept> 映像是所使用的那一个。</source>
          <target state="new">熟悉 <bpt id="p1">**</bpt>docker-machine<ept id="p1">**</ept> 的最快方法是直接从<bpt id="p2">[</bpt>版本共享<ept id="p2">](https://github.com/docker/machine/releases)</ept>下载相应的发行版。本教程中的客户端计算机在 x64 计算机上运行 Ubuntu，因此 <bpt id="p3">**</bpt>docker-machine\_linux amd64<ept id="p3">**</ept> 映像是所使用的那一个。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>你还可以按照<bpt id="p1">[</bpt>提供给虚拟机<ept id="p1">](https://github.com/docker/machine#contributing)</ept>的步骤自己构建 <bpt id="p2">**</bpt>docker-machine<ept id="p2">**</ept>。为执行此生成你应准备好下载多达 1 GB 或更多的内容，但通过这样做你可以按所需方式准确地自定义自己的体验。</source>
          <target state="new">你还可以按照<bpt id="p1">[</bpt>提供给虚拟机<ept id="p1">](https://github.com/docker/machine#contributing)</ept>的步骤自己构建 <bpt id="p2">**</bpt>docker-machine<ept id="p2">**</ept>。为执行此生成你应准备好下载多达 1 GB 或更多的内容，但通过这样做你可以按所需方式准确地自定义自己的体验。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 你或许可以创建指向它的平台版本的<bpt id="p1">[</bpt>符号链接<ept id="p1">](http://en.wikipedia.org/wiki/Symbolic_link)</ept>，但本教程使用二进制文件直接非常清楚地演示行为。结果是，不是使用 <bpt id="p2">**</bpt>docker-machine<ept id="p2">**</ept> 文档所演示的 <ph id="ph2">`docker-machine env`</ph> 等命令，本教程改用 <ph id="ph3">`docker-machine_linux-amd64 env`</ph>。是创建符号链接还是直接使用二进制文件名称直接取决于你，但如果你更改所用的名称，请记得修改下面的说明中的名称。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 你或许可以创建指向它的平台版本的<bpt id="p1">[</bpt>符号链接<ept id="p1">](http://en.wikipedia.org/wiki/Symbolic_link)</ept>，但本教程使用二进制文件直接非常清楚地演示行为。结果是，不是使用 <bpt id="p2">**</bpt>docker-machine<ept id="p2">**</ept> 文档所演示的 <ph id="ph2">`docker-machine env`</ph> 等命令，本教程改用 <ph id="ph3">`docker-machine_linux-amd64 env`</ph>。是创建符号链接还是直接使用二进制文件名称直接取决于你，但如果你更改所用的名称，请记得修改下面的说明中的名称。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>无论你使用哪种方法，你都必须直接在命令行上调用二进制文件或将二进制文件放在路径（例如 <bpt id="p1">**</bpt>/usr/local/bin<ept id="p1">**</ept>）上。请记住，确保通过键入 <ph id="ph1">`chmod +x`</ph> &amp;lt;<bpt id="p2">*</bpt><ph id="ph2">`binaryName`</ph><ept id="p2">*</ept>&amp;gt; 将它标记为可执行文件，其中 &amp;lt;<bpt id="p3">*</bpt><ph id="ph3">`binaryName`</ph><ept id="p3">*</ept>&amp;gt; 是 Docker 计算机可执行文件的名称。本教程使用 <bpt id="p4">**</bpt>docker-machine\_linux-amd64<ept id="p4">**</ept>。</source>
          <target state="new">无论你使用哪种方法，你都必须直接在命令行上调用二进制文件或将二进制文件放在路径（例如 <bpt id="p1">**</bpt>/usr/local/bin<ept id="p1">**</ept>）上。请记住，确保通过键入 <ph id="ph1">`chmod +x`</ph> &amp;lt;<bpt id="p2">*</bpt><ph id="ph2">`binaryName`</ph><ept id="p2">*</ept>&amp;gt; 将它标记为可执行文件，其中 &amp;lt;<bpt id="p3">*</bpt><ph id="ph3">`binaryName`</ph><ept id="p3">*</ept>&amp;gt; 是 Docker 计算机可执行文件的名称。本教程使用 <bpt id="p4">**</bpt>docker-machine\_linux-amd64<ept id="p4">**</ept>。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>为 docker、计算机和 Azure 创建证书和密钥文件</source>
          <target state="new">为 docker、计算机和 Azure 创建证书和密钥文件</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>现在，你必须创建 Azure 需要用来确认你的身份和权限的证书和密钥文件，以及 <bpt id="p1">**</bpt>docker-machine<ept id="p1">**</ept> 需要用来与 Azure 虚拟机进行通信以远程创建和管理容器的证书和密钥文件。如果你的目录中已有这些文件 - 可能用于 docker - 你可以重复使用它们。但是，测试 <bpt id="p2">**</bpt>docker-machine<ept id="p2">**</ept> 的最佳做法是在一个单独的目录中创建它们，并使 docker-machine 指向它们。</source>
          <target state="new">现在，你必须创建 Azure 需要用来确认你的身份和权限的证书和密钥文件，以及 <bpt id="p1">**</bpt>docker-machine<ept id="p1">**</ept> 需要用来与 Azure 虚拟机进行通信以远程创建和管理容器的证书和密钥文件。如果你的目录中已有这些文件 - 可能用于 docker - 你可以重复使用它们。但是，测试 <bpt id="p2">**</bpt>docker-machine<ept id="p2">**</ept> 的最佳做法是在一个单独的目录中创建它们，并使 docker-machine 指向它们。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 如果你结果是反复试用 <bpt id="p1">**</bpt>docker-machine<ept id="p1">**</ept>，请务必重复使用相同的证书和密钥文件。<bpt id="p2">**</bpt>docker-machine<ept id="p2">**</ept> 也创建一组客户端证书（它创建的所有内容都可以在 <ph id="ph2">`~/.docker/machine`</ph> 中查看）。如果将这些证书移到另一台计算机，你也需要移动 <bpt id="p3">**</bpt>docker-machine<ept id="p3">**</ept> 证书文件夹。如果要在另一个平台上使用 <bpt id="p4">**</bpt>docker-machine<ept id="p4">**</ept>（例如，只为了解其所有工作原理），这会有所不同。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 如果你结果是反复试用 <bpt id="p1">**</bpt>docker-machine<ept id="p1">**</ept>，请务必重复使用相同的证书和密钥文件。<bpt id="p2">**</bpt>docker-machine<ept id="p2">**</ept> 也创建一组客户端证书（它创建的所有内容都可以在 <ph id="ph2">`~/.docker/machine`</ph> 中查看）。如果将这些证书移到另一台计算机，你也需要移动 <bpt id="p3">**</bpt>docker-machine<ept id="p3">**</ept> 证书文件夹。如果要在另一个平台上使用 <bpt id="p4">**</bpt>docker-machine<ept id="p4">**</ept>（例如，只为了解其所有工作原理），这会有所不同。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>如果你有 Linux 分发的经验，则可能已将这些文件提供给特定位置中的计算机使用，<bpt id="p1">[</bpt>Docker HTTPS 文档很好地说明了这些步骤<ept id="p1">](https://docs.docker.com/articles/https/)</ept>。但是，以下是此步骤的最简单形式。</source>
          <target state="new">如果你有 Linux 分发的经验，则可能已将这些文件提供给特定位置中的计算机使用，<bpt id="p1">[</bpt>Docker HTTPS 文档很好地说明了这些步骤<ept id="p1">](https://docs.docker.com/articles/https/)</ept>。但是，以下是此步骤的最简单形式。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>创建一个本地文件夹，并在命令行中导航到该文件夹，然后键入：</source>
          <target state="new">创建一个本地文件夹，并在命令行中导航到该文件夹，然后键入：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>在此处准备好输入你的证书的导出密码并捕获该证书供将来使用。然后键入：</source>
          <target state="new">在此处准备好输入你的证书的导出密码并捕获该证书供将来使用。然后键入：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>将证书的 .cer 文件上载到 Azure。在 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](https://manage.windowsazure.cn)</ept>中，单击服务区域左下角的“设置”（下面显示）</source>
          <target state="new">将证书的 .cer 文件上载到 Azure。在 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](https://manage.windowsazure.cn)</ept>中，单击服务区域左下角的“设置”（下面显示）</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>然后单击<bpt id="p1">**</bpt>“管理证书”<ept id="p1">**</ept>：</source>
          <target state="new">然后单击<bpt id="p1">**</bpt>“管理证书”<ept id="p1">**</ept>：</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>然后单击<bpt id="p1">**</bpt>“上载”<ept id="p1">**</ept>（在页面底部）<ph id="ph1">![][uploaditem]</ph> 以上载在上一步中创建的 <bpt id="p2">**</bpt>mycert.cer<ept id="p2">**</ept> 文件。</source>
          <target state="new">然后单击<bpt id="p1">**</bpt>“上载”<ept id="p1">**</ept>（在页面底部）<ph id="ph1">![][uploaditem]</ph> 以上载在上一步中创建的 <bpt id="p2">**</bpt>mycert.cer<ept id="p2">**</ept> 文件。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>在门户的同一个<bpt id="p1">**</bpt>“设置”<ept id="p1">**</ept>窗格中，单击<bpt id="p2">**</bpt>“订阅”<ept id="p2">**</ept>，并捕获在创建 VM 时要使用的订阅 ID，因为你将在下一步中使用它。（你还可以在命令行上使用 Azure CLI 命令 <ph id="ph1">`azure account list`</ph> 查找订阅 ID，该命令显示你的帐户中拥有的每个订阅的订阅 ID。）</source>
          <target state="new">在门户的同一个<bpt id="p1">**</bpt>“设置”<ept id="p1">**</ept>窗格中，单击<bpt id="p2">**</bpt>“订阅”<ept id="p2">**</ept>，并捕获在创建 VM 时要使用的订阅 ID，因为你将在下一步中使用它。（你还可以在命令行上使用 Azure CLI 命令 <ph id="ph1">`azure account list`</ph> 查找订阅 ID，该命令显示你的帐户中拥有的每个订阅的订阅 ID。）</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>在 Azure 上使用 <bpt id="p1">**</bpt>docker-machine create<ept id="p1">**</ept> 命令创建 docker 宿主 VM。该命令需要你在上一步中刚捕获的订阅 ID 和在步骤 1 中创建的 <bpt id="p2">**</bpt>.pem<ept id="p2">**</ept> 文件的路径。本主题使用“machine-name”作为 Azure 云服务（和你的 VM）名称，但你应将其替换为你自己的选项，并在需要 VM 名称的任何其他步骤中记住使用你的云服务名称。（请记住，在此示例中，我们将使用完整二进制文件名称，而不是 <bpt id="p3">**</bpt>docker-machine<ept id="p3">**</ept> 符号链接。）</source>
          <target state="new">在 Azure 上使用 <bpt id="p1">**</bpt>docker-machine create<ept id="p1">**</ept> 命令创建 docker 宿主 VM。该命令需要你在上一步中刚捕获的订阅 ID 和在步骤 1 中创建的 <bpt id="p2">**</bpt>.pem<ept id="p2">**</ept> 文件的路径。本主题使用“machine-name”作为 Azure 云服务（和你的 VM）名称，但你应将其替换为你自己的选项，并在需要 VM 名称的任何其他步骤中记住使用你的云服务名称。（请记住，在此示例中，我们将使用完整二进制文件名称，而不是 <bpt id="p3">**</bpt>docker-machine<ept id="p3">**</ept> 符号链接。）</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>由于前两个步骤需要创建一个新的 VM 并加载 Linux Azure 代理以及更新新的 VM，你应看到如下内容。</source>
          <target state="new">由于前两个步骤需要创建一个新的 VM 并加载 Linux Azure 代理以及更新新的 VM，你应看到如下内容。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 由于正在创建 VM，它可能需要几分钟才能处于就绪状态。在等待时，你可以通过使用 Azure CLI 键入 <ph id="ph2">`azure vm list`</ph> 来查看新 Docker 主机的状态，直到你看到具有 <bpt id="p1">**</bpt>ReadyRole<ept id="p1">**</ept> 状态的 VM。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 由于正在创建 VM，它可能需要几分钟才能处于就绪状态。在等待时，你可以通过使用 Azure CLI 键入 <ph id="ph2">`azure vm list`</ph> 来查看新 Docker 主机的状态，直到你看到具有 <bpt id="p1">**</bpt>ReadyRole<ept id="p1">**</ept> 状态的 VM。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>为终端会话设置 docker 和计算机环境变量。反馈的最后一行建议你立即运行 <bpt id="p1">**</bpt>env<ept id="p1">**</ept> 命令以导出直接在特定计算机上使用 docker 客户端所必需的环境变量。</source>
          <target state="new">为终端会话设置 docker 和计算机环境变量。反馈的最后一行建议你立即运行 <bpt id="p1">**</bpt>env<ept id="p1">**</ept> 命令以导出直接在特定计算机上使用 docker 客户端所必需的环境变量。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>这么做后，你将不需要任何特殊命令即可使用你的本地 docker 客户端连接到 Docker <bpt id="p1">**</bpt>计算机<ept id="p1">**</ept>创建的 VM。</source>
          <target state="new">这么做后，你将不需要任何特殊命令即可使用你的本地 docker 客户端连接到 Docker <bpt id="p1">**</bpt>计算机<ept id="p1">**</ept>创建的 VM。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 本教程演示创建一个 VM 的 <bpt id="p1">**</bpt>docker-machine<ept id="p1">**</ept>。但是，你可以重复执行这些步骤创建所需的任意数量的虚拟机。如果这样做，则使用 docker 切换 VM 的最佳方式是以内联方式使用 <bpt id="p2">**</bpt>env<ept id="p2">**</ept> 命令，以便为每个单独的命令设置 <bpt id="p3">**</bpt>docker<ept id="p3">**</ept> 环境变量。例如，若要对不同 VM 使用 <bpt id="p4">**</bpt>docker info<ept id="p4">**</ept>，可以键入 <ph id="ph2">`docker $(docker-machine env &lt;VM name&gt;) info`</ph>，<bpt id="p5">**</bpt>env<ept id="p5">**</ept> 命令会填写要用于该 VM 的 docker 连接信息。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 本教程演示创建一个 VM 的 <bpt id="p1">**</bpt>docker-machine<ept id="p1">**</ept>。但是，你可以重复执行这些步骤创建所需的任意数量的虚拟机。如果这样做，则使用 docker 切换 VM 的最佳方式是以内联方式使用 <bpt id="p2">**</bpt>env<ept id="p2">**</ept> 命令，以便为每个单独的命令设置 <bpt id="p3">**</bpt>docker<ept id="p3">**</ept> 环境变量。例如，若要对不同 VM 使用 <bpt id="p4">**</bpt>docker info<ept id="p4">**</ept>，可以键入 <ph id="ph2">`docker $(docker-machine env &lt;VM name&gt;) info`</ph>，<bpt id="p5">**</bpt>env<ept id="p5">**</ept> 命令会填写要用于该 VM 的 docker 连接信息。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>至此已完成。让我们来使用 docker 和 Docker Hub 映像远程运行一些应用程序。</source>
          <target state="new">至此已完成。让我们来使用 docker 和 Docker Hub 映像远程运行一些应用程序。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>现在可以以正常方式使用 docker 在容器中创建应用程序。最容易演示的是 <bpt id="p1">[</bpt>busybox<ept id="p1">](https://registry.hub.docker.com/_/busybox/)</ept>：</source>
          <target state="new">现在可以以正常方式使用 docker 在容器中创建应用程序。最容易演示的是 <bpt id="p1">[</bpt>busybox<ept id="p1">](https://registry.hub.docker.com/_/busybox/)</ept>：</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>但是，你可能想要创建可立即在 Internet 上看到的应用程序，例如 <bpt id="p1">[</bpt>Docker Hub<ept id="p1">](https://registry.hub.docker.com/)</ept> 中的 <bpt id="p2">[</bpt>nginx<ept id="p2">](https://registry.hub.docker.com/_/nginx/)</ept>。</source>
          <target state="new">但是，你可能想要创建可立即在 Internet 上看到的应用程序，例如 <bpt id="p1">[</bpt>Docker Hub<ept id="p1">](https://registry.hub.docker.com/)</ept> 中的 <bpt id="p2">[</bpt>nginx<ept id="p2">](https://registry.hub.docker.com/_/nginx/)</ept>。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 请记住使用 <bpt id="p1">**</bpt>-P<ept id="p1">**</ept> 选项让 <bpt id="p2">**</bpt>docker<ept id="p2">**</ept> 随机将端口分配给该映像，并使用 <bpt id="p3">**</bpt>-d<ept id="p3">**</ept> 以确保该容器在后台继续运行。（如果你忘记，你将启动 nginx，然后它将立即关闭。不要忘记！）</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 请记住使用 <bpt id="p1">**</bpt>-P<ept id="p1">**</ept> 选项让 <bpt id="p2">**</bpt>docker<ept id="p2">**</ept> 随机将端口分配给该映像，并使用 <bpt id="p3">**</bpt>-d<ept id="p3">**</ept> 以确保该容器在后台继续运行。（如果你忘记，你将启动 nginx，然后它将立即关闭。不要忘记！）</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>若要在 Internet 上查看它，请在 Azure VM 的端口 80 上创建公共终结点，并将该端口映射到 nginx 容器的端口。首先，使用 <ph id="ph1">`docker ps -a`</ph> 找到容器，并查找 <bpt id="p1">**</bpt>docker<ept id="p1">**</ept> 已将哪些端口分配给容器的端口 80。（下面显示的信息已编辑为仅显示端口信息；你将看到更多信息。）</source>
          <target state="new">若要在 Internet 上查看它，请在 Azure VM 的端口 80 上创建公共终结点，并将该端口映射到 nginx 容器的端口。首先，使用 <ph id="ph1">`docker ps -a`</ph> 找到容器，并查找 <bpt id="p1">**</bpt>docker<ept id="p1">**</ept> 已将哪些端口分配给容器的端口 80。（下面显示的信息已编辑为仅显示端口信息；你将看到更多信息。）</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>我们可以看到 docker 已将容器的端口 80 分配给 VM 的端口 49153。我们现在可以使用 Azure CLI 将外部云服务的公共端口 80 映射到 VM 上的端口 49153。然后，Docker 将确保将 VM 端口 49153 上的入站 tcp 流量路由到 nginx 容器。</source>
          <target state="new">我们可以看到 docker 已将容器的端口 80 分配给 VM 的端口 49153。我们现在可以使用 Azure CLI 将外部云服务的公共端口 80 映射到 VM 上的端口 49153。然后，Docker 将确保将 VM 端口 49153 上的入站 tcp 流量路由到 nginx 容器。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>打开你最喜欢的浏览器进行查看。</source>
          <target state="new">打开你最喜欢的浏览器进行查看。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>转到 <bpt id="p1">[</bpt>Docker 用户指南<ept id="p1">](https://docs.docker.com/userguide/)</ept>并在 Azure 上创建一些应用程序。或者，在 Azure 上玩 <bpt id="p2">[</bpt><bpt id="p3">**</bpt>docker<ept id="p3">**</ept><ept id="p2">](/documentation/articles/virtual-machines-docker-swarm)</ept> 和 <bpt id="p4">[</bpt>swarm<ept id="p4">](https://github.com/docker/swarm)</ept>，并了解如何将 swarm 用于 docker 和 Azure。</source>
          <target state="new">转到 <bpt id="p1">[</bpt>Docker 用户指南<ept id="p1">](https://docs.docker.com/userguide/)</ept>并在 Azure 上创建一些应用程序。或者，在 Azure 上玩 <bpt id="p2">[</bpt><bpt id="p3">**</bpt>docker<ept id="p3">**</ept><ept id="p2">](/documentation/articles/virtual-machines-docker-swarm)</ept> 和 <bpt id="p4">[</bpt>swarm<ept id="p4">](https://github.com/docker/swarm)</ept>，并了解如何将 swarm 用于 docker 和 Azure。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>