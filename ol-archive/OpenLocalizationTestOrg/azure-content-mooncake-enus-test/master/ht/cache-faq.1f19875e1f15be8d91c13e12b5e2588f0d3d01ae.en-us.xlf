<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6fa479b62c8bd2f21577bcaf3d7609a67a5419bb</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Azure Redis 缓存常见问题</source>
          <target state="new">Azure Redis 缓存常见问题</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解常见问题的答案，以及有关 Azure Redis 缓存的模式和最佳实践</source>
          <target state="new">了解常见问题的答案，以及有关 Azure Redis 缓存的模式和最佳实践</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Azure Redis 缓存常见问题</source>
          <target state="new">Azure Redis 缓存常见问题</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>了解常见问题的答案，以及有关 Azure Redis 缓存的模式和最佳实践。</source>
          <target state="new">了解常见问题的答案，以及有关 Azure Redis 缓存的模式和最佳实践。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>我应使用哪种 Redis 缓存产品和大小？</source>
          <target state="new">我应使用哪种 Redis 缓存产品和大小？</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>每款 Azure Redis 缓存产品在<bpt id="p1">**</bpt>大小<ept id="p1">**</ept>、<bpt id="p2">**</bpt>带宽<ept id="p2">**</ept>、<bpt id="p3">**</bpt>高可能性<ept id="p3">**</ept>和 <bpt id="p4">**</bpt>SLA<ept id="p4">**</ept> 方面提供不同的级别。</source>
          <target state="new">每款 Azure Redis 缓存产品在<bpt id="p1">**</bpt>大小<ept id="p1">**</ept>、<bpt id="p2">**</bpt>带宽<ept id="p2">**</ept>、<bpt id="p3">**</bpt>高可能性<ept id="p3">**</ept>和 <bpt id="p4">**</bpt>SLA<ept id="p4">**</ept> 方面提供不同的级别。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>以下是选择缓存产品的注意事项。</source>
          <target state="new">以下是选择缓存产品的注意事项。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>内存<ept id="p1">**</ept>：基本级别和标准级别提供 250 MB - 53 GB。高级级别提供高达 530 GB 的内存。有关详细信息，请参阅 <bpt id="p2">[</bpt>Azure Redis 缓存定价<ept id="p2">](/home/features/redis-cache/#price)</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>内存<ept id="p1">**</ept>：基本级别和标准级别提供 250 MB - 53 GB。高级级别提供高达 530 GB 的内存。有关详细信息，请参阅 <bpt id="p2">[</bpt>Azure Redis 缓存定价<ept id="p2">](/home/features/redis-cache/#price)</ept>。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>网络性能<ept id="p1">**</ept>：如果你的工作负荷需要高的吞吐量，则可使用高级级别，该级别提供比标准级别或基本级别更高的带宽。另外，在每个级别中，缓存大小越大，带宽越高，因为是由基础 VM 托管缓存。有关详细信息，请参阅<bpt id="p2">[</bpt>下表<ept id="p2">](#cache-performance)</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>网络性能<ept id="p1">**</ept>：如果你的工作负荷需要高的吞吐量，则可使用高级级别，该级别提供比标准级别或基本级别更高的带宽。另外，在每个级别中，缓存大小越大，带宽越高，因为是由基础 VM 托管缓存。有关详细信息，请参阅<bpt id="p2">[</bpt>下表<ept id="p2">](#cache-performance)</ept>。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>吞吐量<ept id="p1">**</ept>：高级级别提供的可用吞吐量最大。如果缓存服务器或客户端达到带宽限制，客户端上会出现超时。有关详细信息，请参阅下表。</source>
          <target state="new"><bpt id="p1">**</bpt>吞吐量<ept id="p1">**</ept>：高级级别提供的可用吞吐量最大。如果缓存服务器或客户端达到带宽限制，客户端上会出现超时。有关详细信息，请参阅下表。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>高可用性/SLA<ept id="p1">**</ept>：Azure Redis 缓存保证标准/高级缓存在至少 99.9% 的时间内都可用。若要了解有关 SLA 的详细信息，请参阅 <bpt id="p2">[</bpt>Azure Redis 缓存定价<ept id="p2">](/home/features/redis-cache/#price)</ept>。SLA 仅涉及与缓存终结点的连接。SLA 不涉及对数据丢失的防护。我们建议使用高级级别中的 Redis 数据暂留功能来增加灵活性，防止数据丢失。</source>
          <target state="new"><bpt id="p1">**</bpt>高可用性/SLA<ept id="p1">**</ept>：Azure Redis 缓存保证标准/高级缓存在至少 99.9% 的时间内都可用。若要了解有关 SLA 的详细信息，请参阅 <bpt id="p2">[</bpt>Azure Redis 缓存定价<ept id="p2">](/home/features/redis-cache/#price)</ept>。SLA 仅涉及与缓存终结点的连接。SLA 不涉及对数据丢失的防护。我们建议使用高级级别中的 Redis 数据暂留功能来增加灵活性，防止数据丢失。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Redis 数据持久性<ept id="p1">**</ept>：高级级别允许你将缓存数据暂留在 Azure 存储帐户中。在基本/标准缓存中，所有数据只存储在内存中。如果底层基础结构出现问题，可能会导致数据丢失。我们建议使用高级级别中的 Redis 数据暂留功能来增加灵活性，防止数据丢失。Azure Redis 缓存提供可在 Redis 暂留中使用的 RDB 和 AOF（即将推出）选项。有关详细信息，请参阅<bpt id="p2">[</bpt>如何为高级 Azure Redis 缓存配置持久性<ept id="p2">](/documentation/articles/cache-how-to-premium-persistence)</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>Redis 数据持久性<ept id="p1">**</ept>：高级级别允许你将缓存数据暂留在 Azure 存储帐户中。在基本/标准缓存中，所有数据只存储在内存中。如果底层基础结构出现问题，可能会导致数据丢失。我们建议使用高级级别中的 Redis 数据暂留功能来增加灵活性，防止数据丢失。Azure Redis 缓存提供可在 Redis 暂留中使用的 RDB 和 AOF（即将推出）选项。有关详细信息，请参阅<bpt id="p2">[</bpt>如何为高级 Azure Redis 缓存配置持久性<ept id="p2">](/documentation/articles/cache-how-to-premium-persistence)</ept>。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Redis 群集<ept id="p1">**</ept>：如果你想要创建大于 53 GB 的缓存，或者想要将数据通过分片的方式分散到多个 Redis 节点中，则可以使用在高级级别中提供的 Redis 群集功能。每个节点都包含一个主/副缓存对，目的是提高可用性。有关详细信息，请参阅<bpt id="p2">[</bpt>如何为高级 Azure Redis 缓存配置群集功能<ept id="p2">](/documentation/articles/cache-how-to-premium-clustering)</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>Redis 群集<ept id="p1">**</ept>：如果你想要创建大于 53 GB 的缓存，或者想要将数据通过分片的方式分散到多个 Redis 节点中，则可以使用在高级级别中提供的 Redis 群集功能。每个节点都包含一个主/副缓存对，目的是提高可用性。有关详细信息，请参阅<bpt id="p2">[</bpt>如何为高级 Azure Redis 缓存配置群集功能<ept id="p2">](/documentation/articles/cache-how-to-premium-clustering)</ept>。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>增强的安全性和独立性<ept id="p1">**</ept>：Azure 虚拟网络 (VNET) 部署为 Azure Redis 缓存提供增强的安全性和隔离性，并提供子网、访问控制策略和进一步限制访问的其他功能。有关详细信息，请参阅<bpt id="p2">[</bpt>如何为高级 Azure Redis 缓存配置虚拟网络支持<ept id="p2">](/documentation/articles/cache-how-to-premium-vnet)</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>增强的安全性和独立性<ept id="p1">**</ept>：Azure 虚拟网络 (VNET) 部署为 Azure Redis 缓存提供增强的安全性和隔离性，并提供子网、访问控制策略和进一步限制访问的其他功能。有关详细信息，请参阅<bpt id="p2">[</bpt>如何为高级 Azure Redis 缓存配置虚拟网络支持<ept id="p2">](/documentation/articles/cache-how-to-premium-vnet)</ept>。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>配置 Redis<ept id="p1">**</ept>：在标准级别和高级级别，你都可以针对 Keyspace 通知来配置 Redis。</source>
          <target state="new"><bpt id="p1">**</bpt>配置 Redis<ept id="p1">**</ept>：在标准级别和高级级别，你都可以针对 Keyspace 通知来配置 Redis。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>客户端连接的最大数量<ept id="p1">**</ept>：高级级别提供的可以连接到 Redis 的客户端数量是最大的，缓存大小越大，连接数量越大。<bpt id="p2">[</bpt>有关详细信息，请参阅定价页<ept id="p2">](/home/features/redis-cache/#price)</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>客户端连接的最大数量<ept id="p1">**</ept>：高级级别提供的可以连接到 Redis 的客户端数量是最大的，缓存大小越大，连接数量越大。<bpt id="p2">[</bpt>有关详细信息，请参阅定价页<ept id="p2">](/home/features/redis-cache/#price)</ept>。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>专用 Redis 服务器核心<ept id="p1">**</ept>：高级级别的所有缓存大小都有针对 Redis 的专用核心。在基本级别/标准级别，C1 大小及以上有针对 Redis 服务器的专用核心。</source>
          <target state="new"><bpt id="p1">**</bpt>专用 Redis 服务器核心<ept id="p1">**</ept>：高级级别的所有缓存大小都有针对 Redis 的专用核心。在基本级别/标准级别，C1 大小及以上有针对 Redis 服务器的专用核心。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Redis 是单线程的<ept id="p1">**</ept>，因此与仅使用两个内核相比，使用两个以上的内核并没有额外的优势，但大型 VM 通常提供比小型 VM 更高的带宽。如果缓存服务器或客户端达到带宽限制，客户端上会出现超时。</source>
          <target state="new"><bpt id="p1">**</bpt>Redis 是单线程的<ept id="p1">**</ept>，因此与仅使用两个内核相比，使用两个以上的内核并没有额外的优势，但大型 VM 通常提供比小型 VM 更高的带宽。如果缓存服务器或客户端达到带宽限制，客户端上会出现超时。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>性能改进<ept id="p1">**</ept>：相对于基本级别或标准级别，高级级别的缓存部署在处理器速度更快且性能更高的硬件上。高级级别缓存的吞吐量更高，延迟更低。</source>
          <target state="new"><bpt id="p1">**</bpt>性能改进<ept id="p1">**</ept>：相对于基本级别或标准级别，高级级别的缓存部署在处理器速度更快且性能更高的硬件上。高级级别缓存的吞吐量更高，延迟更低。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="cache-performance"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>下表显示了在 Iaas VM 中使用 <ph id="ph3">`redis-benchmark.exe`</ph> 针对 Azure Redis 缓存终结点测试各种大小的标准缓存和高级缓存时，所观测到的最大带宽值。请注意，这些值是没有保证的，并且我们不针对这些数字提供 SLA，但它们反映了典型的情况。你应该对自己的应用程序进行负载测试，以确定适合应用程序的缓存大小。</source>
          <target state="new"><ph id="ph1">&lt;a name="cache-performance"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>下表显示了在 Iaas VM 中使用 <ph id="ph3">`redis-benchmark.exe`</ph> 针对 Azure Redis 缓存终结点测试各种大小的标准缓存和高级缓存时，所观测到的最大带宽值。请注意，这些值是没有保证的，并且我们不针对这些数字提供 SLA，但它们反映了典型的情况。你应该对自己的应用程序进行负载测试，以确定适合应用程序的缓存大小。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>我们可以从此表得出以下结论。</source>
          <target state="new">我们可以从此表得出以下结论。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>如果缓存大小相同，则高级级别中的吞吐量高于标准级别。例如，就 6 GB 缓存来说，P1 的吞吐量为 140K RPS，而 C3 的吞吐量为 49K。</source>
          <target state="new">如果缓存大小相同，则高级级别中的吞吐量高于标准级别。例如，就 6 GB 缓存来说，P1 的吞吐量为 140K RPS，而 C3 的吞吐量为 49K。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>启用 Redis 群集功能时，增加群集中分片（节点）的数量会导致吞吐量线性提高。例如，如果你创建了一个包含 10 个分片的 P4 群集，则可用吞吐量为 250K *10 = 2.5 百万 RPS</source>
          <target state="new">启用 Redis 群集功能时，增加群集中分片（节点）的数量会导致吞吐量线性提高。例如，如果你创建了一个包含 10 个分片的 P4 群集，则可用吞吐量为 250K *10 = 2.5 百万 RPS</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>如果增加密钥大小，则高级级别的吞吐量要高于标准级别。</source>
          <target state="new">如果增加密钥大小，则高级级别的吞吐量要高于标准级别。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>定价层</source>
          <target state="new">定价层</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>大小</source>
          <target state="new">大小</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>可用带宽</source>
          <target state="new">可用带宽</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>1 KB 密钥大小</source>
          <target state="new">1 KB 密钥大小</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>标准缓存大小</source>
          <target state="new">标准缓存大小</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;</source>
          <target state="new">&amp;nbsp;</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>每秒兆位 (Mbps)</source>
          <target state="new">每秒兆位 (Mbps)</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>每秒请求数 (RPS)</source>
          <target state="new">每秒请求数 (RPS)</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>C0</source>
          <target state="new">C0</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>250 MB</source>
          <target state="new">250 MB</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="new">5</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>600</source>
          <target state="new">600</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>C1</source>
          <target state="new">C1</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>1 GB</source>
          <target state="new">1 GB</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>100</source>
          <target state="new">100</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>12200</source>
          <target state="new">12200</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>C2</source>
          <target state="new">C2</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>2\.5 GB</source>
          <target state="new">2\.5 GB</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>200</source>
          <target state="new">200</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>24000</source>
          <target state="new">24000</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>C3</source>
          <target state="new">C3</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>6 GB</source>
          <target state="new">6 GB</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>400</source>
          <target state="new">400</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>49000</source>
          <target state="new">49000</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>C4</source>
          <target state="new">C4</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>13 GB</source>
          <target state="new">13 GB</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>500</source>
          <target state="new">500</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>61000</source>
          <target state="new">61000</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>C5</source>
          <target state="new">C5</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>26 GB</source>
          <target state="new">26 GB</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>1000</source>
          <target state="new">1000</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>115000</source>
          <target state="new">115000</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>C6</source>
          <target state="new">C6</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>53 GB</source>
          <target state="new">53 GB</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>2000</source>
          <target state="new">2000</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>150000</source>
          <target state="new">150000</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>高级缓存大小</source>
          <target state="new">高级缓存大小</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;</source>
          <target state="new">&amp;nbsp;</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;</source>
          <target state="new">&amp;nbsp;</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>每分片每秒请求数 (RPS)</source>
          <target state="new">每分片每秒请求数 (RPS)</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>P1</source>
          <target state="new">P1</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>6 GB</source>
          <target state="new">6 GB</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>1000</source>
          <target state="new">1000</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>140000</source>
          <target state="new">140000</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>P2</source>
          <target state="new">P2</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>13 GB</source>
          <target state="new">13 GB</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>2000</source>
          <target state="new">2000</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>220000</source>
          <target state="new">220000</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>P3</source>
          <target state="new">P3</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>26 GB</source>
          <target state="new">26 GB</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>2000</source>
          <target state="new">2000</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>220000</source>
          <target state="new">220000</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>P4</source>
          <target state="new">P4</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>53 GB</source>
          <target state="new">53 GB</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>4000</source>
          <target state="new">4000</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>250000</source>
          <target state="new">250000</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>有关下载 Redis 工具（例如 <ph id="ph1">`redis-benchmark.exe`</ph>）的说明，请参阅<bpt id="p1">[</bpt>如何运行 Redis 命令？<ept id="p1">](#cache-commands)</ept>部分。</source>
          <target state="new">有关下载 Redis 工具（例如 <ph id="ph1">`redis-benchmark.exe`</ph>）的说明，请参阅<bpt id="p1">[</bpt>如何运行 Redis 命令？<ept id="p1">](#cache-commands)</ept>部分。</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>我应该将缓存放在哪个区域？</source>
          <target state="new">我应该将缓存放在哪个区域？</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>为了获得最佳性能并最大程度地降低延迟，请在缓存客户端应用程序所在的区域放置 Azure Redis 缓存。</source>
          <target state="new">为了获得最佳性能并最大程度地降低延迟，请在缓存客户端应用程序所在的区域放置 Azure Redis 缓存。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Azure Redis 缓存如何计费？</source>
          <target state="new">Azure Redis 缓存如何计费？</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>此处<ept id="p1">](/home/features/redis-cache/#price)</ept>提供了 Azure Redis 缓存定价。定价页列出了每小时费率。缓存按分钟计费，从创建缓存时开始，到删除缓存时为止。没有提供用于停止或暂停缓存的计费选项。</source>
          <target state="new"><bpt id="p1">[</bpt>此处<ept id="p1">](/home/features/redis-cache/#price)</ept>提供了 Azure Redis 缓存定价。定价页列出了每小时费率。缓存按分钟计费，从创建缓存时开始，到删除缓存时为止。没有提供用于停止或暂停缓存的计费选项。</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>为何会出现超时？</source>
          <target state="new">为何会出现超时？</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>超时发生在用来与 Redis 通信的客户端中。大多数情况下，Redis 服务器不会超时。将某个命令发送到 Redis 服务器后，该命令将会排队，Redis 服务器最终会提取该命令并执行它。但是，客户端在此过程中可能会超时，在这种情况下，会在调用端引发异常。有关排查超时问题的详细信息，请参阅<bpt id="p1">[</bpt>调查 Azure Redis 缓存的 StackExchange.Redis 超时异常<ept id="p1">](http://azure.microsoft.com/blog/2015/02/10/investigating-timeout-exceptions-in-stackexchange-redis-for-azure-redis-cache/)</ept>。</source>
          <target state="new">超时发生在用来与 Redis 通信的客户端中。大多数情况下，Redis 服务器不会超时。将某个命令发送到 Redis 服务器后，该命令将会排队，Redis 服务器最终会提取该命令并执行它。但是，客户端在此过程中可能会超时，在这种情况下，会在调用端引发异常。有关排查超时问题的详细信息，请参阅<bpt id="p1">[</bpt>调查 Azure Redis 缓存的 StackExchange.Redis 超时异常<ept id="p1">](http://azure.microsoft.com/blog/2015/02/10/investigating-timeout-exceptions-in-stackexchange-redis-for-azure-redis-cache/)</ept>。</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>如何监视缓存的运行状况和性能？</source>
          <target state="new">如何监视缓存的运行状况和性能？</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>目前，Azure 中国区仅支持使用 Azure PowerShell 和 Azure CLI 管理 Redis 缓存。因此，你无法以图形方式监视缓存。</source>
          <target state="new">目前，Azure 中国区仅支持使用 Azure PowerShell 和 Azure CLI 管理 Redis 缓存。因此，你无法以图形方式监视缓存。</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>客户端为何与缓存断开连接？</source>
          <target state="new">客户端为何与缓存断开连接？</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>下面是缓存断开连接的一些常见原因。</source>
          <target state="new">下面是缓存断开连接的一些常见原因。</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>客户端的原因</source>
          <target state="new">客户端的原因</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>已重新部署客户端应用程序。</source>
          <target state="new">已重新部署客户端应用程序。</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>客户端应用程序执行了缩放操作。</source>
          <target state="new">客户端应用程序执行了缩放操作。</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>对于云服务或 Web 应用，原因可能在于自动缩放。</source>
          <target state="new">对于云服务或 Web 应用，原因可能在于自动缩放。</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>客户端上的网络层已更改。</source>
          <target state="new">客户端上的网络层已更改。</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>客户端中或客户端与服务器之间的网络节点中发生暂时性错误。</source>
          <target state="new">客户端中或客户端与服务器之间的网络节点中发生暂时性错误。</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>已达到带宽阈值限制。</source>
          <target state="new">已达到带宽阈值限制。</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>占用大量 CPU 的操作花费了太长时间才完成。</source>
          <target state="new">占用大量 CPU 的操作花费了太长时间才完成。</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>服务器端的原因</source>
          <target state="new">服务器端的原因</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>在标准缓存产品上，Azure Redis 缓存服务启动了从主节点到辅助节点的故障转移。</source>
          <target state="new">在标准缓存产品上，Azure Redis 缓存服务启动了从主节点到辅助节点的故障转移。</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Azure 正在修补已部署缓存的实例</source>
          <target state="new">Azure 正在修补已部署缓存的实例</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>原因可能是 Redis 服务器更新或常规 VM 维护。</source>
          <target state="new">原因可能是 Redis 服务器更新或常规 VM 维护。</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>StackExchange.Redis 配置选项有什么作用？</source>
          <target state="new">StackExchange.Redis 配置选项有什么作用？</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>StackExchange.Redis 有很多选项。本部分将介绍一些常用设置。有关 StackExchange.Redis 选项的详细详细，请参阅 <bpt id="p1">[</bpt>StackExchange.Redis 配置<ept id="p1">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Configuration.md)</ept>。</source>
          <target state="new">StackExchange.Redis 有很多选项。本部分将介绍一些常用设置。有关 StackExchange.Redis 选项的详细详细，请参阅 <bpt id="p1">[</bpt>StackExchange.Redis 配置<ept id="p1">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Configuration.md)</ept>。</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>配置选项</source>
          <target state="new">配置选项</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>说明</source>
          <target state="new">说明</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>建议</source>
          <target state="new">建议</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>AbortOnConnectFail</source>
          <target state="new">AbortOnConnectFail</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>如果设置为 true，则发生网络故障后不会重新建立连接。</source>
          <target state="new">如果设置为 true，则发生网络故障后不会重新建立连接。</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>设置为 false，让 StackExchange.Redis 自动重新连接。</source>
          <target state="new">设置为 false，让 StackExchange.Redis 自动重新连接。</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>ConnectRetry</source>
          <target state="new">ConnectRetry</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>初始连接期间重试连接的次数。</source>
          <target state="new">初始连接期间重试连接的次数。</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>ConnectTimeout</source>
          <target state="new">ConnectTimeout</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>连接操作的超时，以毫秒为单位。</source>
          <target state="new">连接操作的超时，以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>在大多数情况下，使用客户端的默认值便已足够。你可以根据工作负载微调选项。</source>
          <target state="new">在大多数情况下，使用客户端的默认值便已足够。你可以根据工作负载微调选项。</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>重试</source>
          <target state="new">重试</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>对于 ConnectRetry 和 ConnectTimeout，一般指导原则是快速失败并重试。这取决于工作负载，以及客户端发出 Redis 命令和接收响应平均花费的时间。</source>
          <target state="new">对于 ConnectRetry 和 ConnectTimeout，一般指导原则是快速失败并重试。这取决于工作负载，以及客户端发出 Redis 命令和接收响应平均花费的时间。</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>让 StackExchange.Redis 自动重新连接，而不是检查连接状态，然后由你自己重新连接。<bpt id="p1">**</bpt>避免使用 ConnectionMultiplexer.IsConnected 属性<ept id="p1">**</ept>。</source>
          <target state="new">让 StackExchange.Redis 自动重新连接，而不是检查连接状态，然后由你自己重新连接。<bpt id="p1">**</bpt>避免使用 ConnectionMultiplexer.IsConnected 属性<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>雪球效应 - 有时，你可能会遇到这样的问题：不断地重试解决，但问题不断累积而永远无法恢复。在这种情况下，你应该根据 WindowsAzure.cn 模式和实践小组发布的<bpt id="p1">[</bpt>一般重试指导原则<ept id="p1">](https://github.com/mspnp/azure-guidance/blob/master/Retry-General.md)</ept>中所述，考虑使用指数退让重试算法。</source>
          <target state="new">雪球效应 - 有时，你可能会遇到这样的问题：不断地重试解决，但问题不断累积而永远无法恢复。在这种情况下，你应该根据 WindowsAzure.cn 模式和实践小组发布的<bpt id="p1">[</bpt>一般重试指导原则<ept id="p1">](https://github.com/mspnp/azure-guidance/blob/master/Retry-General.md)</ept>中所述，考虑使用指数退让重试算法。</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>超时值</source>
          <target state="new">超时值</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>根据工作负载相应地设置值。如果要存储较大值，应将超时设置为较大值。</source>
          <target state="new">根据工作负载相应地设置值。如果要存储较大值，应将超时设置为较大值。</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>将 ABortOnConnectFail 设置为 false，让 StackExchange.Redis 为你重新连接。</source>
          <target state="new">将 ABortOnConnectFail 设置为 false，让 StackExchange.Redis 为你重新连接。</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>使用应用程序的单个 ConnectionMultiplexer 实例。可以使用 LazyConnection 创建 Connection 属性返回的单个实例，如<bpt id="p1">[</bpt>使用 ConnectionMultiplexer 类连接到缓存<ept id="p1">](/documentation/articles/cache-dotnet-how-to-use-azure-redis-cache/#working-with-caches)</ept>中所示。</source>
          <target state="new">使用应用程序的单个 ConnectionMultiplexer 实例。可以使用 LazyConnection 创建 Connection 属性返回的单个实例，如<bpt id="p1">[</bpt>使用 ConnectionMultiplexer 类连接到缓存<ept id="p1">](/documentation/articles/cache-dotnet-how-to-use-azure-redis-cache/#working-with-caches)</ept>中所示。</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>将 <ph id="ph1">`ConnectionMultiplexer.ClientName`</ph> 属性设置为应用程序实例的唯一名称以进行诊断。</source>
          <target state="new">将 <ph id="ph1">`ConnectionMultiplexer.ClientName`</ph> 属性设置为应用程序实例的唯一名称以进行诊断。</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>对自定义工作负载使用多个 <ph id="ph1">`ConnectionMultiplexer`</ph> 实例。</source>
          <target state="new">对自定义工作负载使用多个 <ph id="ph1">`ConnectionMultiplexer`</ph> 实例。</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>如果应用程序中的负载不同，你可以遵循此模型。例如：</source>
          <target state="new">如果应用程序中的负载不同，你可以遵循此模型。例如：</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>可以使用一个多路复用器来处理大键。</source>
          <target state="new">可以使用一个多路复用器来处理大键。</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>可以使用一个多路复用器来处理小键。</source>
          <target state="new">可以使用一个多路复用器来处理小键。</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>可为连接超时设置不同的值，并为使用的每个 ConnectionMultiplexer 设置重试逻辑。</source>
          <target state="new">可为连接超时设置不同的值，并为使用的每个 ConnectionMultiplexer 设置重试逻辑。</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>在每个多路复用器上设置 <ph id="ph1">`ClientName`</ph> 属性以帮助进行诊断。</source>
          <target state="new">在每个多路复用器上设置 <ph id="ph1">`ClientName`</ph> 属性以帮助进行诊断。</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>这可以更好地改进每个 <ph id="ph1">`ConnectionMultiplexer`</ph> 的延迟。</source>
          <target state="new">这可以更好地改进每个 <ph id="ph1">`ConnectionMultiplexer`</ph> 的延迟。</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>使用常见 Redis 命令时要注意哪些问题？</source>
          <target state="new">使用常见 Redis 命令时要注意哪些问题？</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>对于某些需要较长时间才能完成的 Redis 命令，在未了解这些命令造成的影响的情况下，你不应运行这些命令。</source>
          <target state="new">对于某些需要较长时间才能完成的 Redis 命令，在未了解这些命令造成的影响的情况下，你不应运行这些命令。</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>例如，不要在生产环境中运行 <bpt id="p1">[</bpt>KEYS<ept id="p1">](http://redis.io/commands/keys)</ept> 命令，因为它可能需要很长时间才能返回，具体时间取决于键数。Redis 是单线程服务器，每次只能处理一个命令。如果在 KEYS 后面发出了其他命令，则这些命令只会在处理完 KEYS 命令后才会得到处理。</source>
          <target state="new">例如，不要在生产环境中运行 <bpt id="p1">[</bpt>KEYS<ept id="p1">](http://redis.io/commands/keys)</ept> 命令，因为它可能需要很长时间才能返回，具体时间取决于键数。Redis 是单线程服务器，每次只能处理一个命令。如果在 KEYS 后面发出了其他命令，则这些命令只会在处理完 KEYS 命令后才会得到处理。</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>键大小 - 应使用小键/值还是大键/值？ 通常这取决于方案。如果你的方案需要较大的键，则你可以调整 ConnectionTimeout 和重试值，并调整重试逻辑。从 Redis 服务器的角度来看，值越小，性能就越好。</source>
          <target state="new">键大小 - 应使用小键/值还是大键/值？ 通常这取决于方案。如果你的方案需要较大的键，则你可以调整 ConnectionTimeout 和重试值，并调整重试逻辑。从 Redis 服务器的角度来看，值越小，性能就越好。</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>但这并不意味着你不能 Redis 中存储较大值，只是要注意以下事项。延迟将会提高。如果你有一个较大的数据集和一个较小的数据集，则可以使用多个 ConnectionMultiplexer 实例，并根据<bpt id="p1">[</bpt>StackExchange.Redis 配置选项有什么作用<ept id="p1">](#cache-configuration)</ept>部分中所述，为每个实例配置一组不同的超时和重试值。</source>
          <target state="new">但这并不意味着你不能 Redis 中存储较大值，只是要注意以下事项。延迟将会提高。如果你有一个较大的数据集和一个较小的数据集，则可以使用多个 ConnectionMultiplexer 实例，并根据<bpt id="p1">[</bpt>StackExchange.Redis 配置选项有什么作用<ept id="p1">](#cache-configuration)</ept>部分中所述，为每个实例配置一组不同的超时和重试值。</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>何时应启用非 SSL 端口来连接 Redis？</source>
          <target state="new">何时应启用非 SSL 端口来连接 Redis？</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Redis 服务器不能现成地支持 SSL，但 Azure Redis 缓存可提供此支持。如果你要连接到 Azure Redis 缓存并且客户端支持 SSL（如 StackExchange.Redis），则你应使用 SSL。</source>
          <target state="new">Redis 服务器不能现成地支持 SSL，但 Azure Redis 缓存可提供此支持。如果你要连接到 Azure Redis 缓存并且客户端支持 SSL（如 StackExchange.Redis），则你应使用 SSL。</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>请注意，默认情况下，为新的 Azure Redis 缓存实例禁用了非 SSL 端口。如果客户端不支持 SSL，则你必须启用非 SSL 端口。</source>
          <target state="new">请注意，默认情况下，为新的 Azure Redis 缓存实例禁用了非 SSL 端口。如果客户端不支持 SSL，则你必须启用非 SSL 端口。</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`redis-cli`</ph> 等 Redis 工具对 SSL 端口不起作用，但是，你可以根据<bpt id="p1">[</bpt>适用于 Redis 预览版的 ASP.NET 会话状态提供程序通告<ept id="p1">](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx)</ept>中的说明，使用 <ph id="ph2">`stunnel`</ph> 等实用程序安全地将这些工具连接到 SSL。</source>
          <target state="new"><ph id="ph1">`redis-cli`</ph> 等 Redis 工具对 SSL 端口不起作用，但是，你可以根据<bpt id="p1">[</bpt>适用于 Redis 预览版的 ASP.NET 会话状态提供程序通告<ept id="p1">](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx)</ept>中的说明，使用 <ph id="ph2">`stunnel`</ph> 等实用程序安全地将这些工具连接到 SSL。</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>有关下载 Redis 工具的说明，请参阅<bpt id="p1">[</bpt>如何运行 Redis 命令？<ept id="p1">](#cache-commands)</ept>部分。</source>
          <target state="new">有关下载 Redis 工具的说明，请参阅<bpt id="p1">[</bpt>如何运行 Redis 命令？<ept id="p1">](#cache-commands)</ept>部分。</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>如何制定基准和测试缓存的性能？</source>
          <target state="new">如何制定基准和测试缓存的性能？</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>你还可以使用所选的工具<bpt id="p1">[</bpt>下载和查看<ept id="p1">](https://github.com/rustd/RedisSamples/tree/master/CustomMonitoring)</ept>这些度量值。</source>
          <target state="new">你还可以使用所选的工具<bpt id="p1">[</bpt>下载和查看<ept id="p1">](https://github.com/rustd/RedisSamples/tree/master/CustomMonitoring)</ept>这些度量值。</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>可以使用 redis-benchmark.exe 对 Redis 服务器进行负载测试。</source>
          <target state="new">可以使用 redis-benchmark.exe 对 Redis 服务器进行负载测试。</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>确保负载测试客户端和 Redis 缓存位于同一区域。</source>
          <target state="new">确保负载测试客户端和 Redis 缓存位于同一区域。</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>使用 redis-cli.exe，并使用 INFO 命令监视缓存。</source>
          <target state="new">使用 redis-cli.exe，并使用 INFO 命令监视缓存。</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>如果你的负载导致出现大量内存碎片，则你应该扩展为更大的缓存大小。</source>
          <target state="new">如果你的负载导致出现大量内存碎片，则你应该扩展为更大的缓存大小。</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>有关下载 Redis 工具的说明，请参阅<bpt id="p1">[</bpt>如何运行 Redis 命令？<ept id="p1">](#cache-commands)</ept>部分。</source>
          <target state="new">有关下载 Redis 工具的说明，请参阅<bpt id="p1">[</bpt>如何运行 Redis 命令？<ept id="p1">](#cache-commands)</ept>部分。</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>如何运行 Redis 命令？</source>
          <target state="new">如何运行 Redis 命令？</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>你可以使用 <bpt id="p1">[</bpt>Redis 命令<ept id="p1">](http://redis.io/commands#)</ept>中列出的任何命令。可以配合多个选项来运行 Redis 命令。</source>
          <target state="new">你可以使用 <bpt id="p1">[</bpt>Redis 命令<ept id="p1">](http://redis.io/commands#)</ept>中列出的任何命令。可以配合多个选项来运行 Redis 命令。</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>你可以使用 Redis 命令行工具。若要使用这些选项，请执行以下步骤。</source>
          <target state="new">你可以使用 Redis 命令行工具。若要使用这些选项，请执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>下载 <bpt id="p1">[</bpt>Redis 命令行工具<ept id="p1">](https://github.com/MSOpenTech/redis/releases/download/win-2.8.19.1/redis-2.8.19.zip)</ept>。</source>
          <target state="new">下载 <bpt id="p1">[</bpt>Redis 命令行工具<ept id="p1">](https://github.com/MSOpenTech/redis/releases/download/win-2.8.19.1/redis-2.8.19.zip)</ept>。</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>使用 <ph id="ph1">`redis-cli.exe`</ph> 连接到缓存。使用 -h 开关传入缓存终结点，如以下示例中所示使用 -a 传入键。</source>
          <target state="new">使用 <ph id="ph1">`redis-cli.exe`</ph> 连接到缓存。使用 -h 开关传入缓存终结点，如以下示例中所示使用 -a 传入键。</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>请注意，Redis 命令行工具对 SSL 端口不起作用，但是，你可以根据<bpt id="p1">[</bpt>适用于 Redis 预览版的 ASP.NET 会话状态提供程序通告<ept id="p1">](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx)</ept>中的说明，使用 <ph id="ph1">`stunnel`</ph> 等实用程序安全地将这些工具连接到 SSL。</source>
          <target state="new">请注意，Redis 命令行工具对 SSL 端口不起作用，但是，你可以根据<bpt id="p1">[</bpt>适用于 Redis 预览版的 ASP.NET 会话状态提供程序通告<ept id="p1">](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx)</ept>中的说明，使用 <ph id="ph1">`stunnel`</ph> 等实用程序安全地将这些工具连接到 SSL。</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>常见的缓存模式和注意事项有哪些？</source>
          <target state="new">常见的缓存模式和注意事项有哪些？</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>WindowsAzure.cn 模式和实践小组制定了以下指导原则。</source>
          <target state="new">WindowsAzure.cn 模式和实践小组制定了以下指导原则。</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>缓存指导原则<ept id="p1">](https://github.com/mspnp/azure-guidance/blob/master/Caching.md)</ept>。</source>
          <target state="new"><bpt id="p1">[</bpt>缓存指导原则<ept id="p1">](https://github.com/mspnp/azure-guidance/blob/master/Caching.md)</ept>。</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Azure 云应用程序设计和实施指导原则</source>
          <target state="new">Azure 云应用程序设计和实施指导原则</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>使用 Azure Redis 缓存的常见缓存模式</source>
          <target state="new">使用 Azure Redis 缓存的常见缓存模式</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Azure Redis 缓存为何不像某些其他 Azure 服务一样提供 MSDN 类库参考？</source>
          <target state="new">Azure Redis 缓存为何不像某些其他 Azure 服务一样提供 MSDN 类库参考？</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Azure Redis 缓存基于主流开源 Redis 缓存，让你能够访问由 WindowsAzure.cn 管理的安全专用 Redis 缓存。我们针对许多编程语言提供各种 <bpt id="p1">[</bpt>Redis 客户端<ept id="p1">](http://redis.io/clients)</ept>。每个客户端有自身的 API，用于通过 <bpt id="p2">[</bpt>Redis 命令<ept id="p2">](http://redis.io/commands)</ept>调用 Redis 缓存实例。</source>
          <target state="new">Azure Redis 缓存基于主流开源 Redis 缓存，让你能够访问由 WindowsAzure.cn 管理的安全专用 Redis 缓存。我们针对许多编程语言提供各种 <bpt id="p1">[</bpt>Redis 客户端<ept id="p1">](http://redis.io/clients)</ept>。每个客户端有自身的 API，用于通过 <bpt id="p2">[</bpt>Redis 命令<ept id="p2">](http://redis.io/commands)</ept>调用 Redis 缓存实例。</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>由于客户端各不相同，因此 MSDN 上未提供统一的类参考；而是每个客户端都在维护其自身的参考文档。除了参考文档以外，Azure.com 的 <bpt id="p1">[</bpt>Redis 缓存文档<ept id="p1">](/documentation/services/redis-cache/)</ept>页上提供了许多教程，说明如何使用不同的语言和缓存客户端开始使用 Azure Redis 缓存。</source>
          <target state="new">由于客户端各不相同，因此 MSDN 上未提供统一的类参考；而是每个客户端都在维护其自身的参考文档。除了参考文档以外，Azure.com 的 <bpt id="p1">[</bpt>Redis 缓存文档<ept id="p1">](/documentation/services/redis-cache/)</ept>页上提供了许多教程，说明如何使用不同的语言和缓存客户端开始使用 Azure Redis 缓存。</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>哪种 Azure 缓存产品适合我？</source>
          <target state="new">哪种 Azure 缓存产品适合我？</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>WindowsAzure.cn 建议所有新开发使用 Azure Redis 缓存。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>WindowsAzure.cn 建议所有新开发使用 Azure Redis 缓存。</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Azure 缓存当前具有三种产品：</source>
          <target state="new">Azure 缓存当前具有三种产品：</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Azure Redis Cache</source>
          <target state="new">Azure Redis Cache</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Azure 托管缓存服务</source>
          <target state="new">Azure 托管缓存服务</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Azure 角色中缓存</source>
          <target state="new">Azure 角色中缓存</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>我们特此宣布将在 2016 年 11 月 30 日停用 Azure 托管缓存服务和 Azure 角色中缓存。我们建议你迁移到 Azure Redis 缓存，以便为这次停用做好准备。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>我们特此宣布将在 2016 年 11 月 30 日停用 Azure 托管缓存服务和 Azure 角色中缓存。我们建议你迁移到 Azure Redis 缓存，以便为这次停用做好准备。</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>自该服务的正式版推出以来，Azure Redis 缓存一直是 Azure 中建议使用的缓存解决方案，而且它现在可以在所有 Azure 区域使用，包括中国和美国政府。由于这种广泛可用性，我们宣布即将停用托管缓存服务和角色中缓存服务。</source>
          <target state="new">自该服务的正式版推出以来，Azure Redis 缓存一直是 Azure 中建议使用的缓存解决方案，而且它现在可以在所有 Azure 区域使用，包括中国和美国政府。由于这种广泛可用性，我们宣布即将停用托管缓存服务和角色中缓存服务。</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>自 2015 年 11 月 30 日宣布之后，现有的客户最多仍可使用托管缓存服务和角色中缓存服务 12 个月，两者的服务终止日期将在 2016 年 11 月 30 日结束。在此日期之后，将关闭托管缓存服务，并且不再支持角色中缓存服务。</source>
          <target state="new">自 2015 年 11 月 30 日宣布之后，现有的客户最多仍可使用托管缓存服务和角色中缓存服务 12 个月，两者的服务终止日期将在 2016 年 11 月 30 日结束。在此日期之后，将关闭托管缓存服务，并且不再支持角色中缓存服务。</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>我们将在 2016 年 2 月 1 日之后发布的第一个 Azure SDK 版本中去除对创建新角色中缓存的支持。不过，客户可以打开包含角色中缓存的现有项目。</source>
          <target state="new">我们将在 2016 年 2 月 1 日之后发布的第一个 Azure SDK 版本中去除对创建新角色中缓存的支持。不过，客户可以打开包含角色中缓存的现有项目。</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>在此期间，我们建议所有现有托管缓存服务和角色中缓存服务客户迁移到 Azure Redis 缓存。Azure Redis 缓存提供更多的功能以及更高的总体价值。</source>
          <target state="new">在此期间，我们建议所有现有托管缓存服务和角色中缓存服务客户迁移到 Azure Redis 缓存。Azure Redis 缓存提供更多的功能以及更高的总体价值。</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Azure Redis Cache</source>
          <target state="new">Azure Redis Cache</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Azure Redis 缓存已正式发布，最大大小为 53 GB，且其可用性 SLA 为 99.9%。全新<bpt id="p1">[</bpt>高级层<ept id="p1">](/documentation/articles/cache-premium-tier-intro)</ept>提供的最大大小为 530 GB，且支持群集、VNET 和持久性，并附带 99.9% SLA。</source>
          <target state="new">Azure Redis 缓存已正式发布，最大大小为 53 GB，且其可用性 SLA 为 99.9%。全新<bpt id="p1">[</bpt>高级层<ept id="p1">](/documentation/articles/cache-premium-tier-intro)</ept>提供的最大大小为 530 GB，且支持群集、VNET 和持久性，并附带 99.9% SLA。</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Azure Redis 缓存使客户能够使用 WindowsAzure.cn 管理的安全专用 Redis 缓存。有了此产品，你可以利用 Redis 提供的丰富功能集和生态系统，并可以从 WindowsAzure.cn 获得可靠的托管和监控。</source>
          <target state="new">Azure Redis 缓存使客户能够使用 WindowsAzure.cn 管理的安全专用 Redis 缓存。有了此产品，你可以利用 Redis 提供的丰富功能集和生态系统，并可以从 WindowsAzure.cn 获得可靠的托管和监控。</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>与仅处理键/值对的传统缓存不同，Redis 因其高性能的数据类型而受欢迎。Redis 还支持对这些类型运行原子操作，如在字符串后面追加内容；递增哈希中的值；推送到列表；计算交集、并集和差集，或者获取排序集中排名最高的成员。其他功能包括支持事务、发布/订阅、Lua 脚本、具有有限生存时间的键和配置设置，使 Redis 在行为上更类似于传统缓存。</source>
          <target state="new">与仅处理键/值对的传统缓存不同，Redis 因其高性能的数据类型而受欢迎。Redis 还支持对这些类型运行原子操作，如在字符串后面追加内容；递增哈希中的值；推送到列表；计算交集、并集和差集，或者获取排序集中排名最高的成员。其他功能包括支持事务、发布/订阅、Lua 脚本、具有有限生存时间的键和配置设置，使 Redis 在行为上更类似于传统缓存。</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Redis 取得成功的另一个重要方面是围绕它构建了健康而充满活力的开放源生态系统。这反映在可通过多种语言使用各种不同的 Redis 客户端。这样一来，在 Azure 内部生成的几乎任何工作负荷都可以使用此缓存。</source>
          <target state="new">Redis 取得成功的另一个重要方面是围绕它构建了健康而充满活力的开放源生态系统。这反映在可通过多种语言使用各种不同的 Redis 客户端。这样一来，在 Azure 内部生成的几乎任何工作负荷都可以使用此缓存。</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>有关如何开始使用 Azure Redis 缓存的详细信息，请参阅<bpt id="p1">[</bpt>如何使用 Azure Redis 缓存<ept id="p1">](/documentation/articles/cache-dotnet-how-to-use-azure-redis-cache)</ept>和 <bpt id="p2">[</bpt>Azure Redis 缓存文档<ept id="p2">](/documentation/services/redis-cache/)</ept>。</source>
          <target state="new">有关如何开始使用 Azure Redis 缓存的详细信息，请参阅<bpt id="p1">[</bpt>如何使用 Azure Redis 缓存<ept id="p1">](/documentation/articles/cache-dotnet-how-to-use-azure-redis-cache)</ept>和 <bpt id="p2">[</bpt>Azure Redis 缓存文档<ept id="p2">](/documentation/services/redis-cache/)</ept>。</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>托管缓存服务</source>
          <target state="new">托管缓存服务</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>托管缓存服务已安排在 2016 年 11 月 30 日停用。</source>
          <target state="new">托管缓存服务已安排在 2016 年 11 月 30 日停用。</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>角色中缓存</source>
          <target state="new">角色中缓存</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>角色中缓存已安排在 2016 年 11 月 30 日停用。</source>
          <target state="new">角色中缓存已安排在 2016 年 11 月 30 日停用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>