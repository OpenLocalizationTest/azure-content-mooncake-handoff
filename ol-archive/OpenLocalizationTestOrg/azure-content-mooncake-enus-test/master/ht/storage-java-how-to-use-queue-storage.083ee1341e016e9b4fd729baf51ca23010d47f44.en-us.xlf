<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0fd78945f657fdded1b400d8f481c6f6b8603327</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 Java 使用队列存储 | Azure</source>
          <target state="new">如何通过 Java 使用队列存储 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何使用 Azure 队列服务创建和删除队列，以及插入、获取和删除消息。用 Java 编写的示例。</source>
          <target state="new">了解如何使用 Azure 队列服务创建和删除队列，以及插入、获取和删除消息。用 Java 编写的示例。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何通过 Java 使用队列存储</source>
          <target state="new">如何通过 Java 使用队列存储</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本指南将演示如何使用 Azure 队列存储服务执行常见方案。这些示例用 Java 编写并使用 <bpt id="p1">[</bpt>Azure Storage SDK for Java<ept id="p1">][]</ept>。涉及的方案包括“插入”、“扫视”、“获取”和“删除”队列消息以及“创建”和“删除”队列。有关队列的详细信息，请参阅<bpt id="p2">[</bpt>后续步骤<ept id="p2">](#NextSteps)</ept>部分。</source>
          <target state="new">本指南将演示如何使用 Azure 队列存储服务执行常见方案。这些示例用 Java 编写并使用 <bpt id="p1">[</bpt>Azure Storage SDK for Java<ept id="p1">][]</ept>。涉及的方案包括“插入”、“扫视”、“获取”和“删除”队列消息以及“创建”和“删除”队列。有关队列的详细信息，请参阅<bpt id="p2">[</bpt>后续步骤<ept id="p2">](#NextSteps)</ept>部分。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>注意：为在 Android 设备上使用 Azure 存储的开发人员提供了 SDK。有关详细信息，请参阅 <bpt id="p1">[</bpt>Azure Storage SDK for Android<ept id="p1">][]</ept>。</source>
          <target state="new">注意：为在 Android 设备上使用 Azure 存储的开发人员提供了 SDK。有关详细信息，请参阅 <bpt id="p1">[</bpt>Azure Storage SDK for Android<ept id="p1">][]</ept>。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>创建 Java 应用程序</source>
          <target state="new">创建 Java 应用程序</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>在本指南中，你将使用存储功能，这些功能可在本地 Java 应用程序中运行，或在 Azure 的 Web 角色或辅助角色中通过运行的代码来运行。</source>
          <target state="new">在本指南中，你将使用存储功能，这些功能可在本地 Java 应用程序中运行，或在 Azure 的 Web 角色或辅助角色中通过运行的代码来运行。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>为此，你将需要安装 Java 开发工具包 (JDK)，并在你的 Azure 订阅中创建一个 Azure 存储帐户。完成此操作后，你将需要验证开发系统满足最低要求和 GitHub 上的 <bpt id="p1">[</bpt>Azure Storage SDK for Java<ept id="p1">][]</ept> 存储库中列出的依赖项。如果你的系统满足这些要求，你可以按照说明下载和安装系统中该存储库的 Azure Storage Libraries for Java。完成这些任务后，您将能够创建一个 Java 应用程序，以便使用本文中的示例。</source>
          <target state="new">为此，你将需要安装 Java 开发工具包 (JDK)，并在你的 Azure 订阅中创建一个 Azure 存储帐户。完成此操作后，你将需要验证开发系统满足最低要求和 GitHub 上的 <bpt id="p1">[</bpt>Azure Storage SDK for Java<ept id="p1">][]</ept> 存储库中列出的依赖项。如果你的系统满足这些要求，你可以按照说明下载和安装系统中该存储库的 Azure Storage Libraries for Java。完成这些任务后，您将能够创建一个 Java 应用程序，以便使用本文中的示例。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>配置应用程序以访问队列存储</source>
          <target state="new">配置应用程序以访问队列存储</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>将下列 import 语句添加到需要在其中使用 Azure 存储 API 来访问队列的 Java 文件的顶部：</source>
          <target state="new">将下列 import 语句添加到需要在其中使用 Azure 存储 API 来访问队列的 Java 文件的顶部：</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>设置 Azure 存储连接字符串</source>
          <target state="new">设置 Azure 存储连接字符串</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Azure 存储客户端使用存储连接字符串来存储用于访问数据管理服务的终结点和凭据。在客户端应用程序中运行时，必须提供以下格式的存储连接字符串，并对 <bpt id="p1">*</bpt>AccountName<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>AccountKey<ept id="p2">*</ept> 值使用<bpt id="p3">[</bpt>管理门户<ept id="p3">](https://manage.windowsazure.cn)</ept>中列出的存储帐户的名称和存储帐户的主访问密钥。此示例演示如何声明一个静态字段以保存连接字符串：</source>
          <target state="new">Azure 存储客户端使用存储连接字符串来存储用于访问数据管理服务的终结点和凭据。在客户端应用程序中运行时，必须提供以下格式的存储连接字符串，并对 <bpt id="p1">*</bpt>AccountName<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>AccountKey<ept id="p2">*</ept> 值使用<bpt id="p3">[</bpt>管理门户<ept id="p3">](https://manage.windowsazure.cn)</ept>中列出的存储帐户的名称和存储帐户的主访问密钥。此示例演示如何声明一个静态字段以保存连接字符串：</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>在 Azure 的角色中运行的应用程序中，此字符串可存储在服务配置文件 <bpt id="p1">*</bpt>ServiceConfiguration.cscfg<ept id="p1">*</ept> 中，并可通过调用 <bpt id="p2">**</bpt>RoleEnvironment.getConfigurationSettings<ept id="p2">**</ept> 方法进行访问。下面是从服务配置文件中名为 <bpt id="p3">*</bpt>StorageConnectionString<ept id="p3">*</ept> 的 <bpt id="p4">**</bpt>Setting<ept id="p4">**</ept> 元素中获取连接字符串的示例：</source>
          <target state="new">在 Azure 的角色中运行的应用程序中，此字符串可存储在服务配置文件 <bpt id="p1">*</bpt>ServiceConfiguration.cscfg<ept id="p1">*</ept> 中，并可通过调用 <bpt id="p2">**</bpt>RoleEnvironment.getConfigurationSettings<ept id="p2">**</ept> 方法进行访问。下面是从服务配置文件中名为 <bpt id="p3">*</bpt>StorageConnectionString<ept id="p3">*</ept> 的 <bpt id="p4">**</bpt>Setting<ept id="p4">**</ept> 元素中获取连接字符串的示例：</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>下面的示例假定你使用了这两个方法之一来获取存储连接字符串。</source>
          <target state="new">下面的示例假定你使用了这两个方法之一来获取存储连接字符串。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>如何：创建队列</source>
          <target state="new">如何：创建队列</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>利用 <bpt id="p1">**</bpt>CloudQueueClient<ept id="p1">**</ept> 对象，可以获取队列的引用对象。以下代码将创建 <bpt id="p2">**</bpt>CloudQueueClient<ept id="p2">**</ept> 对象。（注意：还有其他方式来创建 <bpt id="p3">**</bpt>CloudStorageAccount<ept id="p3">**</ept> 对象；有关详细信息，请参阅 <bpt id="p4">[</bpt><ept id="p4">Azure 存储客户端 SDK 参考]</ept>中的 <bpt id="p5">**</bpt>CloudStorageAccount<ept id="p5">**</ept>。）</source>
          <target state="new">利用 <bpt id="p1">**</bpt>CloudQueueClient<ept id="p1">**</ept> 对象，可以获取队列的引用对象。以下代码将创建 <bpt id="p2">**</bpt>CloudQueueClient<ept id="p2">**</ept> 对象。（注意：还有其他方式来创建 <bpt id="p3">**</bpt>CloudStorageAccount<ept id="p3">**</ept> 对象；有关详细信息，请参阅 <bpt id="p4">[</bpt><ept id="p4">Azure 存储客户端 SDK 参考]</ept>中的 <bpt id="p5">**</bpt>CloudStorageAccount<ept id="p5">**</ept>。）</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>CloudQueueClient<ept id="p1">**</ept> 对象获取对你要使用的队列的引用。如果队列不存在，你可以创建它。</source>
          <target state="new">使用 <bpt id="p1">**</bpt>CloudQueueClient<ept id="p1">**</ept> 对象获取对你要使用的队列的引用。如果队列不存在，你可以创建它。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>如何：向队列添加消息</source>
          <target state="new">如何：向队列添加消息</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>若要将消息插入现有队列，请先创建一个新的 <bpt id="p1">**</bpt>CloudQueueMessage<ept id="p1">**</ept>。接下来，调用 <bpt id="p2">**</bpt>addMessage<ept id="p2">**</ept> 方法。可从字符串（UTF-8 格式）或字节数组创建 <bpt id="p3">**</bpt>CloudQueueMessage<ept id="p3">**</ept>。以下代码将创建队列（如果队列不存在）并插入消息“Hello, World”。</source>
          <target state="new">若要将消息插入现有队列，请先创建一个新的 <bpt id="p1">**</bpt>CloudQueueMessage<ept id="p1">**</ept>。接下来，调用 <bpt id="p2">**</bpt>addMessage<ept id="p2">**</ept> 方法。可从字符串（UTF-8 格式）或字节数组创建 <bpt id="p3">**</bpt>CloudQueueMessage<ept id="p3">**</ept>。以下代码将创建队列（如果队列不存在）并插入消息“Hello, World”。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>如何：扫视下一条消息</source>
          <target state="new">如何：扫视下一条消息</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>通过调用 <bpt id="p1">**</bpt>peekMessage<ept id="p1">**</ept>，你可以扫视队列前面的消息，而不会从队列中删除它。</source>
          <target state="new">通过调用 <bpt id="p1">**</bpt>peekMessage<ept id="p1">**</ept>，你可以扫视队列前面的消息，而不会从队列中删除它。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>如何：更改已排队消息的内容</source>
          <target state="new">如何：更改已排队消息的内容</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>你可以更改队列中现有消息的内容。如果消息表示工作任务，则你可以使用此功能来更新该工作任务的状态。以下代码使用新内容更新队列消息，并将可见性超时设置为再延长 60 秒。这将保存与消息关联的工作的状态，并额外为客户端提供一分钟的时间来继续处理消息。可使用此方法跟踪队列消息上的多步骤工作流，即使处理步骤因硬件或软件故障而失败，也无需从头开始操作。通常，你还可以保留重试计数，如果某条消息的重试次数超过 <bpt id="p1">*</bpt>n<ept id="p1">*</ept>，你将删除此消息。这可避免每次处理某条消息时都触发应用程序错误。</source>
          <target state="new">你可以更改队列中现有消息的内容。如果消息表示工作任务，则你可以使用此功能来更新该工作任务的状态。以下代码使用新内容更新队列消息，并将可见性超时设置为再延长 60 秒。这将保存与消息关联的工作的状态，并额外为客户端提供一分钟的时间来继续处理消息。可使用此方法跟踪队列消息上的多步骤工作流，即使处理步骤因硬件或软件故障而失败，也无需从头开始操作。通常，你还可以保留重试计数，如果某条消息的重试次数超过 <bpt id="p1">*</bpt>n<ept id="p1">*</ept>，你将删除此消息。这可避免每次处理某条消息时都触发应用程序错误。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>下面的代码示例将搜索队列中的消息，查找内容中第一个与“Hello, World”匹配的消息，然后对消息内容进行修改并退出。</source>
          <target state="new">下面的代码示例将搜索队列中的消息，查找内容中第一个与“Hello, World”匹配的消息，然后对消息内容进行修改并退出。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>或者，以下代码示例只更新了队列中第一个可见消息</source>
          <target state="new">或者，以下代码示例只更新了队列中第一个可见消息</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>如何：获取队列长度</source>
          <target state="new">如何：获取队列长度</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>你可以获取队列中消息的估计数。<bpt id="p1">**</bpt>downloadAttributes<ept id="p1">**</ept> 方法会询问队列服务一些当前值，包括队列中消息的计数。此计数仅为近似值，因为只能在队列服务响应您的请求后添加或删除消息。<bpt id="p2">**</bpt>getApproximateMessageCount<ept id="p2">**</ept> 方法返回通过调用 <bpt id="p3">**</bpt>downloadAttributes<ept id="p3">**</ept> 检索到的最后一个值，而不会调用队列服务。</source>
          <target state="new">你可以获取队列中消息的估计数。<bpt id="p1">**</bpt>downloadAttributes<ept id="p1">**</ept> 方法会询问队列服务一些当前值，包括队列中消息的计数。此计数仅为近似值，因为只能在队列服务响应您的请求后添加或删除消息。<bpt id="p2">**</bpt>getApproximateMessageCount<ept id="p2">**</ept> 方法返回通过调用 <bpt id="p3">**</bpt>downloadAttributes<ept id="p3">**</ept> 检索到的最后一个值，而不会调用队列服务。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>如何：取消对下一条消息的排队</source>
          <target state="new">如何：取消对下一条消息的排队</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>你的代码通过两个步骤来取消对队列中某条消息的排队。在调用 <bpt id="p1">**</bpt>retrieveMessage<ept id="p1">**</ept> 时，你将获得队列中的下一条消息。从 <bpt id="p2">**</bpt>retrieveMessage<ept id="p2">**</ept> 返回的消息变得对从此队列读取消息的任何其他代码不可见。默认情况下，此消息将持续 30 秒不可见。若要从队列中删除消息，你还必须调用 <bpt id="p3">**</bpt>deleteMessage<ept id="p3">**</ept>。此删除消息的两步过程可确保，如果你的代码因硬件或软件故障而无法处理消息，则你的代码的其他实例可以获取相同消息并重试。你的代码在处理消息后会立即调用 <bpt id="p4">**</bpt>deleteMessage<ept id="p4">**</ept>。</source>
          <target state="new">你的代码通过两个步骤来取消对队列中某条消息的排队。在调用 <bpt id="p1">**</bpt>retrieveMessage<ept id="p1">**</ept> 时，你将获得队列中的下一条消息。从 <bpt id="p2">**</bpt>retrieveMessage<ept id="p2">**</ept> 返回的消息变得对从此队列读取消息的任何其他代码不可见。默认情况下，此消息将持续 30 秒不可见。若要从队列中删除消息，你还必须调用 <bpt id="p3">**</bpt>deleteMessage<ept id="p3">**</ept>。此删除消息的两步过程可确保，如果你的代码因硬件或软件故障而无法处理消息，则你的代码的其他实例可以获取相同消息并重试。你的代码在处理消息后会立即调用 <bpt id="p4">**</bpt>deleteMessage<ept id="p4">**</ept>。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>用于取消对消息进行排队的其他选项</source>
          <target state="new">用于取消对消息进行排队的其他选项</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>你可以通过两种方式自定义队列中的消息检索。首先，你可以获取一批消息（最多 32 个）。其次，你可以设置更长或更短的不可见超时时间，从而允许你的代码使用更多或更少时间来完全处理每个消息。</source>
          <target state="new">你可以通过两种方式自定义队列中的消息检索。首先，你可以获取一批消息（最多 32 个）。其次，你可以设置更长或更短的不可见超时时间，从而允许你的代码使用更多或更少时间来完全处理每个消息。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>下面的代码示例使用 <bpt id="p1">**</bpt>retrieveMessages<ept id="p1">**</ept> 方法以在一次调用中获取 20 条消息。然后，它会使用 <bpt id="p2">**</bpt>for<ept id="p2">**</ept> 循环处理每条消息。它还将每条消息的不可见超时设置为五分钟（300 秒）。请注意，这五分钟超时对于所有消息都是同时开始的，因此在调用 <bpt id="p3">**</bpt>retrieveMessages<ept id="p3">**</ept> 五分钟后，尚未删除的任何消息都将再次变得可见。</source>
          <target state="new">下面的代码示例使用 <bpt id="p1">**</bpt>retrieveMessages<ept id="p1">**</ept> 方法以在一次调用中获取 20 条消息。然后，它会使用 <bpt id="p2">**</bpt>for<ept id="p2">**</ept> 循环处理每条消息。它还将每条消息的不可见超时设置为五分钟（300 秒）。请注意，这五分钟超时对于所有消息都是同时开始的，因此在调用 <bpt id="p3">**</bpt>retrieveMessages<ept id="p3">**</ept> 五分钟后，尚未删除的任何消息都将再次变得可见。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>如何：列出队列</source>
          <target state="new">如何：列出队列</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>若要获取当前队列的列表，请调用 <bpt id="p1">**</bpt>CloudQueueClient.listQueues()<ept id="p1">**</ept> 方法，它将返回 <bpt id="p2">**</bpt>CloudQueue<ept id="p2">**</ept> 对象的集合。</source>
          <target state="new">若要获取当前队列的列表，请调用 <bpt id="p1">**</bpt>CloudQueueClient.listQueues()<ept id="p1">**</ept> 方法，它将返回 <bpt id="p2">**</bpt>CloudQueue<ept id="p2">**</ept> 对象的集合。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>如何：删除队列</source>
          <target state="new">如何：删除队列</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>若要删除队列及其包含的所有消息，请对 <bpt id="p1">**</bpt>CloudQueue<ept id="p1">**</ept> 对象调用 <bpt id="p2">**</bpt>deleteIfExists<ept id="p2">**</ept> 方法。</source>
          <target state="new">若要删除队列及其包含的所有消息，请对 <bpt id="p1">**</bpt>CloudQueue<ept id="p1">**</ept> 对象调用 <bpt id="p2">**</bpt>deleteIfExists<ept id="p2">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>现在，您已了解有关队列存储的基础知识，可单击下面的链接来了解更复杂的存储任务。</source>
          <target state="new">现在，您已了解有关队列存储的基础知识，可单击下面的链接来了解更复杂的存储任务。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Azure Storage SDK for Java</source>
          <target state="new">Azure Storage SDK for Java</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Azure 存储客户端 SDK 参考</source>
          <target state="new">Azure 存储客户端 SDK 参考</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Azure 存储 REST API</source>
          <target state="new">Azure 存储 REST API</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Azure 存储团队博客</source>
          <target state="new">Azure 存储团队博客</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>