<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">675df61cd00d0e9efe302b5b06c423ae4f30b7b6</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 Node.js 使用 Blob 存储 | Azure</source>
          <target state="new">如何通过 Node.js 使用 Blob 存储 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何使用 Azure Blob 服务上载、下载、列出和删除 Blob 内容。示例用 Node.js 编写。</source>
          <target state="new">了解如何使用 Azure Blob 服务上载、下载、列出和删除 Blob 内容。示例用 Node.js 编写。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何通过 Node.js 使用 Blob 存储</source>
          <target state="new">如何通过 Node.js 使用 Blob 存储</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本文将演示如何使用 Azure Blob 服务执行常见方案。相关示例是通过 Node.js API 编写的。涉及的方案包括“上传”、“列出”、“下载”和“删除”Blob。</source>
          <target state="new">本文将演示如何使用 Azure Blob 服务执行常见方案。相关示例是通过 Node.js API 编写的。涉及的方案包括“上传”、“列出”、“下载”和“删除”Blob。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>创建 Node.js 应用程序</source>
          <target state="new">创建 Node.js 应用程序</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>有关创建 Node.js 应用程序的说明，请参阅<bpt id="p1">[</bpt><ept id="p1">创建 Node.js 应用程序并将其部署到 Azure Web 应用]</ept>、<bpt id="p2">[</bpt>Node.js 云服务<ept id="p2">][Node.js 云服务]</ept>（使用 Windows PowerShell）或 <bpt id="p3">[</bpt><ept id="p3">使用 WebMatrix 构建 Web 应用]</ept>。</source>
          <target state="new">有关创建 Node.js 应用程序的说明，请参阅<bpt id="p1">[</bpt><ept id="p1">创建 Node.js 应用程序并将其部署到 Azure Web 应用]</ept>、<bpt id="p2">[</bpt>Node.js 云服务<ept id="p2">][Node.js 云服务]</ept>（使用 Windows PowerShell）或 <bpt id="p3">[</bpt><ept id="p3">使用 WebMatrix 构建 Web 应用]</ept>。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>配置应用程序以访问存储</source>
          <target state="new">配置应用程序以访问存储</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>若要使用 Azure 存储空间，你需要 Azure Storage SDK for Node.js，其中包括一组便于与存储 REST 服务进行通信的库。</source>
          <target state="new">若要使用 Azure 存储空间，你需要 Azure Storage SDK for Node.js，其中包括一组便于与存储 REST 服务进行通信的库。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>使用 Node 包管理器 (NPM) 可获取该程序包</source>
          <target state="new">使用 Node 包管理器 (NPM) 可获取该程序包</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>PowerShell<ept id="p1">**</ept> (Windows)、<bpt id="p2">**</bpt>Terminal<ept id="p2">**</ept> (Mac) 或 <bpt id="p3">**</bpt>Bash<ept id="p3">**</ept> (Unix) 等命令行界面导航到您在其中创建了示例应用程序的文件夹。</source>
          <target state="new">使用 <bpt id="p1">**</bpt>PowerShell<ept id="p1">**</ept> (Windows)、<bpt id="p2">**</bpt>Terminal<ept id="p2">**</ept> (Mac) 或 <bpt id="p3">**</bpt>Bash<ept id="p3">**</ept> (Unix) 等命令行界面导航到您在其中创建了示例应用程序的文件夹。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>在命令窗口中键入 <bpt id="p1">**</bpt>npm install azure-storage<ept id="p1">**</ept>。该命令的输出类似于以下代码示例。</source>
          <target state="new">在命令窗口中键入 <bpt id="p1">**</bpt>npm install azure-storage<ept id="p1">**</ept>。该命令的输出类似于以下代码示例。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>可以手动运行 <bpt id="p1">**</bpt>ls<ept id="p1">**</ept> 命令来验证是否创建了 <bpt id="p2">**</bpt>node\_modules<ept id="p2">**</ept> 文件夹。在该文件夹中，您将找到 <bpt id="p3">**</bpt>azure-storage<ept id="p3">**</ept> 包，其中包含您访问存储所需的库。</source>
          <target state="new">可以手动运行 <bpt id="p1">**</bpt>ls<ept id="p1">**</ept> 命令来验证是否创建了 <bpt id="p2">**</bpt>node\_modules<ept id="p2">**</ept> 文件夹。在该文件夹中，您将找到 <bpt id="p3">**</bpt>azure-storage<ept id="p3">**</ept> 包，其中包含您访问存储所需的库。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>导入包</source>
          <target state="new">导入包</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>使用记事本或其他文本编辑器将以下内容添加到您要在其中使用存储的应用程序的 <bpt id="p1">**</bpt>server.js<ept id="p1">**</ept> 文件的顶部：</source>
          <target state="new">使用记事本或其他文本编辑器将以下内容添加到您要在其中使用存储的应用程序的 <bpt id="p1">**</bpt>server.js<ept id="p1">**</ept> 文件的顶部：</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>设置 Azure 存储连接</source>
          <target state="new">设置 Azure 存储连接</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Azure 模块将读取环境变量 <ph id="ph1">`AZURE_STORAGE_ACCOUNT`</ph>、<ph id="ph2">`AZURE_STORAGE_ACCESS_KEY`</ph> 或 <ph id="ph3">`AZURE_STORAGE_CONNECTION_STRING`</ph>，以便获取连接到 Azure 存储帐户所需的信息。如果未设置这些环境变量，则在调用 <bpt id="p1">**</bpt>createBlobService<ept id="p1">**</ept> 时必须指定帐户信息。</source>
          <target state="new">Azure 模块将读取环境变量 <ph id="ph1">`AZURE_STORAGE_ACCOUNT`</ph>、<ph id="ph2">`AZURE_STORAGE_ACCESS_KEY`</ph> 或 <ph id="ph3">`AZURE_STORAGE_CONNECTION_STRING`</ph>，以便获取连接到 Azure 存储帐户所需的信息。如果未设置这些环境变量，则在调用 <bpt id="p1">**</bpt>createBlobService<ept id="p1">**</ept> 时必须指定帐户信息。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>有关在管理门户中为 Azure Web 应用设置环境变量的示例，请参阅<bpt id="p1">[</bpt><ept id="p1">使用存储构建 Node.js Web 应用]</ept>。</source>
          <target state="new">有关在管理门户中为 Azure Web 应用设置环境变量的示例，请参阅<bpt id="p1">[</bpt><ept id="p1">使用存储构建 Node.js Web 应用]</ept>。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>创建容器</source>
          <target state="new">创建容器</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>BlobService<ept id="p1">**</ept> 对象可以对容器和 Blob 进行操作。以下代码创建 <bpt id="p2">**</bpt>BlobService<ept id="p2">**</ept> 对象。将以下内容添加到 <bpt id="p3">**</bpt>server.js<ept id="p3">**</ept> 顶部附近。</source>
          <target state="new">使用 <bpt id="p1">**</bpt>BlobService<ept id="p1">**</ept> 对象可以对容器和 Blob 进行操作。以下代码创建 <bpt id="p2">**</bpt>BlobService<ept id="p2">**</ept> 对象。将以下内容添加到 <bpt id="p3">**</bpt>server.js<ept id="p3">**</ept> 顶部附近。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 您可以匿名访问 Blob，只需使用 <bpt id="p1">**</bpt>createBlobServiceAnonymous<ept id="p1">**</ept> 并提供主机地址即可。例如，使用 <ph id="ph2">`var blobSvc = azure.createBlobServiceAnonymous('https://myblob.blob.core.chinacloudapi.cn/');`</ph>。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 您可以匿名访问 Blob，只需使用 <bpt id="p1">**</bpt>createBlobServiceAnonymous<ept id="p1">**</ept> 并提供主机地址即可。例如，使用 <ph id="ph2">`var blobSvc = azure.createBlobServiceAnonymous('https://myblob.blob.core.chinacloudapi.cn/');`</ph>。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>若要创建一个新的容器，请使用 <bpt id="p1">**</bpt>createContainerIfNotExists<ept id="p1">**</ept>。以下代码示例将创建名为“mycontainer”的新容器</source>
          <target state="new">若要创建一个新的容器，请使用 <bpt id="p1">**</bpt>createContainerIfNotExists<ept id="p1">**</ept>。以下代码示例将创建名为“mycontainer”的新容器</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>如果该容器是新建的，则 <ph id="ph1">`result`</ph> 为 true。如果容器已存在，<ph id="ph2">`result`</ph> 将为 false。<ph id="ph3">`response`</ph> 将包含有关操作的信息，包括容器的 <bpt id="p1">[</bpt>ETag<ept id="p1">](http://zh.wikipedia.org/wiki/HTTP_ETag)</ept> 信息。</source>
          <target state="new">如果该容器是新建的，则 <ph id="ph1">`result`</ph> 为 true。如果容器已存在，<ph id="ph2">`result`</ph> 将为 false。<ph id="ph3">`response`</ph> 将包含有关操作的信息，包括容器的 <bpt id="p1">[</bpt>ETag<ept id="p1">](http://zh.wikipedia.org/wiki/HTTP_ETag)</ept> 信息。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>容器安全性</source>
          <target state="new">容器安全性</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>默认情况下，新容器是私有的，不能匿名访问。若要使容器公开，以便能够对其进行匿名访问，可将容器的访问级别设置为“Blob”或“容器”。</source>
          <target state="new">默认情况下，新容器是私有的，不能匿名访问。若要使容器公开，以便能够对其进行匿名访问，可将容器的访问级别设置为“Blob”或“容器”。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Blob<ept id="p1">**</ept> - 可匿名读取此容器中的 Blob 内容和元数据，但无法匿名读取容器元数据（如列出容器中的所有 Blob）</source>
          <target state="new"><bpt id="p1">**</bpt>Blob<ept id="p1">**</ept> - 可匿名读取此容器中的 Blob 内容和元数据，但无法匿名读取容器元数据（如列出容器中的所有 Blob）</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>容器<ept id="p1">**</ept> - 可匿名读取 Blob 内容和元数据，以及容器元数据</source>
          <target state="new"><bpt id="p1">**</bpt>容器<ept id="p1">**</ept> - 可匿名读取 Blob 内容和元数据，以及容器元数据</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>以下代码示例演示了如何将访问级别设置为“Blob”：</source>
          <target state="new">以下代码示例演示了如何将访问级别设置为“Blob”：</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>另外，您可以通过使用 <bpt id="p1">**</bpt>setContainerAcl<ept id="p1">**</ept> 指定访问级别来修改容器的访问级别。以下代码示例将访问级别更改为“容器”：</source>
          <target state="new">另外，您可以通过使用 <bpt id="p1">**</bpt>setContainerAcl<ept id="p1">**</ept> 指定访问级别来修改容器的访问级别。以下代码示例将访问级别更改为“容器”：</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>结果将包含有关操作的信息，包括容器的当前 <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept>。</source>
          <target state="new">结果将包含有关操作的信息，包括容器的当前 <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>筛选器</source>
          <target state="new">筛选器</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>你可以向使用 <bpt id="p1">**</bpt>BlobService<ept id="p1">**</ept> 执行的操作应用可选的筛选操作。筛选操作可包括日志记录、自动重试等。筛选器是实现具有签名的方法的对象：</source>
          <target state="new">你可以向使用 <bpt id="p1">**</bpt>BlobService<ept id="p1">**</ept> 执行的操作应用可选的筛选操作。筛选操作可包括日志记录、自动重试等。筛选器是实现具有签名的方法的对象：</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>在对请求选项执行预处理后，该方法需要调用“next”并且传递具有以下签名的回调：</source>
          <target state="new">在对请求选项执行预处理后，该方法需要调用“next”并且传递具有以下签名的回调：</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>在此回调中并且在处理 returnObject（来自对服务器请求的响应）后，回调需要调用 next（如果它存在以便继续处理其他筛选器）或只调用 finalCallback 以便结束服务调用。</source>
          <target state="new">在此回调中并且在处理 returnObject（来自对服务器请求的响应）后，回调需要调用 next（如果它存在以便继续处理其他筛选器）或只调用 finalCallback 以便结束服务调用。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Azure SDK for Node.js 中附带了两个实现了重试逻辑的筛选器，分别是 <bpt id="p1">**</bpt>ExponentialRetryPolicyFilter<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>LinearRetryPolicyFilter<ept id="p2">**</ept>。下面的代码将创建一个 <bpt id="p3">**</bpt>BlobService<ept id="p3">**</ept> 对象，该对象使用 <bpt id="p4">**</bpt>ExponentialRetryPolicyFilter<ept id="p4">**</ept>：</source>
          <target state="new">Azure SDK for Node.js 中附带了两个实现了重试逻辑的筛选器，分别是 <bpt id="p1">**</bpt>ExponentialRetryPolicyFilter<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>LinearRetryPolicyFilter<ept id="p2">**</ept>。下面的代码将创建一个 <bpt id="p3">**</bpt>BlobService<ept id="p3">**</ept> 对象，该对象使用 <bpt id="p4">**</bpt>ExponentialRetryPolicyFilter<ept id="p4">**</ept>：</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>将 Blob 上载到容器中</source>
          <target state="new">将 Blob 上载到容器中</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Blob 可以基于块，也可以基于页。块 Blob 可以让你更高效地上传大型数据，而页 Blob 则针对读/写操作进行了优化。有关详细信息，请参阅<bpt id="p1">[</bpt>了解块 Blob 和页 Blob<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/azure/ee691964.aspx)</ept>。</source>
          <target state="new">Blob 可以基于块，也可以基于页。块 Blob 可以让你更高效地上传大型数据，而页 Blob 则针对读/写操作进行了优化。有关详细信息，请参阅<bpt id="p1">[</bpt>了解块 Blob 和页 Blob<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/azure/ee691964.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>块 Blob</source>
          <target state="new">块 Blob</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>若要将数据上传到块 Blob，可使用以下方法：</source>
          <target state="new">若要将数据上传到块 Blob，可使用以下方法：</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>createBlockBlobFromLocalFile<ept id="p1">**</ept> - 创建新的块 Blob 和上传文件的内容。</source>
          <target state="new"><bpt id="p1">**</bpt>createBlockBlobFromLocalFile<ept id="p1">**</ept> - 创建新的块 Blob 和上传文件的内容。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>createBlockBlobFromStream<ept id="p1">**</ept> - 创建新的块 Blob 和上传流的内容。</source>
          <target state="new"><bpt id="p1">**</bpt>createBlockBlobFromStream<ept id="p1">**</ept> - 创建新的块 Blob 和上传流的内容。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>createBlockBlobFromText<ept id="p1">**</ept> - 创建新的块 Blob 和上传字符串的内容。</source>
          <target state="new"><bpt id="p1">**</bpt>createBlockBlobFromText<ept id="p1">**</ept> - 创建新的块 Blob 和上传字符串的内容。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>createWriteStreamToBlockBlob<ept id="p1">**</ept> - 向块 Blob 提供写入流。</source>
          <target state="new"><bpt id="p1">**</bpt>createWriteStreamToBlockBlob<ept id="p1">**</ept> - 向块 Blob 提供写入流。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>以下代码示例将 <bpt id="p1">**</bpt>test.txt<ept id="p1">**</ept> 文件的内容上传到 <bpt id="p2">**</bpt>myblob<ept id="p2">**</ept> 中。</source>
          <target state="new">以下代码示例将 <bpt id="p1">**</bpt>test.txt<ept id="p1">**</ept> 文件的内容上传到 <bpt id="p2">**</bpt>myblob<ept id="p2">**</ept> 中。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>这些方法返回的 <ph id="ph1">`result`</ph> 将包含有关操作的信息，例如 Blob 的 <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept>。</source>
          <target state="new">这些方法返回的 <ph id="ph1">`result`</ph> 将包含有关操作的信息，例如 Blob 的 <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>页 Blob</source>
          <target state="new">页 Blob</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>若要将数据上传到页 Blob，可使用以下方法：</source>
          <target state="new">若要将数据上传到页 Blob，可使用以下方法：</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>createPageBlob<ept id="p1">**</ept> - 创建新的特定长度的页 Blob。</source>
          <target state="new"><bpt id="p1">**</bpt>createPageBlob<ept id="p1">**</ept> - 创建新的特定长度的页 Blob。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>createPageBlobFromLocalFile<ept id="p1">**</ept> - 创建新的页 Blob 并上传文件的内容。</source>
          <target state="new"><bpt id="p1">**</bpt>createPageBlobFromLocalFile<ept id="p1">**</ept> - 创建新的页 Blob 并上传文件的内容。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>createPageBlobFromStream<ept id="p1">**</ept> - 创建新的页 Blob 并上传流的内容。</source>
          <target state="new"><bpt id="p1">**</bpt>createPageBlobFromStream<ept id="p1">**</ept> - 创建新的页 Blob 并上传流的内容。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>createWriteStreamToExistingPageBlob<ept id="p1">**</ept> - 向现有页 Blob 提供写入流。</source>
          <target state="new"><bpt id="p1">**</bpt>createWriteStreamToExistingPageBlob<ept id="p1">**</ept> - 向现有页 Blob 提供写入流。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>createWriteStreamToNewPageBlob<ept id="p1">**</ept> - 创建新的 blob，然后向其提供写入流。</source>
          <target state="new"><bpt id="p1">**</bpt>createWriteStreamToNewPageBlob<ept id="p1">**</ept> - 创建新的 blob，然后向其提供写入流。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>以下代码示例将 <bpt id="p1">**</bpt>test.txt<ept id="p1">**</ept> 文件的内容上传到 <bpt id="p2">**</bpt>mypageblob<ept id="p2">**</ept> 中。</source>
          <target state="new">以下代码示例将 <bpt id="p1">**</bpt>test.txt<ept id="p1">**</ept> 文件的内容上传到 <bpt id="p2">**</bpt>mypageblob<ept id="p2">**</ept> 中。</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 页 Blob 包含 512 字节的“页面”。当你上传大小不是 512 倍数的数据时，可能会收到错误。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 页 Blob 包含 512 字节的“页面”。当你上传大小不是 512 倍数的数据时，可能会收到错误。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>列出容器中的 Blob</source>
          <target state="new">列出容器中的 Blob</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>若要列出容器中的 Blob，请使用 <bpt id="p1">**</bpt>listBlobsSegmented<ept id="p1">**</ept> 方法。如果您想要返回带特定前缀的 Blob，请使用 <bpt id="p2">**</bpt>listBlobsSegmentedWithPrefix<ept id="p2">**</ept>。</source>
          <target state="new">若要列出容器中的 Blob，请使用 <bpt id="p1">**</bpt>listBlobsSegmented<ept id="p1">**</ept> 方法。如果您想要返回带特定前缀的 Blob，请使用 <bpt id="p2">**</bpt>listBlobsSegmentedWithPrefix<ept id="p2">**</ept>。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`result`</ph> 包含一个 <ph id="ph2">`entries`</ph> 集合，该集合是一组用于描述每个 Blob 的对象。如果不能返回所有 Blob，<ph id="ph3">`result`</ph> 还将提供 <ph id="ph4">`continuationToken`</ph>，这可用作第二个参数来检索其他条目。</source>
          <target state="new"><ph id="ph1">`result`</ph> 包含一个 <ph id="ph2">`entries`</ph> 集合，该集合是一组用于描述每个 Blob 的对象。如果不能返回所有 Blob，<ph id="ph3">`result`</ph> 还将提供 <ph id="ph4">`continuationToken`</ph>，这可用作第二个参数来检索其他条目。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>下载 Blob</source>
          <target state="new">下载 Blob</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>若要从 Blob 下载数据，可使用以下方法：</source>
          <target state="new">若要从 Blob 下载数据，可使用以下方法：</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>getBlobToLocalFile<ept id="p1">**</ept> - 将 Blob 内容写入文件</source>
          <target state="new"><bpt id="p1">**</bpt>getBlobToLocalFile<ept id="p1">**</ept> - 将 Blob 内容写入文件</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>getBlobToStream<ept id="p1">**</ept> - 将 Blob 内容写入流</source>
          <target state="new"><bpt id="p1">**</bpt>getBlobToStream<ept id="p1">**</ept> - 将 Blob 内容写入流</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>getBlobToText<ept id="p1">**</ept> - 将 Blob 内容写入字符串</source>
          <target state="new"><bpt id="p1">**</bpt>getBlobToText<ept id="p1">**</ept> - 将 Blob 内容写入字符串</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>createReadStream<ept id="p1">**</ept> - 提供可从 Blob 读取内容的流</source>
          <target state="new"><bpt id="p1">**</bpt>createReadStream<ept id="p1">**</ept> - 提供可从 Blob 读取内容的流</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>以下代码示例演示了如何使用 <bpt id="p1">**</bpt>getBlobToStream<ept id="p1">**</ept> 下载 <bpt id="p2">**</bpt>myblob<ept id="p2">**</ept> Blob 的内容，并使用一个流将其存储到 <bpt id="p3">**</bpt>output.txt<ept id="p3">**</ept> 文件：</source>
          <target state="new">以下代码示例演示了如何使用 <bpt id="p1">**</bpt>getBlobToStream<ept id="p1">**</ept> 下载 <bpt id="p2">**</bpt>myblob<ept id="p2">**</ept> Blob 的内容，并使用一个流将其存储到 <bpt id="p3">**</bpt>output.txt<ept id="p3">**</ept> 文件：</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`result`</ph> 包含有关 Blob 的信息，包括 <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept> 信息。</source>
          <target state="new"><ph id="ph1">`result`</ph> 包含有关 Blob 的信息，包括 <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept> 信息。</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>删除 Blob</source>
          <target state="new">删除 Blob</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>最后，若要删除 Blob，请调用 <bpt id="p1">**</bpt>deleteBlob<ept id="p1">**</ept>。以下代码示例将删除名为 <bpt id="p2">**</bpt>myblob<ept id="p2">**</ept> 的 Blob。</source>
          <target state="new">最后，若要删除 Blob，请调用 <bpt id="p1">**</bpt>deleteBlob<ept id="p1">**</ept>。以下代码示例将删除名为 <bpt id="p2">**</bpt>myblob<ept id="p2">**</ept> 的 Blob。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>并发访问</source>
          <target state="new">并发访问</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>若要允许从多个客户端或多个进程实例并发访问某个 Blob，您可以使用 <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept> 或<bpt id="p2">**</bpt>租约<ept id="p2">**</ept>。</source>
          <target state="new">若要允许从多个客户端或多个进程实例并发访问某个 Blob，您可以使用 <bpt id="p1">**</bpt>ETag<ept id="p1">**</ept> 或<bpt id="p2">**</bpt>租约<ept id="p2">**</ept>。</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Etag<ept id="p1">**</ept> - 用于检测 Blob 或容器是否已被其他进程修改</source>
          <target state="new"><bpt id="p1">**</bpt>Etag<ept id="p1">**</ept> - 用于检测 Blob 或容器是否已被其他进程修改</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>租约<ept id="p1">**</ept> - 用于在某个时段内获取对 Blob 的独占式可续订写入或删除访问</source>
          <target state="new"><bpt id="p1">**</bpt>租约<ept id="p1">**</ept> - 用于在某个时段内获取对 Blob 的独占式可续订写入或删除访问</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>ETag</source>
          <target state="new">ETag</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>如果你需要允许多个客户端或实例同时写入该 Blob，请使用 ETag。ETag 用于确定自从你第一次读取或创建某个容器或 Blob 以来，该容器或 Blob 是否被修改，这样就可以避免覆盖其他客户端或进程提交的更改。</source>
          <target state="new">如果你需要允许多个客户端或实例同时写入该 Blob，请使用 ETag。ETag 用于确定自从你第一次读取或创建某个容器或 Blob 以来，该容器或 Blob 是否被修改，这样就可以避免覆盖其他客户端或进程提交的更改。</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>可以使用可选的 <ph id="ph1">`options.accessConditions`</ph> 参数设置ETag 条件。如果 Blob 已存在且具有 <ph id="ph2">`etagToMatch`</ph> 所包含的 ETag 值，则以下代码示例将仅上传 <bpt id="p1">**</bpt>test.txt<ept id="p1">**</ept> 文件。</source>
          <target state="new">可以使用可选的 <ph id="ph1">`options.accessConditions`</ph> 参数设置ETag 条件。如果 Blob 已存在且具有 <ph id="ph2">`etagToMatch`</ph> 所包含的 ETag 值，则以下代码示例将仅上传 <bpt id="p1">**</bpt>test.txt<ept id="p1">**</ept> 文件。</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>当你使用 ETag 时，常规模式为：</source>
          <target state="new">当你使用 ETag 时，常规模式为：</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>通过创建、列出或获取操作来获取 ETag。</source>
          <target state="new">通过创建、列出或获取操作来获取 ETag。</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>执行一个操作，查看 ETag 值是否尚未修改。</source>
          <target state="new">执行一个操作，查看 ETag 值是否尚未修改。</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>如果值已修改，则表明在你获得 ETag 值后，其他客户端或实例已修改该 Blob 或容器。</source>
          <target state="new">如果值已修改，则表明在你获得 ETag 值后，其他客户端或实例已修改该 Blob 或容器。</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>租约</source>
          <target state="new">租约</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>新的租约可使用 <bpt id="p1">**</bpt>acquireLease<ept id="p1">**</ept> 方法获取，只需指定您希望获取其租约的 Blob 或容器即可。例如，以下代码将获取 <bpt id="p2">**</bpt>myblob<ept id="p2">**</ept> 的租约。</source>
          <target state="new">新的租约可使用 <bpt id="p1">**</bpt>acquireLease<ept id="p1">**</ept> 方法获取，只需指定您希望获取其租约的 Blob 或容器即可。例如，以下代码将获取 <bpt id="p2">**</bpt>myblob<ept id="p2">**</ept> 的租约。</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>对 <bpt id="p1">**</bpt>myblob<ept id="p1">**</ept> 的后续操作必须提供 <ph id="ph1">`options.leaseId`</ph> 参数。租约 ID 作为 <ph id="ph2">`result.id`</ph> 从 <bpt id="p2">**</bpt>acquireLease<ept id="p2">**</ept> 返回。</source>
          <target state="new">对 <bpt id="p1">**</bpt>myblob<ept id="p1">**</ept> 的后续操作必须提供 <ph id="ph1">`options.leaseId`</ph> 参数。租约 ID 作为 <ph id="ph2">`result.id`</ph> 从 <bpt id="p2">**</bpt>acquireLease<ept id="p2">**</ept> 返回。</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 默认情况下，租约期限为无期。您可以指定一个无限的租期（15 到 60 秒），只需提供 <ph id="ph2">`options.leaseDuration`</ph> 参数即可。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 默认情况下，租约期限为无期。您可以指定一个无限的租期（15 到 60 秒），只需提供 <ph id="ph2">`options.leaseDuration`</ph> 参数即可。</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>若要删除租约，请使用 <bpt id="p1">**</bpt>releaseLease<ept id="p1">**</ept>。若要中断租约，但又要防止其他人在您的原始租约到期之前获得新租约，则可使用 <bpt id="p2">**</bpt>breakLease<ept id="p2">**</ept>。</source>
          <target state="new">若要删除租约，请使用 <bpt id="p1">**</bpt>releaseLease<ept id="p1">**</ept>。若要中断租约，但又要防止其他人在您的原始租约到期之前获得新租约，则可使用 <bpt id="p2">**</bpt>breakLease<ept id="p2">**</ept>。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>使用共享访问签名</source>
          <target state="new">使用共享访问签名</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>共享访问签名 (SAS) 是一种安全的方法，用于对 Blob 和容器进行细致访问而无需提供你的存储帐户名或密钥。通常使用共享访问签名来提供对你的数据的有限访问权限，例如允许移动应用程序访问 Blob。</source>
          <target state="new">共享访问签名 (SAS) 是一种安全的方法，用于对 Blob 和容器进行细致访问而无需提供你的存储帐户名或密钥。通常使用共享访问签名来提供对你的数据的有限访问权限，例如允许移动应用程序访问 Blob。</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 虽然你也可以允许匿名访问 Blob，但共享访问签名可以让你提供更受控制的访问，因为你必须生成 SAS。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 虽然你也可以允许匿名访问 Blob，但共享访问签名可以让你提供更受控制的访问，因为你必须生成 SAS。</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>受信任的应用程序（例如基于云的服务）可使用 <bpt id="p1">**</bpt>BlobService<ept id="p1">**</ept> 的 <bpt id="p2">**</bpt>generateSharedAccessSignature<ept id="p2">**</ept> 生成共享访问签名，然后将其提供给不受信任的或不完全受信任的应用程序，例如移动应用。共享访问签名可使用策略生成，该策略描述了共享访问签名的生效日期和失效日期，以及授予共享访问签名持有者的访问级别。</source>
          <target state="new">受信任的应用程序（例如基于云的服务）可使用 <bpt id="p1">**</bpt>BlobService<ept id="p1">**</ept> 的 <bpt id="p2">**</bpt>generateSharedAccessSignature<ept id="p2">**</ept> 生成共享访问签名，然后将其提供给不受信任的或不完全受信任的应用程序，例如移动应用。共享访问签名可使用策略生成，该策略描述了共享访问签名的生效日期和失效日期，以及授予共享访问签名持有者的访问级别。</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>以下代码示例生成了一个新的共享访问策略，该策略将允许共享访问签名持有者对 <bpt id="p1">**</bpt>myblob<ept id="p1">**</ept> Blob 执行读取操作，在创建后 100 分钟过期。</source>
          <target state="new">以下代码示例生成了一个新的共享访问策略，该策略将允许共享访问签名持有者对 <bpt id="p1">**</bpt>myblob<ept id="p1">**</ept> Blob 执行读取操作，在创建后 100 分钟过期。</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>请注意，还必须提供主机信息，因为共享访问签名持有者尝试访问容器时，必须提供该信息。</source>
          <target state="new">请注意，还必须提供主机信息，因为共享访问签名持有者尝试访问容器时，必须提供该信息。</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>然后，客户端应用程序将共享访问签名用于 <bpt id="p1">**</bpt>BlobServiceWithSAS<ept id="p1">**</ept>，以便针对 Blob 执行操作。以下语句获取有关 <bpt id="p2">**</bpt>myblob<ept id="p2">**</ept> 的信息。</source>
          <target state="new">然后，客户端应用程序将共享访问签名用于 <bpt id="p1">**</bpt>BlobServiceWithSAS<ept id="p1">**</ept>，以便针对 Blob 执行操作。以下语句获取有关 <bpt id="p2">**</bpt>myblob<ept id="p2">**</ept> 的信息。</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>由于共享访问签名在生成时具有只读访问权限，因此如果尝试修改 Blob，则会返回错误。</source>
          <target state="new">由于共享访问签名在生成时具有只读访问权限，因此如果尝试修改 Blob，则会返回错误。</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>访问控制列表</source>
          <target state="new">访问控制列表</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>你还可以使用访问控制列表 (ACL) 为 SAS 设置访问策略。如果你希望允许多个客户端访问某个容器，但为每个客户端提供了不同的访问策略，则访问控制列表会很有用。</source>
          <target state="new">你还可以使用访问控制列表 (ACL) 为 SAS 设置访问策略。如果你希望允许多个客户端访问某个容器，但为每个客户端提供了不同的访问策略，则访问控制列表会很有用。</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>ACL 是使用一组访问策略实施的，每个策略都有一个关联的 ID。以下代码示例定义了两个策略，一个用于“user1”，一个用于“user2”：</source>
          <target state="new">ACL 是使用一组访问策略实施的，每个策略都有一个关联的 ID。以下代码示例定义了两个策略，一个用于“user1”，一个用于“user2”：</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>以下代码示例将获取 <bpt id="p1">**</bpt>mycontainer<ept id="p1">**</ept> 的当前 ACL，然后使用 <bpt id="p2">**</bpt>setBlobAcl<ept id="p2">**</ept> 添加新策略。此方法具有以下用途：</source>
          <target state="new">以下代码示例将获取 <bpt id="p1">**</bpt>mycontainer<ept id="p1">**</ept> 的当前 ACL，然后使用 <bpt id="p2">**</bpt>setBlobAcl<ept id="p2">**</ept> 添加新策略。此方法具有以下用途：</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>设置 ACL 后，你可以根据某个策略的 ID 创建共享访问签名。以下代码示例将为“user2”创建新的共享访问签名：</source>
          <target state="new">设置 ACL 后，你可以根据某个策略的 ID 创建共享访问签名。以下代码示例将为“user2”创建新的共享访问签名：</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>有关详细信息，请参阅以下资源。</source>
          <target state="new">有关详细信息，请参阅以下资源。</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Azure Storage SDK for Node API 参考</source>
          <target state="new">Azure Storage SDK for Node API 参考</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>[Azure 存储团队博客][]</source>
          <target state="new">[Azure 存储团队博客][]</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>GitHub 上的 <bpt id="p1">[</bpt>Azure Storage SDK for Node<ept id="p1">][]</ept> 存储库</source>
          <target state="new">GitHub 上的 <bpt id="p1">[</bpt>Azure Storage SDK for Node<ept id="p1">][]</ept> 存储库</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Node.js 开发人员中心</source>
          <target state="new">Node.js 开发人员中心</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>使用 AzCopy 命令行实用程序传输数据</source>
          <target state="new">使用 AzCopy 命令行实用程序传输数据</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>