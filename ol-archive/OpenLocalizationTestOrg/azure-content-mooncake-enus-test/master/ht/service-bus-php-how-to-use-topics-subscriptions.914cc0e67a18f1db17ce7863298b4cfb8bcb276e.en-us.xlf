<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">552e99454ecb70a5132424b407f286a7f8b01f61</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 PHP 使用服务总线主题 | Microsoft Azure</source>
          <target state="new">如何通过 PHP 使用服务总线主题 | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何通过 PHP 使用 Azure 中的服务总线主题。</source>
          <target state="new">了解如何通过 PHP 使用 Azure 中的服务总线主题。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何使用服务总线主题和订阅</source>
          <target state="new">如何使用服务总线主题和订阅</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>本文说明如何使用服务总线主题和订阅。示例是用 PHP 编写的并使用了 <bpt id="p1">[</bpt>Azure SDK for PHP<ept id="p1">](/documentation/articles/php-download-sdk)</ept>。涉及的任务包括<bpt id="p2">**</bpt>创建主题和订阅<ept id="p2">**</ept>、<bpt id="p3">**</bpt>创建订阅筛选器<ept id="p3">**</ept>、<bpt id="p4">**</bpt>将消息发送到主题<ept id="p4">**</ept>、<bpt id="p5">**</bpt>从订阅接收消息<ept id="p5">**</ept>以及<bpt id="p6">**</bpt>删除主题和订阅<ept id="p6">**</ept>。</source>
          <target state="new">本文说明如何使用服务总线主题和订阅。示例是用 PHP 编写的并使用了 <bpt id="p1">[</bpt>Azure SDK for PHP<ept id="p1">](/documentation/articles/php-download-sdk)</ept>。涉及的任务包括<bpt id="p2">**</bpt>创建主题和订阅<ept id="p2">**</ept>、<bpt id="p3">**</bpt>创建订阅筛选器<ept id="p3">**</ept>、<bpt id="p4">**</bpt>将消息发送到主题<ept id="p4">**</ept>、<bpt id="p5">**</bpt>从订阅接收消息<ept id="p5">**</ept>以及<bpt id="p6">**</bpt>删除主题和订阅<ept id="p6">**</ept>。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>创建 PHP 应用程序</source>
          <target state="new">创建 PHP 应用程序</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>创建访问 Azure Blob 服务的 PHP 应用程序的唯一要求是从代码中引用 <bpt id="p1">[</bpt>Azure SDK for PHP<ept id="p1">](/documentation/articles/php-download-sdk)</ept> 中的类。你可以使用任何开发工具或记事本创建应用程序。</source>
          <target state="new">创建访问 Azure Blob 服务的 PHP 应用程序的唯一要求是从代码中引用 <bpt id="p1">[</bpt>Azure SDK for PHP<ept id="p1">](/documentation/articles/php-download-sdk)</ept> 中的类。你可以使用任何开发工具或记事本创建应用程序。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>你的 PHP 安装还必须已安装并启用 <bpt id="p1">[</bpt>OpenSSL 扩展<ept id="p1">](http://php.net/openssl)</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>你的 PHP 安装还必须已安装并启用 <bpt id="p1">[</bpt>OpenSSL 扩展<ept id="p1">](http://php.net/openssl)</ept>。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>本文说明如何使用服务功能，这些功能可在 PHP 应用程序中本地调用，或通过在 Azure 的 Web 角色、辅助角色或网站中运行的代码调用。</source>
          <target state="new">本文说明如何使用服务功能，这些功能可在 PHP 应用程序中本地调用，或通过在 Azure 的 Web 角色、辅助角色或网站中运行的代码调用。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>获取 Azure 客户端库</source>
          <target state="new">获取 Azure 客户端库</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>配置应用程序以使用 Service Bus</source>
          <target state="new">配置应用程序以使用 Service Bus</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>使用服务总线 API：</source>
          <target state="new">使用服务总线 API：</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">[</bpt>require_once<ept id="p1">][require-once]</ept> 语句引用 autoloader 文件。</source>
          <target state="new">使用 <bpt id="p1">[</bpt>require_once<ept id="p1">][require-once]</ept> 语句引用 autoloader 文件。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>引用可使用的所有类。</source>
          <target state="new">引用可使用的所有类。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>以下示例演示如何包含 autoloader 文件并引用 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 类。</source>
          <target state="new">以下示例演示如何包含 autoloader 文件并引用 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 类。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>本示例（以及本文中的其他示例）假定你已通过 Composer 安装用于 Azure 的 PHP 客户端库。如果你已手动安装这些库或将其作为 PEAR 包安装，则必须引用 <bpt id="p1">**</bpt>WindowsAzure.php<ept id="p1">**</ept> autoloader 文件。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>本示例（以及本文中的其他示例）假定你已通过 Composer 安装用于 Azure 的 PHP 客户端库。如果你已手动安装这些库或将其作为 PEAR 包安装，则必须引用 <bpt id="p1">**</bpt>WindowsAzure.php<ept id="p1">**</ept> autoloader 文件。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>在以下示例中，<ph id="ph1">`require_once`</ph> 语句将始终显示，但只会引用执行该示例所需的类。</source>
          <target state="new">在以下示例中，<ph id="ph1">`require_once`</ph> 语句将始终显示，但只会引用执行该示例所需的类。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>设置服务总线连接</source>
          <target state="new">设置服务总线连接</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>若要实例化 Azure 服务总线客户端，必须先设置采用以下格式的有效连接字符串：</source>
          <target state="new">若要实例化 Azure 服务总线客户端，必须先设置采用以下格式的有效连接字符串：</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>其中，<bpt id="p1">**</bpt>Endpoint<ept id="p1">**</ept> 的格式通常为 <ph id="ph1">`https://[yourNamespace].servicebus.chinacloudapi.cn`</ph>。</source>
          <target state="new">其中，<bpt id="p1">**</bpt>Endpoint<ept id="p1">**</ept> 的格式通常为 <ph id="ph1">`https://[yourNamespace].servicebus.chinacloudapi.cn`</ph>。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>若要创建任何 Azure 服务客户端，必须使用 <bpt id="p1">**</bpt>ServicesBuilder<ept id="p1">**</ept> 类。你可以：</source>
          <target state="new">若要创建任何 Azure 服务客户端，必须使用 <bpt id="p1">**</bpt>ServicesBuilder<ept id="p1">**</ept> 类。你可以：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>将连接字符串直接传递给它。</source>
          <target state="new">将连接字符串直接传递给它。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>CloudConfigurationManager (CCM)<ept id="p1">**</ept> 检查多个外部源以获取连接字符串：</source>
          <target state="new">使用 <bpt id="p1">**</bpt>CloudConfigurationManager (CCM)<ept id="p1">**</ept> 检查多个外部源以获取连接字符串：</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>默认情况下，它附带了对一个外部源的支持 - 环境变量。</source>
          <target state="new">默认情况下，它附带了对一个外部源的支持 - 环境变量。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>您可通过扩展 <bpt id="p1">**</bpt>ConnectionStringSource<ept id="p1">**</ept> 类来添加新源。</source>
          <target state="new">您可通过扩展 <bpt id="p1">**</bpt>ConnectionStringSource<ept id="p1">**</ept> 类来添加新源。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>在此处列出的示例中，将直接传递连接字符串。</source>
          <target state="new">在此处列出的示例中，将直接传递连接字符串。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>创建主题</source>
          <target state="new">创建主题</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>你可以通过 <bpt id="p1">**</bpt>ServiceBusRestProxy<ept id="p1">**</ept> 类执行服务总线主题的管理操作。<bpt id="p2">**</bpt>ServiceBusRestProxy<ept id="p2">**</ept> 对象是通过 <bpt id="p3">**</bpt>ServicesBuilder::createServiceBusService<ept id="p3">**</ept> 工厂方法与一个适当的连接字符串（该字符串封装了令牌权限以进行管理）构造的。</source>
          <target state="new">你可以通过 <bpt id="p1">**</bpt>ServiceBusRestProxy<ept id="p1">**</ept> 类执行服务总线主题的管理操作。<bpt id="p2">**</bpt>ServiceBusRestProxy<ept id="p2">**</ept> 对象是通过 <bpt id="p3">**</bpt>ServicesBuilder::createServiceBusService<ept id="p3">**</ept> 工厂方法与一个适当的连接字符串（该字符串封装了令牌权限以进行管理）构造的。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>以下示例说明如何实例化 <bpt id="p1">**</bpt>ServiceBusRestProxy<ept id="p1">**</ept> 并调用 <bpt id="p2">**</bpt>ServiceBusRestProxy-&gt;createTopic<ept id="p2">**</ept> 在 <ph id="ph1">`MySBNamespace`</ph> 命名空间中创建名为 <ph id="ph2">`mytopic`</ph> 的主题：</source>
          <target state="new">以下示例说明如何实例化 <bpt id="p1">**</bpt>ServiceBusRestProxy<ept id="p1">**</ept> 并调用 <bpt id="p2">**</bpt>ServiceBusRestProxy-&gt;createTopic<ept id="p2">**</ept> 在 <ph id="ph1">`MySBNamespace`</ph> 命名空间中创建名为 <ph id="ph2">`mytopic`</ph> 的主题：</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 你可以对 <ph id="ph2">`ServiceBusRestProxy`</ph> 对象使用 <ph id="ph3">`listTopics`</ph> 方法，以检查具有指定名称的主题是否已位于服务命名空间中。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 你可以对 <ph id="ph2">`ServiceBusRestProxy`</ph> 对象使用 <ph id="ph3">`listTopics`</ph> 方法，以检查具有指定名称的主题是否已位于服务命名空间中。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>创建订阅</source>
          <target state="new">创建订阅</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>主题订阅同样使用 <bpt id="p1">**</bpt>ServiceBusRestProxy-&gt;createSubscription<ept id="p1">**</ept> 方法创建。订阅已命名，并且具有一个限制传递到订阅的虚拟队列的消息集的可选筛选器。</source>
          <target state="new">主题订阅同样使用 <bpt id="p1">**</bpt>ServiceBusRestProxy-&gt;createSubscription<ept id="p1">**</ept> 方法创建。订阅已命名，并且具有一个限制传递到订阅的虚拟队列的消息集的可选筛选器。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>创建具有默认 (MatchAll) 筛选器的订阅</source>
          <target state="new">创建具有默认 (MatchAll) 筛选器的订阅</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MatchAll<ept id="p1">**</ept> 筛选器是默认筛选器，在创建新订阅时未指定筛选器的情况下使用。使用 <bpt id="p2">**</bpt>MatchAll<ept id="p2">**</ept> 筛选器时，发布到主题的所有消息都将置于订阅的虚拟队列中。以下示例将创建名为“mysubscription”的订阅，并使用默认的 <bpt id="p3">**</bpt>MatchAll<ept id="p3">**</ept> 筛选器。</source>
          <target state="new"><bpt id="p1">**</bpt>MatchAll<ept id="p1">**</ept> 筛选器是默认筛选器，在创建新订阅时未指定筛选器的情况下使用。使用 <bpt id="p2">**</bpt>MatchAll<ept id="p2">**</ept> 筛选器时，发布到主题的所有消息都将置于订阅的虚拟队列中。以下示例将创建名为“mysubscription”的订阅，并使用默认的 <bpt id="p3">**</bpt>MatchAll<ept id="p3">**</ept> 筛选器。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>创建具有筛选器的订阅</source>
          <target state="new">创建具有筛选器的订阅</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>还可以设置筛选器，以指定发送到主题的哪些消息应该在特定主题订阅中显示。订阅支持的最灵活的一种筛选器是 <bpt id="p1">**</bpt>SqlFilter<ept id="p1">**</ept>，它实现了一部分 SQL92 功能。SQL 筛选器将对发布到主题的消息的属性进行操作。有关 SqlFilters 的详细信息，请参阅 <bpt id="p2">[</bpt>SqlFilter.SqlExpression 属性<ept id="p2">][sqlfilter]</ept>。</source>
          <target state="new">还可以设置筛选器，以指定发送到主题的哪些消息应该在特定主题订阅中显示。订阅支持的最灵活的一种筛选器是 <bpt id="p1">**</bpt>SqlFilter<ept id="p1">**</ept>，它实现了一部分 SQL92 功能。SQL 筛选器将对发布到主题的消息的属性进行操作。有关 SqlFilters 的详细信息，请参阅 <bpt id="p2">[</bpt>SqlFilter.SqlExpression 属性<ept id="p2">][sqlfilter]</ept>。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>有关订阅的每个规则单独处理传入消息，并将其结果消息添加到订阅。此外，每个新订阅的筛选器具有一个默认 <bpt id="p1">**</bpt>Rule<ept id="p1">**</ept> 对象，该对象包含将主题中的所有消息添加到订阅的筛选器。若要仅接收与您的筛选器的消息，您必须删除默认规则。可以使用 <ph id="ph2">`ServiceBusRestProxy-&gt;deleteRule`</ph> 方法删除默认规则。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>有关订阅的每个规则单独处理传入消息，并将其结果消息添加到订阅。此外，每个新订阅的筛选器具有一个默认 <bpt id="p1">**</bpt>Rule<ept id="p1">**</ept> 对象，该对象包含将主题中的所有消息添加到订阅的筛选器。若要仅接收与您的筛选器的消息，您必须删除默认规则。可以使用 <ph id="ph2">`ServiceBusRestProxy-&gt;deleteRule`</ph> 方法删除默认规则。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>以下示例将创建一个名为 <bpt id="p1">**</bpt>HighMessages<ept id="p1">**</ept> 的订阅，该订阅包含的 <bpt id="p2">**</bpt>SqlFilter<ept id="p2">**</ept> 仅选择自定义 <bpt id="p3">**</bpt>MessageNumber<ept id="p3">**</ept> 属性大于 3 的的消息（有关将自定义属性添加到消息的信息，请参阅<bpt id="p4">[</bpt>将消息发送到主题<ept id="p4">](#send-messages-to-a-topic)</ept>）：</source>
          <target state="new">以下示例将创建一个名为 <bpt id="p1">**</bpt>HighMessages<ept id="p1">**</ept> 的订阅，该订阅包含的 <bpt id="p2">**</bpt>SqlFilter<ept id="p2">**</ept> 仅选择自定义 <bpt id="p3">**</bpt>MessageNumber<ept id="p3">**</ept> 属性大于 3 的的消息（有关将自定义属性添加到消息的信息，请参阅<bpt id="p4">[</bpt>将消息发送到主题<ept id="p4">](#send-messages-to-a-topic)</ept>）：</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>请注意，此代码需要使用另一个命名空间：<ph id="ph1">`WindowsAzure\ServiceBus\Models\SubscriptionInfo`</ph>。</source>
          <target state="new">请注意，此代码需要使用另一个命名空间：<ph id="ph1">`WindowsAzure\ServiceBus\Models\SubscriptionInfo`</ph>。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>类似地，以下示例创建一个名为 <bpt id="p1">**</bpt>LowMessages<ept id="p1">**</ept> 的订阅，其 <bpt id="p2">**</bpt>SqlFilter<ept id="p2">**</ept> 只选择 <bpt id="p3">**</bpt>MessageNumber<ept id="p3">**</ept> 属性小于或等于 3 的消息：</source>
          <target state="new">类似地，以下示例创建一个名为 <bpt id="p1">**</bpt>LowMessages<ept id="p1">**</ept> 的订阅，其 <bpt id="p2">**</bpt>SqlFilter<ept id="p2">**</ept> 只选择 <bpt id="p3">**</bpt>MessageNumber<ept id="p3">**</ept> 属性小于或等于 3 的消息：</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>现在，当消息发送到 <ph id="ph1">`mytopic`</ph> 主题后，它总是会传送给订阅了 <ph id="ph2">`mysubscription`</ph> 订阅的接收者，并且选择性地传送给订阅了 <ph id="ph3">`HighMessages`</ph> 和 <ph id="ph4">`LowMessages`</ph> 订阅的接收者（具体取决于消息内容）。</source>
          <target state="new">现在，当消息发送到 <ph id="ph1">`mytopic`</ph> 主题后，它总是会传送给订阅了 <ph id="ph2">`mysubscription`</ph> 订阅的接收者，并且选择性地传送给订阅了 <ph id="ph3">`HighMessages`</ph> 和 <ph id="ph4">`LowMessages`</ph> 订阅的接收者（具体取决于消息内容）。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>将消息发送到主题</source>
          <target state="new">将消息发送到主题</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>若要向服务总线主题发送消息，你的应用程序将调用 <bpt id="p1">**</bpt>ServiceBusRestProxy-&gt;sendTopicMessage<ept id="p1">**</ept> 方法。以下代码演示了如何将消息发送到前面在 <ph id="ph1">`MySBNamespace`</ph> 服务命名空间中创建的 <ph id="ph2">`mytopic`</ph> 主题。</source>
          <target state="new">若要向服务总线主题发送消息，你的应用程序将调用 <bpt id="p1">**</bpt>ServiceBusRestProxy-&gt;sendTopicMessage<ept id="p1">**</ept> 方法。以下代码演示了如何将消息发送到前面在 <ph id="ph1">`MySBNamespace`</ph> 服务命名空间中创建的 <ph id="ph2">`mytopic`</ph> 主题。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>发送到服务总线主题的消息是 <bpt id="p1">**</bpt>BrokeredMessage<ept id="p1">**</ept> 类的实例。<bpt id="p2">**</bpt>BrokeredMessage<ept id="p2">**</ept> 对象包含一组标准属性和方法（如 <bpt id="p3">**</bpt>getLabel<ept id="p3">**</ept>、<bpt id="p4">**</bpt>getTimeToLive<ept id="p4">**</ept>、<bpt id="p5">**</bpt>setLabel<ept id="p5">**</ept> 和 <bpt id="p6">**</bpt>setTimeToLive<ept id="p6">**</ept>）以及用来保存自定义应用程序特定属性的属性。以下示例演示了如何将 5 条测试消息发送到前面创建的 <ph id="ph1">`mytopic`</ph> 主题。<bpt id="p7">**</bpt>setProperty<ept id="p7">**</ept> 方法用于将自定义属性 (<ph id="ph2">`MessageNumber`</ph>) 添加到每条消息。请注意，<ph id="ph3">`MessageNumber`</ph> 属性值在每条消息中都不同（这可用于确定接收消息的订阅，如<bpt id="p8">[</bpt>创建订阅<ept id="p8">](#create-a-subscription)</ept>部分中所述）：</source>
          <target state="new">发送到服务总线主题的消息是 <bpt id="p1">**</bpt>BrokeredMessage<ept id="p1">**</ept> 类的实例。<bpt id="p2">**</bpt>BrokeredMessage<ept id="p2">**</ept> 对象包含一组标准属性和方法（如 <bpt id="p3">**</bpt>getLabel<ept id="p3">**</ept>、<bpt id="p4">**</bpt>getTimeToLive<ept id="p4">**</ept>、<bpt id="p5">**</bpt>setLabel<ept id="p5">**</ept> 和 <bpt id="p6">**</bpt>setTimeToLive<ept id="p6">**</ept>）以及用来保存自定义应用程序特定属性的属性。以下示例演示了如何将 5 条测试消息发送到前面创建的 <ph id="ph1">`mytopic`</ph> 主题。<bpt id="p7">**</bpt>setProperty<ept id="p7">**</ept> 方法用于将自定义属性 (<ph id="ph2">`MessageNumber`</ph>) 添加到每条消息。请注意，<ph id="ph3">`MessageNumber`</ph> 属性值在每条消息中都不同（这可用于确定接收消息的订阅，如<bpt id="p8">[</bpt>创建订阅<ept id="p8">](#create-a-subscription)</ept>部分中所述）：</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Service Bus 队列支持最大为 256 KB 的消息（标头最大为 64 KB，其中包括标准和自定义应用程序属性）。一个队列可包含的消息数不受限制，但消息的总大小受限。队列大小的上限为 5 GB。有关配额的详细信息，请参阅 <bpt id="p1">[</bpt>Azure 队列和服务总线队列<ept id="p1">][]</ept>。</source>
          <target state="new">Service Bus 队列支持最大为 256 KB 的消息（标头最大为 64 KB，其中包括标准和自定义应用程序属性）。一个队列可包含的消息数不受限制，但消息的总大小受限。队列大小的上限为 5 GB。有关配额的详细信息，请参阅 <bpt id="p1">[</bpt>Azure 队列和服务总线队列<ept id="p1">][]</ept>。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>从订阅接收消息</source>
          <target state="new">从订阅接收消息</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>从订阅接收消息的最佳方式是使用 <bpt id="p1">**</bpt>ServiceBusRestProxy-&gt;receiveSubscriptionMessage<ept id="p1">**</ept> 方法。收到的消息可在两种不同模式下工作：<bpt id="p2">**</bpt>ReceiveAndDelete<ept id="p2">**</ept>（默认）和 <bpt id="p3">**</bpt>PeekLock<ept id="p3">**</ept>。</source>
          <target state="new">从订阅接收消息的最佳方式是使用 <bpt id="p1">**</bpt>ServiceBusRestProxy-&gt;receiveSubscriptionMessage<ept id="p1">**</ept> 方法。收到的消息可在两种不同模式下工作：<bpt id="p2">**</bpt>ReceiveAndDelete<ept id="p2">**</ept>（默认）和 <bpt id="p3">**</bpt>PeekLock<ept id="p3">**</ept>。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>当使用 <bpt id="p1">**</bpt>ReceiveAndDelete<ept id="p1">**</ept> 模式时，接收是一个单步操作，即，当服务总线接收订阅中的消息读取请求时，它会将消息标记为“正在使用”并将其返回给应用程序。<bpt id="p2">**</bpt>ReceiveAndDelete<ept id="p2">**</ept> 模式是最简单的模式，最适合应用程序允许出现故障时不处理消息的方案。为了理解这一点，可以考虑这样一种情形：使用方发出接收请求，但在处理该请求前发生了崩溃。由于 Service Bus 会将消息标记为“将使用”，因此当应用程序重启并重新开始使用消息时，它会丢失在发生崩溃前使用的消息。</source>
          <target state="new">当使用 <bpt id="p1">**</bpt>ReceiveAndDelete<ept id="p1">**</ept> 模式时，接收是一个单步操作，即，当服务总线接收订阅中的消息读取请求时，它会将消息标记为“正在使用”并将其返回给应用程序。<bpt id="p2">**</bpt>ReceiveAndDelete<ept id="p2">**</ept> 模式是最简单的模式，最适合应用程序允许出现故障时不处理消息的方案。为了理解这一点，可以考虑这样一种情形：使用方发出接收请求，但在处理该请求前发生了崩溃。由于 Service Bus 会将消息标记为“将使用”，因此当应用程序重启并重新开始使用消息时，它会丢失在发生崩溃前使用的消息。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>PeekLock<ept id="p1">**</ept> 模式下，接收消息会变成一个两阶段操作，这将能够支持不能允许丢失消息的应用程序。当 Service Bus 收到请求时，它会查找下一条要使用的消息，锁定该消息以防其他使用者接收，然后将该消息返回到应用程序。在应用程序处理完消息（或以可靠方式存储消息以供将来处理）后，它通过将收到的消息传送到 <bpt id="p2">**</bpt>ServiceBusRestProxy-&gt;deleteMessage<ept id="p2">**</ept> 来完成接收过程的第二个阶段。当服务总线发现 <bpt id="p3">**</bpt>deleteMessage<ept id="p3">**</ept> 调用时，它会将消息标记为“正在使用”并将其从队列中删除。</source>
          <target state="new">在 <bpt id="p1">**</bpt>PeekLock<ept id="p1">**</ept> 模式下，接收消息会变成一个两阶段操作，这将能够支持不能允许丢失消息的应用程序。当 Service Bus 收到请求时，它会查找下一条要使用的消息，锁定该消息以防其他使用者接收，然后将该消息返回到应用程序。在应用程序处理完消息（或以可靠方式存储消息以供将来处理）后，它通过将收到的消息传送到 <bpt id="p2">**</bpt>ServiceBusRestProxy-&gt;deleteMessage<ept id="p2">**</ept> 来完成接收过程的第二个阶段。当服务总线发现 <bpt id="p3">**</bpt>deleteMessage<ept id="p3">**</ept> 调用时，它会将消息标记为“正在使用”并将其从队列中删除。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>以下示例演示了如何使用 <bpt id="p1">**</bpt>PeekLock<ept id="p1">**</ept> 模式（非默认模式）接收和处理消息。</source>
          <target state="new">以下示例演示了如何使用 <bpt id="p1">**</bpt>PeekLock<ept id="p1">**</ept> 模式（非默认模式）接收和处理消息。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>如何：处理应用程序崩溃和不可读消息</source>
          <target state="new">如何：处理应用程序崩溃和不可读消息</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Service Bus 提供了相关功能来帮助你轻松地从应用程序错误或消息处理问题中恢复。如果接收方应用程序出于某种原因无法处理消息，它可以对收到的消息调用 <bpt id="p1">**</bpt>unlockMessage<ept id="p1">**</ept> 方法（而不是 <bpt id="p2">**</bpt>deleteMessage<ept id="p2">**</ept> 方法）。这将导致 Service Bus 解锁队列中的消息并使其能够重新被同一个正在使用的应用程序或其他正在使用的应用程序接收。</source>
          <target state="new">Service Bus 提供了相关功能来帮助你轻松地从应用程序错误或消息处理问题中恢复。如果接收方应用程序出于某种原因无法处理消息，它可以对收到的消息调用 <bpt id="p1">**</bpt>unlockMessage<ept id="p1">**</ept> 方法（而不是 <bpt id="p2">**</bpt>deleteMessage<ept id="p2">**</ept> 方法）。这将导致 Service Bus 解锁队列中的消息并使其能够重新被同一个正在使用的应用程序或其他正在使用的应用程序接收。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>还存在与队列中已锁定消息关联的超时，并且如果应用程序无法在锁定超时到期之前处理消息（例如，如果应用程序崩溃），服务总线将自动解锁该消息并使它可再次被接收。</source>
          <target state="new">还存在与队列中已锁定消息关联的超时，并且如果应用程序无法在锁定超时到期之前处理消息（例如，如果应用程序崩溃），服务总线将自动解锁该消息并使它可再次被接收。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>如果在处理消息之后但在发出 <bpt id="p1">**</bpt>deleteMessage<ept id="p1">**</ept> 请求之前应用程序发生崩溃，该消息将在应用程序重新启动时重新传送给它。此情况通常称作<bpt id="p2">**</bpt>至少处理一次<ept id="p2">**</ept>，即每条消息将至少被处理一次，但在某些情况下，同一消息可能会被重新传送。如果方案无法容忍重复处理，则应用程序开发人员应向其应用程序添加更多逻辑以处理重复消息传送。通常可使用消息的 <bpt id="p3">**</bpt>getMessageId<ept id="p3">**</ept> 方法实现此操作，这在多个传送尝试中保持不变。</source>
          <target state="new">如果在处理消息之后但在发出 <bpt id="p1">**</bpt>deleteMessage<ept id="p1">**</ept> 请求之前应用程序发生崩溃，该消息将在应用程序重新启动时重新传送给它。此情况通常称作<bpt id="p2">**</bpt>至少处理一次<ept id="p2">**</ept>，即每条消息将至少被处理一次，但在某些情况下，同一消息可能会被重新传送。如果方案无法容忍重复处理，则应用程序开发人员应向其应用程序添加更多逻辑以处理重复消息传送。通常可使用消息的 <bpt id="p3">**</bpt>getMessageId<ept id="p3">**</ept> 方法实现此操作，这在多个传送尝试中保持不变。</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>删除主题和订阅</source>
          <target state="new">删除主题和订阅</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>若要删除主题或订阅，请分别使用 <bpt id="p1">**</bpt>ServiceBusRestProxy-&gt;deleteTopic<ept id="p1">**</ept> 或 <bpt id="p2">**</bpt>ServiceBusRestProxy-&gt;deleteSubscripton<ept id="p2">**</ept> 方法。请注意，删除某个主题也会删除向该主题注册的所有订阅。</source>
          <target state="new">若要删除主题或订阅，请分别使用 <bpt id="p1">**</bpt>ServiceBusRestProxy-&gt;deleteTopic<ept id="p1">**</ept> 或 <bpt id="p2">**</bpt>ServiceBusRestProxy-&gt;deleteSubscripton<ept id="p2">**</ept> 方法。请注意，删除某个主题也会删除向该主题注册的所有订阅。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>以下示例演示了如何删除名为 <ph id="ph1">`mytopic`</ph> 的主题及其注册的订阅。</source>
          <target state="new">以下示例演示了如何删除名为 <ph id="ph1">`mytopic`</ph> 的主题及其注册的订阅。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>通过使用 <bpt id="p1">**</bpt>deleteSubscription<ept id="p1">**</ept> 方法，你可以单独删除订阅：</source>
          <target state="new">通过使用 <bpt id="p1">**</bpt>deleteSubscription<ept id="p1">**</ept> 方法，你可以单独删除订阅：</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>现在，你已了解服务总线队列的基础知识，请参阅<bpt id="p1">[</bpt>队列、主题和订阅<ept id="p1">][]</ept>以获取更多信息。</source>
          <target state="new">现在，你已了解服务总线队列的基础知识，请参阅<bpt id="p1">[</bpt>队列、主题和订阅<ept id="p1">][]</ept>以获取更多信息。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>