<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">eec6b927111db8a282a946ceb2b6354d5a77be6f</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>使用 JavaScript 后端移动服务</source>
          <target state="new">使用 JavaScript 后端移动服务</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>提供有关如何在 Azure 移动服务中定义、注册以及使用服务器脚本的示例。</source>
          <target state="new">提供有关如何在 Azure 移动服务中定义、注册以及使用服务器脚本的示例。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>使用 JavaScript 后端移动服务</source>
          <target state="new">使用 JavaScript 后端移动服务</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>本文提供有关如何在 Azure 移动服务中使用 JavaScript 后端的详细信息和示例。</source>
          <target state="new">本文提供有关如何在 Azure 移动服务中使用 JavaScript 后端的详细信息和示例。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="intro"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>介绍</source>
          <target state="new"><ph id="ph1">&lt;a name="intro"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>介绍</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>在 JavaScript 后端移动服务中，你可以定义 JavaScript 代码形式的自定义业务逻辑，该代码将在服务器中存储和执行。此服务器脚本代码将分配到下列服务器功能之一：</source>
          <target state="new">在 JavaScript 后端移动服务中，你可以定义 JavaScript 代码形式的自定义业务逻辑，该代码将在服务器中存储和执行。此服务器脚本代码将分配到下列服务器功能之一：</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>对给定表执行的插入、读取、更新或删除操作<ept id="p1">][Table operations]</ept>。</source>
          <target state="new"><bpt id="p1">[</bpt>对给定表执行的插入、读取、更新或删除操作<ept id="p1">][Table operations]</ept>。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>计划的作业<ept id="p1">][Job Scheduler]</ept>。</source>
          <target state="new"><bpt id="p1">[</bpt>计划的作业<ept id="p1">][Job Scheduler]</ept>。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>自定义 API 中定义的 HTTP 方法<ept id="p1">][Custom API anchor]</ept>。</source>
          <target state="new"><bpt id="p1">[</bpt>自定义 API 中定义的 HTTP 方法<ept id="p1">][Custom API anchor]</ept>。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>服务器脚本中 main 函数的签名取决于脚本的具体使用位置。你还可以将公用脚本代码定义为可在脚本之间共享的 nodes.js 模块。有关详细信息，请参阅<bpt id="p1">[</bpt>源代码管理和共享代码<ept id="p1">][Source control, shared code, and helper functions]</ept>。</source>
          <target state="new">服务器脚本中 main 函数的签名取决于脚本的具体使用位置。你还可以将公用脚本代码定义为可在脚本之间共享的 nodes.js 模块。有关详细信息，请参阅<bpt id="p1">[</bpt>源代码管理和共享代码<ept id="p1">][Source control, shared code, and helper functions]</ept>。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>有关各个服务器脚本对象和函数的说明，请参阅<bpt id="p1">[</bpt><ept id="p1">移动服务服务器脚本参考]</ept>。</source>
          <target state="new">有关各个服务器脚本对象和函数的说明，请参阅<bpt id="p1">[</bpt><ept id="p1">移动服务服务器脚本参考]</ept>。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="table-scripts"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>表操作</source>
          <target state="new"><ph id="ph1">&lt;a name="table-scripts"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>表操作</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>表操作脚本是一种服务器脚本，它将注册到对表执行的操作 &amp;mdash; 插入、读取、更新或删除 (<bpt id="p1">*</bpt>del<ept id="p1">*</ept>)。本部分介绍如何在 JavaScript 后端使用表操作，具体包括以下小节：</source>
          <target state="new">表操作脚本是一种服务器脚本，它将注册到对表执行的操作 &amp;mdash; 插入、读取、更新或删除 (<bpt id="p1">*</bpt>del<ept id="p1">*</ept>)。本部分介绍如何在 JavaScript 后端使用表操作，具体包括以下小节：</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>表操作概述</source>
          <target state="new">表操作概述</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>如何：注册表操作</source>
          <target state="new">如何：注册表操作</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>如何：重写默认响应</source>
          <target state="new">如何：重写默认响应</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>如何：重写 execute success</source>
          <target state="new">如何：重写 execute success</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>如何：重写默认错误处理</source>
          <target state="new">如何：重写默认错误处理</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>如何：生成唯一 ID 值</source>
          <target state="new">如何：生成唯一 ID 值</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>如何：添加自定义参数</source>
          <target state="new">如何：添加自定义参数</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>如何：处理表用户</source>
          <target state="new">如何：处理表用户</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="basic-table-ops"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>表操作概述</source>
          <target state="new"><ph id="ph1">&lt;a name="basic-table-ops"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>表操作概述</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>该脚本的名称必须与注册的操作类型相匹配。对于一个给定的表操作，只能注册一个脚本。每当 REST 请求调用给定的操作时（例如，当收到要在表中插入项的 POST 请求时），就会执行该脚本。移动服务不会保存每次执行脚本后的状态。由于每次运行脚本时都会创建一个新的全局上下文，因此脚本中定义的所有状态变量都会重新初始化。如果你想要存储执行不同请求后的状态，请在移动服务中创建一个表，然后读取状态并将状态写入该表。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">如何：从脚本访问表]</ept>。</source>
          <target state="new">该脚本的名称必须与注册的操作类型相匹配。对于一个给定的表操作，只能注册一个脚本。每当 REST 请求调用给定的操作时（例如，当收到要在表中插入项的 POST 请求时），就会执行该脚本。移动服务不会保存每次执行脚本后的状态。由于每次运行脚本时都会创建一个新的全局上下文，因此脚本中定义的所有状态变量都会重新初始化。如果你想要存储执行不同请求后的状态，请在移动服务中创建一个表，然后读取状态并将状态写入该表。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">如何：从脚本访问表]</ept>。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>如果需要在执行操作时强制实施自定义的业务逻辑，请编写表操作脚本。例如，当 <ph id="ph1">`text`</ph> 字段的字符串长度大于 10 个字符时，以下脚本将拒绝插入操作：</source>
          <target state="new">如果需要在执行操作时强制实施自定义的业务逻辑，请编写表操作脚本。例如，当 <ph id="ph1">`text`</ph> 字段的字符串长度大于 10 个字符时，以下脚本将拒绝插入操作：</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>表脚本函数始终采用三个参数。</source>
          <target state="new">表脚本函数始终采用三个参数。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>第一个参数根据表操作的不同而异。</source>
          <target state="new">第一个参数根据表操作的不同而异。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>对于插入和更新，它是一个 <bpt id="p1">**</bpt>item<ept id="p1">**</ept> 对象，即操作所影响的行的 JSON 表示形式。这样，你便可以按名称（例如 <bpt id="p2">*</bpt>item.Owner<ept id="p2">*</ept>，其中 <bpt id="p3">*</bpt>Owner<ept id="p3">*</ept> 是 JSON 表示形式的名称之一）访问列值。</source>
          <target state="new">对于插入和更新，它是一个 <bpt id="p1">**</bpt>item<ept id="p1">**</ept> 对象，即操作所影响的行的 JSON 表示形式。这样，你便可以按名称（例如 <bpt id="p2">*</bpt>item.Owner<ept id="p2">*</ept>，其中 <bpt id="p3">*</bpt>Owner<ept id="p3">*</ept> 是 JSON 表示形式的名称之一）访问列值。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>对于删除，它是要删除的记录的 ID。</source>
          <target state="new">对于删除，它是要删除的记录的 ID。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>对于读取，它是用于指定要返回的行集的 <bpt id="p1">[</bpt><ept id="p1">query 对象]</ept>。</source>
          <target state="new">对于读取，它是用于指定要返回的行集的 <bpt id="p1">[</bpt><ept id="p1">query 对象]</ept>。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>第二个参数始终是 <bpt id="p1">[</bpt>user 对象<ept id="p1">][User object]</ept>，表示提交了请求的用户。</source>
          <target state="new">第二个参数始终是 <bpt id="p1">[</bpt>user 对象<ept id="p1">][User object]</ept>，表示提交了请求的用户。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>第三个参数始终是 <bpt id="p1">[</bpt>request 对象<ept id="p1">][request object]</ept>，你可以凭此控制所请求的操作的执行，以及发送到客户端的响应。</source>
          <target state="new">第三个参数始终是 <bpt id="p1">[</bpt>request 对象<ept id="p1">][request object]</ept>，你可以凭此控制所请求的操作的执行，以及发送到客户端的响应。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>以下是表操作的规范主函数签名：</source>
          <target state="new">以下是表操作的规范主函数签名：</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Insert<ept id="p1">][insert function]</ept>：<ph id="ph1">`function insert (item, user, request) { ... }`</ph></source>
          <target state="new"><bpt id="p1">[</bpt>Insert<ept id="p1">][insert function]</ept>：<ph id="ph1">`function insert (item, user, request) { ... }`</ph></target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Update<ept id="p1">][update function]</ept>：<ph id="ph1">`function update (item, user, request) { ... }`</ph></source>
          <target state="new"><bpt id="p1">[</bpt>Update<ept id="p1">][update function]</ept>：<ph id="ph1">`function update (item, user, request) { ... }`</ph></target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delete<ept id="p1">][delete function]</ept>：<ph id="ph1">`function del (id, user, request) { ... }`</ph></source>
          <target state="new"><bpt id="p1">[</bpt>Delete<ept id="p1">][delete function]</ept>：<ph id="ph1">`function del (id, user, request) { ... }`</ph></target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Read<ept id="p1">][read function]</ept>：<ph id="ph1">`function read (query, user, request) { ... }`</ph></source>
          <target state="new"><bpt id="p1">[</bpt>Read<ept id="p1">][read function]</ept>：<ph id="ph1">`function read (query, user, request) { ... }`</ph></target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>注册到删除操作的函数必须命名为 <bpt id="p1">_</bpt>del<ept id="p1">_</ept>，因为 delete 是 JavaScript 中的保留关键字。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>注册到删除操作的函数必须命名为 <bpt id="p1">_</bpt>del<ept id="p1">_</ept>，因为 delete 是 JavaScript 中的保留关键字。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>每个服务器脚本都有一个主函数，并包含可选的 Helper 函数。即使服务器脚本是为特定表创建的，它也可以引用同一数据库中的其他表。你还可以将公用函数定义为可在脚本之间共享的模块。有关详细信息，请参阅<bpt id="p1">[</bpt>源代码管理和共享代码<ept id="p1">][Source control, shared code, and helper functions]</ept>。</source>
          <target state="new">每个服务器脚本都有一个主函数，并包含可选的 Helper 函数。即使服务器脚本是为特定表创建的，它也可以引用同一数据库中的其他表。你还可以将公用函数定义为可在脚本之间共享的模块。有关详细信息，请参阅<bpt id="p1">[</bpt>源代码管理和共享代码<ept id="p1">][Source control, shared code, and helper functions]</ept>。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="register-table-scripts"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：注册表脚本</source>
          <target state="new"><ph id="ph1">&lt;a name="register-table-scripts"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：注册表脚本</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>你可以使用下列方式之一定义可注册到表操作的服务器脚本：</source>
          <target state="new">你可以使用下列方式之一定义可注册到表操作的服务器脚本：</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>通过 <bpt id="p1">[</bpt><ept id="p1">Azure 经典门户]</ept>。在给定表的“脚本”选项卡中访问表操作的脚本。下面显示了已注册到 <ph id="ph1">`TodoItem`</ph> 表的插入脚本的默认代码。你可以使用自己的自定义业务逻辑重写此代码。</source>
          <target state="new">通过 <bpt id="p1">[</bpt><ept id="p1">Azure 经典门户]</ept>。在给定表的“脚本”选项卡中访问表操作的脚本。下面显示了已注册到 <ph id="ph1">`TodoItem`</ph> 表的插入脚本的默认代码。你可以使用自己的自定义业务逻辑重写此代码。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="new">1</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>若要了解如何执行此操作，请参阅<bpt id="p1">[</bpt><ept id="p1">使用服务器脚本在移动服务中验证和修改数据]</ept>。</source>
          <target state="new">若要了解如何执行此操作，请参阅<bpt id="p1">[</bpt><ept id="p1">使用服务器脚本在移动服务中验证和修改数据]</ept>。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>使用源代码管理。启用源代码管理后，只需在 git 存储库中的 .\\service\\table 子文件夹内创建一个名为 <ph id="ph1">&lt;em&gt;</ph><ph id="ph2">`&lt;table&gt;`</ph><ph id="ph3">&lt;/em&gt;</ph>.<ph id="ph4">&lt;em&gt;</ph><ph id="ph5">`&lt;operation&gt;`</ph><ph id="ph6">&lt;/em&gt;</ph>.js 的文件，其中，<ph id="ph7">&lt;em&gt;</ph><ph id="ph8">`&lt;table&gt;`</ph><ph id="ph9">&lt;/em&gt;</ph> 是表的名称，<ph id="ph10">&lt;em&gt;</ph><ph id="ph11">`&lt;operation&gt;`</ph><ph id="ph12">&lt;/em&gt;</ph> 是要注册的表操作。有关详细信息，请参阅<bpt id="p1">[</bpt>源代码管理和共享代码<ept id="p1">][Source control, shared code, and helper functions]</ept>。</source>
          <target state="new">使用源代码管理。启用源代码管理后，只需在 git 存储库中的 .\\service\\table 子文件夹内创建一个名为 <ph id="ph1">&lt;em&gt;</ph><ph id="ph2">`&lt;table&gt;`</ph><ph id="ph3">&lt;/em&gt;</ph>.<ph id="ph4">&lt;em&gt;</ph><ph id="ph5">`&lt;operation&gt;`</ph><ph id="ph6">&lt;/em&gt;</ph>.js 的文件，其中，<ph id="ph7">&lt;em&gt;</ph><ph id="ph8">`&lt;table&gt;`</ph><ph id="ph9">&lt;/em&gt;</ph> 是表的名称，<ph id="ph10">&lt;em&gt;</ph><ph id="ph11">`&lt;operation&gt;`</ph><ph id="ph12">&lt;/em&gt;</ph> 是要注册的表操作。有关详细信息，请参阅<bpt id="p1">[</bpt>源代码管理和共享代码<ept id="p1">][Source control, shared code, and helper functions]</ept>。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>使用 Azure 命令行工具中的命令提示符。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">使用命令行工具]</ept>。</source>
          <target state="new">使用 Azure 命令行工具中的命令提示符。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">使用命令行工具]</ept>。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>表操作脚本必须至少调用 <bpt id="p1">[</bpt><ept id="p1">request 对象]</ept>的下列函数之一，以确保客户端收到响应。</source>
          <target state="new">表操作脚本必须至少调用 <bpt id="p1">[</bpt><ept id="p1">request 对象]</ept>的下列函数之一，以确保客户端收到响应。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>execute 函数<ept id="p1">**</ept>：已按请求完成操作，并已返回标准响应。</source>
          <target state="new"><bpt id="p1">**</bpt>execute 函数<ept id="p1">**</ept>：已按请求完成操作，并已返回标准响应。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>respond 函数<ept id="p1">**</ept>：已返回自定义响应。</source>
          <target state="new"><bpt id="p1">**</bpt>respond 函数<ept id="p1">**</ept>：已返回自定义响应。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>如果在脚本的某个代码路径中 <bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>respond<ept id="p2">**</ept> 均未调用，则该操作可能不返回响应。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>如果在脚本的某个代码路径中 <bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>respond<ept id="p2">**</ept> 均未调用，则该操作可能不返回响应。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>以下脚本将调用 <bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数来完成客户端请求的数据操作：</source>
          <target state="new">以下脚本将调用 <bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数来完成客户端请求的数据操作：</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>在此示例中，将向数据库中插入项目，并且将相应的状态代码返回给用户。</source>
          <target state="new">在此示例中，将向数据库中插入项目，并且将相应的状态代码返回给用户。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>调用 <bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数时，作为第一个参数传入脚本函数的 <ph id="ph1">`item`</ph>、<bpt id="p2">[</bpt>query<ept id="p2">][query object]</ept> 或 <ph id="ph2">`id`</ph> 值用于执行该操作。对于插入、更新或查询操作，你可以在调用 <bpt id="p3">**</bpt>execute<ept id="p3">**</ept> 之前修改 item 或 query：</source>
          <target state="new">调用 <bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数时，作为第一个参数传入脚本函数的 <ph id="ph1">`item`</ph>、<bpt id="p2">[</bpt>query<ept id="p2">][query object]</ept> 或 <ph id="ph2">`id`</ph> 值用于执行该操作。对于插入、更新或查询操作，你可以在调用 <bpt id="p3">**</bpt>execute<ept id="p3">**</ept> 之前修改 item 或 query：</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>在删除脚本中，更改所提供的 userId 变量不会影响所删除的记录。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>在删除脚本中，更改所提供的 userId 变量不会影响所删除的记录。</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>有关更多示例，请参阅<bpt id="p1">[</bpt><ept id="p1">读取和写入数据]</ept>、<bpt id="p2">[</bpt><ept id="p2">修改请求]</ept>和<bpt id="p3">[</bpt><ept id="p3">验证数据]</ept>。</source>
          <target state="new">有关更多示例，请参阅<bpt id="p1">[</bpt><ept id="p1">读取和写入数据]</ept>、<bpt id="p2">[</bpt><ept id="p2">修改请求]</ept>和<bpt id="p3">[</bpt><ept id="p3">验证数据]</ept>。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="override-response"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：重写默认响应</source>
          <target state="new"><ph id="ph1">&lt;a name="override-response"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：重写默认响应</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>你还可以使用脚本来实现能够重写默认响应行为的验证逻辑。如果验证失败，则只需调用 <bpt id="p1">**</bpt>respond<ept id="p1">**</ept> 函数而不是 <bpt id="p2">**</bpt>execute<ept id="p2">**</ept> 函数，然后将响应写入客户端：</source>
          <target state="new">你还可以使用脚本来实现能够重写默认响应行为的验证逻辑。如果验证失败，则只需调用 <bpt id="p1">**</bpt>respond<ept id="p1">**</ept> 函数而不是 <bpt id="p2">**</bpt>execute<ept id="p2">**</ept> 函数，然后将响应写入客户端：</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>在此示例中，当所插入项的 <ph id="ph1">`userId`</ph> 属性与为经过身份验证的客户端提供提供的 <bpt id="p1">[</bpt><ept id="p1">user 对象]</ept>的 <ph id="ph2">`userId`</ph> 不匹配时，该请求将被拒绝。在这种情况下，数据库操作 (<bpt id="p2">*</bpt>insert<ept id="p2">*</ept>) 将不会发生，并且会将 HTTP 状态代码为 403 的响应以及自定义的错误消息返回到客户端。有关更多示例，请参阅<bpt id="p3">[</bpt><ept id="p3">修改响应]</ept>。</source>
          <target state="new">在此示例中，当所插入项的 <ph id="ph1">`userId`</ph> 属性与为经过身份验证的客户端提供提供的 <bpt id="p1">[</bpt><ept id="p1">user 对象]</ept>的 <ph id="ph2">`userId`</ph> 不匹配时，该请求将被拒绝。在这种情况下，数据库操作 (<bpt id="p2">*</bpt>insert<ept id="p2">*</ept>) 将不会发生，并且会将 HTTP 状态代码为 403 的响应以及自定义的错误消息返回到客户端。有关更多示例，请参阅<bpt id="p3">[</bpt><ept id="p3">修改响应]</ept>。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="override-success"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：重写 execute success</source>
          <target state="new"><ph id="ph1">&lt;a name="override-success"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：重写 execute success</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>默认情况下，在表操作中，<bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数会自动写入响应。但是，你可以向 execute 函数传递两个可选参数，用于重写该函数在成功和/或出错时的行为。</source>
          <target state="new">默认情况下，在表操作中，<bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数会自动写入响应。但是，你可以向 execute 函数传递两个可选参数，用于重写该函数在成功和/或出错时的行为。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>通过在调用 execute 时传入 <bpt id="p1">**</bpt>success<ept id="p1">**</ept> 处理程序，你可以先修改查询的结果，然后再将结果写入到响应中。以下示例调用 <ph id="ph1">`execute({ success: function(results) { ... })`</ph>，以便在从数据库读取数据后但在写入响应之前执行附加操作：</source>
          <target state="new">通过在调用 execute 时传入 <bpt id="p1">**</bpt>success<ept id="p1">**</ept> 处理程序，你可以先修改查询的结果，然后再将结果写入到响应中。以下示例调用 <ph id="ph1">`execute({ success: function(results) { ... })`</ph>，以便在从数据库读取数据后但在写入响应之前执行附加操作：</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>如果为 <bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数提供了 <bpt id="p2">**</bpt>success<ept id="p2">**</ept> 处理程序，则还必须在 <bpt id="p3">**</bpt>success<ept id="p3">**</ept> 处理程序中调用 <bpt id="p4">**</bpt>respond<ept id="p4">**</ept> 函数，使运行时知道脚本已完成，并且可写入响应。如果在调用 <bpt id="p5">**</bpt>respond<ept id="p5">**</ept> 时未传递任何参数，则移动服务将生成默认响应。</source>
          <target state="new">如果为 <bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数提供了 <bpt id="p2">**</bpt>success<ept id="p2">**</ept> 处理程序，则还必须在 <bpt id="p3">**</bpt>success<ept id="p3">**</ept> 处理程序中调用 <bpt id="p4">**</bpt>respond<ept id="p4">**</ept> 函数，使运行时知道脚本已完成，并且可写入响应。如果在调用 <bpt id="p5">**</bpt>respond<ept id="p5">**</ept> 时未传递任何参数，则移动服务将生成默认响应。</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>只有在先调用 <bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数之后，才能调用不带参数的 <bpt id="p2">**</bpt>respond<ept id="p2">**</ept> 来调用默认响应。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>只有在先调用 <bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数之后，才能调用不带参数的 <bpt id="p2">**</bpt>respond<ept id="p2">**</ept> 来调用默认响应。</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="override-error"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：重写默认错误处理</source>
          <target state="new"><ph id="ph1">&lt;a name="override-error"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：重写默认错误处理</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>如果与数据库的连接断开、对象无效或者查询不正确，<bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数可能会失败。默认情况下，当发生错误时，服务器脚本会记录错误，并将错误结果写入到响应中。由于移动服务提供了默认的错误处理，因此你不需要处理服务中可能会发生的错误。</source>
          <target state="new">如果与数据库的连接断开、对象无效或者查询不正确，<bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数可能会失败。默认情况下，当发生错误时，服务器脚本会记录错误，并将错误结果写入到响应中。由于移动服务提供了默认的错误处理，因此你不需要处理服务中可能会发生的错误。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>如果你想要采取特定的补救措施，或者想要使用全局控制台对象向日志写入更详细信息，则可以通过实施显式错误处理来重写默认的错误处理。向 <bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数提供一个 <bpt id="p2">**</bpt>error<ept id="p2">**</ept> 处理程序即可实现此目的：</source>
          <target state="new">如果你想要采取特定的补救措施，或者想要使用全局控制台对象向日志写入更详细信息，则可以通过实施显式错误处理来重写默认的错误处理。向 <bpt id="p1">**</bpt>execute<ept id="p1">**</ept> 函数提供一个 <bpt id="p2">**</bpt>error<ept id="p2">**</ept> 处理程序即可实现此目的：</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>提供 error 处理程序后，调用 <bpt id="p1">**</bpt>respond<ept id="p1">**</ept> 时，移动服务会向客户端返回错误结果。</source>
          <target state="new">提供 error 处理程序后，调用 <bpt id="p1">**</bpt>respond<ept id="p1">**</ept> 时，移动服务会向客户端返回错误结果。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>如果需要，你也可以同时提供 <bpt id="p1">**</bpt>success<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>error<ept id="p2">**</ept> 处理程序。</source>
          <target state="new">如果需要，你也可以同时提供 <bpt id="p1">**</bpt>success<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>error<ept id="p2">**</ept> 处理程序。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="generate-guids"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：生成唯一 ID 值</source>
          <target state="new"><ph id="ph1">&lt;a name="generate-guids"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：生成唯一 ID 值</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>移动服务支持为表的 <bpt id="p1">**</bpt>ID<ept id="p1">**</ept> 列使用唯一的自定义字符串值。这样，应用程序便可为 ID 使用自定义值（如电子邮件地址或用户名）。</source>
          <target state="new">移动服务支持为表的 <bpt id="p1">**</bpt>ID<ept id="p1">**</ept> 列使用唯一的自定义字符串值。这样，应用程序便可为 ID 使用自定义值（如电子邮件地址或用户名）。</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>字符串 ID 可提供以下优势：</source>
          <target state="new">字符串 ID 可提供以下优势：</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>无需往返访问数据库即可生成 ID。</source>
          <target state="new">无需往返访问数据库即可生成 ID。</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>更方便地合并不同表或数据库中的记录。</source>
          <target state="new">更方便地合并不同表或数据库中的记录。</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>ID 值能够更好地与应用程序的逻辑相集成。</source>
          <target state="new">ID 值能够更好地与应用程序的逻辑相集成。</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>如果插入的记录中未设置字符串 ID 值，移动服务将为 ID 生成唯一值。你可以在服务器脚本中生成自己的唯一 ID 值。下面的脚本示例将生成一个自定义 GUID 并将其分配给新记录的 ID。此 ID 类似于你未传入记录的 ID 值时，移动服务生成的 ID 值。</source>
          <target state="new">如果插入的记录中未设置字符串 ID 值，移动服务将为 ID 生成唯一值。你可以在服务器脚本中生成自己的唯一 ID 值。下面的脚本示例将生成一个自定义 GUID 并将其分配给新记录的 ID。此 ID 类似于你未传入记录的 ID 值时，移动服务生成的 ID 值。</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>如果应用程序提供了某个 ID 的值，移动服务将按原样存储该值，包括前导和尾随空格。不会从值中裁剪掉空格。</source>
          <target state="new">如果应用程序提供了某个 ID 的值，移动服务将按原样存储该值，包括前导和尾随空格。不会从值中裁剪掉空格。</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`id`</ph> 的值必须唯一，并且不能包含以下集中的字符：</source>
          <target state="new"><ph id="ph1">`id`</ph> 的值必须唯一，并且不能包含以下集中的字符：</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>控制字符：[0x0000-0x001F] 和 [0x007F-0x009F]。有关详细信息，请参阅 <bpt id="p1">[</bpt>ASCII 控制代码 C0 和 C1<ept id="p1">](http://zh.wikipedia.org/wiki/Data_link_escape_character#C1_set)</ept>。</source>
          <target state="new">控制字符：[0x0000-0x001F] 和 [0x007F-0x009F]。有关详细信息，请参阅 <bpt id="p1">[</bpt>ASCII 控制代码 C0 和 C1<ept id="p1">](http://zh.wikipedia.org/wiki/Data_link_escape_character#C1_set)</ept>。</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>可打印字符：<bpt id="p1">**</bpt>"<ept id="p1">**</ept>(0x0022), <bpt id="p2">**</bpt>+<ept id="p2">**</ept> (0x002B), <bpt id="p3">**</bpt>/<ept id="p3">**</ept> (0x002F), <bpt id="p4">**</bpt>?<ept id="p4">**</ept></source>
          <target state="new">可打印字符：<bpt id="p1">**</bpt>"<ept id="p1">**</ept>(0x0022), <bpt id="p2">**</bpt>+<ept id="p2">**</ept> (0x002B), <bpt id="p3">**</bpt>/<ept id="p3">**</ept> (0x002F), <bpt id="p4">**</bpt>?<ept id="p4">**</ept></target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>(0x003F), *<bpt id="p1">*</bpt>\*<ept id="p1">*</ept> (0x005C), <bpt id="p2">**</bpt>`<ept id="p2">**</ept> (0x0060)</source>
          <target state="new">(0x003F), *<bpt id="p1">*</bpt>\*<ept id="p1">*</ept> (0x005C), <bpt id="p2">**</bpt>`<ept id="p2">**</ept> (0x0060)</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>ID“.”和“..”</source>
          <target state="new">ID“.”和“..”</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>也可以为表使用整数 ID。若要使用整数 ID，必须结合 <ph id="ph1">`--integerId`</ph> 选项使用 <ph id="ph2">`mobile table create`</ph> 命令创建表。应在适用于 Azure 的命令行界面 (CLI) 中使用此命令。有关使用 CLI 的详细信息，请参阅<bpt id="p1">[</bpt>用于管理移动服务表的 CLI<ept id="p1">](/documentation/articles/virtual-machines-command-line-tools/#Mobile_Tables)</ept>。</source>
          <target state="new">也可以为表使用整数 ID。若要使用整数 ID，必须结合 <ph id="ph1">`--integerId`</ph> 选项使用 <ph id="ph2">`mobile table create`</ph> 命令创建表。应在适用于 Azure 的命令行界面 (CLI) 中使用此命令。有关使用 CLI 的详细信息，请参阅<bpt id="p1">[</bpt>用于管理移动服务表的 CLI<ept id="p1">](/documentation/articles/virtual-machines-command-line-tools/#Mobile_Tables)</ept>。</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="access-headers"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：访问自定义参数</source>
          <target state="new"><ph id="ph1">&lt;a name="access-headers"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：访问自定义参数</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>向移动服务发送请求时，你可以在请求 URI 中包含自定义参数，以指示表操作脚本如何处理给定的请求。然后，你可以修改脚本，通过检查参数的方式来确定处理路径。</source>
          <target state="new">向移动服务发送请求时，你可以在请求 URI 中包含自定义参数，以指示表操作脚本如何处理给定的请求。然后，你可以修改脚本，通过检查参数的方式来确定处理路径。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>例如，以下 POST 请求 URI 将指示服务不要允许插入具有相同 text 值的新 <bpt id="p1">*</bpt>TodoItem<ept id="p1">*</ept>：</source>
          <target state="new">例如，以下 POST 请求 URI 将指示服务不要允许插入具有相同 text 值的新 <bpt id="p1">*</bpt>TodoItem<ept id="p1">*</ept>：</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>可从 <bpt id="p1">[</bpt><ept id="p1">request 对象]</ept>的 <bpt id="p2">**</bpt>parameters<ept id="p2">**</ept> 属性访问这些以 JSON 值提供的自定义查询参数。移动服务向已注册到表操作的任何函数提供 <bpt id="p3">**</bpt>request<ept id="p3">**</ept> 对象。以下用于插入操作的服务器脚本将在运行插入操作之前检查 <ph id="ph1">`duplicateText`</ph> 参数的值：</source>
          <target state="new">可从 <bpt id="p1">[</bpt><ept id="p1">request 对象]</ept>的 <bpt id="p2">**</bpt>parameters<ept id="p2">**</ept> 属性访问这些以 JSON 值提供的自定义查询参数。移动服务向已注册到表操作的任何函数提供 <bpt id="p3">**</bpt>request<ept id="p3">**</ept> 对象。以下用于插入操作的服务器脚本将在运行插入操作之前检查 <ph id="ph1">`duplicateText`</ph> 参数的值：</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>请注意，在 <bpt id="p1">**</bpt>insertItemIfNotComplete<ept id="p1">**</ept> 中，如果不存在重复文本，则会调用 <bpt id="p2">[</bpt><ept id="p2">request 对象]</ept>的 <bpt id="p3">**</bpt>execute<ept id="p3">**</ept> 函数来插入项；否则，会调用 <bpt id="p4">**</bpt>respond<ept id="p4">**</ept> 函数来通知客户端存在重复文本。</source>
          <target state="new">请注意，在 <bpt id="p1">**</bpt>insertItemIfNotComplete<ept id="p1">**</ept> 中，如果不存在重复文本，则会调用 <bpt id="p2">[</bpt><ept id="p2">request 对象]</ept>的 <bpt id="p3">**</bpt>execute<ept id="p3">**</ept> 函数来插入项；否则，会调用 <bpt id="p4">**</bpt>respond<ept id="p4">**</ept> 函数来通知客户端存在重复文本。</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>请注意上述代码中 <bpt id="p1">**</bpt>success<ept id="p1">**</ept> 函数的调用语法：</source>
          <target state="new">请注意上述代码中 <bpt id="p1">**</bpt>success<ept id="p1">**</ept> 函数的调用语法：</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>上述代码较为精简，JavaScript 中更冗长的等效代码为：</source>
          <target state="new">上述代码较为精简，JavaScript 中更冗长的等效代码为：</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="work-with-users"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：处理用户</source>
          <target state="new"><ph id="ph1">&lt;a name="work-with-users"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：处理用户</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>在 Azure 移动服务中，你可以使用标识提供程序对用户进行身份验证。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">身份验证入门]</ept>。当经过身份验证的用户调用表操作时，移动服务将使用 <bpt id="p2">[</bpt><ept id="p2">user 对象]</ept>向已注册的脚本函数提供有关该用户的信息。可以使用 <bpt id="p3">**</bpt>userId<ept id="p3">**</ept> 属性来存储和检索用户特定的信息。以下示例将基于某个经过身份验证的用户的 <bpt id="p4">**</bpt>userId<ept id="p4">**</ept> 来设置项的 owner 属性：</source>
          <target state="new">在 Azure 移动服务中，你可以使用标识提供程序对用户进行身份验证。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">身份验证入门]</ept>。当经过身份验证的用户调用表操作时，移动服务将使用 <bpt id="p2">[</bpt><ept id="p2">user 对象]</ept>向已注册的脚本函数提供有关该用户的信息。可以使用 <bpt id="p3">**</bpt>userId<ept id="p3">**</ept> 属性来存储和检索用户特定的信息。以下示例将基于某个经过身份验证的用户的 <bpt id="p4">**</bpt>userId<ept id="p4">**</ept> 来设置项的 owner 属性：</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>以下示例将基于某个经过身份验证的用户的 <bpt id="p1">**</bpt>userId<ept id="p1">**</ept> 向查询添加一个附加的筛选器。此筛选器会将结果限制为属于当前用户的项：</source>
          <target state="new">以下示例将基于某个经过身份验证的用户的 <bpt id="p1">**</bpt>userId<ept id="p1">**</ept> 向查询添加一个附加的筛选器。此筛选器会将结果限制为属于当前用户的项：</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="custom-api"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>自定义 API</source>
          <target state="new"><ph id="ph1">&lt;a name="custom-api"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>自定义 API</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>本部分介绍如何创建和使用自定义 API 终结点，具体包括以下小节：</source>
          <target state="new">本部分介绍如何创建和使用自定义 API 终结点，具体包括以下小节：</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>自定义 API 概述</source>
          <target state="new">自定义 API 概述</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>如何：定义自定义 API</source>
          <target state="new">如何：定义自定义 API</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>如何：实现 HTTP 方法</source>
          <target state="new">如何：实现 HTTP 方法</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>如何：发送和接收 XML 格式的数据</source>
          <target state="new">如何：发送和接收 XML 格式的数据</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>如何：处理用户和自定义 API 中的标头</source>
          <target state="new">如何：处理用户和自定义 API 中的标头</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>如何：在一个自定义 API 中定义多个路由</source>
          <target state="new">如何：在一个自定义 API 中定义多个路由</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="custom-api-overview"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>自定义 API 概述</source>
          <target state="new"><ph id="ph1">&lt;a name="custom-api-overview"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>自定义 API 概述</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>自定义 API 是移动服务中可通过一个或多个标准 HTTP 方法访问的终结点，这些方法包括：GET、POST、PUT、PATCH 和 DELETE。可以在单个脚本文件中为自定义 API 支持的每个 HTTP 方法单独定义一个函数导出。收到使用给定方法向自定义 API 发出的请求后，将调用注册的脚本。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">自定义 API]</ept>。</source>
          <target state="new">自定义 API 是移动服务中可通过一个或多个标准 HTTP 方法访问的终结点，这些方法包括：GET、POST、PUT、PATCH 和 DELETE。可以在单个脚本文件中为自定义 API 支持的每个 HTTP 方法单独定义一个函数导出。收到使用给定方法向自定义 API 发出的请求后，将调用注册的脚本。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">自定义 API]</ept>。</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>当移动服务运行时调用自定义 API 函数时，将同时提供 <bpt id="p1">[</bpt>request<ept id="p1">][request object]</ept> 和 <bpt id="p2">[</bpt>response<ept id="p2">][response object]</ept> 对象。这些对象将公开 <bpt id="p3">[</bpt><ept id="p3">express.js 库]</ept>的功能，而你的脚本可以利用这些功能。以下名为 <bpt id="p4">**</bpt>hello<ept id="p4">**</ept> 的自定义 API 是一个极简单的示例，它会返回 <bpt id="p5">_</bpt>Hello, world!<ept id="p5">_</ept></source>
          <target state="new">当移动服务运行时调用自定义 API 函数时，将同时提供 <bpt id="p1">[</bpt>request<ept id="p1">][request object]</ept> 和 <bpt id="p2">[</bpt>response<ept id="p2">][response object]</ept> 对象。这些对象将公开 <bpt id="p3">[</bpt><ept id="p3">express.js 库]</ept>的功能，而你的脚本可以利用这些功能。以下名为 <bpt id="p4">**</bpt>hello<ept id="p4">**</ept> 的自定义 API 是一个极简单的示例，它会返回 <bpt id="p5">_</bpt>Hello, world!<ept id="p5">_</ept></target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>以响应 POST 请求：</source>
          <target state="new">以响应 POST 请求：</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ept id="p1">response 对象]</ept>的 <bpt id="p2">**</bpt>send<ept id="p2">**</ept> 函数向客户端返回所需的响应。可以通过向以下 URL 发送 POST 请求来调用此代码：</source>
          <target state="new"><bpt id="p1">[</bpt><ept id="p1">response 对象]</ept>的 <bpt id="p2">**</bpt>send<ept id="p2">**</ept> 函数向客户端返回所需的响应。可以通过向以下 URL 发送 POST 请求来调用此代码：</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>每次执行后都会保留全局状态。</source>
          <target state="new">每次执行后都会保留全局状态。</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="define-custom-api"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：定义自定义 API</source>
          <target state="new"><ph id="ph1">&lt;a name="define-custom-api"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：定义自定义 API</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>你可以使用下列方式之一定义可注册到自定义 API 终结点中 HTTP 方法的服务器脚本：</source>
          <target state="new">你可以使用下列方式之一定义可注册到自定义 API 终结点中 HTTP 方法的服务器脚本：</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>通过 <bpt id="p1">[</bpt><ept id="p1">Azure 经典门户]</ept>。可以在“API”选项卡中创建和修改自定义 API 脚本。服务器脚本代码位于给定自定义 API 的“脚本”选项卡中。下面显示了向 <ph id="ph1">`CompleteAll`</ph> 自定义 API 终结点发出的 POST 请求调用的脚本。</source>
          <target state="new">通过 <bpt id="p1">[</bpt><ept id="p1">Azure 经典门户]</ept>。可以在“API”选项卡中创建和修改自定义 API 脚本。服务器脚本代码位于给定自定义 API 的“脚本”选项卡中。下面显示了向 <ph id="ph1">`CompleteAll`</ph> 自定义 API 终结点发出的 POST 请求调用的脚本。</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="new">2</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>对自定义 API 方法的访问权限在“权限”选项卡中分配。若要了解此自定义 API 的创建方式，请参阅<bpt id="p1">[</bpt><ept id="p1">从客户端调用自定义 API]</ept>。</source>
          <target state="new">对自定义 API 方法的访问权限在“权限”选项卡中分配。若要了解此自定义 API 的创建方式，请参阅<bpt id="p1">[</bpt><ept id="p1">从客户端调用自定义 API]</ept>。</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>使用源代码管理。如果已启用源代码管理，只需在 git 存储库的 .\\service\\api 子文件夹中创建一个名为 <ph id="ph1">&lt;em&gt;</ph><ph id="ph2">`&lt;custom_api&gt;`</ph><ph id="ph3">&lt;/em&gt;</ph>.js 的文件，其中 <ph id="ph4">&lt;em&gt;</ph><ph id="ph5">`&lt;custom_api&gt;`</ph><ph id="ph6">&lt;/em&gt;</ph> 是要注册的自定义 API 的名称。此脚本文件包含自定义 API 公开的每个 HTTP 方法的 <bpt id="p1">_</bpt>exported<ept id="p1">_</ept> 函数。权限在随附的 .json 文件中定义。有关详细信息，请参阅<bpt id="p2">[</bpt>源代码管理和共享代码<ept id="p2">][Source control, shared code, and helper functions]</ept>。</source>
          <target state="new">使用源代码管理。如果已启用源代码管理，只需在 git 存储库的 .\\service\\api 子文件夹中创建一个名为 <ph id="ph1">&lt;em&gt;</ph><ph id="ph2">`&lt;custom_api&gt;`</ph><ph id="ph3">&lt;/em&gt;</ph>.js 的文件，其中 <ph id="ph4">&lt;em&gt;</ph><ph id="ph5">`&lt;custom_api&gt;`</ph><ph id="ph6">&lt;/em&gt;</ph> 是要注册的自定义 API 的名称。此脚本文件包含自定义 API 公开的每个 HTTP 方法的 <bpt id="p1">_</bpt>exported<ept id="p1">_</ept> 函数。权限在随附的 .json 文件中定义。有关详细信息，请参阅<bpt id="p2">[</bpt>源代码管理和共享代码<ept id="p2">][Source control, shared code, and helper functions]</ept>。</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>使用 Azure 命令行工具中的命令提示符。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">使用命令行工具]</ept>。</source>
          <target state="new">使用 Azure 命令行工具中的命令提示符。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">使用命令行工具]</ept>。</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="handle-methods"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：实现 HTTP 方法</source>
          <target state="new"><ph id="ph1">&lt;a name="handle-methods"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：实现 HTTP 方法</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>一个自定义 API 可以处理一个或多个 HTTP 方法：GET、POST、PUT、PATCH 和 DELETE。将为自定义 API 处理的每个 HTTP 方法定义一个导出函数。单个自定义 API 代码文件可以导出下列一个或所有函数：</source>
          <target state="new">一个自定义 API 可以处理一个或多个 HTTP 方法：GET、POST、PUT、PATCH 和 DELETE。将为自定义 API 处理的每个 HTTP 方法定义一个导出函数。单个自定义 API 代码文件可以导出下列一个或所有函数：</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>不能使用服务器脚本中尚未实现的 HTTP 方法调用自定义 API 终结点，该调用会返回 405（“不允许的方法”）错误响应。可向每个支持 HTTP 方法单独分配权限级别。</source>
          <target state="new">不能使用服务器脚本中尚未实现的 HTTP 方法调用自定义 API 终结点，该调用会返回 405（“不允许的方法”）错误响应。可向每个支持 HTTP 方法单独分配权限级别。</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="api-return-xml"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：发送和接收 XML 格式的数据</source>
          <target state="new"><ph id="ph1">&lt;a name="api-return-xml"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：发送和接收 XML 格式的数据</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>当客户端存储和检索数据时，移动服务将使用 JavaScript 对象表示法 (JSON) 来表示消息正文中的数据。但是，在某些情况下，你可能希望使用 XML 负载。例如，Windows 应用商店应用程序具有内置的定期通知功能，这就需要服务发出 XML 数据。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">定义支持定期通知的自定义 API]</ept>。</source>
          <target state="new">当客户端存储和检索数据时，移动服务将使用 JavaScript 对象表示法 (JSON) 来表示消息正文中的数据。但是，在某些情况下，你可能希望使用 XML 负载。例如，Windows 应用商店应用程序具有内置的定期通知功能，这就需要服务发出 XML 数据。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">定义支持定期通知的自定义 API]</ept>。</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>以下 <bpt id="p1">**</bpt>OrderPizza<ept id="p1">**</ept> 自定义 API 函数将返回一个简单的 XML 文档作为响应负载：</source>
          <target state="new">以下 <bpt id="p1">**</bpt>OrderPizza<ept id="p1">**</ept> 自定义 API 函数将返回一个简单的 XML 文档作为响应负载：</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>可以通过向以下终结点发出 HTTP GET 请求来调用此自定义 API 函数：</source>
          <target state="new">可以通过向以下终结点发出 HTTP GET 请求来调用此自定义 API 函数：</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="get-api-user"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：处理用户和自定义 API 中的标头</source>
          <target state="new"><ph id="ph1">&lt;a name="get-api-user"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：处理用户和自定义 API 中的标头</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>在 Azure 移动服务中，你可以使用标识提供程序对用户进行身份验证。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">身份验证入门]</ept>。当经过身份验证的用户请求自定义 API 时，移动服务将使用<bpt id="p2">[</bpt><ept id="p2">用户对象]</ept>向自定义 API 代码提供有关该用户的信息。可从 <bpt id="p3">[</bpt><ept id="p3">request 对象]</ept>的 user 属性访问 <bpt id="p4">[</bpt><ept id="p4">user 对象]</ept>。可以使用 <bpt id="p5">**</bpt>userId<ept id="p5">**</ept> 属性来存储和检索用户特定的信息。</source>
          <target state="new">在 Azure 移动服务中，你可以使用标识提供程序对用户进行身份验证。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">身份验证入门]</ept>。当经过身份验证的用户请求自定义 API 时，移动服务将使用<bpt id="p2">[</bpt><ept id="p2">用户对象]</ept>向自定义 API 代码提供有关该用户的信息。可从 <bpt id="p3">[</bpt><ept id="p3">request 对象]</ept>的 user 属性访问 <bpt id="p4">[</bpt><ept id="p4">user 对象]</ept>。可以使用 <bpt id="p5">**</bpt>userId<ept id="p5">**</ept> 属性来存储和检索用户特定的信息。</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>以下 <bpt id="p1">**</bpt>OrderPizza<ept id="p1">**</ept> 自定义 API 函数将基于某个经过身份验证的用户的 <bpt id="p2">**</bpt>userId<ept id="p2">**</ept> 来设置项的 owner 属性：</source>
          <target state="new">以下 <bpt id="p1">**</bpt>OrderPizza<ept id="p1">**</ept> 自定义 API 函数将基于某个经过身份验证的用户的 <bpt id="p2">**</bpt>userId<ept id="p2">**</ept> 来设置项的 owner 属性：</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>可以通过向以下终结点发出 HTTP POST 请求来调用此自定义 API 函数：</source>
          <target state="new">可以通过向以下终结点发出 HTTP POST 请求来调用此自定义 API 函数：</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>你还可以通过 <bpt id="p1">[</bpt><ept id="p1">request 对象]</ept>访问特定的 HTTP 标头，如以下代码中所示：</source>
          <target state="new">你还可以通过 <bpt id="p1">[</bpt><ept id="p1">request 对象]</ept>访问特定的 HTTP 标头，如以下代码中所示：</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>这个简单示例将读取名为 <ph id="ph1">`my-custom-header`</ph> 的自定义标头，然后在响应中返回值。</source>
          <target state="new">这个简单示例将读取名为 <ph id="ph1">`my-custom-header`</ph> 的自定义标头，然后在响应中返回值。</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="api-routes"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：在一个自定义 API 中定义多个路由</source>
          <target state="new"><ph id="ph1">&lt;a name="api-routes"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：在一个自定义 API 中定义多个路由</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>移动服务允许你在一个自定义 API 中定义多个路径或路由。例如，向 <bpt id="p1">**</bpt>calculator<ept id="p1">**</ept> 自定义 API 中的以下 URL 发出的 HTTP GET 请求将分别调用 <bpt id="p2">**</bpt>add<ept id="p2">**</ept> 或 <bpt id="p3">**</bpt>subtract<ept id="p3">**</ept> 函数：</source>
          <target state="new">移动服务允许你在一个自定义 API 中定义多个路径或路由。例如，向 <bpt id="p1">**</bpt>calculator<ept id="p1">**</ept> 自定义 API 中的以下 URL 发出的 HTTP GET 请求将分别调用 <bpt id="p2">**</bpt>add<ept id="p2">**</ept> 或 <bpt id="p3">**</bpt>subtract<ept id="p3">**</ept> 函数：</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>可以通过导出一个传递了 <bpt id="p1">**</bpt>api<ept id="p1">**</ept> 对象（类似于 <bpt id="p2">[</bpt><ept id="p2">express.js 中的 express 对象]</ept>）的 <bpt id="p3">**</bpt>register<ept id="p3">**</ept> 函数来定义多个路由，该对象用于在自定义 API 终结点下注册路由。以下示例将在 <bpt id="p4">**</bpt>calculator<ept id="p4">**</ept> 自定义 API 中实现 <bpt id="p5">**</bpt>add<ept id="p5">**</ept> 和 <bpt id="p6">**</bpt>sub<ept id="p6">**</ept> 方法：</source>
          <target state="new">可以通过导出一个传递了 <bpt id="p1">**</bpt>api<ept id="p1">**</ept> 对象（类似于 <bpt id="p2">[</bpt><ept id="p2">express.js 中的 express 对象]</ept>）的 <bpt id="p3">**</bpt>register<ept id="p3">**</ept> 函数来定义多个路由，该对象用于在自定义 API 终结点下注册路由。以下示例将在 <bpt id="p4">**</bpt>calculator<ept id="p4">**</ept> 自定义 API 中实现 <bpt id="p5">**</bpt>add<ept id="p5">**</ept> 和 <bpt id="p6">**</bpt>sub<ept id="p6">**</ept> 方法：</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>传递给 <bpt id="p1">**</bpt>register<ept id="p1">**</ept> 函数的 <bpt id="p2">**</bpt>api<ept id="p2">**</ept> 对象将为每个 HTTP 方法（<bpt id="p3">**</bpt>get<ept id="p3">**</ept>、<bpt id="p4">**</bpt>post<ept id="p4">**</ept>、<bpt id="p5">**</bpt>put<ept id="p5">**</ept>、<bpt id="p6">**</bpt>patch<ept id="p6">**</ept> 和 <bpt id="p7">**</bpt>delete<ept id="p7">**</ept>）公开一个函数。这些函数会将一个路由注册到特定 HTTP 方法的已定义函数。每个函数均采用两个参数，第一个参数是路由名称，第二个参数是注册到路由的函数。</source>
          <target state="new">传递给 <bpt id="p1">**</bpt>register<ept id="p1">**</ept> 函数的 <bpt id="p2">**</bpt>api<ept id="p2">**</ept> 对象将为每个 HTTP 方法（<bpt id="p3">**</bpt>get<ept id="p3">**</ept>、<bpt id="p4">**</bpt>post<ept id="p4">**</ept>、<bpt id="p5">**</bpt>put<ept id="p5">**</ept>、<bpt id="p6">**</bpt>patch<ept id="p6">**</ept> 和 <bpt id="p7">**</bpt>delete<ept id="p7">**</ept>）公开一个函数。这些函数会将一个路由注册到特定 HTTP 方法的已定义函数。每个函数均采用两个参数，第一个参数是路由名称，第二个参数是注册到路由的函数。</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>HTTP GET 请求可按如下所示调用上述自定义 API 示例中的两个路由（随响应一起显示）：</source>
          <target state="new">HTTP GET 请求可按如下所示调用上述自定义 API 示例中的两个路由（随响应一起显示）：</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="scheduler-scripts"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>作业计划程序</source>
          <target state="new"><ph id="ph1">&lt;a name="scheduler-scripts"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>作业计划程序</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>移动服务允许你定义按固定计划以作业形式执行或通过 Azure 经典门户按需执行的服务器脚本。计划的作业可用于执行周期性任务，例如，清理表数据和批处理。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">计划作业]</ept>。</source>
          <target state="new">移动服务允许你定义按固定计划以作业形式执行或通过 Azure 经典门户按需执行的服务器脚本。计划的作业可用于执行周期性任务，例如，清理表数据和批处理。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">计划作业]</ept>。</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>注册到计划作业的脚本具有一个与计划作业同名的主函数。由于 HTTP 请求不调用计划的脚本，没有可由服务器运行时传递的上下文，因此该函数不采用任何参数。与其他类型的脚本一样，你可以使用子例程函数并需要使用共享模块。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">源代码管理、共享代码和 Helper 函数]</ept>。</source>
          <target state="new">注册到计划作业的脚本具有一个与计划作业同名的主函数。由于 HTTP 请求不调用计划的脚本，没有可由服务器运行时传递的上下文，因此该函数不采用任何参数。与其他类型的脚本一样，你可以使用子例程函数并需要使用共享模块。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">源代码管理、共享代码和 Helper 函数]</ept>。</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="scheduler-scripts"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：定义计划的作业脚本</source>
          <target state="new"><ph id="ph1">&lt;a name="scheduler-scripts"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：定义计划的作业脚本</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>可将一个服务器脚本分配到移动服务计划程序中定义的作业。这些脚本属于该作业，并根据作业计划执行。（你也可以使用 <bpt id="p1">[</bpt><ept id="p1">Azure 经典门户]</ept>按需运行作业。） 定义计划作业的脚本不带参数，因为移动服务不会向它传递任何数据；该脚本作为常规 JavaScript 函数执行，不直接与移动服务交互。</source>
          <target state="new">可将一个服务器脚本分配到移动服务计划程序中定义的作业。这些脚本属于该作业，并根据作业计划执行。（你也可以使用 <bpt id="p1">[</bpt><ept id="p1">Azure 经典门户]</ept>按需运行作业。） 定义计划作业的脚本不带参数，因为移动服务不会向它传递任何数据；该脚本作为常规 JavaScript 函数执行，不直接与移动服务交互。</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>可通过下列方式之一定义计划作业：</source>
          <target state="new">可通过下列方式之一定义计划作业：</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>通过 <bpt id="p1">[</bpt><ept id="p1">Azure 经典门户]</ept>中的计划程序的“脚本”选项卡：</source>
          <target state="new">通过 <bpt id="p1">[</bpt><ept id="p1">Azure 经典门户]</ept>中的计划程序的“脚本”选项卡：</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="new">3</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>使用 Azure 命令行工具中的命令提示符。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">使用命令行工具]</ept>。</source>
          <target state="new">使用 Azure 命令行工具中的命令提示符。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">使用命令行工具]</ept>。</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>启用源代码管理后，你可以直接在 git 存储库的 .\\service\\scheduler 子文件夹中编辑计划的作业脚本文件。有关详细信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">如何：使用源代码管理来共享代码]</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>启用源代码管理后，你可以直接在 git 存储库的 .\\service\\scheduler 子文件夹中编辑计划的作业脚本文件。有关详细信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">如何：使用源代码管理来共享代码]</ept>。</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="shared-code"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>源代码管理、共享代码和 Helper 函数</source>
          <target state="new"><ph id="ph1">&lt;a name="shared-code"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>源代码管理、共享代码和 Helper 函数</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>本部分说明如何利用源代码管理来添加你自己的自定义 node.js 模块、共享的代码和其他代码重用策略，具体包括以下小节：</source>
          <target state="new">本部分说明如何利用源代码管理来添加你自己的自定义 node.js 模块、共享的代码和其他代码重用策略，具体包括以下小节：</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>利用共享代码概述</source>
          <target state="new">利用共享代码概述</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>如何：加载 Node.js 模块</source>
          <target state="new">如何：加载 Node.js 模块</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>如何：使用 Helper 函数</source>
          <target state="new">如何：使用 Helper 函数</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>如何：使用源代码管理来共享代码</source>
          <target state="new">如何：使用源代码管理来共享代码</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>如何：使用应用程序设置</source>
          <target state="new">如何：使用应用程序设置</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="leverage-source-control"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>利用共享代码概述</source>
          <target state="new"><ph id="ph1">&lt;a name="leverage-source-control"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>利用共享代码概述</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>由于移动服务使用服务器上的 Node.js，因此你的脚本已经获取了对内置 Node.js 模块的访问权限。你也可以使用源代码管理定义自己的模块，或者将其他 Node.js 模块添加到你的服务。</source>
          <target state="new">由于移动服务使用服务器上的 Node.js，因此你的脚本已经获取了对内置 Node.js 模块的访问权限。你也可以使用源代码管理定义自己的模块，或者将其他 Node.js 模块添加到你的服务。</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>下面列出了你可以通过全局 <bpt id="p1">**</bpt>require<ept id="p1">**</ept> 函数在脚本中利用的一些较为有用的模块：</source>
          <target state="new">下面列出了你可以通过全局 <bpt id="p1">**</bpt>require<ept id="p1">**</ept> 函数在脚本中利用的一些较为有用的模块：</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>azure<ept id="p1">**</ept>：公开 Azure SDK for Node.js 的功能。有关详细信息，请参阅 <bpt id="p2">[</bpt><ept id="p2">Azure SDK for Node.js]</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>azure<ept id="p1">**</ept>：公开 Azure SDK for Node.js 的功能。有关详细信息，请参阅 <bpt id="p2">[</bpt><ept id="p2">Azure SDK for Node.js]</ept>。</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>crypto<ept id="p1">**</ept>：提供 OpenSSL 的加密功能。有关详细信息，请参阅 <bpt id="p2">[</bpt>Node.js 文档<ept id="p2">][crypto API]</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>crypto<ept id="p1">**</ept>：提供 OpenSSL 的加密功能。有关详细信息，请参阅 <bpt id="p2">[</bpt>Node.js 文档<ept id="p2">][crypto API]</ept>。</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>path<ept id="p1">**</ept>：包含用于处理文件路径的实用工具。有关详细信息，请参阅 <bpt id="p2">[</bpt>Node.js 文档<ept id="p2">][path API]</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>path<ept id="p1">**</ept>：包含用于处理文件路径的实用工具。有关详细信息，请参阅 <bpt id="p2">[</bpt>Node.js 文档<ept id="p2">][path API]</ept>。</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>querystring<ept id="p1">**</ept>：包含用于处理查询字符串的实用工具。有关详细信息，请参阅 <bpt id="p2">[</bpt>Node.js 文档<ept id="p2">][querystring API]</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>querystring<ept id="p1">**</ept>：包含用于处理查询字符串的实用工具。有关详细信息，请参阅 <bpt id="p2">[</bpt>Node.js 文档<ept id="p2">][querystring API]</ept>。</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>request<ept id="p1">**</ept>：向 Twitter 和 Facebook 等外部 REST 服务发送 HTTP 请求。有关详细信息，请参阅<bpt id="p2">[</bpt><ept id="p2">发送 HTTP 请求]</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>request<ept id="p1">**</ept>：向 Twitter 和 Facebook 等外部 REST 服务发送 HTTP 请求。有关详细信息，请参阅<bpt id="p2">[</bpt><ept id="p2">发送 HTTP 请求]</ept>。</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>sendgrid<ept id="p1">**</ept>：使用 Azure 中的 Sendgrid 电子邮件服务发送电子邮件。有关详细信息，请参阅<bpt id="p2">[</bpt><ept id="p2">使用 SendGrid 从移动服务发送电子邮件]</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>sendgrid<ept id="p1">**</ept>：使用 Azure 中的 Sendgrid 电子邮件服务发送电子邮件。有关详细信息，请参阅<bpt id="p2">[</bpt><ept id="p2">使用 SendGrid 从移动服务发送电子邮件]</ept>。</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>url<ept id="p1">**</ept>：包含用于分析和解析 URL 的实用工具。有关详细信息，请参阅 <bpt id="p2">[</bpt>Node.js 文档<ept id="p2">][url API]</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>url<ept id="p1">**</ept>：包含用于分析和解析 URL 的实用工具。有关详细信息，请参阅 <bpt id="p2">[</bpt>Node.js 文档<ept id="p2">][url API]</ept>。</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>util<ept id="p1">**</ept>：包含各种实用工具，例如字符串格式设置和对象类型检查。有关详细信息，请参阅 <bpt id="p2">[</bpt>Node.js 文档<ept id="p2">][util API]</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>util<ept id="p1">**</ept>：包含各种实用工具，例如字符串格式设置和对象类型检查。有关详细信息，请参阅 <bpt id="p2">[</bpt>Node.js 文档<ept id="p2">][util API]</ept>。</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>zlib<ept id="p1">**</ept>：公开压缩功能，例如 gzip 和 deflate。有关详细信息，请参阅 <bpt id="p2">[</bpt>Node.js 文档<ept id="p2">][zlib API]</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>zlib<ept id="p1">**</ept>：公开压缩功能，例如 gzip 和 deflate。有关详细信息，请参阅 <bpt id="p2">[</bpt>Node.js 文档<ept id="p2">][zlib API]</ept>。</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="modules-helper-functions"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：利用模块</source>
          <target state="new"><ph id="ph1">&lt;a name="modules-helper-functions"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：利用模块</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>移动服务公开了脚本可以使用全局 <bpt id="p1">**</bpt>require<ept id="p1">**</ept> 函数加载的一组模块。例如，脚本可以要求使用 <bpt id="p2">**</bpt>request<ept id="p2">**</ept> 发出 HTTP 请求：</source>
          <target state="new">移动服务公开了脚本可以使用全局 <bpt id="p1">**</bpt>require<ept id="p1">**</ept> 函数加载的一组模块。例如，脚本可以要求使用 <bpt id="p2">**</bpt>request<ept id="p2">**</ept> 发出 HTTP 请求：</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="shared-code-source-control"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：使用源代码管理来共享代码</source>
          <target state="new"><ph id="ph1">&lt;a name="shared-code-source-control"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：使用源代码管理来共享代码</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>你可以将源代码管理与 Node.js 程序包管理器 (npm) 结合使用，以控制可供移动服务使用的模块。可通过两种方式实现此目的：</source>
          <target state="new">你可以将源代码管理与 Node.js 程序包管理器 (npm) 结合使用，以控制可供移动服务使用的模块。可通过两种方式实现此目的：</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>对于已发布到 npm 的模块以及 npm 安装的模块，可以使用 package.json 文件来声明你希望通过移动服务进行安装的程序包。这样，你的服务始终都能访问所需程序包的最新版本。package.json 文件驻留在 <ph id="ph1">`.\service`</ph> 目录中。有关详细信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">Azure 移动服务中对 package.json 的支持]</ept>。</source>
          <target state="new">对于已发布到 npm 的模块以及 npm 安装的模块，可以使用 package.json 文件来声明你希望通过移动服务进行安装的程序包。这样，你的服务始终都能访问所需程序包的最新版本。package.json 文件驻留在 <ph id="ph1">`.\service`</ph> 目录中。有关详细信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">Azure 移动服务中对 package.json 的支持]</ept>。</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>对于专用或自定义模块，你可以使用 npm 手动将模块安装到源代码管理的 <ph id="ph1">`.\service\node_modules`</ph> 目录中。有关如何手动上载模块的示例，请参阅<bpt id="p1">[</bpt><ept id="p1">在服务器脚本中利用共享代码和 Node.js 模块]</ept>。</source>
          <target state="new">对于专用或自定义模块，你可以使用 npm 手动将模块安装到源代码管理的 <ph id="ph1">`.\service\node_modules`</ph> 目录中。有关如何手动上载模块的示例，请参阅<bpt id="p1">[</bpt><ept id="p1">在服务器脚本中利用共享代码和 Node.js 模块]</ept>。</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>如果 <ph id="ph2">`node_modules`</ph> 已在目录层次结构中存在，NPM 将在该目录中创建 <ph id="ph3">`\node-uuid`</ph> 子目录，而不是在存储库中创建一个新的 <ph id="ph4">`node_modules`</ph>。在此情况下，你只需删除现有的 <ph id="ph5">`node_modules`</ph> 目录即可。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>如果 <ph id="ph2">`node_modules`</ph> 已在目录层次结构中存在，NPM 将在该目录中创建 <ph id="ph3">`\node-uuid`</ph> 子目录，而不是在存储库中创建一个新的 <ph id="ph4">`node_modules`</ph>。在此情况下，你只需删除现有的 <ph id="ph5">`node_modules`</ph> 目录即可。</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>将 package.json 文件或自定义模块提交到移动服务的存储库后，请使用 <bpt id="p1">**</bpt>require<ept id="p1">**</ept> 来按名称引用这些模块。</source>
          <target state="new">将 package.json 文件或自定义模块提交到移动服务的存储库后，请使用 <bpt id="p1">**</bpt>require<ept id="p1">**</ept> 来按名称引用这些模块。</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>在 package.json 中指定的模块或者上载到移动服务的模块只会在服务器脚本代码中使用。移动服务运行时不使用这些模块。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>在 package.json 中指定的模块或者上载到移动服务的模块只会在服务器脚本代码中使用。移动服务运行时不使用这些模块。</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="helper-functions"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：使用 Helper 函数</source>
          <target state="new"><ph id="ph1">&lt;a name="helper-functions"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：使用 Helper 函数</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>除了要求使用模块外，单个服务器脚本还可以包含 Helper 函数。这些函数与主函数不同，后者可用于分离脚本中的代码。</source>
          <target state="new">除了要求使用模块外，单个服务器脚本还可以包含 Helper 函数。这些函数与主函数不同，后者可用于分离脚本中的代码。</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>在以下示例中，表脚本已注册到包含 Helper 函数 <bpt id="p1">**</bpt>handleUnapprovedItem<ept id="p1">**</ept> 的插入操作：</source>
          <target state="new">在以下示例中，表脚本已注册到包含 Helper 函数 <bpt id="p1">**</bpt>handleUnapprovedItem<ept id="p1">**</ept> 的插入操作：</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>在脚本中，Helper 函数必须在主函数之后声明。必须声明脚本中的所有变量。未声明的变量会导致出错。</source>
          <target state="new">在脚本中，Helper 函数必须在主函数之后声明。必须声明脚本中的所有变量。未声明的变量会导致出错。</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Helper 函数也可以只定义一次，然后在服务器脚本之间共享。若要在脚本之间共享某个函数，必须导出该函数，并且脚本文件必须在 <ph id="ph1">`.\service\shared`</ph> 目录中存在。以下模板演示了如何在文件 <ph id="ph2">`.\services\shared\helpers.js`</ph> 中导出共享函数：</source>
          <target state="new">Helper 函数也可以只定义一次，然后在服务器脚本之间共享。若要在脚本之间共享某个函数，必须导出该函数，并且脚本文件必须在 <ph id="ph1">`.\service\shared`</ph> 目录中存在。以下模板演示了如何在文件 <ph id="ph2">`.\services\shared\helpers.js`</ph> 中导出共享函数：</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>然后，你可以在表操作脚本中使用类似于下面的函数：</source>
          <target state="new">然后，你可以在表操作脚本中使用类似于下面的函数：</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>在此示例中，必须将 <bpt id="p1">[</bpt><ept id="p1">tables 对象]</ept>和 <bpt id="p2">[</bpt><ept id="p2">user 对象]</ept>都传递给共享函数。这是因为共享脚本不能访问全局 <bpt id="p3">[</bpt><ept id="p3">tables 对象]</ept>，而 <bpt id="p4">[</bpt><ept id="p4">user 对象]</ept>只在请求的上下文中存在。</source>
          <target state="new">在此示例中，必须将 <bpt id="p1">[</bpt><ept id="p1">tables 对象]</ept>和 <bpt id="p2">[</bpt><ept id="p2">user 对象]</ept>都传递给共享函数。这是因为共享脚本不能访问全局 <bpt id="p3">[</bpt><ept id="p3">tables 对象]</ept>，而 <bpt id="p4">[</bpt><ept id="p4">user 对象]</ept>只在请求的上下文中存在。</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>可以使用<bpt id="p1">[</bpt>源代码管理<ept id="p1">][How to: Share code by using source control]</ept>或<bpt id="p2">[</bpt>命令行工具<ept id="p2">][Using the command line tool]</ept>将脚本文件上载到共享目录。</source>
          <target state="new">可以使用<bpt id="p1">[</bpt>源代码管理<ept id="p1">][How to: Share code by using source control]</ept>或<bpt id="p2">[</bpt>命令行工具<ept id="p2">][Using the command line tool]</ept>将脚本文件上载到共享目录。</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="app-settings"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：使用应用程序设置</source>
          <target state="new"><ph id="ph1">&lt;a name="app-settings"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：使用应用程序设置</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>移动服务允许你将值安全地存储为应用程序设置，服务器脚本在运行时可以访问这些设置。将数据添加到移动服务的应用程序设置时，名称/值对将以加密的形式存储，你可以在服务器脚本中访问这些数据，而无需在脚本文件中对其进行硬编码。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">应用设置]</ept>。</source>
          <target state="new">移动服务允许你将值安全地存储为应用程序设置，服务器脚本在运行时可以访问这些设置。将数据添加到移动服务的应用程序设置时，名称/值对将以加密的形式存储，你可以在服务器脚本中访问这些数据，而无需在脚本文件中对其进行硬编码。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">应用设置]</ept>。</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>以下自定义 API 示例使用提供的 <bpt id="p1">[</bpt><ept id="p1">service 对象]</ept>来检索某个应用程序设置值。</source>
          <target state="new">以下自定义 API 示例使用提供的 <bpt id="p1">[</bpt><ept id="p1">service 对象]</ept>来检索某个应用程序设置值。</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>以下代码使用配置模块来检索计划作业脚本使用的应用程序设置中存储的 Twitter 访问令牌值：</source>
          <target state="new">以下代码使用配置模块来检索计划作业脚本使用的应用程序设置中存储的 Twitter 访问令牌值：</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>请注意，此代码还会检索门户的“标识”选项卡中存储的 Twitter 使用者密钥值。由于 <bpt id="p1">**</bpt>config 对象<ept id="p1">**</ept>在表操作和计划的作业脚本中不可用，因此你必须要求配置模块访问应用程序设置。</source>
          <target state="new">请注意，此代码还会检索门户的“标识”选项卡中存储的 Twitter 使用者密钥值。由于 <bpt id="p1">**</bpt>config 对象<ept id="p1">**</ept>在表操作和计划的作业脚本中不可用，因此你必须要求配置模块访问应用程序设置。</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="command-prompt"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>使用命令行工具</source>
          <target state="new"><ph id="ph1">&lt;a name="command-prompt"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>使用命令行工具</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>在移动服务中，你可以使用 Azure 命令行工具创建、修改和删除服务器脚本。上载脚本之前，请确保使用的是以下目录结构：</source>
          <target state="new">在移动服务中，你可以使用 Azure 命令行工具创建、修改和删除服务器脚本。上载脚本之前，请确保使用的是以下目录结构：</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="new">4</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>请注意，此目录结构与使用源代码管理时的 git 存储库相同。</source>
          <target state="new">请注意，此目录结构与使用源代码管理时的 git 存储库相同。</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>从命令行工具上载脚本文件时，必须先导航到 <ph id="ph1">`.\services`</ph> 目录。以下命令从 <ph id="ph2">`table`</ph> 子目录上载名为 <ph id="ph3">`todoitem.insert.js`</ph> 的脚本：</source>
          <target state="new">从命令行工具上载脚本文件时，必须先导航到 <ph id="ph1">`.\services`</ph> 目录。以下命令从 <ph id="ph2">`table`</ph> 子目录上载名为 <ph id="ph3">`todoitem.insert.js`</ph> 的脚本：</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>以下命令返回移动服务中维护的每个脚本文件的相关信息：</source>
          <target state="new">以下命令返回移动服务中维护的每个脚本文件的相关信息：</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">用于管理 Azure 移动服务的命令]</ept>。</source>
          <target state="new">有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">用于管理 Azure 移动服务的命令]</ept>。</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="working-with-tables"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>使用表</source>
          <target state="new"><ph id="ph1">&lt;a name="working-with-tables"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>使用表</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>本部分详细介绍了用于直接处理 SQL 数据库表数据的策略，具体包括以下小节：</source>
          <target state="new">本部分详细介绍了用于直接处理 SQL 数据库表数据的策略，具体包括以下小节：</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>使用表的概述</source>
          <target state="new">使用表的概述</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>如何：从脚本访问表</source>
          <target state="new">如何：从脚本访问表</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>如何：执行批量插入</source>
          <target state="new">如何：执行批量插入</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>如何：将 JSON 类型映射到数据库类型</source>
          <target state="new">如何：将 JSON 类型映射到数据库类型</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>使用 Transact-SQL 访问表</source>
          <target state="new">使用 Transact-SQL 访问表</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="overview-tables"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>使用表的概述</source>
          <target state="new"><ph id="ph1">&lt;a name="overview-tables"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>使用表的概述</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>移动服务中的许多情况都要求服务器脚本访问数据库中的表。例如，由于每次执行脚本后移动服务不保存状态，因此，必须在表中存储每次执行脚本后需要持久保留的数据。你还可能想要检查权限表中的条目，或者要存储审核数据而不仅仅是写入日志，因为日志中的数据保留期有限，并且无法以编程方式访问。</source>
          <target state="new">移动服务中的许多情况都要求服务器脚本访问数据库中的表。例如，由于每次执行脚本后移动服务不保存状态，因此，必须在表中存储每次执行脚本后需要持久保留的数据。你还可能想要检查权限表中的条目，或者要存储审核数据而不仅仅是写入日志，因为日志中的数据保留期有限，并且无法以编程方式访问。</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>移动服务提供两种用于访问表的方法：使用 <bpt id="p1">[</bpt><ept id="p1">table 对象]</ept>代理，或者通过使用 <bpt id="p2">[</bpt><ept id="p2">mssql 对象]</ept>撰写 Transact-SQL 查询。使用 <bpt id="p3">[</bpt><ept id="p3">table 对象]</ept>可以轻松访问服务器脚本代码中的表数据，不过，<bpt id="p4">[</bpt><ept id="p4">mssql 对象]</ept>支持更复杂的数据操作，并提供最大的灵活性。</source>
          <target state="new">移动服务提供两种用于访问表的方法：使用 <bpt id="p1">[</bpt><ept id="p1">table 对象]</ept>代理，或者通过使用 <bpt id="p2">[</bpt><ept id="p2">mssql 对象]</ept>撰写 Transact-SQL 查询。使用 <bpt id="p3">[</bpt><ept id="p3">table 对象]</ept>可以轻松访问服务器脚本代码中的表数据，不过，<bpt id="p4">[</bpt><ept id="p4">mssql 对象]</ept>支持更复杂的数据操作，并提供最大的灵活性。</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="access-tables"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：从脚本访问表</source>
          <target state="new"><ph id="ph1">&lt;a name="access-tables"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：从脚本访问表</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>从脚本访问表的最简单方法就是使用 <bpt id="p1">[</bpt><ept id="p1">tables 对象]</ept>。<bpt id="p2">**</bpt>getTable<ept id="p2">**</ept> 函数将返回一个 <bpt id="p3">[</bpt><ept id="p3">table 对象]</ept>实例，即用于访问所请求表的代理。然后，你可以调用该代理的函数来访问和更改数据。</source>
          <target state="new">从脚本访问表的最简单方法就是使用 <bpt id="p1">[</bpt><ept id="p1">tables 对象]</ept>。<bpt id="p2">**</bpt>getTable<ept id="p2">**</ept> 函数将返回一个 <bpt id="p3">[</bpt><ept id="p3">table 对象]</ept>实例，即用于访问所请求表的代理。然后，你可以调用该代理的函数来访问和更改数据。</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>已同时注册到表操作和计划作业的脚本可以访问全局对象形式的 <bpt id="p1">[</bpt><ept id="p1">tables 对象]</ept>。以下代码行将从全局 <bpt id="p2">[</bpt><ept id="p2">tables 对象]</ept>中获取 <bpt id="p3">*</bpt>TodoItems<ept id="p3">*</ept> 表的代理：</source>
          <target state="new">已同时注册到表操作和计划作业的脚本可以访问全局对象形式的 <bpt id="p1">[</bpt><ept id="p1">tables 对象]</ept>。以下代码行将从全局 <bpt id="p2">[</bpt><ept id="p2">tables 对象]</ept>中获取 <bpt id="p3">*</bpt>TodoItems<ept id="p3">*</ept> 表的代理：</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>自定义 API 脚本可从提供的 <bpt id="p1">[</bpt><ept id="p1">request 对象]</ept>的 <ph id="ph1">&lt;strong&gt;</ph>service<ph id="ph2">&lt;/strong&gt;</ph> 属性访问 <bpt id="p2">[</bpt><ept id="p2">tables 对象]</ept>。以下代码行将从请求中获取 <bpt id="p3">[</bpt><ept id="p3">tables 对象]</ept>：</source>
          <target state="new">自定义 API 脚本可从提供的 <bpt id="p1">[</bpt><ept id="p1">request 对象]</ept>的 <ph id="ph1">&lt;strong&gt;</ph>service<ph id="ph2">&lt;/strong&gt;</ph> 属性访问 <bpt id="p2">[</bpt><ept id="p2">tables 对象]</ept>。以下代码行将从请求中获取 <bpt id="p3">[</bpt><ept id="p3">tables 对象]</ept>：</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>共享函数不能直接访问 <bpt id="p1">**</bpt>tables<ept id="p1">**</ept> 对象。在共享函数中，必须将表对象传递给该函数。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>共享函数不能直接访问 <bpt id="p1">**</bpt>tables<ept id="p1">**</ept> 对象。在共享函数中，必须将表对象传递给该函数。</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>获得 <bpt id="p1">[</bpt><ept id="p1">table 对象]</ept>后，可以调用一个或多个表操作函数：insert、update、delete 或 read。以下示例将从 permissions 表中读取用户权限：</source>
          <target state="new">获得 <bpt id="p1">[</bpt><ept id="p1">table 对象]</ept>后，可以调用一个或多个表操作函数：insert、update、delete 或 read。以下示例将从 permissions 表中读取用户权限：</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>下一个示例将审核信息写入 <bpt id="p1">**</bpt>audit<ept id="p1">**</ept> 表：</source>
          <target state="new">下一个示例将审核信息写入 <bpt id="p1">**</bpt>audit<ept id="p1">**</ept> 表：</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>以下部分的代码示例中提供了最后一个示例：<bpt id="p1">[</bpt>如何：访问自定义参数<ept id="p1">][How to: Add custom parameters]</ept>。</source>
          <target state="new">以下部分的代码示例中提供了最后一个示例：<bpt id="p1">[</bpt>如何：访问自定义参数<ept id="p1">][How to: Add custom parameters]</ept>。</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="bulk-inserts"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：执行批量插入</source>
          <target state="new"><ph id="ph1">&lt;a name="bulk-inserts"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：执行批量插入</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>如果你使用 <bpt id="p1">**</bpt>for<ept id="p1">**</ept> 或 <bpt id="p2">**</bpt>while<ept id="p2">**</ept> 循环直接在表中插入大量的项（例如 1000 个），可能会遇到 SQL 连接限制，导致某些插入操作失败。你的请求可能永远无法完成，或者返回 HTTP 500 内部服务器错误。若要避免此问题，可以按照大约每 10 个一批的形式插入项。插入第一批后，再提交下一批，直至完成。</source>
          <target state="new">如果你使用 <bpt id="p1">**</bpt>for<ept id="p1">**</ept> 或 <bpt id="p2">**</bpt>while<ept id="p2">**</ept> 循环直接在表中插入大量的项（例如 1000 个），可能会遇到 SQL 连接限制，导致某些插入操作失败。你的请求可能永远无法完成，或者返回 HTTP 500 内部服务器错误。若要避免此问题，可以按照大约每 10 个一批的形式插入项。插入第一批后，再提交下一批，直至完成。</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>使用以下脚本可以设置要同时插入的记录批的大小。建议保持使用较小的记录数。完成异步插入批时，<bpt id="p1">**</bpt>insertItems<ept id="p1">**</ept> 函数将以递归方式调用自身。末尾的 for 循环一次插入一条记录，并在成功时调用 <bpt id="p2">**</bpt>insertComplete<ept id="p2">**</ept>，在出错时调用 <bpt id="p3">**</bpt>errorHandler<ept id="p3">**</ept>。<bpt id="p4">**</bpt>insertComplete<ept id="p4">**</ept> 控制是以递归方式为下一批调用 <bpt id="p5">**</bpt>insertItems<ept id="p5">**</ept>，还是在作业已完成的情况下退出脚本。</source>
          <target state="new">使用以下脚本可以设置要同时插入的记录批的大小。建议保持使用较小的记录数。完成异步插入批时，<bpt id="p1">**</bpt>insertItems<ept id="p1">**</ept> 函数将以递归方式调用自身。末尾的 for 循环一次插入一条记录，并在成功时调用 <bpt id="p2">**</bpt>insertComplete<ept id="p2">**</ept>，在出错时调用 <bpt id="p3">**</bpt>errorHandler<ept id="p3">**</ept>。<bpt id="p4">**</bpt>insertComplete<ept id="p4">**</ept> 控制是以递归方式为下一批调用 <bpt id="p5">**</bpt>insertItems<ept id="p5">**</ept>，还是在作业已完成的情况下退出脚本。</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>可以在此<bpt id="p1">[</bpt>博客文章<ept id="p1">](http://blogs.msdn.com/b/jpsanders/archive/2013/03/20/server-script-to-insert-table-items-in-windows-azure-mobile-services.aspx)</ept>中找到整个代码示例和相关的讨论。如果使用此代码，你可以根据你的具体情况对它进行改写，并全面进行测试。</source>
          <target state="new">可以在此<bpt id="p1">[</bpt>博客文章<ept id="p1">](http://blogs.msdn.com/b/jpsanders/archive/2013/03/20/server-script-to-insert-table-items-in-windows-azure-mobile-services.aspx)</ept>中找到整个代码示例和相关的讨论。如果使用此代码，你可以根据你的具体情况对它进行改写，并全面进行测试。</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="JSON-types"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：将 JSON 类型映射到数据库类型</source>
          <target state="new"><ph id="ph1">&lt;a name="JSON-types"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：将 JSON 类型映射到数据库类型</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>客户端上的数据类型集合不同于移动服务数据库表中的数据类型集合。有时它们可以轻松地映射到另一种类型，而其他时候不会映射。移动服务执行映射中的多种类型转换：</source>
          <target state="new">客户端上的数据类型集合不同于移动服务数据库表中的数据类型集合。有时它们可以轻松地映射到另一种类型，而其他时候不会映射。移动服务执行映射中的多种类型转换：</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>客户端语言特定的类型将序列化为 JSON。</source>
          <target state="new">客户端语言特定的类型将序列化为 JSON。</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>JSON 表示形式在出现于服务器脚本中之前将转换成 JavaScript。</source>
          <target state="new">JSON 表示形式在出现于服务器脚本中之前将转换成 JavaScript。</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">[</bpt><ept id="p1">tables 对象]</ept>保存 JavaScript 数据类型时，这些类型将转换成 SQL 数据库类型。</source>
          <target state="new">使用 <bpt id="p1">[</bpt><ept id="p1">tables 对象]</ept>保存 JavaScript 数据类型时，这些类型将转换成 SQL 数据库类型。</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>从客户端架构到 JSON 的转换根据平台的不同而异。Windows 应用商店和 Windows Phone 客户端使用 JSON.NET。Android 客户端使用 gson 库。iOS 客户端使用 NSJSONSerialization 类。将使用其中每个库的默认序列化行为，不过，日期对象将转换成 JSON 字符串，这些字符串包含使用 ISO 8601 编码的日期。</source>
          <target state="new">从客户端架构到 JSON 的转换根据平台的不同而异。Windows 应用商店和 Windows Phone 客户端使用 JSON.NET。Android 客户端使用 gson 库。iOS 客户端使用 NSJSONSerialization 类。将使用其中每个库的默认序列化行为，不过，日期对象将转换成 JSON 字符串，这些字符串包含使用 ISO 8601 编码的日期。</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>当你编写使用 <bpt id="p1">[</bpt><ept id="p1">insert]</ept>、<bpt id="p2">[</bpt><ept id="p2">update]</ept>、<bpt id="p3">[</bpt><ept id="p3">read]</ept> 或 <bpt id="p4">[</bpt><ept id="p4">delete]</ept> 函数的服务器脚本时，可以访问数据的 JavaScript 表示形式。移动服务使用 Node.js 的反序列化函数 (<bpt id="p5">[</bpt>JSON.parse<ept id="p5">](http://es5.github.io/#x15.12)</ept>) 将 JSON 在线转换为 JavaScript 对象。但是，移动服务将执行转换以提取 ISO 8601 字符串中的 <bpt id="p6">**</bpt>Date<ept id="p6">**</ept> 对象。</source>
          <target state="new">当你编写使用 <bpt id="p1">[</bpt><ept id="p1">insert]</ept>、<bpt id="p2">[</bpt><ept id="p2">update]</ept>、<bpt id="p3">[</bpt><ept id="p3">read]</ept> 或 <bpt id="p4">[</bpt><ept id="p4">delete]</ept> 函数的服务器脚本时，可以访问数据的 JavaScript 表示形式。移动服务使用 Node.js 的反序列化函数 (<bpt id="p5">[</bpt>JSON.parse<ept id="p5">](http://es5.github.io/#x15.12)</ept>) 将 JSON 在线转换为 JavaScript 对象。但是，移动服务将执行转换以提取 ISO 8601 字符串中的 <bpt id="p6">**</bpt>Date<ept id="p6">**</ept> 对象。</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>当你使用 <bpt id="p1">[</bpt><ept id="p1">tables 对象]</ept>或 <bpt id="p2">[</bpt><ept id="p2">mssql 对象]</ept>时，或只是执行表脚本时，将在 SQL 数据库中插入反序列化的 JavaScript 对象。在此过程中，对象属性将映射到 T-SQL 类型：</source>
          <target state="new">当你使用 <bpt id="p1">[</bpt><ept id="p1">tables 对象]</ept>或 <bpt id="p2">[</bpt><ept id="p2">mssql 对象]</ept>时，或只是执行表脚本时，将在 SQL 数据库中插入反序列化的 JavaScript 对象。在此过程中，对象属性将映射到 T-SQL 类型：</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>JavaScript 属性</source>
          <target state="new">JavaScript 属性</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>T-SQL 类型</source>
          <target state="new">T-SQL 类型</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="new">Number</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Float(53)</source>
          <target state="new">Float(53)</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="new">Boolean</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Bit</source>
          <target state="new">Bit</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Date</source>
          <target state="new">Date</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>DateTimeOffset(3)</source>
          <target state="new">DateTimeOffset(3)</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="new">String</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Nvarchar(max)</source>
          <target state="new">Nvarchar(max)</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Buffer</source>
          <target state="new">Buffer</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>不支持</source>
          <target state="new">不支持</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>对象</source>
          <target state="new">对象</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>不支持</source>
          <target state="new">不支持</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="new">Array</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>不支持</source>
          <target state="new">不支持</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="new">Stream</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>不支持</source>
          <target state="new">不支持</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="TSQL"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>使用 Transact-SQL 访问表</source>
          <target state="new"><ph id="ph1">&lt;a name="TSQL"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>使用 Transact-SQL 访问表</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>从服务器脚本处理表数据的最简单方法就是使用 <bpt id="p1">[</bpt><ept id="p1">table 对象]</ept>代理。但是，<bpt id="p2">[</bpt><ept id="p2">table 对象]</ept>并不支持一些较为高级的方案，例如，联接查询和其他一些复杂查询，以及存储过程的调用。在这些情况下，你必须使用 <bpt id="p3">[</bpt><ept id="p3">mssql 对象]</ept>针对关系表直接执行 Transact-SQL 语句。此对象提供以下函数：</source>
          <target state="new">从服务器脚本处理表数据的最简单方法就是使用 <bpt id="p1">[</bpt><ept id="p1">table 对象]</ept>代理。但是，<bpt id="p2">[</bpt><ept id="p2">table 对象]</ept>并不支持一些较为高级的方案，例如，联接查询和其他一些复杂查询，以及存储过程的调用。在这些情况下，你必须使用 <bpt id="p3">[</bpt><ept id="p3">mssql 对象]</ept>针对关系表直接执行 Transact-SQL 语句。此对象提供以下函数：</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>query<ept id="p1">**</ept>：执行 TSQL 字符串指定的查询；结果将返回到 <bpt id="p2">**</bpt>options<ept id="p2">**</ept> 对象中的 <bpt id="p3">**</bpt>success<ept id="p3">**</ept> 回调。如果存在 <bpt id="p4">*</bpt>params<ept id="p4">*</ept> 参数，则该查询可以包含参数。</source>
          <target state="new"><bpt id="p1">**</bpt>query<ept id="p1">**</ept>：执行 TSQL 字符串指定的查询；结果将返回到 <bpt id="p2">**</bpt>options<ept id="p2">**</ept> 对象中的 <bpt id="p3">**</bpt>success<ept id="p3">**</ept> 回调。如果存在 <bpt id="p4">*</bpt>params<ept id="p4">*</ept> 参数，则该查询可以包含参数。</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>queryRaw<ept id="p1">**</ept>：与 <bpt id="p2">*</bpt>query<ept id="p2">*</ept> 类似，不过，从查询返回的结果集采用“原始”格式（请参阅以下示例）。</source>
          <target state="new"><bpt id="p1">**</bpt>queryRaw<ept id="p1">**</ept>：与 <bpt id="p2">*</bpt>query<ept id="p2">*</ept> 类似，不过，从查询返回的结果集采用“原始”格式（请参阅以下示例）。</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>open<ept id="p1">**</ept>：用于获取与移动服务数据库建立的连接，获取该连接后，你可以使用连接对象来调用 transactions 等数据库操作。</source>
          <target state="new"><bpt id="p1">**</bpt>open<ept id="p1">**</ept>：用于获取与移动服务数据库建立的连接，获取该连接后，你可以使用连接对象来调用 transactions 等数据库操作。</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>这些方法可以进一步让你对查询处理进行低级别的控制。</source>
          <target state="new">这些方法可以进一步让你对查询处理进行低级别的控制。</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>如何：运行静态查询</source>
          <target state="new">如何：运行静态查询</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>如何：运行动态查询</source>
          <target state="new">如何：运行动态查询</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>如何：联接关系表</source>
          <target state="new">如何：联接关系表</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>如何：运行返回 <bpt id="p1">*</bpt>raw<ept id="p1">*</ept> 结果的查询</source>
          <target state="new">如何：运行返回 <bpt id="p1">*</bpt>raw<ept id="p1">*</ept> 结果的查询</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>如何：获取对数据库连接的访问权限</source>
          <target state="new">如何：获取对数据库连接的访问权限</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="static-query"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：运行静态查询</source>
          <target state="new"><ph id="ph1">&lt;a name="static-query"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：运行静态查询</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>以下查询不带参数，将返回 <ph id="ph1">`statusupdate`</ph> 表中的三条记录。行集采用标准的 JSON 格式。</source>
          <target state="new">以下查询不带参数，将返回 <ph id="ph1">`statusupdate`</ph> 表中的三条记录。行集采用标准的 JSON 格式。</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="dynamic-query"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：运行动态参数化查询</source>
          <target state="new"><ph id="ph1">&lt;a name="dynamic-query"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：运行动态参数化查询</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>以下示例通过从权限表中读取每个用户的权限来实现自定义授权。执行该查询时，占位符 (?) 将被替换为提供的参数。</source>
          <target state="new">以下示例通过从权限表中读取每个用户的权限来实现自定义授权。执行该查询时，占位符 (?) 将被替换为提供的参数。</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="joins"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：联接关系表</source>
          <target state="new"><ph id="ph1">&lt;a name="joins"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：联接关系表</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>你可以使用 <bpt id="p1">[</bpt><ept id="p1">mssql 对象]</ept>的 <bpt id="p2">**</bpt>query<ept id="p2">**</ept> 方法联接两个表，以传入实现联接的 TSQL 代码。假设 <bpt id="p3">**</bpt>ToDoItem<ept id="p3">**</ept> 表中有一些项，其中每个项都有一个对应于表中的列的 <bpt id="p4">**</bpt>priority<ept id="p4">**</ept> 属性。其中一个项类似于：</source>
          <target state="new">你可以使用 <bpt id="p1">[</bpt><ept id="p1">mssql 对象]</ept>的 <bpt id="p2">**</bpt>query<ept id="p2">**</ept> 方法联接两个表，以传入实现联接的 TSQL 代码。假设 <bpt id="p3">**</bpt>ToDoItem<ept id="p3">**</ept> 表中有一些项，其中每个项都有一个对应于表中的列的 <bpt id="p4">**</bpt>priority<ept id="p4">**</ept> 属性。其中一个项类似于：</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>另外，我们假设还有一个名为 <bpt id="p1">**</bpt>Priority<ept id="p1">**</ept> 的表，它的行包含优先级 <bpt id="p2">**</bpt>number<ept id="p2">**</ept> 和文本 <bpt id="p3">**</bpt>description<ept id="p3">**</ept>。如果优先级编号 (number) 1 的描述 (description) 为“Critical”，则相应的对象类似于：</source>
          <target state="new">另外，我们假设还有一个名为 <bpt id="p1">**</bpt>Priority<ept id="p1">**</ept> 的表，它的行包含优先级 <bpt id="p2">**</bpt>number<ept id="p2">**</ept> 和文本 <bpt id="p3">**</bpt>description<ept id="p3">**</ept>。如果优先级编号 (number) 1 的描述 (description) 为“Critical”，则相应的对象类似于：</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>现在，我们可以将项中的 <bpt id="p1">**</bpt>priority<ept id="p1">**</ept> 编号替换为优先级编号的文本描述。将两个表进行关系联接即可实现此目的。</source>
          <target state="new">现在，我们可以将项中的 <bpt id="p1">**</bpt>priority<ept id="p1">**</ept> 编号替换为优先级编号的文本描述。将两个表进行关系联接即可实现此目的。</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>该脚本将联接两个表，并将结果写入日志。最终的对象可能类似于：</source>
          <target state="new">该脚本将联接两个表，并将结果写入日志。最终的对象可能类似于：</target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="raw"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：运行返回 <bpt id="p1">*</bpt>raw<ept id="p1">*</ept> 结果的查询</source>
          <target state="new"><ph id="ph1">&lt;a name="raw"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：运行返回 <bpt id="p1">*</bpt>raw<ept id="p1">*</ept> 结果的查询</target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>此示例将像前面一样执行查询，不过，这次会逐行逐列地返回需要你予以分析的“原始”格式结果集。用到此查询的可能情况是你需要访问移动服务不支持的数据类型。此代码会直接将输出写入控制台日志，使你能够检查原始格式。</source>
          <target state="new">此示例将像前面一样执行查询，不过，这次会逐行逐列地返回需要你予以分析的“原始”格式结果集。用到此查询的可能情况是你需要访问移动服务不支持的数据类型。此代码会直接将输出写入控制台日志，使你能够检查原始格式。</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>下面显示了运行此查询后的输出。其中包含有关表中每个列的元数据，后接行和列的表示形式。</source>
          <target state="new">下面显示了运行此查询后的输出。其中包含有关表中每个列的元数据，后接行和列的表示形式。</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="connection"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：获取对数据库连接的访问权限</source>
          <target state="new"><ph id="ph1">&lt;a name="connection"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：获取对数据库连接的访问权限</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>可以使用 <bpt id="p1">**</bpt>open<ept id="p1">**</ept> 方法获取对数据库连接的访问权限。执行此操作的原因之一是你需要使用数据库事务。</source>
          <target state="new">可以使用 <bpt id="p1">**</bpt>open<ept id="p1">**</ept> 方法获取对数据库连接的访问权限。执行此操作的原因之一是你需要使用数据库事务。</target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>成功执行 <bpt id="p1">**</bpt>open<ept id="p1">**</ept> 后，将在 <bpt id="p2">**</bpt>success<ept id="p2">**</ept> 函数中以参数形式传入数据库连接。你可以对 <bpt id="p3">**</bpt>connection<ept id="p3">**</ept> 对象调用以下任何函数：<bpt id="p4">*</bpt>close<ept id="p4">*</ept>、<bpt id="p5">*</bpt>queryRaw<ept id="p5">*</ept>、<bpt id="p6">*</bpt>query<ept id="p6">*</ept>、<bpt id="p7">*</bpt>beginTransaction<ept id="p7">*</ept>、<bpt id="p8">*</bpt>commit<ept id="p8">*</ept> 和 <bpt id="p9">*</bpt>rollback<ept id="p9">*</ept>。</source>
          <target state="new">成功执行 <bpt id="p1">**</bpt>open<ept id="p1">**</ept> 后，将在 <bpt id="p2">**</bpt>success<ept id="p2">**</ept> 函数中以参数形式传入数据库连接。你可以对 <bpt id="p3">**</bpt>connection<ept id="p3">**</ept> 对象调用以下任何函数：<bpt id="p4">*</bpt>close<ept id="p4">*</ept>、<bpt id="p5">*</bpt>queryRaw<ept id="p5">*</ept>、<bpt id="p6">*</bpt>query<ept id="p6">*</ept>、<bpt id="p7">*</bpt>beginTransaction<ept id="p7">*</ept>、<bpt id="p8">*</bpt>commit<ept id="p8">*</ept> 和 <bpt id="p9">*</bpt>rollback<ept id="p9">*</ept>。</target>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="debugging"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>调试和故障排除</source>
          <target state="new"><ph id="ph1">&lt;a name="debugging"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>调试和故障排除</target>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>调试服务器脚本及排查其错误的主要方法是写入服务日志。默认情况下，移动服务会将执行服务脚本期间发生的错误写入服务日志。你的脚本也可以对日志执行写入操作。写入日志是调试脚本及验证其行为是否符合预期的良好方法。</source>
          <target state="new">调试服务器脚本及排查其错误的主要方法是写入服务日志。默认情况下，移动服务会将执行服务脚本期间发生的错误写入服务日志。你的脚本也可以对日志执行写入操作。写入日志是调试脚本及验证其行为是否符合预期的良好方法。</target>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="write-to-logs"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：将输出写入移动服务日志</source>
          <target state="new"><ph id="ph1">&lt;a name="write-to-logs"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：将输出写入移动服务日志</target>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>若要写入日志，请使用全局 <bpt id="p1">[</bpt><ept id="p1">console 对象]</ept>。使用 <bpt id="p2">**</bpt>log<ept id="p2">**</ept> 或 <bpt id="p3">**</bpt>info<ept id="p3">**</ept> 函数记录信息级警告。<bpt id="p4">**</bpt>warning<ept id="p4">**</ept> 和 <bpt id="p5">**</bpt>error<ept id="p5">**</ept> 函数将记录其对应级别，这些级别已在日志中予以标注。</source>
          <target state="new">若要写入日志，请使用全局 <bpt id="p1">[</bpt><ept id="p1">console 对象]</ept>。使用 <bpt id="p2">**</bpt>log<ept id="p2">**</ept> 或 <bpt id="p3">**</bpt>info<ept id="p3">**</ept> 函数记录信息级警告。<bpt id="p4">**</bpt>warning<ept id="p4">**</ept> 和 <bpt id="p5">**</bpt>error<ept id="p5">**</ept> 函数将记录其对应级别，这些级别已在日志中予以标注。</target>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>若要查看移动服务的日志，请登录到 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">](https://manage.windowsazure.cn/)</ept>，选择你的移动服务，然后选择“日志”选项卡。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>若要查看移动服务的日志，请登录到 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">](https://manage.windowsazure.cn/)</ept>，选择你的移动服务，然后选择“日志”选项卡。</target>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>你还可以使用 <bpt id="p1">[</bpt><ept id="p1">console 对象]</ept>的日志记录功能通过参数来设置消息格式。以下示例向消息字符串提供了一个参数形式的 JSON 对象：</source>
          <target state="new">你还可以使用 <bpt id="p1">[</bpt><ept id="p1">console 对象]</ept>的日志记录功能通过参数来设置消息格式。以下示例向消息字符串提供了一个参数形式的 JSON 对象：</target>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>请注意，字符串 <ph id="ph1">`%j`</ph> 用作 JSON 对象的占位符，并且参数是按顺序提供的。</source>
          <target state="new">请注意，字符串 <ph id="ph1">`%j`</ph> 用作 JSON 对象的占位符，并且参数是按顺序提供的。</target>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>为了避免在日志中记录过多的信息，你应该删除或禁用生产环境不需要使用的 console.log() 调用。</source>
          <target state="new">为了避免在日志中记录过多的信息，你应该删除或禁用生产环境不需要使用的 console.log() 调用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>