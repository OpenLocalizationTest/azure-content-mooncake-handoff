<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">895c42f6a0e334709902aa2c0c8b69d70085006e</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>创建具有 .NET 后端的 Windows 应用商店排行榜应用 | Azure 移动服务</source>
          <target state="new">创建具有 .NET 后端的 Windows 应用商店排行榜应用 | Azure 移动服务</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何使用 Azure 移动服务构建具有 .NET 后端的 Windows 应用商店排行榜应用。</source>
          <target state="new">了解如何使用 Azure 移动服务构建具有 .NET 后端的 Windows 应用商店排行榜应用。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>使用 Azure 移动服务 .NET 后端创建排行榜应用程序</source>
          <target state="new">使用 Azure 移动服务 .NET 后端创建排行榜应用程序</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;</source>
          <target state="new">&amp;nbsp;</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本教程将说明如何使用具有 .NET 后端的 Azure 移动服务生成 Windows 应用商店应用程序。Azure 移动服务提供可缩放且安全的后端，具有内置身份验证、监视、推送通知和其他功能，以及用来生成移动应用程序的跨平台客户端库。移动服务的 .NET 后端基于 <bpt id="p1">[</bpt>ASP.NET Web API<ept id="p1">](http://asp.net/web-api)</ept>，可为 .NET 开发人员提供创建 REST API 的绝佳途径。</source>
          <target state="new">本教程将说明如何使用具有 .NET 后端的 Azure 移动服务生成 Windows 应用商店应用程序。Azure 移动服务提供可缩放且安全的后端，具有内置身份验证、监视、推送通知和其他功能，以及用来生成移动应用程序的跨平台客户端库。移动服务的 .NET 后端基于 <bpt id="p1">[</bpt>ASP.NET Web API<ept id="p1">](http://asp.net/web-api)</ept>，可为 .NET 开发人员提供创建 REST API 的绝佳途径。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Web API 是一个开源框架，可为 .NET 开发人员提供创建 REST API 的绝佳途径。你可以在 Azure 网站或使用 .NET 后端的 Azure 移动服务上托管 Web API 解决方案，甚至以自定义过程自我托管解决方案。移动服务是专门为移动应用程序设计的托管环境。当你在移动服务上托管 Web API 服务时，除了数据存储以外，还可以获得以下好处：</source>
          <target state="new">Web API 是一个开源框架，可为 .NET 开发人员提供创建 REST API 的绝佳途径。你可以在 Azure 网站或使用 .NET 后端的 Azure 移动服务上托管 Web API 解决方案，甚至以自定义过程自我托管解决方案。移动服务是专门为移动应用程序设计的托管环境。当你在移动服务上托管 Web API 服务时，除了数据存储以外，还可以获得以下好处：</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>使用社交服务提供商和 Azure Active Directory (AAD) 的内置身份验证。</source>
          <target state="new">使用社交服务提供商和 Azure Active Directory (AAD) 的内置身份验证。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>使用设备特定的通知服务将通知推送到应用程序。</source>
          <target state="new">使用设备特定的通知服务将通知推送到应用程序。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>一整套可让你从任何应用程序轻松访问服务的客户端库。</source>
          <target state="new">一整套可让你从任何应用程序轻松访问服务的客户端库。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>内置的日志记录和诊断。</source>
          <target state="new">内置的日志记录和诊断。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>在本教程中你将：</source>
          <target state="new">在本教程中你将：</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>使用 Azure 移动服务创建 REST API。</source>
          <target state="new">使用 Azure 移动服务创建 REST API。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>将服务发布到 Azure。</source>
          <target state="new">将服务发布到 Azure。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>创建使用服务的 Windows 应用商店应用程序。</source>
          <target state="new">创建使用服务的 Windows 应用商店应用程序。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>使用 Entity Framework (EF) 创建外键关系和数据传输对象 (DTO)。</source>
          <target state="new">使用 Entity Framework (EF) 创建外键关系和数据传输对象 (DTO)。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>使用 ASP.NET Web API 定义自定义 API。</source>
          <target state="new">使用 ASP.NET Web API 定义自定义 API。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>本教程使用 <bpt id="p1">[</bpt>Visual Studio 2013 最新更新版<ept id="p1">](http://go.microsoft.com/fwlink/p/?LinkID=390465)</ept>。</source>
          <target state="new">本教程使用 <bpt id="p1">[</bpt>Visual Studio 2013 最新更新版<ept id="p1">](http://go.microsoft.com/fwlink/p/?LinkID=390465)</ept>。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>关于示例应用程序</source>
          <target state="new">关于示例应用程序</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>排行榜<ept id="p1">*</ept>显示游戏的玩家列表，以及每个玩家的分数和排名。排行榜可作为较大游戏的一部分，或作为单独的应用程序。排行榜是实际的应用程序，但简单易懂且可用于教程。下面是该应用程序的屏幕截图：</source>
          <target state="new"><bpt id="p1">*</bpt>排行榜<ept id="p1">*</ept>显示游戏的玩家列表，以及每个玩家的分数和排名。排行榜可作为较大游戏的一部分，或作为单独的应用程序。排行榜是实际的应用程序，但简单易懂且可用于教程。下面是该应用程序的屏幕截图：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>为了方便说明此应用程序，其中不含任何实际的游戏。你可以添加玩家，以及提交每个玩家的分数。当你提交分数时，移动服务会计算新排名。在后端上，移动服务会创建具有两个表的数据库：</source>
          <target state="new">为了方便说明此应用程序，其中不含任何实际的游戏。你可以添加玩家，以及提交每个玩家的分数。当你提交分数时，移动服务会计算新排名。在后端上，移动服务会创建具有两个表的数据库：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Player。包含玩家 ID 和姓名。</source>
          <target state="new">Player。包含玩家 ID 和姓名。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>PlayerRank。包含玩家的分数和排名。</source>
          <target state="new">PlayerRank。包含玩家的分数和排名。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>PlayerRank 具有 Player 的外键。每个玩家各有零个或一个 PlayerRank。</source>
          <target state="new">PlayerRank 具有 Player 的外键。每个玩家各有零个或一个 PlayerRank。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>在实际的排行榜应用程序中，PlayerRank 还可能会有游戏 ID，让玩家提交多个游戏的分数。</source>
          <target state="new">在实际的排行榜应用程序中，PlayerRank 还可能会有游戏 ID，让玩家提交多个游戏的分数。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>客户端应用程序可对 Player 执行一组完整的 CRUD 操作。它可读取或删除现有的 PlayerRank 实体，但无法直接加以创建或更新。这是因为排名值是由服务所计算的。实际做法是，在客户端提交分数后，由服务更新所有玩家的排名。</source>
          <target state="new">客户端应用程序可对 Player 执行一组完整的 CRUD 操作。它可读取或删除现有的 PlayerRank 实体，但无法直接加以创建或更新。这是因为排名值是由服务所计算的。实际做法是，在客户端提交分数后，由服务更新所有玩家的排名。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>在<bpt id="p1">[</bpt>此处<ept id="p1">](http://code.msdn.microsoft.com/Leaderboard-App-with-Azure-9acf63af)</ept>下载完成的项目。</source>
          <target state="new">在<bpt id="p1">[</bpt>此处<ept id="p1">](http://code.msdn.microsoft.com/Leaderboard-App-with-Azure-9acf63af)</ept>下载完成的项目。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>创建项目</source>
          <target state="new">创建项目</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>启动 Visual Studio，并创建新的 ASP.NET Web 应用程序项目。将项目命名为 Leaderboard。</source>
          <target state="new">启动 Visual Studio，并创建新的 ASP.NET Web 应用程序项目。将项目命名为 Leaderboard。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>在 Visual Studio 2013 中，ASP.NET Web 应用程序项目包含 Azure 移动服务的模板。请选择此模板，然后单击“确定”。</source>
          <target state="new">在 Visual Studio 2013 中，ASP.NET Web 应用程序项目包含 Azure 移动服务的模板。请选择此模板，然后单击“确定”。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>项目模板包含示例控制器和数据对象。</source>
          <target state="new">项目模板包含示例控制器和数据对象。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>教程中并不需要这些项目，因此你可以将其从项目中删除。此外，请在 WebApiConfig.cs 和 LeaderboardContext.cs 中删除对 TodoItem 的引用。</source>
          <target state="new">教程中并不需要这些项目，因此你可以将其从项目中删除。此外，请在 WebApiConfig.cs 和 LeaderboardContext.cs 中删除对 TodoItem 的引用。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>添加数据模型</source>
          <target state="new">添加数据模型</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>你将使用 <bpt id="p1">[</bpt>EF Code First<ept id="p1">](http://msdn.microsoft.com/zh-cn/data/ee712907#codefirst)</ept> 来定义数据库表。在 DataObjects 文件夹下，添加名为 <ph id="ph1">`Player`</ph> 的类。</source>
          <target state="new">你将使用 <bpt id="p1">[</bpt>EF Code First<ept id="p1">](http://msdn.microsoft.com/zh-cn/data/ee712907#codefirst)</ept> 来定义数据库表。在 DataObjects 文件夹下，添加名为 <ph id="ph1">`Player`</ph> 的类。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>添加名为 <ph id="ph1">`PlayerRank`</ph> 的另一个类。</source>
          <target state="new">添加名为 <ph id="ph1">`PlayerRank`</ph> 的另一个类。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>请注意，这两个类都继承自 <bpt id="p1">**</bpt>EntityData<ept id="p1">**</ept> 类。派生自 <bpt id="p2">**</bpt>EntityData<ept id="p2">**</ept> 可方便应用程序使用数据，并将跨平台客户端库用于 Azure 移动服务。<bpt id="p3">**</bpt>EntityData<ept id="p3">**</ept> 还可方便应用程序<bpt id="p4">[</bpt>处理数据库写入冲突<ept id="p4">](/documentation/articles/mobile-services-windows-store-dotnet-handle-database-conflicts)</ept>。</source>
          <target state="new">请注意，这两个类都继承自 <bpt id="p1">**</bpt>EntityData<ept id="p1">**</ept> 类。派生自 <bpt id="p2">**</bpt>EntityData<ept id="p2">**</ept> 可方便应用程序使用数据，并将跨平台客户端库用于 Azure 移动服务。<bpt id="p3">**</bpt>EntityData<ept id="p3">**</ept> 还可方便应用程序<bpt id="p4">[</bpt>处理数据库写入冲突<ept id="p4">](/documentation/articles/mobile-services-windows-store-dotnet-handle-database-conflicts)</ept>。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`PlayerRank`</ph> 类具有指向相关 <ph id="ph2">`Player`</ph> 实体的<bpt id="p1">[</bpt>导航属性<ept id="p1">](http://msdn.microsoft.com/zh-cn/data/jj713564.aspx)</ept>。<bpt id="p2">**</bpt>[ForeignKey]<ept id="p2">**</ept> 属性让 EF 知道 <ph id="ph3">`Player`</ph> 属性表示外键。</source>
          <target state="new"><ph id="ph1">`PlayerRank`</ph> 类具有指向相关 <ph id="ph2">`Player`</ph> 实体的<bpt id="p1">[</bpt>导航属性<ept id="p1">](http://msdn.microsoft.com/zh-cn/data/jj713564.aspx)</ept>。<bpt id="p2">**</bpt>[ForeignKey]<ept id="p2">**</ept> 属性让 EF 知道 <ph id="ph3">`Player`</ph> 属性表示外键。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>添加 Web API 控制器</source>
          <target state="new">添加 Web API 控制器</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>接下来，你要为 <ph id="ph1">`Player`</ph> 和 <ph id="ph2">`PlayerRank`</ph> 添加 Web API 控制器。要添加的并不是普通 Web API 控制器，而是专门针对 Azure 移动服务设计的名为<bpt id="p1">*</bpt>表控制器<ept id="p1">*</ept>的特殊控制器。</source>
          <target state="new">接下来，你要为 <ph id="ph1">`Player`</ph> 和 <ph id="ph2">`PlayerRank`</ph> 添加 Web API 控制器。要添加的并不是普通 Web API 控制器，而是专门针对 Azure 移动服务设计的名为<bpt id="p1">*</bpt>表控制器<ept id="p1">*</ept>的特殊控制器。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>右键单击 Controllers 文件夹，选择“添加”，然后选择“新建基架项”。</source>
          <target state="new">右键单击 Controllers 文件夹，选择“添加”，然后选择“新建基架项”。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>在“添加基架”对话框中，展开左侧的“通用”，然后选择“Azure 移动服务”。接下来，选择“Azure 移动服务表控制器”。单击<bpt id="p1">**</bpt>“添加”<ept id="p1">**</ept>。</source>
          <target state="new">在“添加基架”对话框中，展开左侧的“通用”，然后选择“Azure 移动服务”。接下来，选择“Azure 移动服务表控制器”。单击<bpt id="p1">**</bpt>“添加”<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>在“添加控制器”对话框中：</source>
          <target state="new">在“添加控制器”对话框中：</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>在“模型类”下，选择“Player”。</source>
          <target state="new">在“模型类”下，选择“Player”。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>在“数据上下文类”下，选择“MobileServiceContext”。</source>
          <target state="new">在“数据上下文类”下，选择“MobileServiceContext”。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>将控制器命名为“PlayerController”。</source>
          <target state="new">将控制器命名为“PlayerController”。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>单击<bpt id="p1">**</bpt>“添加”<ept id="p1">**</ept>。</source>
          <target state="new">单击<bpt id="p1">**</bpt>“添加”<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>此步骤将名为 PlayerController.cs 的文件添加到项目中。</source>
          <target state="new">此步骤将名为 PlayerController.cs 的文件添加到项目中。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>该控制器派生自 <bpt id="p1">**</bpt>TableController<ph id="ph1">&lt;T&gt;</ph><ept id="p1">**</ept>。此类继承 <bpt id="p2">**</bpt>ApiController<ept id="p2">**</ept>，但它是专用于 Azure 移动服务的类。</source>
          <target state="new">该控制器派生自 <bpt id="p1">**</bpt>TableController<ph id="ph1">&lt;T&gt;</ph><ept id="p1">**</ept>。此类继承 <bpt id="p2">**</bpt>ApiController<ept id="p2">**</ept>，但它是专用于 Azure 移动服务的类。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>路由：<bpt id="p1">**</bpt>TableController<ept id="p1">**</ept> 的默认路径为 <ph id="ph1">`/tables/{table_name}/{id}`</ph>，其中，<bpt id="p2">*</bpt>table\_name<ept id="p2">*</ept> 与实体名称匹配。因此，Player 控制器的路由为 <bpt id="p3">*</bpt>/tables/player/{id}<ept id="p3">*</ept>。这种路由约定使得 <bpt id="p4">**</bpt>TableController<ept id="p4">**</ept> 与移动服务 <bpt id="p5">[</bpt>REST API<ept id="p5">](http://msdn.microsoft.com/zh-cn/library/azure/jj710104.aspx)</ept> 相一致。</source>
          <target state="new">路由：<bpt id="p1">**</bpt>TableController<ept id="p1">**</ept> 的默认路径为 <ph id="ph1">`/tables/{table_name}/{id}`</ph>，其中，<bpt id="p2">*</bpt>table\_name<ept id="p2">*</ept> 与实体名称匹配。因此，Player 控制器的路由为 <bpt id="p3">*</bpt>/tables/player/{id}<ept id="p3">*</ept>。这种路由约定使得 <bpt id="p4">**</bpt>TableController<ept id="p4">**</ept> 与移动服务 <bpt id="p5">[</bpt>REST API<ept id="p5">](http://msdn.microsoft.com/zh-cn/library/azure/jj710104.aspx)</ept> 相一致。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>数据访问：对于数据库操作，<bpt id="p1">**</bpt>TableController<ept id="p1">**</ept> 类使用 <bpt id="p2">**</bpt>IDomainManager<ept id="p2">**</ept> 接口，该接口定义数据访问的抽象。基架使用 <bpt id="p3">**</bpt>EntityDomainManager<ept id="p3">**</ept>，这是包装 EF 上下文的 <bpt id="p4">**</bpt>IDomainManager<ept id="p4">**</ept> 的具体实现。</source>
          <target state="new">数据访问：对于数据库操作，<bpt id="p1">**</bpt>TableController<ept id="p1">**</ept> 类使用 <bpt id="p2">**</bpt>IDomainManager<ept id="p2">**</ept> 接口，该接口定义数据访问的抽象。基架使用 <bpt id="p3">**</bpt>EntityDomainManager<ept id="p3">**</ept>，这是包装 EF 上下文的 <bpt id="p4">**</bpt>IDomainManager<ept id="p4">**</ept> 的具体实现。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>现在，请为 PlayerRank 实体添加第二个控制器。请遵循相同的步骤，但选择 PlayerRank 作为模型类。请使用相同的数据上下文类，而不要创建新类。将控制器命名为“PlayerRankController”。</source>
          <target state="new">现在，请为 PlayerRank 实体添加第二个控制器。请遵循相同的步骤，但选择 PlayerRank 作为模型类。请使用相同的数据上下文类，而不要创建新类。将控制器命名为“PlayerRankController”。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>使用 DTO 返回相关实体</source>
          <target state="new">使用 DTO 返回相关实体</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>回想一下，<ph id="ph1">`PlayerRank`</ph> 具有相关的 <ph id="ph2">`Player`</ph> 实体：</source>
          <target state="new">回想一下，<ph id="ph1">`PlayerRank`</ph> 具有相关的 <ph id="ph2">`Player`</ph> 实体：</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>移动服务客户端库不支持导航属性，并且这些属性将不序列化。例如，下面是 GET <ph id="ph1">`/tables/PlayerRank`</ph> 的原始 HTTP 响应：</source>
          <target state="new">移动服务客户端库不支持导航属性，并且这些属性将不序列化。例如，下面是 GET <ph id="ph1">`/tables/PlayerRank`</ph> 的原始 HTTP 响应：</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>请注意，<ph id="ph1">`Player`</ph> 并未包含在对象图形中。若要包含玩家，可以通过定义<bpt id="p1">*</bpt>数据传输对象 (DTO)<ept id="p1">*</ept> 将对象图形平面化。</source>
          <target state="new">请注意，<ph id="ph1">`Player`</ph> 并未包含在对象图形中。若要包含玩家，可以通过定义<bpt id="p1">*</bpt>数据传输对象 (DTO)<ept id="p1">*</ept> 将对象图形平面化。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>DTO 是定义如何通过网络发送数据的对象。如果你希望有线格式看起来与数据库模型不同，即可使用 DTO。若要为 <ph id="ph1">`PlayerRank`</ph> 创建 DTO，请在 DataObjects 文件夹中添加名为 <ph id="ph2">`PlayerRankDto`</ph> 的新类。</source>
          <target state="new">DTO 是定义如何通过网络发送数据的对象。如果你希望有线格式看起来与数据库模型不同，即可使用 DTO。若要为 <ph id="ph1">`PlayerRank`</ph> 创建 DTO，请在 DataObjects 文件夹中添加名为 <ph id="ph2">`PlayerRankDto`</ph> 的新类。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>在 <ph id="ph1">`PlayerRankController`</ph> 类中，我们将使用 LINQ <bpt id="p1">**</bpt>Select<ept id="p1">**</ept> 方法，将 <ph id="ph2">`PlayerRank`</ph> 实例转换为 <ph id="ph3">`PlayerRankDto`</ph> 实例。按以下方式更新 <ph id="ph4">`GetAllPlayerRank`</ph> 和 <ph id="ph5">`GetPlayerRank`</ph> 控制器方法：</source>
          <target state="new">在 <ph id="ph1">`PlayerRankController`</ph> 类中，我们将使用 LINQ <bpt id="p1">**</bpt>Select<ept id="p1">**</ept> 方法，将 <ph id="ph2">`PlayerRank`</ph> 实例转换为 <ph id="ph3">`PlayerRankDto`</ph> 实例。按以下方式更新 <ph id="ph4">`GetAllPlayerRank`</ph> 和 <ph id="ph5">`GetPlayerRank`</ph> 控制器方法：</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>做出这些更改后，两个 GET 方法将 <ph id="ph1">`PlayerRankDto`</ph> 对象返回到客户端。<ph id="ph2">`PlayerRankDto.PlayerName`</ph> 属性设置为玩家姓名。以下是做出此更改后的示例响应：</source>
          <target state="new">做出这些更改后，两个 GET 方法将 <ph id="ph1">`PlayerRankDto`</ph> 对象返回到客户端。<ph id="ph2">`PlayerRankDto.PlayerName`</ph> 属性设置为玩家姓名。以下是做出此更改后的示例响应：</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>请注意 JSON 负载现在包含玩家姓名。</source>
          <target state="new">请注意 JSON 负载现在包含玩家姓名。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>除了使用 LINQ Select 语句以外，另一种做法是使用 AutoMapper。这种做法需要使用其他设置代码，但可启用从域实体到 DTO 的自动映射。有关详细信息，请参阅<bpt id="p1">[</bpt>使用 AutoMapper 在 .NET 后端中的数据库类型与客户端类型之间映射<ept id="p1">](http://blogs.msdn.com/b/azuremobile/archive/2014/05/19/mapping-between-database-types-and-client-type-in-the-net-backend-using-automapper.aspx)</ept>。</source>
          <target state="new">除了使用 LINQ Select 语句以外，另一种做法是使用 AutoMapper。这种做法需要使用其他设置代码，但可启用从域实体到 DTO 的自动映射。有关详细信息，请参阅<bpt id="p1">[</bpt>使用 AutoMapper 在 .NET 后端中的数据库类型与客户端类型之间映射<ept id="p1">](http://blogs.msdn.com/b/azuremobile/archive/2014/05/19/mapping-between-database-types-and-client-type-in-the-net-backend-using-automapper.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>定义自定义 API 来提交分数</source>
          <target state="new">定义自定义 API 来提交分数</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`PlayerRank`</ph> 实体包含 <ph id="ph2">`Rank`</ph> 属性。此值由服务器计算，而我们不希望客户端设置它。客户端应使用自定义 API 提交玩家的分数。当服务器获取新分数时，将更新所有的玩家排名。</source>
          <target state="new"><ph id="ph1">`PlayerRank`</ph> 实体包含 <ph id="ph2">`Rank`</ph> 属性。此值由服务器计算，而我们不希望客户端设置它。客户端应使用自定义 API 提交玩家的分数。当服务器获取新分数时，将更新所有的玩家排名。</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>首先，将名为 <ph id="ph1">`PlayerScore`</ph> 的类添加到 DataObjects 文件夹。</source>
          <target state="new">首先，将名为 <ph id="ph1">`PlayerScore`</ph> 的类添加到 DataObjects 文件夹。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>在 <ph id="ph1">`PlayerRankController`</ph> 类中，将 <ph id="ph2">`MobileServiceContext`</ph> 变量从构造函数移到类变量：</source>
          <target state="new">在 <ph id="ph1">`PlayerRankController`</ph> 类中，将 <ph id="ph2">`MobileServiceContext`</ph> 变量从构造函数移到类变量：</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>从 <ph id="ph1">`PlayerRankController`</ph> 中删除以下方法：</source>
          <target state="new">从 <ph id="ph1">`PlayerRankController`</ph> 中删除以下方法：</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>然后，将以下代码添加到 <ph id="ph1">`PlayerRankController`</ph>：</source>
          <target state="new">然后，将以下代码添加到 <ph id="ph1">`PlayerRankController`</ph>：</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`PostPlayerScore`</ph> 方法采用 <ph id="ph2">`PlayerScore`</ph> 实例作为输入。（客户端将在 HTTP POST 请求中发送 <ph id="ph3">`PlayerScore`</ph>。） 该方法将执行以下操作：</source>
          <target state="new"><ph id="ph1">`PostPlayerScore`</ph> 方法采用 <ph id="ph2">`PlayerScore`</ph> 实例作为输入。（客户端将在 HTTP POST 请求中发送 <ph id="ph3">`PlayerScore`</ph>。） 该方法将执行以下操作：</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>如果数据库中尚无玩家的 <ph id="ph1">`PlayerRank`</ph>，则新增一个。</source>
          <target state="new">如果数据库中尚无玩家的 <ph id="ph1">`PlayerRank`</ph>，则新增一个。</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>更新玩家的分数。</source>
          <target state="new">更新玩家的分数。</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>运行 SQL 查询，以分批更新所有玩家排名。</source>
          <target state="new">运行 SQL 查询，以分批更新所有玩家排名。</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>[Route]<ept id="p1">**</ept> 属性为此方法定义一个自定义路由：</source>
          <target state="new"><bpt id="p1">**</bpt>[Route]<ept id="p1">**</ept> 属性为此方法定义一个自定义路由：</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>也可以将方法放入单独的控制器中。没有哪种方法特别好，具体取决于你想要如何组织代码。</source>
          <target state="new">也可以将方法放入单独的控制器中。没有哪种方法特别好，具体取决于你想要如何组织代码。</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>若要深入了解 <bpt id="p1">**</bpt>[Route]<ept id="p1">**</ept> 属性，请参阅 <bpt id="p2">[</bpt>Web API 中的属性路由<ept id="p2">](http://www.asp.net/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2)</ept>。</source>
          <target state="new">若要深入了解 <bpt id="p1">**</bpt>[Route]<ept id="p1">**</ept> 属性，请参阅 <bpt id="p2">[</bpt>Web API 中的属性路由<ept id="p2">](http://www.asp.net/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2)</ept>。</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>创建 Windows 应用商店应用程序</source>
          <target state="new">创建 Windows 应用商店应用程序</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>在本部分中，我将介绍使用移动服务的 Windows 应用商店应用程序。但是，我不会将重点放在 XAML 或 UI 上，而是着重于应用程序逻辑。你可以在<bpt id="p1">[</bpt>此处<ept id="p1">](http://code.msdn.microsoft.com/Leaderboard-App-with-Azure-9acf63af)</ept>下载完整项目。</source>
          <target state="new">在本部分中，我将介绍使用移动服务的 Windows 应用商店应用程序。但是，我不会将重点放在 XAML 或 UI 上，而是着重于应用程序逻辑。你可以在<bpt id="p1">[</bpt>此处<ept id="p1">](http://code.msdn.microsoft.com/Leaderboard-App-with-Azure-9acf63af)</ept>下载完整项目。</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>将新的 Windows 应用商店应用程序项目添加到解决方案。我使用了空白应用程序 (Windows) 模板。</source>
          <target state="new">将新的 Windows 应用商店应用程序项目添加到解决方案。我使用了空白应用程序 (Windows) 模板。</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>使用 NuGet Package Manager 添加移动服务客户端库。在 Visual Studio 中，从“工具”菜单中选择“NuGet Package Manager”。然后选择“Package Manager Console”。在“Package Manager Console”窗口中键入以下命令。</source>
          <target state="new">使用 NuGet Package Manager 添加移动服务客户端库。在 Visual Studio 中，从“工具”菜单中选择“NuGet Package Manager”。然后选择“Package Manager Console”。在“Package Manager Console”窗口中键入以下命令。</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>-Project 开关指定要将包安装到哪个项目。</source>
          <target state="new">-Project 开关指定要将包安装到哪个项目。</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>添加模型类</source>
          <target state="new">添加模型类</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>创建名为 Models 的文件夹并添加以下类：</source>
          <target state="new">创建名为 Models 的文件夹并添加以下类：</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>这些类直接对应于移动服务中的数据实体。</source>
          <target state="new">这些类直接对应于移动服务中的数据实体。</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>创建视图模型</source>
          <target state="new">创建视图模型</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>模型-视图-视图模型 (MVVM) 是模型-视图-控制器 (MVC) 的变体。MVVM 模式有助于将应用程序逻辑与表示形式区分开来。</source>
          <target state="new">模型-视图-视图模型 (MVVM) 是模型-视图-控制器 (MVC) 的变体。MVVM 模式有助于将应用程序逻辑与表示形式区分开来。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>模型表示域数据（玩家、玩家排名和玩家分数）。</source>
          <target state="new">模型表示域数据（玩家、玩家排名和玩家分数）。</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>视图模型是视图的抽象表示形式。</source>
          <target state="new">视图模型是视图的抽象表示形式。</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>视图显示视图模型，并向视图模型发送用户输入。对于 Windows 应用商店应用程序，视图在 XAML 中定义。</source>
          <target state="new">视图显示视图模型，并向视图模型发送用户输入。对于 Windows 应用商店应用程序，视图在 XAML 中定义。</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>添加名为的 <ph id="ph1">`LeaderboardViewModel`</ph> 的类。</source>
          <target state="new">添加名为的 <ph id="ph1">`LeaderboardViewModel`</ph> 的类。</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>在视图模型上实现 <bpt id="p1">**</bpt>INotifyPropertyChanged<ept id="p1">**</ept>，使视图模型可以参与数据绑定。</source>
          <target state="new">在视图模型上实现 <bpt id="p1">**</bpt>INotifyPropertyChanged<ept id="p1">**</ept>，使视图模型可以参与数据绑定。</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>接下来，添加可查看属性。XAML 将与这些属性建立数据绑定。</source>
          <target state="new">接下来，添加可查看属性。XAML 将与这些属性建立数据绑定。</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>当服务的异步操作挂起时，<ph id="ph1">`IsPending`</ph> 属性为 true。<ph id="ph2">`ErrorMessage`</ph> 属性包含来自服务的任何错误消息。</source>
          <target state="new">当服务的异步操作挂起时，<ph id="ph1">`IsPending`</ph> 属性为 true。<ph id="ph2">`ErrorMessage`</ph> 属性包含来自服务的任何错误消息。</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>最后，添加调用服务层的方法。</source>
          <target state="new">最后，添加调用服务层的方法。</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>添加 MobileServiceClient 实例</source>
          <target state="new">添加 MobileServiceClient 实例</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>打开 <bpt id="p1">*</bpt>App.xaml.cs<ept id="p1">*</ept> 文件并将 <bpt id="p2">**</bpt>MobileServiceClient<ept id="p2">**</ept> 实例添加到 <ph id="ph1">`App`</ph> 类。</source>
          <target state="new">打开 <bpt id="p1">*</bpt>App.xaml.cs<ept id="p1">*</ept> 文件并将 <bpt id="p2">**</bpt>MobileServiceClient<ept id="p2">**</ept> 实例添加到 <ph id="ph1">`App`</ph> 类。</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>当你在本地调试时，移动服务将在 IIS Express 上运行。Visual Studio 将分配一个随机端口号，因此本地 URL 为 http://localhost:<bpt id="p1">*</bpt>port<ept id="p1">*</ept>，其中 <bpt id="p2">*</bpt>port<ept id="p2">*</ept> 为端口号。若要获取端口号，请按 F5 在 Visual Studio 中启动服务，以进行调试。Visual Studio 将启动浏览器，并导航到服务 URL。你也可以在项目属性中的 <bpt id="p3">**</bpt>Web<ept id="p3">**</ept> 下查找本地 URL。</source>
          <target state="new">当你在本地调试时，移动服务将在 IIS Express 上运行。Visual Studio 将分配一个随机端口号，因此本地 URL 为 http://localhost:<bpt id="p1">*</bpt>port<ept id="p1">*</ept>，其中 <bpt id="p2">*</bpt>port<ept id="p2">*</ept> 为端口号。若要获取端口号，请按 F5 在 Visual Studio 中启动服务，以进行调试。Visual Studio 将启动浏览器，并导航到服务 URL。你也可以在项目属性中的 <bpt id="p3">**</bpt>Web<ept id="p3">**</ept> 下查找本地 URL。</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>创建主页面</source>
          <target state="new">创建主页面</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>在主页面中，添加视图模型的实例。然后将视图模型设置为该页面的 <bpt id="p1">**</bpt>DataContext<ept id="p1">**</ept>。</source>
          <target state="new">在主页面中，添加视图模型的实例。然后将视图模型设置为该页面的 <bpt id="p1">**</bpt>DataContext<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>前面已经提到，我不会介绍应用程序的所有 XAML。MVVM 模式的优点之一是能够区分表示形式和应用程序逻辑，因此，如果你不喜欢示例应用程序，可以轻松更改 UI。</source>
          <target state="new">前面已经提到，我不会介绍应用程序的所有 XAML。MVVM 模式的优点之一是能够区分表示形式和应用程序逻辑，因此，如果你不喜欢示例应用程序，可以轻松更改 UI。</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>玩家列表显示在 <bpt id="p1">**</bpt>ListBox<ept id="p1">**</ept> 中：</source>
          <target state="new">玩家列表显示在 <bpt id="p1">**</bpt>ListBox<ept id="p1">**</ept> 中：</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>排名显示在 <bpt id="p1">**</bpt>ListView<ept id="p1">**</ept> 中：</source>
          <target state="new">排名显示在 <bpt id="p1">**</bpt>ListView<ept id="p1">**</ept> 中：</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>所有数据绑定都通过视图模型发生。</source>
          <target state="new">所有数据绑定都通过视图模型发生。</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>发布移动服务</source>
          <target state="new">发布移动服务</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>在此步骤中，你要将移动服务发布到 Azure，并修改应用程序以使用实时服务。</source>
          <target state="new">在此步骤中，你要将移动服务发布到 Azure，并修改应用程序以使用实时服务。</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中，右键单击 Leaderboard 项目并选择“发布”。</source>
          <target state="new">在“解决方案资源管理器”中，右键单击 Leaderboard 项目并选择“发布”。</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>在“发布”对话框中，单击“Azure 移动服务”。</source>
          <target state="new">在“发布”对话框中，单击“Azure 移动服务”。</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>如果你尚未登录你的 Azure 帐户，请单击“登录”。</source>
          <target state="new">如果你尚未登录你的 Azure 帐户，请单击“登录”。</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>选择现有的移动服务，或单击“新建”以创建一个新的服务。然后单击“确定”以发布。</source>
          <target state="new">选择现有的移动服务，或单击“新建”以创建一个新的服务。然后单击“确定”以发布。</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>发布过程会自动创建数据库。你不需要配置连接字符串。</source>
          <target state="new">发布过程会自动创建数据库。你不需要配置连接字符串。</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>现在，你可以将排行榜应用程序连接到实时服务了。你需要以下两项：</source>
          <target state="new">现在，你可以将排行榜应用程序连接到实时服务了。你需要以下两项：</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>服务的 URL</source>
          <target state="new">服务的 URL</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>应用程序密钥</source>
          <target state="new">应用程序密钥</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>你可以从 Azure 经典门户获取这两项信息。在门户中单击“移动服务”，然后单击该移动服务。仪表板选项卡上列出了服务 URL。若要获取应用程序密钥，请单击“管理密钥”。</source>
          <target state="new">你可以从 Azure 经典门户获取这两项信息。在门户中单击“移动服务”，然后单击该移动服务。仪表板选项卡上列出了服务 URL。若要获取应用程序密钥，请单击“管理密钥”。</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>在“管理访问密钥”对话框中，复制应用程序密钥值。</source>
          <target state="new">在“管理访问密钥”对话框中，复制应用程序密钥值。</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>将服务 URL 和应用程序密钥传递给 <bpt id="p1">**</bpt>MobileServiceClient<ept id="p1">**</ept> 构造函数。</source>
          <target state="new">将服务 URL 和应用程序密钥传递给 <bpt id="p1">**</bpt>MobileServiceClient<ept id="p1">**</ept> 构造函数。</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>现在，当你运行该应用程序时，它将与实际的服务通信。</source>
          <target state="new">现在，当你运行该应用程序时，它将与实际的服务通信。</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>详细了解 Azure 移动服务</source>
          <target state="new">详细了解 Azure 移动服务</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>详细了解 Web API</source>
          <target state="new">详细了解 Web API</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>处理数据库写入冲突</source>
          <target state="new">处理数据库写入冲突</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ept id="p1">添加推送通知]</ept>（例如，当某人添加新玩家或更新分数时）。</source>
          <target state="new"><bpt id="p1">[</bpt><ept id="p1">添加推送通知]</ept>（例如，当某人添加新玩家或更新分数时）。</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>身份验证入门</source>
          <target state="new">身份验证入门</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>