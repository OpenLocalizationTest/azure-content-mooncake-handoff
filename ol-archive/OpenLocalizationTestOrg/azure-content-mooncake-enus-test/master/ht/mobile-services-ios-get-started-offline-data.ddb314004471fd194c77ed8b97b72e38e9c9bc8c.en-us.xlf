<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7aed3c7638af35dbef1fae4013839d9697d4d753</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>移动服务中的脱机数据同步入门 (iOS) | Azure</source>
          <target state="new">移动服务中的脱机数据同步入门 (iOS) | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何在 iOS 应用程序中使用 Azure 移动服务缓存和同步脱机数据</source>
          <target state="new">了解如何在 iOS 应用程序中使用 Azure 移动服务缓存和同步脱机数据</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>移动服务中的脱机数据同步入门</source>
          <target state="new">移动服务中的脱机数据同步入门</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;</source>
          <target state="new">&amp;nbsp;</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>借助脱机同步，即使在没有网络连接的情况下，你也可以查看、添加或修改移动应用中的数据。在本程中，你将了解应用如何在本地脱机数据库中自动存储更改，并在重新联机时同步这些更改。</source>
          <target state="new">借助脱机同步，即使在没有网络连接的情况下，你也可以查看、添加或修改移动应用中的数据。在本程中，你将了解应用如何在本地脱机数据库中自动存储更改，并在重新联机时同步这些更改。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>脱机同步具有几个优点：</source>
          <target state="new">脱机同步具有几个优点：</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>通过在设备上本地缓存服务器数据来提高应用响应能力</source>
          <target state="new">通过在设备上本地缓存服务器数据来提高应用响应能力</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>使应用可灵活应对间歇性网络连接</source>
          <target state="new">使应用可灵活应对间歇性网络连接</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>即使连接状态很差或者根本没有连接，也能让你创建和修改数据</source>
          <target state="new">即使连接状态很差或者根本没有连接，也能让你创建和修改数据</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>跨多个设备同步数据</source>
          <target state="new">跨多个设备同步数据</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>在两个设备修改同一条记录时检测冲突</source>
          <target state="new">在两个设备修改同一条记录时检测冲突</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 若要完成本教程，你需要一个 Azure 帐户。如果你没有帐户，可以注册 Azure 试用版并获取<bpt id="p1">[</bpt>免费的移动服务，即使在试用期结束之后仍可继续使用这些服务<ept id="p1">](/home/features/mobile-services/#price)</ept>。有关详细信息，请参阅 [Azure 试用](/pricing/1rmb-trial/ target="\_blank")。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 若要完成本教程，你需要一个 Azure 帐户。如果你没有帐户，可以注册 Azure 试用版并获取<bpt id="p1">[</bpt>免费的移动服务，即使在试用期结束之后仍可继续使用这些服务<ept id="p1">](/home/features/mobile-services/#price)</ept>。有关详细信息，请参阅 [Azure 试用](/pricing/1rmb-trial/ target="\_blank")。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>本教程是在<bpt id="p1">[</bpt><ept id="p1">移动服务快速入门教程]</ept>的基础之上制作的，所以必须先完成该教程。首先，让我们回顾“快速入门”中与脱机同步相关的代码。</source>
          <target state="new">本教程是在<bpt id="p1">[</bpt><ept id="p1">移动服务快速入门教程]</ept>的基础之上制作的，所以必须先完成该教程。首先，让我们回顾“快速入门”中与脱机同步相关的代码。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="review-sync"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>回顾移动服务同步代码</source>
          <target state="new"><ph id="ph1">&lt;a name="review-sync"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>回顾移动服务同步代码</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Azure 移动服务脱机同步允许最终用户在无法访问网络时与本地数据库交互。若要在应用中使用这些功能，你可以初始化 <ph id="ph1">`MSClient`</ph> 的同步上下文，并引用本机存储。然后，通过 <ph id="ph2">`MSSyncTable`</ph> 接口引用你的表。</source>
          <target state="new">Azure 移动服务脱机同步允许最终用户在无法访问网络时与本地数据库交互。若要在应用中使用这些功能，你可以初始化 <ph id="ph1">`MSClient`</ph> 的同步上下文，并引用本机存储。然后，通过 <ph id="ph2">`MSSyncTable`</ph> 接口引用你的表。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中，请注意成员 <ph id="ph1">`syncTable`</ph> 的类型是 <ph id="ph2">`MSSyncTable`</ph>。脱机同步使用此类型而不是 <ph id="ph3">`MSTable`</ph>。使用同步表时，所有操作将会转到本地存储，而且只会与具有显式推送和提取操作的远程服务同步。</source>
          <target state="new">在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中，请注意成员 <ph id="ph1">`syncTable`</ph> 的类型是 <ph id="ph2">`MSSyncTable`</ph>。脱机同步使用此类型而不是 <ph id="ph3">`MSTable`</ph>。使用同步表时，所有操作将会转到本地存储，而且只会与具有显式推送和提取操作的远程服务同步。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>若要获取对同步表的引用，请使用 <ph id="ph1">`syncTableWithName`</ph> 方法。若要删除脱机同步功能，请改用 <ph id="ph2">`tableWithName`</ph>。</source>
          <target state="new">若要获取对同步表的引用，请使用 <ph id="ph1">`syncTableWithName`</ph> 方法。若要删除脱机同步功能，请改用 <ph id="ph2">`tableWithName`</ph>。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中，执行表操作之前，本地存储将在 <ph id="ph1">`QSTodoService.init`</ph> 中初始化：</source>
          <target state="new">在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中，执行表操作之前，本地存储将在 <ph id="ph1">`QSTodoService.init`</ph> 中初始化：</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>这会使用 <ph id="ph1">`MSCoreDataStore`</ph> 接口创建本地存储。你可以通过实现 <ph id="ph2">`MSSyncContextDataSource`</ph> 协议来提供不同的本地存储。</source>
          <target state="new">这会使用 <ph id="ph1">`MSCoreDataStore`</ph> 接口创建本地存储。你可以通过实现 <ph id="ph2">`MSSyncContextDataSource`</ph> 协议来提供不同的本地存储。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`initWithDelegate`</ph> 的第一个参数指定冲突处理程序，但由于我们已传递 <ph id="ph2">`nil`</ph>，因此默认的冲突处理程序将在发生任何冲突时失败。有关如何实现自定义冲突处理程序的详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">使用移动服务脱机支持处理冲突]</ept>。</source>
          <target state="new"><ph id="ph1">`initWithDelegate`</ph> 的第一个参数指定冲突处理程序，但由于我们已传递 <ph id="ph2">`nil`</ph>，因此默认的冲突处理程序将在发生任何冲突时失败。有关如何实现自定义冲突处理程序的详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">使用移动服务脱机支持处理冲突]</ept>。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中，<ph id="ph1">`syncData`</ph> 先推送新的更改，然后调用 <ph id="ph2">`pullData`</ph> 从远程服务获取数据。在 <ph id="ph3">`syncData`</ph> 中，我们先对同步上下文调用 <ph id="ph4">`pushWithCompletion`</ph>。此方法是 <ph id="ph5">`MSSyncContext`</ph> 的成员，而不是异步表本身，因为它会将更改推送到所有表。只有以某种方式在本地上修改过的记录（通过创建、更新或删除操作）才会发送到服务器。在 <ph id="ph6">`syncData`</ph> 结束时，调用帮助器 <ph id="ph7">`pullData`</ph>。</source>
          <target state="new">在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中，<ph id="ph1">`syncData`</ph> 先推送新的更改，然后调用 <ph id="ph2">`pullData`</ph> 从远程服务获取数据。在 <ph id="ph3">`syncData`</ph> 中，我们先对同步上下文调用 <ph id="ph4">`pushWithCompletion`</ph>。此方法是 <ph id="ph5">`MSSyncContext`</ph> 的成员，而不是异步表本身，因为它会将更改推送到所有表。只有以某种方式在本地上修改过的记录（通过创建、更新或删除操作）才会发送到服务器。在 <ph id="ph6">`syncData`</ph> 结束时，调用帮助器 <ph id="ph7">`pullData`</ph>。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>在此示例中，推送操作并非绝对必要。如果同步上下文中正在进行推送操作的表存在待定的更改，则提取始终会先发出推送。但是，如果你有多个同步表，请显式调用推送，使表之间保持一致。</source>
          <target state="new">在此示例中，推送操作并非绝对必要。如果同步上下文中正在进行推送操作的表存在待定的更改，则提取始终会先发出推送。但是，如果你有多个同步表，请显式调用推送，使表之间保持一致。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>接下来，在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中，<ph id="ph1">`pullData`</ph> 将获取与查询匹配的新数据。<ph id="ph2">`pullData`</ph> 将调用 <ph id="ph3">`MSSyncTable.pullWithQuery`</ph> 以检索远程数据，并将数据存储在本地。<ph id="ph4">`pullWithQuery`</ph> 也允许你指定查询以筛选你要检索的记录。在此示例中，查询只会检索远程 <ph id="ph5">`TodoItem`</ph> 表中的所有记录。</source>
          <target state="new">接下来，在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中，<ph id="ph1">`pullData`</ph> 将获取与查询匹配的新数据。<ph id="ph2">`pullData`</ph> 将调用 <ph id="ph3">`MSSyncTable.pullWithQuery`</ph> 以检索远程数据，并将数据存储在本地。<ph id="ph4">`pullWithQuery`</ph> 也允许你指定查询以筛选你要检索的记录。在此示例中，查询只会检索远程 <ph id="ph5">`TodoItem`</ph> 表中的所有记录。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`pullWithQuery`</ph> 的第二个参数是<bpt id="p1">_</bpt>增量同步<ept id="p1">_</ept>的查询 ID。增量同步只会使用记录的 <ph id="ph2">`UpdatedAt`</ph> 时间戳（在本地存储中称为 <ph id="ph3">`ms_updatedAt`</ph>）检索自上次同步以来修改的记录。对于应用中的每个逻辑查询而言，查询 ID 是唯一的描述性字符串。若选择不要增量同步，请传递 <ph id="ph4">`nil`</ph> 作为查询 ID。这会降低效率，因为它会检索每个推送操作的所有记录。</source>
          <target state="new"><ph id="ph1">`pullWithQuery`</ph> 的第二个参数是<bpt id="p1">_</bpt>增量同步<ept id="p1">_</ept>的查询 ID。增量同步只会使用记录的 <ph id="ph2">`UpdatedAt`</ph> 时间戳（在本地存储中称为 <ph id="ph3">`ms_updatedAt`</ph>）检索自上次同步以来修改的记录。对于应用中的每个逻辑查询而言，查询 ID 是唯一的描述性字符串。若选择不要增量同步，请传递 <ph id="ph4">`nil`</ph> 作为查询 ID。这会降低效率，因为它会检索每个推送操作的所有记录。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 若要从设备本地存储区中删除已在移动设备数据库中删除的记录，应启用“<bpt id="p1">[</bpt><ept id="p1">软删除]</ept>”。否则，你的应用程序应定期调用 <ph id="ph2">`MSSyncTable.purgeWithQuery`</ph> 以清除本地存储。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 若要从设备本地存储区中删除已在移动设备数据库中删除的记录，应启用“<bpt id="p1">[</bpt><ept id="p1">软删除]</ept>”。否则，你的应用程序应定期调用 <ph id="ph2">`MSSyncTable.purgeWithQuery`</ph> 以清除本地存储。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中，<ph id="ph1">`addItem`</ph> 和 <ph id="ph2">`completeItem`</ph> 方法会在修改数据后调用 <ph id="ph3">`syncData`</ph>。在 <bpt id="p2">**</bpt>QSTodoListViewController.m<ept id="p2">**</ept> 中，<ph id="ph4">`refresh`</ph> 方法也会调用 <ph id="ph5">`syncData`</ph>，使 UI 在每次刷新和启动时（<ph id="ph6">`init`</ph> 调用 <ph id="ph7">`refresh`</ph>）显示最新数据。</source>
          <target state="new">在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中，<ph id="ph1">`addItem`</ph> 和 <ph id="ph2">`completeItem`</ph> 方法会在修改数据后调用 <ph id="ph3">`syncData`</ph>。在 <bpt id="p2">**</bpt>QSTodoListViewController.m<ept id="p2">**</ept> 中，<ph id="ph4">`refresh`</ph> 方法也会调用 <ph id="ph5">`syncData`</ph>，使 UI 在每次刷新和启动时（<ph id="ph6">`init`</ph> 调用 <ph id="ph7">`refresh`</ph>）显示最新数据。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>因为每当你修改数据时，应用就会调用 <ph id="ph1">`syncData`</ph>，所以无论你何时在应用中编辑数据，应用都会假设你已联机。</source>
          <target state="new">因为每当你修改数据时，应用就会调用 <ph id="ph1">`syncData`</ph>，所以无论你何时在应用中编辑数据，应用都会假设你已联机。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="review-core-data"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>了解核心数据模型</source>
          <target state="new"><ph id="ph1">&lt;a name="review-core-data"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>了解核心数据模型</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>在使用核心数据脱机存储时，你需要在数据模型中定义特定的表和字段。示例应用已包含具有正确格式的数据模型。在本部分中，我们会逐步介绍这些表及其用法。</source>
          <target state="new">在使用核心数据脱机存储时，你需要在数据模型中定义特定的表和字段。示例应用已包含具有正确格式的数据模型。在本部分中，我们会逐步介绍这些表及其用法。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>打开 <bpt id="p1">**</bpt>QSDataModel.xcdatamodeld<ept id="p1">**</ept>。已定义了四个表，其中三个由 SDK 使用，一个供 todo 项本身使用：</source>
          <target state="new">打开 <bpt id="p1">**</bpt>QSDataModel.xcdatamodeld<ept id="p1">**</ept>。已定义了四个表，其中三个由 SDK 使用，一个供 todo 项本身使用：</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>移动服务 SDK 会保留以“<bpt id="p1">**</bpt><ph id="ph2">`ms_`</ph><ept id="p1">**</ept>”开头的列名称。请不要在系统列以外的项中使用此前缀。否则，列名称会在使用远程服务时被修改。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>移动服务 SDK 会保留以“<bpt id="p1">**</bpt><ph id="ph2">`ms_`</ph><ept id="p1">**</ept>”开头的列名称。请不要在系统列以外的项中使用此前缀。否则，列名称会在使用远程服务时被修改。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>使用脱机同步功能时，必须先定义系统表，如下所示。</source>
          <target state="new">使用脱机同步功能时，必须先定义系统表，如下所示。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>系统表</source>
          <target state="new">系统表</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>MS\_TableOperations</source>
          <target state="new">MS\_TableOperations</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>属性</source>
          <target state="new">属性</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>类型</source>
          <target state="new">类型</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>ID（必需）</source>
          <target state="new">ID（必需）</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>64 位整数</source>
          <target state="new">64 位整数</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>itemId</source>
          <target state="new">itemId</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>字符串</source>
          <target state="new">字符串</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>properties</source>
          <target state="new">properties</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>二进制数据</source>
          <target state="new">二进制数据</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>table</source>
          <target state="new">table</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="new">String</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>tableKind</source>
          <target state="new">tableKind</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>16 位整数</source>
          <target state="new">16 位整数</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>MS\_TableOperationErrors</source>
          <target state="new">MS\_TableOperationErrors</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>属性</source>
          <target state="new">属性</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>类型</source>
          <target state="new">类型</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>ID（必需）</source>
          <target state="new">ID（必需）</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>字符串</source>
          <target state="new">字符串</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>operationId</source>
          <target state="new">operationId</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>64 位整数</source>
          <target state="new">64 位整数</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>属性</source>
          <target state="new">属性</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>二进制数据</source>
          <target state="new">二进制数据</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>tableKind</source>
          <target state="new">tableKind</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>16 位整数</source>
          <target state="new">16 位整数</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>MS\_TableConfig</source>
          <target state="new">MS\_TableConfig</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="setup-sync"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>更改应用的同步行为</source>
          <target state="new"><ph id="ph1">&lt;a name="setup-sync"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>更改应用的同步行为</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>在本部分中，你将要修改应用，使其不会在应用启动时或插入及更新项时同步，而只会在执行刷新手势时同步。</source>
          <target state="new">在本部分中，你将要修改应用，使其不会在应用启动时或插入及更新项时同步，而只会在执行刷新手势时同步。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>QSTodoListViewController.m<ept id="p1">**</ept> 中，更改 <ph id="ph1">`viewDidLoad`</ph> 以删除方法末尾的 <ph id="ph2">`[self refresh]`</ph> 调用。现在，数据不会在应用启动时与服务器进行同步，而只会储存在本地。</source>
          <target state="new">在 <bpt id="p1">**</bpt>QSTodoListViewController.m<ept id="p1">**</ept> 中，更改 <ph id="ph1">`viewDidLoad`</ph> 以删除方法末尾的 <ph id="ph2">`[self refresh]`</ph> 调用。现在，数据不会在应用启动时与服务器进行同步，而只会储存在本地。</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中修改 <ph id="ph1">`addItem`</ph>，使其不会在插入项后同步。删除 <ph id="ph2">`self syncData`</ph> 块并将它替换为以下内容：</source>
          <target state="new">在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中修改 <ph id="ph1">`addItem`</ph>，使其不会在插入项后同步。删除 <ph id="ph2">`self syncData`</ph> 块并将它替换为以下内容：</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>同样地，再次在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中的 <ph id="ph1">`completeItem`</ph> 内，删除 <ph id="ph2">`self syncData`</ph> 的块并将它替换为以下内容：</source>
          <target state="new">同样地，再次在 <bpt id="p1">**</bpt>QSTodoService.m<ept id="p1">**</ept> 中的 <ph id="ph1">`completeItem`</ph> 内，删除 <ph id="ph2">`self syncData`</ph> 的块并将它替换为以下内容：</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="test-app"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>测试应用程序</source>
          <target state="new"><ph id="ph1">&lt;a name="test-app"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>测试应用程序</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>在本部分中，你将在模拟器中关闭 Wi-Fi 以创建脱机方案。在添加数据项时，数据项将保存在本地核心数据存储中，而不同步到移动服务。</source>
          <target state="new">在本部分中，你将在模拟器中关闭 Wi-Fi 以创建脱机方案。在添加数据项时，数据项将保存在本地核心数据存储中，而不同步到移动服务。</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>在 Mac 上关闭 Internet 连接。只是在 iOS 模拟器中关闭 WiFi 可能不起作用，因为模拟器仍可以使用 Mac 主机的 Internet 连接，因此只是关闭了计算机本身的 Internet。这会模拟脱机方案。</source>
          <target state="new">在 Mac 上关闭 Internet 连接。只是在 iOS 模拟器中关闭 WiFi 可能不起作用，因为模拟器仍可以使用 Mac 主机的 Internet 连接，因此只是关闭了计算机本身的 Internet。这会模拟脱机方案。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>添加一些 todo 项或完成某些项。退出模拟器（或强行关闭应用），然后重新启动。验证你的更改是否已保存。请注意，数据项仍会显示，因为它们都保留在本地核心数据存储中。</source>
          <target state="new">添加一些 todo 项或完成某些项。退出模拟器（或强行关闭应用），然后重新启动。验证你的更改是否已保存。请注意，数据项仍会显示，因为它们都保留在本地核心数据存储中。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>查看远程 TodoItem 表的内容。验证新项是否<bpt id="p1">_</bpt>未<ept id="p1">_</ept>同步到服务器。</source>
          <target state="new">查看远程 TodoItem 表的内容。验证新项是否<bpt id="p1">_</bpt>未<ept id="p1">_</ept>同步到服务器。</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>对于 JavaScript 后端，请转到 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">](http://manage.windowsazure.cn)</ept>，然后单击“数据”选项卡查看 <ph id="ph1">`TodoItem`</ph> 表的内容。</source>
          <target state="new">对于 JavaScript 后端，请转到 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">](http://manage.windowsazure.cn)</ept>，然后单击“数据”选项卡查看 <ph id="ph1">`TodoItem`</ph> 表的内容。</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>对于 .NET 后端，请使用 SQL 工具（如 SQL Server Management Studio）或 REST 客户端（如 Fiddler 或 Postman）查看表内容。</source>
          <target state="new">对于 .NET 后端，请使用 SQL 工具（如 SQL Server Management Studio）或 REST 客户端（如 Fiddler 或 Postman）查看表内容。</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>在 iOS 模拟器中打开 Wi-Fi。接下来，通过拉下项列表来执行刷新手势。你将看到旋转进度条和“正在同步...”文字。</source>
          <target state="new">在 iOS 模拟器中打开 Wi-Fi。接下来，通过拉下项列表来执行刷新手势。你将看到旋转进度条和“正在同步...”文字。</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>再次查看 TodoItem 数据。新的和更改的 TodoItem 现在应会出现。</source>
          <target state="new">再次查看 TodoItem 数据。新的和更改的 TodoItem 现在应会出现。</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>摘要</source>
          <target state="new">摘要</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>为了支持移动服务的脱机功能，你使用了 <ph id="ph1">`MSSyncTable`</ph> 接口，并使用本地存储初始化了 <ph id="ph2">`MSClient.syncContext`</ph>。在这种情况下，本地存储是基于核心数据的数据库。</source>
          <target state="new">为了支持移动服务的脱机功能，你使用了 <ph id="ph1">`MSSyncTable`</ph> 接口，并使用本地存储初始化了 <ph id="ph2">`MSClient.syncContext`</ph>。在这种情况下，本地存储是基于核心数据的数据库。</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>使用核心数据本地存储时，你使用<bpt id="p1">[</bpt>正确的系统属性<ept id="p1">][Review the Core Data model]</ept>定义了多个表。移动服务的一般操作在进行时如同应用仍处于连接状态，但所有的操作都针对本地存储执行。</source>
          <target state="new">使用核心数据本地存储时，你使用<bpt id="p1">[</bpt>正确的系统属性<ept id="p1">][Review the Core Data model]</ept>定义了多个表。移动服务的一般操作在进行时如同应用仍处于连接状态，但所有的操作都针对本地存储执行。</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>为了与服务器同步本地存储，你使用了 <ph id="ph1">`MSSyncTable.pullWithQuery`</ph> 和 <ph id="ph2">`MSClient.syncContext.pushWithCompletion`</ph>：</source>
          <target state="new">为了与服务器同步本地存储，你使用了 <ph id="ph1">`MSSyncTable.pullWithQuery`</ph> 和 <ph id="ph2">`MSClient.syncContext.pushWithCompletion`</ph>：</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>使用移动服务脱机支持处理冲突</source>
          <target state="new">使用移动服务脱机支持处理冲突</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>使用移动服务中的软删除</source>
          <target state="new">使用移动服务中的软删除</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>其他资源</source>
          <target state="new">其他资源</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>云覆盖：Azure 移动服务中的脱机同步</source>
          <target state="new">云覆盖：Azure 移动服务中的脱机同步</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>