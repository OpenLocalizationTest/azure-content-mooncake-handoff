<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1cd16555a0639260ce9d579063bd64608d6cd133</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>使用移动服务托管客户端库 (Windows | Xamarin) | Azure</source>
          <target state="new">使用移动服务托管客户端库 (Windows | Xamarin) | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何在 Windows 和 Xamarin 应用中使用 Azure 移动服务的 .NET 客户端。</source>
          <target state="new">了解如何在 Windows 和 Xamarin 应用中使用 Azure 移动服务的 .NET 客户端。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何使用 Azure 移动服务的托管客户端库</source>
          <target state="new">如何使用 Azure 移动服务的托管客户端库</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;</source>
          <target state="new">&amp;nbsp;</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>本指南说明如何在 Windows 应用和 Xamarin 应用中使用 Azure 移动服务的托管客户端库执行常见方案。所述的任务包括查询数据、插入、更新和删除数据、对用户进行身份验证和处理错误。如果你是第一次使用移动服务，最好先完成<bpt id="p1">[</bpt>移动服务快速入门<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-xamarin-ios-get-started)</ept>教程。</source>
          <target state="new">本指南说明如何在 Windows 应用和 Xamarin 应用中使用 Azure 移动服务的托管客户端库执行常见方案。所述的任务包括查询数据、插入、更新和删除数据、对用户进行身份验证和处理错误。如果你是第一次使用移动服务，最好先完成<bpt id="p1">[</bpt>移动服务快速入门<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-xamarin-ios-get-started)</ept>教程。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="setup"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>安装与先决条件</source>
          <target state="new"><ph id="ph1">&lt;a name="setup"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>安装与先决条件</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>假设你已创建一个移动服务和一个表。有关详细信息，请参阅<bpt id="p1">[</bpt>创建表<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=298592)</ept>。在本主题使用的代码中，表的名称为 <ph id="ph1">`TodoItem`</ph>，其中包含以下列：<ph id="ph2">`Id`</ph>、<ph id="ph3">`Text`</ph> 和 <ph id="ph4">`Complete`</ph>。</source>
          <target state="new">假设你已创建一个移动服务和一个表。有关详细信息，请参阅<bpt id="p1">[</bpt>创建表<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=298592)</ept>。在本主题使用的代码中，表的名称为 <ph id="ph1">`TodoItem`</ph>，其中包含以下列：<ph id="ph2">`Id`</ph>、<ph id="ph3">`Text`</ph> 和 <ph id="ph4">`Complete`</ph>。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>相应的类型化客户端 .NET 类型如下：</source>
          <target state="new">相应的类型化客户端 .NET 类型如下：</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>请注意，<bpt id="p1">[</bpt>JsonPropertyAttribute<ept id="p1">](http://www.newtonsoft.com/json/help/html/Properties_T_Newtonsoft_Json_JsonPropertyAttribute.htm)</ept> 用于定义客户端类型与表之间 PropertyName 映射之间的映射。</source>
          <target state="new">请注意，<bpt id="p1">[</bpt>JsonPropertyAttribute<ept id="p1">](http://www.newtonsoft.com/json/help/html/Properties_T_Newtonsoft_Json_JsonPropertyAttribute.htm)</ept> 用于定义客户端类型与表之间 PropertyName 映射之间的映射。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>在 JavaScript 后端移动服务中启用动态架构后，Azure 移动服务将基于 insert 或 update 请求中的对象自动生成新列。有关详细信息，请参阅<bpt id="p1">[</bpt>动态架构<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=296271)</ept>。在 .NET 后端移动服务中，表在项目的数据模型中定义。</source>
          <target state="new">在 JavaScript 后端移动服务中启用动态架构后，Azure 移动服务将基于 insert 或 update 请求中的对象自动生成新列。有关详细信息，请参阅<bpt id="p1">[</bpt>动态架构<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=296271)</ept>。在 .NET 后端移动服务中，表在项目的数据模型中定义。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="create-client"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何创建移动服务客户端</source>
          <target state="new"><ph id="ph1">&lt;a name="create-client"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何创建移动服务客户端</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>以下代码将创建用于访问移动服务的 <ph id="ph1">`MobileServiceClient`</ph> 对象。</source>
          <target state="new">以下代码将创建用于访问移动服务的 <ph id="ph1">`MobileServiceClient`</ph> 对象。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>在上面的代码中，请将 <ph id="ph1">`AppUrl`</ph> 和 <ph id="ph2">`AppKey`</ph> 依次替换为移动服务 URL 和应用程序密钥。在 Azure 经典门户中选择你的移动服务，然后单击“仪表板”即可获取这两个值。</source>
          <target state="new">在上面的代码中，请将 <ph id="ph1">`AppUrl`</ph> 和 <ph id="ph2">`AppKey`</ph> 依次替换为移动服务 URL 和应用程序密钥。在 Azure 经典门户中选择你的移动服务，然后单击“仪表板”即可获取这两个值。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>应用程序密钥用于针对移动服务筛选出随机请求，将随应用程序一起分发。由于此密钥未加密，因此不能被认为是安全的。为确保安全访问你的移动服务数据，你必须改为在允许用户访问前对用户进行身份验证。有关详细信息，请参阅<bpt id="p1">[</bpt>如何：对用户进行身份验证<ept id="p1">](#authentication)</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>应用程序密钥用于针对移动服务筛选出随机请求，将随应用程序一起分发。由于此密钥未加密，因此不能被认为是安全的。为确保安全访问你的移动服务数据，你必须改为在允许用户访问前对用户进行身份验证。有关详细信息，请参阅<bpt id="p1">[</bpt>如何：对用户进行身份验证<ept id="p1">](#authentication)</ept>。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="instantiating"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何创建表引用</source>
          <target state="new"><ph id="ph1">&lt;a name="instantiating"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何创建表引用</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>访问或修改移动服务表中数据的所有代码都将对 <ph id="ph1">`MobileServiceTable`</ph> 对象调用函数。通过对 <ph id="ph2">`MobileServiceClient`</ph> 的实例调用 <bpt id="p1">[</bpt>GetTable<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/azure/jj554275.aspx)</ept> 方法可以获取对表的引用，如下所示：</source>
          <target state="new">访问或修改移动服务表中数据的所有代码都将对 <ph id="ph1">`MobileServiceTable`</ph> 对象调用函数。通过对 <ph id="ph2">`MobileServiceClient`</ph> 的实例调用 <bpt id="p1">[</bpt>GetTable<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/azure/jj554275.aspx)</ept> 方法可以获取对表的引用，如下所示：</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>这是类型化的序列化模型；请参阅下面有关<bpt id="p1">[</bpt>非类型化序列化模型<ept id="p1">](#untyped)</ept>的介绍。</source>
          <target state="new">这是类型化的序列化模型；请参阅下面有关<bpt id="p1">[</bpt>非类型化序列化模型<ept id="p1">](#untyped)</ept>的介绍。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="querying"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何从移动服务查询数据</source>
          <target state="new"><ph id="ph1">&lt;a name="querying"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何从移动服务查询数据</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>本部分介绍如何向包含以下功能的移动服务发出查询：</source>
          <target state="new">本部分介绍如何向包含以下功能的移动服务发出查询：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>筛选返回的数据</source>
          <target state="new">筛选返回的数据</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>为返回的数据排序</source>
          <target state="new">为返回的数据排序</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>在页中返回数据</source>
          <target state="new">在页中返回数据</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>选择特定的列</source>
          <target state="new">选择特定的列</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>按 ID 查找数据</source>
          <target state="new">按 ID 查找数据</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>将强制使用服务器驱动的页大小来防止返回所有行。这可以防止对大型数据集发出的默认请求对服务造成负面影响。若要返回 50 个以上的行，请根据<bpt id="p1">[</bpt><ept id="p1">在页中返回数据]</ept>所述使用 <ph id="ph2">`Take`</ph> 方法。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>将强制使用服务器驱动的页大小来防止返回所有行。这可以防止对大型数据集发出的默认请求对服务造成负面影响。若要返回 50 个以上的行，请根据<bpt id="p1">[</bpt><ept id="p1">在页中返回数据]</ept>所述使用 <ph id="ph2">`Take`</ph> 方法。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="filtering"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何筛选返回的数据</source>
          <target state="new"><ph id="ph1">&lt;a name="filtering"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何筛选返回的数据</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何通过在查询中包含 <ph id="ph1">`Where`</ph> 子句来筛选数据。该代码将返回 <ph id="ph2">`Complete`</ph> 属性等于 <ph id="ph3">`false`</ph> 的 <ph id="ph4">`todoTable`</ph> 中的所有项。<ph id="ph5">`Where`</ph> 函数针对该表将一个行筛选谓词应用到查询。</source>
          <target state="new">以下代码演示了如何通过在查询中包含 <ph id="ph1">`Where`</ph> 子句来筛选数据。该代码将返回 <ph id="ph2">`Complete`</ph> 属性等于 <ph id="ph3">`false`</ph> 的 <ph id="ph4">`todoTable`</ph> 中的所有项。<ph id="ph5">`Where`</ph> 函数针对该表将一个行筛选谓词应用到查询。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>可以使用消息检查软件（例如浏览器开发人员工具或 <bpt id="p1">[</bpt><ept id="p1">Fiddler]</ept>）来查看发送到移动服务的请求的 URI。从下面的请求 URI 中，可以看出我们正在修改查询字符串本身：</source>
          <target state="new">可以使用消息检查软件（例如浏览器开发人员工具或 <bpt id="p1">[</bpt><ept id="p1">Fiddler]</ept>）来查看发送到移动服务的请求的 URI。从下面的请求 URI 中，可以看出我们正在修改查询字符串本身：</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>在服务器端，此请求通常会粗略地转换成以下 SQL 查询：</source>
          <target state="new">在服务器端，此请求通常会粗略地转换成以下 SQL 查询：</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>传递给 <ph id="ph1">`Where`</ph> 方法的函数可以包含任意数目的条件。例如，以下行：</source>
          <target state="new">传递给 <ph id="ph1">`Where`</ph> 方法的函数可以包含任意数目的条件。例如，以下行：</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>将粗略地转换为（针对前面显示的同一请求）</source>
          <target state="new">将粗略地转换为（针对前面显示的同一请求）</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>上述 <ph id="ph1">`where`</ph> 语句将查找 <ph id="ph2">`Complete`</ph> 状态设置为 false 且 <ph id="ph3">`Text`</ph> 不为 null 的项。</source>
          <target state="new">上述 <ph id="ph1">`where`</ph> 语句将查找 <ph id="ph2">`Complete`</ph> 状态设置为 false 且 <ph id="ph3">`Text`</ph> 不为 null 的项。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>我们也可以使用多个行编写该代码：</source>
          <target state="new">我们也可以使用多个行编写该代码：</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>这两种方法是等效的，可以换用。前一个选项（在一个查询中连接多个谓词）更为精简，也是我们推荐的方法。</source>
          <target state="new">这两种方法是等效的，可以换用。前一个选项（在一个查询中连接多个谓词）更为精简，也是我们推荐的方法。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`where`</ph> 子句支持可转换成移动服务 OData 子集的操作，其中包括关系运算符（==、!=、&lt;、&lt;=、&gt;、&gt;=）、数学运算符（+、-、/、*、%）、数字精度（Math.Floor、Math.Ceiling）、字符串函数（Length、Substring、Replace、IndexOf、StartsWith、EndsWith）、日期属性（Year、Month、Day、Hour、Minute、Second）、对象的访问属性，以及组合了上述所有操作的表达式。</source>
          <target state="new"><ph id="ph1">`where`</ph> 子句支持可转换成移动服务 OData 子集的操作，其中包括关系运算符（==、!=、&lt;、&lt;=、&gt;、&gt;=）、数学运算符（+、-、/、*、%）、数字精度（Math.Floor、Math.Ceiling）、字符串函数（Length、Substring、Replace、IndexOf、StartsWith、EndsWith）、日期属性（Year、Month、Day、Hour、Minute、Second）、对象的访问属性，以及组合了上述所有操作的表达式。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="sorting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何为返回的数据排序</source>
          <target state="new"><ph id="ph1">&lt;a name="sorting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何为返回的数据排序</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何通过在查询中包含 <ph id="ph1">`OrderBy`</ph> 或 <ph id="ph2">`OrderByDescending`</ph> 函数来为数据排序。该代码将返回 <ph id="ph3">`todoTable`</ph> 中的项，这些项已按 <ph id="ph4">`Text`</ph> 字段的升序排序。</source>
          <target state="new">以下代码演示了如何通过在查询中包含 <ph id="ph1">`OrderBy`</ph> 或 <ph id="ph2">`OrderByDescending`</ph> 函数来为数据排序。该代码将返回 <ph id="ph3">`todoTable`</ph> 中的项，这些项已按 <ph id="ph4">`Text`</ph> 字段的升序排序。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="paging"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在页中返回数据</source>
          <target state="new"><ph id="ph1">&lt;a name="paging"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在页中返回数据</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>默认情况下，服务器只返回前 50 行。你可以通过调用 <bpt id="p1">[</bpt><ept id="p1">Take]</ept> 方法来增加返回的行数。将 <ph id="ph1">`Take`</ph> 与 <bpt id="p2">[</bpt><ept id="p2">Skip]</ept> 方法一起使用可以请求查询返回的总数据集的特定“页”。执行以下查询后，将返回表中的前三个项。</source>
          <target state="new">默认情况下，服务器只返回前 50 行。你可以通过调用 <bpt id="p1">[</bpt><ept id="p1">Take]</ept> 方法来增加返回的行数。将 <ph id="ph1">`Take`</ph> 与 <bpt id="p2">[</bpt><ept id="p2">Skip]</ept> 方法一起使用可以请求查询返回的总数据集的特定“页”。执行以下查询后，将返回表中的前三个项。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>以下经过修改的查询将跳过前三个结果，返回其后的三个结果。实际上这是数据的第二“页”，其页大小为三个项。</source>
          <target state="new">以下经过修改的查询将跳过前三个结果，返回其后的三个结果。实际上这是数据的第二“页”，其页大小为三个项。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>你还可以使用 <bpt id="p1">[</bpt><ept id="p1">IncludeTotalCount]</ept> 方法来确保查询获取应该返回的<ph id="ph1">&lt;i&gt;</ph>所有<ph id="ph2">&lt;/i&gt;</ph>记录的总计数，并忽略指定的任何 take 分页/限制子句：</source>
          <target state="new">你还可以使用 <bpt id="p1">[</bpt><ept id="p1">IncludeTotalCount]</ept> 方法来确保查询获取应该返回的<ph id="ph1">&lt;i&gt;</ph>所有<ph id="ph2">&lt;/i&gt;</ph>记录的总计数，并忽略指定的任何 take 分页/限制子句：</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>这是将硬编码分页值传递给 <ph id="ph1">`Take`</ph> 和 <ph id="ph2">`Skip`</ph> 方法的简化方案。在实际应用中，你可以对页导航控件或类似的 UI 使用类似于上面的查询，让用户导航到上一页和下一页。</source>
          <target state="new">这是将硬编码分页值传递给 <ph id="ph1">`Take`</ph> 和 <ph id="ph2">`Skip`</ph> 方法的简化方案。在实际应用中，你可以对页导航控件或类似的 UI 使用类似于上面的查询，让用户导航到上一页和下一页。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>.NET 后端移动服务的分页注意事项</source>
          <target state="new">.NET 后端移动服务的分页注意事项</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>若要重写 .NET 后端移动服务中的 50 行限制，你还必须将 <bpt id="p1">[</bpt>EnableQueryAttribute<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/system.web.http.odata.enablequeryattribute.aspx)</ept> 应用到公共 GET 方法，并指定分页行为。将以下语句应用到该方法后，最大返回行数将设置为 1000：</source>
          <target state="new">若要重写 .NET 后端移动服务中的 50 行限制，你还必须将 <bpt id="p1">[</bpt>EnableQueryAttribute<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/system.web.http.odata.enablequeryattribute.aspx)</ept> 应用到公共 GET 方法，并指定分页行为。将以下语句应用到该方法后，最大返回行数将设置为 1000：</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="selecting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何选择特定的列</source>
          <target state="new"><ph id="ph1">&lt;a name="selecting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何选择特定的列</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>你可以通过在查询中添加 <ph id="ph1">`Select`</ph> 子句来指定要包含在结果中的属性集。例如，以下代码演示了如何做到只选择一个字段，以及如何选择并格式化多个字段：</source>
          <target state="new">你可以通过在查询中添加 <ph id="ph1">`Select`</ph> 子句来指定要包含在结果中的属性集。例如，以下代码演示了如何做到只选择一个字段，以及如何选择并格式化多个字段：</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>到目前为止所述的所有函数都是加性函数，我们可以不断地调用它们，每次调用都能进一步影响查询。再提供一个示例：</source>
          <target state="new">到目前为止所述的所有函数都是加性函数，我们可以不断地调用它们，每次调用都能进一步影响查询。再提供一个示例：</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="lookingup"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：按 ID 查找数据</source>
          <target state="new"><ph id="ph1">&lt;a name="lookingup"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：按 ID 查找数据</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>使用 <ph id="ph1">`LookupAsync`</ph> 函数可以查找数据库中具有特定 ID 的对象。</source>
          <target state="new">使用 <ph id="ph1">`LookupAsync`</ph> 函数可以查找数据库中具有特定 ID 的对象。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="inserting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中插入数据</source>
          <target state="new"><ph id="ph1">&lt;a name="inserting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中插入数据</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>如果你想要对某个类型执行插入、查找、删除或更新操作，则需要创建一个名为 <bpt id="p1">**</bpt>Id<ept id="p1">**</ept> 的成员。正因如此，示例类 <bpt id="p2">**</bpt>TodoItem<ept id="p2">**</ept> 包含了一个名为 <bpt id="p3">**</bpt>Id<ept id="p3">**</ept> 的成员。更新和删除操作中始终必须存在一个有效的 ID 值。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>如果你想要对某个类型执行插入、查找、删除或更新操作，则需要创建一个名为 <bpt id="p1">**</bpt>Id<ept id="p1">**</ept> 的成员。正因如此，示例类 <bpt id="p2">**</bpt>TodoItem<ept id="p2">**</ept> 包含了一个名为 <bpt id="p3">**</bpt>Id<ept id="p3">**</ept> 的成员。更新和删除操作中始终必须存在一个有效的 ID 值。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何在表中插入新行。参数包含要作为 .NET 对象插入的数据。</source>
          <target state="new">以下代码演示了如何在表中插入新行。参数包含要作为 .NET 对象插入的数据。</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>如果在传递给 <ph id="ph1">`todoTable.InsertAsync`</ph> 调用的 <ph id="ph2">`todoItem`</ph> 中未包含唯一的自定义 ID 值，则服务器将会生成一个 ID 值，并在返回到客户端的 <ph id="ph3">`todoItem`</ph> 对象中设置该值。</source>
          <target state="new">如果在传递给 <ph id="ph1">`todoTable.InsertAsync`</ph> 调用的 <ph id="ph2">`todoItem`</ph> 中未包含唯一的自定义 ID 值，则服务器将会生成一个 ID 值，并在返回到客户端的 <ph id="ph3">`todoItem`</ph> 对象中设置该值。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>若要插入非类型化数据，你可以按如下所示利用 Json.NET。</source>
          <target state="new">若要插入非类型化数据，你可以按如下所示利用 Json.NET。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>以下示例使用电子邮件地址作为唯一的字符串 ID。</source>
          <target state="new">以下示例使用电子邮件地址作为唯一的字符串 ID。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>使用 ID 值</source>
          <target state="new">使用 ID 值</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>移动服务支持为表的 <bpt id="p1">**</bpt>ID<ept id="p1">**</ept> 列使用唯一的自定义字符串值。这样，应用程序便可为 ID 使用自定义值（如电子邮件地址或用户名）。</source>
          <target state="new">移动服务支持为表的 <bpt id="p1">**</bpt>ID<ept id="p1">**</ept> 列使用唯一的自定义字符串值。这样，应用程序便可为 ID 使用自定义值（如电子邮件地址或用户名）。</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>字符串 ID 可提供以下优势：</source>
          <target state="new">字符串 ID 可提供以下优势：</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>无需往返访问数据库即可生成 ID。</source>
          <target state="new">无需往返访问数据库即可生成 ID。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>更方便地合并不同表或数据库中的记录。</source>
          <target state="new">更方便地合并不同表或数据库中的记录。</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>ID 值能够更好地与应用程序的逻辑相集成。</source>
          <target state="new">ID 值能够更好地与应用程序的逻辑相集成。</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>如果插入的记录中未设置字符串 ID 值，移动服务将为 ID 生成唯一值。你可以在客户端上或在 .NET 移动后端服务中，使用 <ph id="ph1">`Guid.NewGuid()`</ph> 方法生成自己的 ID 值。若要了解有关在 JavaScript 后端移动服务中生成 GUID 的详细信息，请参阅<bpt id="p1">[</bpt>如何：生成唯一的 ID 值<ept id="p1">](/documentation/articles/mobile-services-how-to-use-server-scripts/#generate-guids)</ept>。</source>
          <target state="new">如果插入的记录中未设置字符串 ID 值，移动服务将为 ID 生成唯一值。你可以在客户端上或在 .NET 移动后端服务中，使用 <ph id="ph1">`Guid.NewGuid()`</ph> 方法生成自己的 ID 值。若要了解有关在 JavaScript 后端移动服务中生成 GUID 的详细信息，请参阅<bpt id="p1">[</bpt>如何：生成唯一的 ID 值<ept id="p1">](/documentation/articles/mobile-services-how-to-use-server-scripts/#generate-guids)</ept>。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>也可以为表使用整数 ID。若要使用整数 ID，必须结合 <ph id="ph1">`--integerId`</ph> 选项使用 <ph id="ph2">`mobile table create`</ph> 命令创建表。应在适用于 Azure 的命令行界面 (CLI) 中使用此命令。有关使用 CLI 的详细信息，请参阅<bpt id="p1">[</bpt>用于管理移动服务表的 CLI<ept id="p1">](/documentation/articles/virtual-machines-command-line-tools/#Mobile_Tables)</ept>。</source>
          <target state="new">也可以为表使用整数 ID。若要使用整数 ID，必须结合 <ph id="ph1">`--integerId`</ph> 选项使用 <ph id="ph2">`mobile table create`</ph> 命令创建表。应在适用于 Azure 的命令行界面 (CLI) 中使用此命令。有关使用 CLI 的详细信息，请参阅<bpt id="p1">[</bpt>用于管理移动服务表的 CLI<ept id="p1">](/documentation/articles/virtual-machines-command-line-tools/#Mobile_Tables)</ept>。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="modifying"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：在移动服务中修改数据</source>
          <target state="new"><ph id="ph1">&lt;a name="modifying"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：在移动服务中修改数据</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何使用新的信息更新具有相同 ID 的现有实例。参数包含要作为 .NET 对象更新的数据。</source>
          <target state="new">以下代码演示了如何使用新的信息更新具有相同 ID 的现有实例。参数包含要作为 .NET 对象更新的数据。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>若要插入非类型化数据，你可以按此方式利用 Json.NET。请注意，在执行更新时，必须指定 ID，移动服务将凭此 ID 来识别要更新的实例。可以从 <ph id="ph1">`InsertAsync`</ph> 调用的结果中获取该 ID。</source>
          <target state="new">若要插入非类型化数据，你可以按此方式利用 Json.NET。请注意，在执行更新时，必须指定 ID，移动服务将凭此 ID 来识别要更新的实例。可以从 <ph id="ph1">`InsertAsync`</ph> 调用的结果中获取该 ID。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>如果你尝试更新某个项但未提供“ID”值，则服务无法识别要更新的实例，从而导致移动服务 SDK 引发 <ph id="ph1">`ArgumentException`</ph>。</source>
          <target state="new">如果你尝试更新某个项但未提供“ID”值，则服务无法识别要更新的实例，从而导致移动服务 SDK 引发 <ph id="ph1">`ArgumentException`</ph>。</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="deleting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中删除数据</source>
          <target state="new"><ph id="ph1">&lt;a name="deleting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中删除数据</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何删除现有实例。该实例由 <ph id="ph1">`todoItem`</ph> 中设置的“Id”字段标识。</source>
          <target state="new">以下代码演示了如何删除现有实例。该实例由 <ph id="ph1">`todoItem`</ph> 中设置的“Id”字段标识。</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>若要删除非类型化数据，你可以按此方式利用 Json.NET。请注意，在执行删除请求时，必须指定 ID，移动服务将凭此 ID 来识别要删除的实例。删除请求只需要 ID；其他属性将不会传递给服务，如果传递了任何属性，服务会将其忽略。<ph id="ph1">`DeleteAsync`</ph> 调用的结果通常也是 <ph id="ph2">`null`</ph>。可以从 <ph id="ph3">`InsertAsync`</ph> 调用的结果中获取要传入的 ID。</source>
          <target state="new">若要删除非类型化数据，你可以按此方式利用 Json.NET。请注意，在执行删除请求时，必须指定 ID，移动服务将凭此 ID 来识别要删除的实例。删除请求只需要 ID；其他属性将不会传递给服务，如果传递了任何属性，服务会将其忽略。<ph id="ph1">`DeleteAsync`</ph> 调用的结果通常也是 <ph id="ph2">`null`</ph>。可以从 <ph id="ph3">`InsertAsync`</ph> 调用的结果中获取要传入的 ID。</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>如果你尝试删除某个项但尚未设置“Id”字段，则服务无法识别要删除的实例，因此你会收到服务发出的 <ph id="ph1">`MobileServiceInvalidOperationException`</ph>。同样，如果你尝试删除某个非类型化项但尚未设置“Id”字段，则也会收到服务发出的 <ph id="ph2">`MobileServiceInvalidOperationException`</ph>。</source>
          <target state="new">如果你尝试删除某个项但尚未设置“Id”字段，则服务无法识别要删除的实例，因此你会收到服务发出的 <ph id="ph1">`MobileServiceInvalidOperationException`</ph>。同样，如果你尝试删除某个非类型化项但尚未设置“Id”字段，则也会收到服务发出的 <ph id="ph2">`MobileServiceInvalidOperationException`</ph>。</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="#custom-api"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：调用自定义 API</source>
          <target state="new"><ph id="ph1">&lt;a name="#custom-api"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：调用自定义 API</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>自定义 API 可让你定义自定义终结点，这些终结点将会公开不映射到插入、更新、删除或读取操作的服务器功能。使用自定义 API 能够以更大的力度控制消息传送，包括读取和设置 HTTP 消息标头，以及定义除 JSON 以外的消息正文格式。有关如何在移动服务中创建自定义 API 的示例，请参阅<bpt id="p1">[</bpt>如何：定义自定义 API 终结点<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-define-custom-api)</ept>。</source>
          <target state="new">自定义 API 可让你定义自定义终结点，这些终结点将会公开不映射到插入、更新、删除或读取操作的服务器功能。使用自定义 API 能够以更大的力度控制消息传送，包括读取和设置 HTTP 消息标头，以及定义除 JSON 以外的消息正文格式。有关如何在移动服务中创建自定义 API 的示例，请参阅<bpt id="p1">[</bpt>如何：定义自定义 API 终结点<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-define-custom-api)</ept>。</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>通过在客户端上调用某一个 <bpt id="p1">[</bpt><ept id="p1">InvokeApiAsync]</ept> 方法重载来调用自定义 API。例如，以下代码行向移动服务上的 <bpt id="p2">**</bpt>completeAll<ept id="p2">**</ept> API 发送 POST 请求：</source>
          <target state="new">通过在客户端上调用某一个 <bpt id="p1">[</bpt><ept id="p1">InvokeApiAsync]</ept> 方法重载来调用自定义 API。例如，以下代码行向移动服务上的 <bpt id="p2">**</bpt>completeAll<ept id="p2">**</ept> API 发送 POST 请求：</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>请注意，这种类型化方法调用要求定义 <bpt id="p1">**</bpt>MarkAllResult<ept id="p1">**</ept> 返回类型。支持类型化和非类型化的方法。这几乎是最小的示例，因为它是类型化方法，不发送任何负载，没有查询参数，而且不改变请求标头。有关更现实可行的示例和对 <bpt id="p2">[</bpt><ept id="p2">InvokeApiAsync]</ept> 更完整的介绍，请参阅 <bpt id="p3">[</bpt><ept id="p3">Azure 移动服务客户端 SDK 中的自定义 API]</ept>。</source>
          <target state="new">请注意，这种类型化方法调用要求定义 <bpt id="p1">**</bpt>MarkAllResult<ept id="p1">**</ept> 返回类型。支持类型化和非类型化的方法。这几乎是最小的示例，因为它是类型化方法，不发送任何负载，没有查询参数，而且不改变请求标头。有关更现实可行的示例和对 <bpt id="p2">[</bpt><ept id="p2">InvokeApiAsync]</ept> 更完整的介绍，请参阅 <bpt id="p3">[</bpt><ept id="p3">Azure 移动服务客户端 SDK 中的自定义 API]</ept>。</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>如何：注册推送通知</source>
          <target state="new">如何：注册推送通知</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>移动服务客户端可让你向 Azure 通知中心注册推送通知。注册时，你将获得从平台特定的推送通知服务 (PNS) 获取的句柄。然后你就可以在创建注册时提供此值以及任何标记。以下代码将用于推送通知的 Windows 应用注册到 Windows 通知服务 (WNS)：</source>
          <target state="new">移动服务客户端可让你向 Azure 通知中心注册推送通知。注册时，你将获得从平台特定的推送通知服务 (PNS) 获取的句柄。然后你就可以在创建注册时提供此值以及任何标记。以下代码将用于推送通知的 Windows 应用注册到 Windows 通知服务 (WNS)：</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>请注意，在此示例中，注册包含两个标记。有关 Windows 应用的详细信息，请参阅<bpt id="p1">[</bpt>向应用添加推送通知<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-windows-universal-dotnet-get-started-push)</ept></source>
          <target state="new">请注意，在此示例中，注册包含两个标记。有关 Windows 应用的详细信息，请参阅<bpt id="p1">[</bpt>向应用添加推送通知<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-windows-universal-dotnet-get-started-push)</ept></target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Xamarin 应用需要一些额外的代码才能将 iOS 或 Android 应用上运行的 Xamarin 应用分别注册到 Apple Push Notification 服务 (APNS) 和 Google Cloud Messaging (GCM) 服务。有关详细信息，请参阅<bpt id="p1">**</bpt>向应用添加推送通知<ept id="p1">**</ept> (<bpt id="p2">[</bpt>Xamarin.iOS<ept id="p2">](/documentation/articles/partner-xamarin-mobile-services-ios-get-started-push/#add-push)</ept> | <bpt id="p3">[</bpt>Xamarin.Android<ept id="p3">](/documentation/articles/partner-xamarin-mobile-services-android-get-started-push/#add-push)</ept>)。</source>
          <target state="new">Xamarin 应用需要一些额外的代码才能将 iOS 或 Android 应用上运行的 Xamarin 应用分别注册到 Apple Push Notification 服务 (APNS) 和 Google Cloud Messaging (GCM) 服务。有关详细信息，请参阅<bpt id="p1">**</bpt>向应用添加推送通知<ept id="p1">**</ept> (<bpt id="p2">[</bpt>Xamarin.iOS<ept id="p2">](/documentation/articles/partner-xamarin-mobile-services-ios-get-started-push/#add-push)</ept> | <bpt id="p3">[</bpt>Xamarin.Android<ept id="p3">](/documentation/articles/partner-xamarin-mobile-services-android-get-started-push/#add-push)</ept>)。</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>当你需要发送通知给特定的已注册用户时，必须在注册之前要求身份验证，然后验证是否已授权该用户注册特定标记。例如，必须检查以确保用户注册的标记不是其他人的用户 ID。有关详细信息，请参阅<bpt id="p1">[</bpt>向经过身份验证的用户发送推送通知<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-windows-store-dotnet-push-notifications-app-users)</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>当你需要发送通知给特定的已注册用户时，必须在注册之前要求身份验证，然后验证是否已授权该用户注册特定标记。例如，必须检查以确保用户注册的标记不是其他人的用户 ID。有关详细信息，请参阅<bpt id="p1">[</bpt>向经过身份验证的用户发送推送通知<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-windows-store-dotnet-push-notifications-app-users)</ept>。</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="pull-notifications"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：在 Windows 应用中使用定期通知</source>
          <target state="new"><ph id="ph1">&lt;a name="pull-notifications"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：在 Windows 应用中使用定期通知</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Windows 支持使用定期通知（提取通知）更新动态磁贴。启用定期通知后，Windows 将定期访问自定义 API 终结点以更新开始菜单上的应用磁贴。若要使用定期通知，必须<bpt id="p1">[</bpt>定义一个自定义 API<ept id="p1">](mobile-services-javascript-backend-define-custom-api.md)</ept>，以便使用磁贴特定的格式返回 XML 数据。有关详细信息，请参阅<bpt id="p2">[</bpt>定期通知<ept id="p2">](https://msdn.microsoft.com/library/windows/apps/hh761461.aspx)</ept>。</source>
          <target state="new">Windows 支持使用定期通知（提取通知）更新动态磁贴。启用定期通知后，Windows 将定期访问自定义 API 终结点以更新开始菜单上的应用磁贴。若要使用定期通知，必须<bpt id="p1">[</bpt>定义一个自定义 API<ept id="p1">](mobile-services-javascript-backend-define-custom-api.md)</ept>，以便使用磁贴特定的格式返回 XML 数据。有关详细信息，请参阅<bpt id="p2">[</bpt>定期通知<ept id="p2">](https://msdn.microsoft.com/library/windows/apps/hh761461.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>以下示例将启用定期通知，以便从 <bpt id="p1">*</bpt>tiles<ept id="p1">*</ept> 自定义终结点请求磁贴模板数据：</source>
          <target state="new">以下示例将启用定期通知，以便从 <bpt id="p1">*</bpt>tiles<ept id="p1">*</ept> 自定义终结点请求磁贴模板数据：</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>选择与你的数据更新频率最匹配的 <bpt id="p1">[</bpt>PeriodicUpdateRecurrance<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/windows/apps/windows.ui.notifications.periodicupdaterecurrence.aspx)</ept> 值。</source>
          <target state="new">选择与你的数据更新频率最匹配的 <bpt id="p1">[</bpt>PeriodicUpdateRecurrance<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/windows/apps/windows.ui.notifications.periodicupdaterecurrence.aspx)</ept> 值。</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="optimisticconcurrency"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：使用乐观并发</source>
          <target state="new"><ph id="ph1">&lt;a name="optimisticconcurrency"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：使用乐观并发</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>在某些情况下，两个或两个以上客户端可能会同时将更改写入同一项目。如果没有任何冲突检测，则最后一次写入会覆盖任何以前的更新，即使这并不是所需要的结果。乐观并发控制假定每个事务均可以提交，因此不使用任何资源锁定。提交事务之前，乐观并发控制将验证是否没有其他事务修改了数据。如果数据已修改，则将回滚正在提交的事务。</source>
          <target state="new">在某些情况下，两个或两个以上客户端可能会同时将更改写入同一项目。如果没有任何冲突检测，则最后一次写入会覆盖任何以前的更新，即使这并不是所需要的结果。乐观并发控制假定每个事务均可以提交，因此不使用任何资源锁定。提交事务之前，乐观并发控制将验证是否没有其他事务修改了数据。如果数据已修改，则将回滚正在提交的事务。</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>移动服务通过使用 <ph id="ph1">`__version`</ph> 系统属性列（该列是为移动服务创建的每个表定义的）跟踪对每个项的更改来支持乐观并发控制。每次更新某个记录时，移动服务都将该记录的 <ph id="ph2">`__version`</ph> 属性设置为新值。在每次执行更新请求期间，会将该请求包含的记录的 <ph id="ph3">`__version`</ph> 属性与服务器上的记录的同一属性进行比较。如果随请求传递的版本与服务器不匹配，则移动服务 .NET 客户端库将引发 <ph id="ph4">`MobileServicePreconditionFailedException&lt;T&gt;`</ph>。该异常中提供的类型就是包含记录服务器版本的服务器中的记录。然后，应用程序可以借助此信息来确定是否要使用服务器中正确的 <ph id="ph5">`__version`</ph> 值再次执行更新请求以提交更改。</source>
          <target state="new">移动服务通过使用 <ph id="ph1">`__version`</ph> 系统属性列（该列是为移动服务创建的每个表定义的）跟踪对每个项的更改来支持乐观并发控制。每次更新某个记录时，移动服务都将该记录的 <ph id="ph2">`__version`</ph> 属性设置为新值。在每次执行更新请求期间，会将该请求包含的记录的 <ph id="ph3">`__version`</ph> 属性与服务器上的记录的同一属性进行比较。如果随请求传递的版本与服务器不匹配，则移动服务 .NET 客户端库将引发 <ph id="ph4">`MobileServicePreconditionFailedException&lt;T&gt;`</ph>。该异常中提供的类型就是包含记录服务器版本的服务器中的记录。然后，应用程序可以借助此信息来确定是否要使用服务器中正确的 <ph id="ph5">`__version`</ph> 值再次执行更新请求以提交更改。</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>为了启用乐观并发，应用程序将在表类中为 <ph id="ph1">`__version`</ph> 系统属性定义一个列。以下定义就是一个示例。</source>
          <target state="new">为了启用乐观并发，应用程序将在表类中为 <ph id="ph1">`__version`</ph> 系统属性定义一个列。以下定义就是一个示例。</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>使用非类型化表的应用程序通过在表的 <ph id="ph1">`SystemProperties`</ph> 中设置 <ph id="ph2">`Version`</ph> 标志来启用乐观并发，如下所示。</source>
          <target state="new">使用非类型化表的应用程序通过在表的 <ph id="ph1">`SystemProperties`</ph> 中设置 <ph id="ph2">`Version`</ph> 标志来启用乐观并发，如下所示。</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何解决检测到的写入冲突。若要提交解决方法，必须在 <ph id="ph1">`UpdateAsync()`</ph> 调用中包含正确的 <ph id="ph2">`__version`</ph> 值。</source>
          <target state="new">以下代码演示了如何解决检测到的写入冲突。若要提交解决方法，必须在 <ph id="ph1">`UpdateAsync()`</ph> 调用中包含正确的 <ph id="ph2">`__version`</ph> 值。</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>有关使用移动服务乐观并发的更完整示例，请参阅<bpt id="p1">[</bpt><ept id="p1">乐观并发教程]</ept>。</source>
          <target state="new">有关使用移动服务乐观并发的更完整示例，请参阅<bpt id="p1">[</bpt><ept id="p1">乐观并发教程]</ept>。</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="binding"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：将移动服务数据绑定到 Windows 用户界面</source>
          <target state="new"><ph id="ph1">&lt;a name="binding"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：将移动服务数据绑定到 Windows 用户界面</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>本部分说明如何使用 Windows 应用中的 UI 元素显示返回的数据对象。若要查询 <ph id="ph1">`todoTable`</ph> 中的不完整项并在极简单的列表中显示这些项，可以运行以下示例代码，以使用查询绑定列表源。使用 <ph id="ph2">`MobileServiceCollection`</ph> 可以创建移动服务感知型绑定集合。</source>
          <target state="new">本部分说明如何使用 Windows 应用中的 UI 元素显示返回的数据对象。若要查询 <ph id="ph1">`todoTable`</ph> 中的不完整项并在极简单的列表中显示这些项，可以运行以下示例代码，以使用查询绑定列表源。使用 <ph id="ph2">`MobileServiceCollection`</ph> 可以创建移动服务感知型绑定集合。</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>托管运行时中的某些控件支持名为 <bpt id="p1">[</bpt>ISupportIncrementalLoading<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/windows/apps/Hh701916)</ept> 的接口。当用户滚动浏览时，此接口允许控件请求更多的数据。系统通过 <ph id="ph1">`MobileServiceIncrementalLoadingCollection`</ph>（可自动处理来自控件的调用）为这个适用于通用 Windows 8.1 应用的接口提供内置支持。若要在 Windows 应用中使用 <ph id="ph2">`MobileServiceIncrementalLoadingCollection`</ph>，请执行以下代码：</source>
          <target state="new">托管运行时中的某些控件支持名为 <bpt id="p1">[</bpt>ISupportIncrementalLoading<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/windows/apps/Hh701916)</ept> 的接口。当用户滚动浏览时，此接口允许控件请求更多的数据。系统通过 <ph id="ph1">`MobileServiceIncrementalLoadingCollection`</ph>（可自动处理来自控件的调用）为这个适用于通用 Windows 8.1 应用的接口提供内置支持。若要在 Windows 应用中使用 <ph id="ph2">`MobileServiceIncrementalLoadingCollection`</ph>，请执行以下代码：</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>若要在 Windows Phone 8 和“Silverlight”应用上使用新的集合，请在 <ph id="ph1">`IMobileServiceTableQuery&lt;T&gt;`</ph> 和 <ph id="ph2">`IMobileServiceTable&lt;T&gt;`</ph> 上使用 <ph id="ph3">`ToCollection`</ph> 扩展方法。若要实际加载数据，请调用 <ph id="ph4">`LoadMoreItemsAsync()`</ph>。</source>
          <target state="new">若要在 Windows Phone 8 和“Silverlight”应用上使用新的集合，请在 <ph id="ph1">`IMobileServiceTableQuery&lt;T&gt;`</ph> 和 <ph id="ph2">`IMobileServiceTable&lt;T&gt;`</ph> 上使用 <ph id="ph3">`ToCollection`</ph> 扩展方法。若要实际加载数据，请调用 <ph id="ph4">`LoadMoreItemsAsync()`</ph>。</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>当你使用通过调用 <ph id="ph1">`ToCollectionAsync`</ph> 或 <ph id="ph2">`ToCollection`</ph> 创建的集合时，可以获取可绑定到 UI 控件的集合。此集合支持分页，也就是说，控件可以要求该集合“加载更多项”，而该集合也确实会这样做。这样看来，无需执行任何用户代码，控件就能启动工作流。但是，由于集合要从网络加载数据，因此可以预料到这种加载有时会失败。若要处理这种故障，你可以重写 <ph id="ph3">`MobileServiceIncrementalLoadingCollection`</ph> 中的 <ph id="ph4">`OnException`</ph> 方法，以处理调用控件执行的 <ph id="ph5">`LoadMoreItemsAsync`</ph> 后发生的异常。</source>
          <target state="new">当你使用通过调用 <ph id="ph1">`ToCollectionAsync`</ph> 或 <ph id="ph2">`ToCollection`</ph> 创建的集合时，可以获取可绑定到 UI 控件的集合。此集合支持分页，也就是说，控件可以要求该集合“加载更多项”，而该集合也确实会这样做。这样看来，无需执行任何用户代码，控件就能启动工作流。但是，由于集合要从网络加载数据，因此可以预料到这种加载有时会失败。若要处理这种故障，你可以重写 <ph id="ph3">`MobileServiceIncrementalLoadingCollection`</ph> 中的 <ph id="ph4">`OnException`</ph> 方法，以处理调用控件执行的 <ph id="ph5">`LoadMoreItemsAsync`</ph> 后发生的异常。</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>最后，假设你的表包含许多字段，但你只想在控件中显示其中的某些字段。在这种情况下，你可以参考上面“<bpt id="p1">[</bpt>选择特定的列<ept id="p1">](#selecting)</ept>”部分中的指导，选择要在 UI 中显示的特定列。</source>
          <target state="new">最后，假设你的表包含许多字段，但你只想在控件中显示其中的某些字段。在这种情况下，你可以参考上面“<bpt id="p1">[</bpt>选择特定的列<ept id="p1">](#selecting)</ept>”部分中的指导，选择要在 UI 中显示的特定列。</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="authentication"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何对用户进行身份验证</source>
          <target state="new"><ph id="ph1">&lt;a name="authentication"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何对用户进行身份验证</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>移动服务支持使用各种外部标识提供者对应用程序用户进行身份验证和授权，这些提供者包括：Facebook、Google、Microsoft 帐户、Twitter 和 Active Directory。你可以在表中设置权限，以便将特定操作的访问权限限制给已经过身份验证的用户。你还可以在服务器脚本中使用已经过身份验证的用户的标识来实施授权规则。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">向应用程序添加身份验证]</ept>教程。</source>
          <target state="new">移动服务支持使用各种外部标识提供者对应用程序用户进行身份验证和授权，这些提供者包括：Facebook、Google、Microsoft 帐户、Twitter 和 Active Directory。你可以在表中设置权限，以便将特定操作的访问权限限制给已经过身份验证的用户。你还可以在服务器脚本中使用已经过身份验证的用户的标识来实施授权规则。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">向应用程序添加身份验证]</ept>教程。</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>支持两种身份验证流：<bpt id="p1">_</bpt>服务器流<ept id="p1">_</ept>和<bpt id="p2">_</bpt>客户端流<ept id="p2">_</ept>。服务器流依赖于提供者的 Web 身份验证界面，因此可提供最简便的身份验证体验。客户端流依赖于提供者和设备特定的 SDK，因此允许与设备特定的功能进行更深入的集成。</source>
          <target state="new">支持两种身份验证流：<bpt id="p1">_</bpt>服务器流<ept id="p1">_</ept>和<bpt id="p2">_</bpt>客户端流<ept id="p2">_</ept>。服务器流依赖于提供者的 Web 身份验证界面，因此可提供最简便的身份验证体验。客户端流依赖于提供者和设备特定的 SDK，因此允许与设备特定的功能进行更深入的集成。</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>服务器流</source>
          <target state="new">服务器流</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>若要让移动服务管理 Windows 应用中的身份验证过程，必须将你的应用注册到标识提供者。然后，需要在移动服务中配置提供者提供的应用程序 ID 和机密。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">向应用程序添加身份验证]</ept>教程。</source>
          <target state="new">若要让移动服务管理 Windows 应用中的身份验证过程，必须将你的应用注册到标识提供者。然后，需要在移动服务中配置提供者提供的应用程序 ID 和机密。有关详细信息，请参阅<bpt id="p1">[</bpt><ept id="p1">向应用程序添加身份验证]</ept>教程。</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>注册标识提供者后，只需结合提供者的 <bpt id="p1">[</bpt><ept id="p1">MobileServiceAuthenticationProvider]</ept> 值调用 <bpt id="p2">[</bpt><ept id="p2">LoginAsync 方法]</ept>。例如，以下代码将使用 Facebook 启动服务器流登录。</source>
          <target state="new">注册标识提供者后，只需结合提供者的 <bpt id="p1">[</bpt><ept id="p1">MobileServiceAuthenticationProvider]</ept> 值调用 <bpt id="p2">[</bpt><ept id="p2">LoginAsync 方法]</ept>。例如，以下代码将使用 Facebook 启动服务器流登录。</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>如果使用的标识提供商不是 Facebook，请将上述 <bpt id="p1">[</bpt><ept id="p1">MobileServiceAuthenticationProvider]</ept> 的值更改为你的提供商的值。</source>
          <target state="new">如果使用的标识提供商不是 Facebook，请将上述 <bpt id="p1">[</bpt><ept id="p1">MobileServiceAuthenticationProvider]</ept> 的值更改为你的提供商的值。</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>在此情况下，移动服务将通过以下方式管理 OAuth 2.0 身份验证流：显示选定提供者的登录页，并在用户成功使用标识提供者登录后生成移动服务身份验证令牌。<bpt id="p1">[</bpt><ept id="p1">LoginAsync 方法]</ept>将返回 <bpt id="p2">[</bpt><ept id="p2">MobileServiceUser]</ept>，该类将提供已经过身份验证的用户的 <bpt id="p3">[</bpt><ept id="p3">userId]</ept>，以及 JSON Web 令牌 (JWT) 形式的 <bpt id="p4">[</bpt><ept id="p4">MobileServiceAuthenticationToken]</ept>。你可以缓存此令牌，并在它过期之前重复使用。有关详细信息，请参阅<bpt id="p5">[</bpt><ept id="p5">缓存身份验证令牌]</ept>。</source>
          <target state="new">在此情况下，移动服务将通过以下方式管理 OAuth 2.0 身份验证流：显示选定提供者的登录页，并在用户成功使用标识提供者登录后生成移动服务身份验证令牌。<bpt id="p1">[</bpt><ept id="p1">LoginAsync 方法]</ept>将返回 <bpt id="p2">[</bpt><ept id="p2">MobileServiceUser]</ept>，该类将提供已经过身份验证的用户的 <bpt id="p3">[</bpt><ept id="p3">userId]</ept>，以及 JSON Web 令牌 (JWT) 形式的 <bpt id="p4">[</bpt><ept id="p4">MobileServiceAuthenticationToken]</ept>。你可以缓存此令牌，并在它过期之前重复使用。有关详细信息，请参阅<bpt id="p5">[</bpt><ept id="p5">缓存身份验证令牌]</ept>。</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>客户端流</source>
          <target state="new">客户端流</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>你的应用程序还能够独立联系标识提供者，然后将返回的令牌提供给移动服务以进行身份验证。使用此客户端流可为用户提供单一登录体验，或者从标识提供者中检索其他用户数据。</source>
          <target state="new">你的应用程序还能够独立联系标识提供者，然后将返回的令牌提供给移动服务以进行身份验证。使用此客户端流可为用户提供单一登录体验，或者从标识提供者中检索其他用户数据。</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>单一登录使用来自 Facebook 或 Google 的令牌</source>
          <target state="new">单一登录使用来自 Facebook 或 Google 的令牌</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>你可以根据以下代码段中所示，为 Facebook 或 Google 使用这种最简单形式的客户端流。</source>
          <target state="new">你可以根据以下代码段中所示，为 Facebook 或 Google 使用这种最简单形式的客户端流。</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>单一登录将 Microsoft 帐户与 Live SDK 配合使用</source>
          <target state="new">单一登录将 Microsoft 帐户与 Live SDK 配合使用</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>若要对用户进行身份验证，必须在 Microsoft 帐户开发人员中心注册你的应用程序。然后，必须将此注册连接到你的移动服务。完成<bpt id="p1">[</bpt>注册应用以使用 Microsoft 帐户登录<ept id="p1">](/documentation/articles/mobile-services-how-to-register-microsoft-authentication)</ept>中的步骤，以创建 Microsoft 帐户注册并将注册连接到你的移动服务。如果你同时拥有 Windows 应用商店和 Windows Phone 8/Silverlight 版本的应用，请先注册 Windows 应用商店版本。</source>
          <target state="new">若要对用户进行身份验证，必须在 Microsoft 帐户开发人员中心注册你的应用程序。然后，必须将此注册连接到你的移动服务。完成<bpt id="p1">[</bpt>注册应用以使用 Microsoft 帐户登录<ept id="p1">](/documentation/articles/mobile-services-how-to-register-microsoft-authentication)</ept>中的步骤，以创建 Microsoft 帐户注册并将注册连接到你的移动服务。如果你同时拥有 Windows 应用商店和 Windows Phone 8/Silverlight 版本的应用，请先注册 Windows 应用商店版本。</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>下面的代码使用 Live SDK 进行身份验证，并使用返回的令牌来登录到你的移动服务。</source>
          <target state="new">下面的代码使用 Live SDK 进行身份验证，并使用返回的令牌来登录到你的移动服务。</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="caching"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>缓存身份验证令牌</source>
          <target state="new"><ph id="ph1">&lt;a name="caching"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>缓存身份验证令牌</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>在某些情况下，完成首次用户身份验证后，可以避免调用 login 方法。你可以使用适用于 Windows 应用商店应用程序的 <bpt id="p1">[</bpt><ept id="p1">PasswordVault]</ept> 来缓存当前用户首次登录时使用的标识，以后每次该用户登录时，系统都会检查缓存中是否存在该用户标识。如果缓存为空，则用户仍然需要完成整个登录过程。</source>
          <target state="new">在某些情况下，完成首次用户身份验证后，可以避免调用 login 方法。你可以使用适用于 Windows 应用商店应用程序的 <bpt id="p1">[</bpt><ept id="p1">PasswordVault]</ept> 来缓存当前用户首次登录时使用的标识，以后每次该用户登录时，系统都会检查缓存中是否存在该用户标识。如果缓存为空，则用户仍然需要完成整个登录过程。</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>对于 Windows Phone 应用程序，可以使用 <bpt id="p1">[</bpt><ept id="p1">ProtectedData]</ept> 类加密和缓存数据，并在隔离的存储中存储敏感信息。</source>
          <target state="new">对于 Windows Phone 应用程序，可以使用 <bpt id="p1">[</bpt><ept id="p1">ProtectedData]</ept> 类加密和缓存数据，并在隔离的存储中存储敏感信息。</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="errors"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：处理错误</source>
          <target state="new"><ph id="ph1">&lt;a name="errors"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：处理错误</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>在移动服务中，你可能会遇到各种形式的错误，并且可以通过多种方式来验证和解决这些错误。</source>
          <target state="new">在移动服务中，你可能会遇到各种形式的错误，并且可以通过多种方式来验证和解决这些错误。</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>例如，你可以在移动服务中注册服务器脚本，然后使用这些脚本对所要插入和更新的数据执行各种操作，包括验证和数据修改。你可以按如下所示定义并注册一个用于验证和修改数据的服务器脚本：</source>
          <target state="new">例如，你可以在移动服务中注册服务器脚本，然后使用这些脚本对所要插入和更新的数据执行各种操作，包括验证和数据修改。你可以按如下所示定义并注册一个用于验证和修改数据的服务器脚本：</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>此服务器端脚本将验证发送到移动服务的字符串数据长度，并拒绝过长（在本例中为 10 个字符以上）的字符串。</source>
          <target state="new">此服务器端脚本将验证发送到移动服务的字符串数据长度，并拒绝过长（在本例中为 10 个字符以上）的字符串。</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>由于移动服务能够在服务器端验证数据和发送错误响应，因此你可以更新你的 .NET 应用程序，使其能够处理验证后生成的错误响应。</source>
          <target state="new">由于移动服务能够在服务器端验证数据和发送错误响应，因此你可以更新你的 .NET 应用程序，使其能够处理验证后生成的错误响应。</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="untyped"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何处理非类型化数据</source>
          <target state="new"><ph id="ph1">&lt;a name="untyped"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何处理非类型化数据</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>.NET 客户端在设计上支持强类型化方案。但有时，松散类型化的体验可为用户带来方便；例如，在处理采用开放架构的对象时，可能就需要这种体验。可按如下所示启用这种方案。在查询中，先指定 LINQ 语句并使用有线格式。</source>
          <target state="new">.NET 客户端在设计上支持强类型化方案。但有时，松散类型化的体验可为用户带来方便；例如，在处理采用开放架构的对象时，可能就需要这种体验。可按如下所示启用这种方案。在查询中，先指定 LINQ 语句并使用有线格式。</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>此时，你将获取一些可以像属性包一样使用的 JSON 值。有关 JToken 和 Json.NET 的详细信息，请参阅 <bpt id="p1">[</bpt>Json.NET<ept id="p1">](http://json.codeplex.com/)</ept></source>
          <target state="new">此时，你将获取一些可以像属性包一样使用的 JSON 值。有关 JToken 和 Json.NET 的详细信息，请参阅 <bpt id="p1">[</bpt>Json.NET<ept id="p1">](http://json.codeplex.com/)</ept></target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="unit-testing"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：设计单元测试</source>
          <target state="new"><ph id="ph1">&lt;a name="unit-testing"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：设计单元测试</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MobileServiceClient.GetTable`</ph> 返回的值和查询是接口。这使它们可轻松“模拟”用于测试目的，以便创建一个实现测试逻辑的 <ph id="ph2">`MyMockTable : IMobileServiceTable&lt;TodoItem&gt;`</ph>。</source>
          <target state="new"><ph id="ph1">`MobileServiceClient.GetTable`</ph> 返回的值和查询是接口。这使它们可轻松“模拟”用于测试目的，以便创建一个实现测试逻辑的 <ph id="ph2">`MyMockTable : IMobileServiceTable&lt;TodoItem&gt;`</ph>。</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="customizing"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自定义客户端</source>
          <target state="new"><ph id="ph1">&lt;a name="customizing"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自定义客户端</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>本部分说明你可以使用哪些方法来自定义请求标头，以及自定义响应中的 JSON 对象序列化。</source>
          <target state="new">本部分说明你可以使用哪些方法来自定义请求标头，以及自定义响应中的 JSON 对象序列化。</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="headers"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自定义请求标头</source>
          <target state="new"><ph id="ph1">&lt;a name="headers"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自定义请求标头</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>若要支持特定的应用程序方案，你可能需要自定义与移动服务之间的通信。例如，你可能需要将一个自定义标头添加到每个传出请求，甚至要更改响应状态代码。可以通过提供自定义 DelegatingHandler 来实现此目的，如以下示例中所示：</source>
          <target state="new">若要支持特定的应用程序方案，你可能需要自定义与移动服务之间的通信。例如，你可能需要将一个自定义标头添加到每个传出请求，甚至要更改响应状态代码。可以通过提供自定义 DelegatingHandler 来实现此目的，如以下示例中所示：</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>此代码在请求中添加新的 <bpt id="p1">**</bpt>x-my-header<ept id="p1">**</ept> 标头，并强行将响应代码设为不可用。在实际方案中，你会根据应用程序所需的某种自定义逻辑来设置响应状态码。</source>
          <target state="new">此代码在请求中添加新的 <bpt id="p1">**</bpt>x-my-header<ept id="p1">**</ept> 标头，并强行将响应代码设为不可用。在实际方案中，你会根据应用程序所需的某种自定义逻辑来设置响应状态码。</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="serialization"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自定义序列化</source>
          <target state="new"><ph id="ph1">&lt;a name="serialization"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自定义序列化</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>移动服务客户端库使用 Json.NET 在客户端上将 JSON 响应转换为 .NET 对象。你可以在消息中设置此序列化在 .NET 类型与 JSON 之间的行为。<bpt id="p1">[</bpt>MobileServiceClient<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/microsoft.windowsazure.mobileservices.mobileserviceclient.aspx)</ept> 类公开 <bpt id="p2">[</bpt>JsonSerializerSettings<ept id="p2">](http://james.newtonking.com/projects/json/help/?topic=html/T_Newtonsoft_Json_JsonSerializerSettings.htm)</ept> 类型的 <ph id="ph1">`SerializerSettings`</ph> 属性</source>
          <target state="new">移动服务客户端库使用 Json.NET 在客户端上将 JSON 响应转换为 .NET 对象。你可以在消息中设置此序列化在 .NET 类型与 JSON 之间的行为。<bpt id="p1">[</bpt>MobileServiceClient<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/microsoft.windowsazure.mobileservices.mobileserviceclient.aspx)</ept> 类公开 <bpt id="p2">[</bpt>JsonSerializerSettings<ept id="p2">](http://james.newtonking.com/projects/json/help/?topic=html/T_Newtonsoft_Json_JsonSerializerSettings.htm)</ept> 类型的 <ph id="ph1">`SerializerSettings`</ph> 属性</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>使用此属性可以设置许多 Json.NET 属性中的一个，如下所示：</source>
          <target state="new">使用此属性可以设置许多 Json.NET 属性中的一个，如下所示：</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>此属性在序列化期间将所有属性转换为小写。</source>
          <target state="new">此属性在序列化期间将所有属性转换为小写。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>