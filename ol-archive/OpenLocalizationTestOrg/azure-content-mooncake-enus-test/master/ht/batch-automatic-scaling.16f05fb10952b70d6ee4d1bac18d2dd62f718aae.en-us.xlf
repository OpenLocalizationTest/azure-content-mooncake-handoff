<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">da89a27d92f981a906923b1df099e44465201d51</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>自动缩放 Azure  批处理( Batch )池中的计算节点</source>
          <target state="new">自动缩放 Azure  批处理( Batch )池中的计算节点</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>可以通过对池启用自动缩放，并将一个公式（用于计算处理应用程序所需的计算节点数）关联到该池，来实现自动缩放。</source>
          <target state="new">可以通过对池启用自动缩放，并将一个公式（用于计算处理应用程序所需的计算节点数）关联到该池，来实现自动缩放。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>自动缩放 Azure 批处理 ( Batch )池中的计算节点</source>
          <target state="new">自动缩放 Azure 批处理 ( Batch )池中的计算节点</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Azure Batch 中的自动缩放是指在作业执行期间动态添加或删除计算节点，从而自动调整应用程序使用的处理能力。这种自动调整可以节省时间和资金。</source>
          <target state="new">Azure Batch 中的自动缩放是指在作业执行期间动态添加或删除计算节点，从而自动调整应用程序使用的处理能力。这种自动调整可以节省时间和资金。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>可以通过将 <bpt id="p1">*</bpt>自动缩放公式<ept id="p1">*</ept> 与池相关联（例如，使用 <bpt id="p2">[</bpt>Batch .NET<ept id="p2">](/documentation/articles/batch-dotnet-get-started)</ept> 库中的 <bpt id="p3">[</bpt>PoolOperations.EnableAutoScale<ept id="p3">][net_enableautoscale]</ept> 方法），对计算节点池启用自动缩放。然后，Batch 服务将使用此公式来确定执行工作负荷所需的计算节点数目。对定期收集的服务度量值样本进行操作时，池中的计算节点数会根据关联的公式按可配置的间隔进行调整。</source>
          <target state="new">可以通过将 <bpt id="p1">*</bpt>自动缩放公式<ept id="p1">*</ept> 与池相关联（例如，使用 <bpt id="p2">[</bpt>Batch .NET<ept id="p2">](/documentation/articles/batch-dotnet-get-started)</ept> 库中的 <bpt id="p3">[</bpt>PoolOperations.EnableAutoScale<ept id="p3">][net_enableautoscale]</ept> 方法），对计算节点池启用自动缩放。然后，Batch 服务将使用此公式来确定执行工作负荷所需的计算节点数目。对定期收集的服务度量值样本进行操作时，池中的计算节点数会根据关联的公式按可配置的间隔进行调整。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>可以在创建池时或在现有的池上启用自动缩放，也可以更改已启用自动缩放的池上的现有公式。Batch 可让你在将公式分配给池之前先评估公式，以及监视自动缩放运行的状态。</source>
          <target state="new">可以在创建池时或在现有的池上启用自动缩放，也可以更改已启用自动缩放的池上的现有公式。Batch 可让你在将公式分配给池之前先评估公式，以及监视自动缩放运行的状态。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>自动缩放公式</source>
          <target state="new">自动缩放公式</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>自动缩放公式是一个字符串值，该值包含分配给池的 <bpt id="p1">[</bpt>autoScaleFormula<ept id="p1">][rest_autoscaleformula]</ept> 元素 (Batch REST API) 或 <bpt id="p2">[</bpt>CloudPool.AutoScaleFormula<ept id="p2">][net_cloudpool_autoscaleformula]</ept> 属性 (Batch .NET API) 的一个或多个语句。这些公式由你来定义。将公式分配到池后，它们将确定池中可供下一个处理间隔使用的计算节点数目（稍后将详细说明间隔）。公式是一个字符串，其大小不能超过 8KB，最多可以包含 100 个以分号分隔的语句，可以包括换行符和注释。</source>
          <target state="new">自动缩放公式是一个字符串值，该值包含分配给池的 <bpt id="p1">[</bpt>autoScaleFormula<ept id="p1">][rest_autoscaleformula]</ept> 元素 (Batch REST API) 或 <bpt id="p2">[</bpt>CloudPool.AutoScaleFormula<ept id="p2">][net_cloudpool_autoscaleformula]</ept> 属性 (Batch .NET API) 的一个或多个语句。这些公式由你来定义。将公式分配到池后，它们将确定池中可供下一个处理间隔使用的计算节点数目（稍后将详细说明间隔）。公式是一个字符串，其大小不能超过 8KB，最多可以包含 100 个以分号分隔的语句，可以包括换行符和注释。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>可以将自动缩放公式视为使用 Batch 自动缩放“语言”。 公式语句是任意格式的表达式，可以包含系统与用户定义的变量和常量。它们可以使用内置类型、运算符和函数对这些值执行各种操作。例如，语句可以采用以下格式：</source>
          <target state="new">可以将自动缩放公式视为使用 Batch 自动缩放“语言”。 公式语句是任意格式的表达式，可以包含系统与用户定义的变量和常量。它们可以使用内置类型、运算符和函数对这些值执行各种操作。例如，语句可以采用以下格式：</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>公式通常包含多个语句，这些语句对先前语句中获取的值执行操作：</source>
          <target state="new">公式通常包含多个语句，这些语句对先前语句中获取的值执行操作：</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>在公式中使用语句的目标是实现池要缩放到的计算节点数目，也就是<bpt id="p1">**</bpt>专用节点<ept id="p1">**</ept>的<bpt id="p2">**</bpt>目标<ept id="p2">**</ept>数目。此“专用目标”数目可以大于、小于或等于池中当前的节点数目。Batch 按特定的间隔评估池的自动缩放公式（下面将讨论<bpt id="p3">[</bpt>自动缩放间隔<ept id="p3">](#interval)</ept>），并在评估时将池中的目标节点数目调整为自动缩放公式指定的数目。</source>
          <target state="new">在公式中使用语句的目标是实现池要缩放到的计算节点数目，也就是<bpt id="p1">**</bpt>专用节点<ept id="p1">**</ept>的<bpt id="p2">**</bpt>目标<ept id="p2">**</ept>数目。此“专用目标”数目可以大于、小于或等于池中当前的节点数目。Batch 按特定的间隔评估池的自动缩放公式（下面将讨论<bpt id="p3">[</bpt>自动缩放间隔<ept id="p3">](#interval)</ept>），并在评估时将池中的目标节点数目调整为自动缩放公式指定的数目。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>举个简单的例子，以下两行自动缩放公式根据活动任务数目指定应该调整的节点数目（最多 10 个计算节点）：</source>
          <target state="new">举个简单的例子，以下两行自动缩放公式根据活动任务数目指定应该调整的节点数目（最多 10 个计算节点）：</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>本文的后续部分将介绍构成自动缩放公式的各个实体，包括变量、运算符、操作和函数。你将了解如何获取 Batch 中的各种计算资源和任务度量值，以便根据资源使用量和任务状态明智地调整池的节点计数。然后，你将了解如何使用 Batch REST 和 .NET API 构建公式以及对池启用自动缩放，最后我们将讨论几个示例公式。</source>
          <target state="new">本文的后续部分将介绍构成自动缩放公式的各个实体，包括变量、运算符、操作和函数。你将了解如何获取 Batch 中的各种计算资源和任务度量值，以便根据资源使用量和任务状态明智地调整池的节点计数。然后，你将了解如何使用 Batch REST 和 .NET API 构建公式以及对池启用自动缩放，最后我们将讨论几个示例公式。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 每个 Azure 批处理帐户限制为可用于处理的计算节点的最大数目。Batch 服务最多会创建限制数目的节点，因此不可能会达到公式指定的目标数。请参阅 <bpt id="p1">[</bpt>Azure Batch 服务的配额和限制<ept id="p1">](batch-quota-limit.md)</ept>了解有关查看和提高帐户配额的信息。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 每个 Azure 批处理帐户限制为可用于处理的计算节点的最大数目。Batch 服务最多会创建限制数目的节点，因此不可能会达到公式指定的目标数。请参阅 <bpt id="p1">[</bpt>Azure Batch 服务的配额和限制<ept id="p1">](batch-quota-limit.md)</ept>了解有关查看和提高帐户配额的信息。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="variables"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>变量</source>
          <target state="new"><ph id="ph1">&lt;a name="variables"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>变量</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>可以在自动缩放公式中使用系统定义的变量和用户定义的变量。在上述两行示例公式中，<ph id="ph1">`$TargetDedicated`</ph> 是系统定义的变量，而 <ph id="ph2">`$averageActiveTaskCount`</ph> 是用户定义的变量。下表显示了 Batch 服务定义的读写和只读变量。</source>
          <target state="new">可以在自动缩放公式中使用系统定义的变量和用户定义的变量。在上述两行示例公式中，<ph id="ph1">`$TargetDedicated`</ph> 是系统定义的变量，而 <ph id="ph2">`$averageActiveTaskCount`</ph> 是用户定义的变量。下表显示了 Batch 服务定义的读写和只读变量。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>可以 <bpt id="p1">*</bpt>获取<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>设置<ept id="p2">*</ept> 这些<bpt id="p3">**</bpt>系统定义变量<ept id="p3">**</ept>的值，以管理池中计算节点的数目：</source>
          <target state="new">可以 <bpt id="p1">*</bpt>获取<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>设置<ept id="p2">*</ept> 这些<bpt id="p3">**</bpt>系统定义变量<ept id="p3">**</ept>的值，以管理池中计算节点的数目：</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>变量（读写）</source>
          <target state="new">变量（读写）</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>说明</source>
          <target state="new">说明</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>$TargetDedicated</source>
          <target state="new">$TargetDedicated</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>池的<ph id="ph1">&lt;b&gt;</ph>专用计算节点<ph id="ph2">&lt;/b&gt;</ph>的<ph id="ph3">&lt;b&gt;</ph>目标<ph id="ph4">&lt;/b&gt;</ph>数。这是池应该缩放到的计算节点数目。它是一个“目标”数目，因为池可能达不到此目标节点数目。如果在池达到初始目标之前后续自动缩放评估再次修改目标节点数目，或者在达到目标节点数目前便达到了 Batch 帐户节点或核心配额，则可能发生这种情况。</source>
          <target state="new">池的<ph id="ph1">&lt;b&gt;</ph>专用计算节点<ph id="ph2">&lt;/b&gt;</ph>的<ph id="ph3">&lt;b&gt;</ph>目标<ph id="ph4">&lt;/b&gt;</ph>数。这是池应该缩放到的计算节点数目。它是一个“目标”数目，因为池可能达不到此目标节点数目。如果在池达到初始目标之前后续自动缩放评估再次修改目标节点数目，或者在达到目标节点数目前便达到了 Batch 帐户节点或核心配额，则可能发生这种情况。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>$NodeDeallocationOption</source>
          <target state="new">$NodeDeallocationOption</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>从池中删除计算节点时发生的操作。可能的值包括：</source>
          <target state="new">从池中删除计算节点时发生的操作。可能的值包括：</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>requeue<ph id="ph1">&lt;/b&gt;</ph> – 立即终止任务并将其放回作业队列，以便重新计划这些任务。</source>
          <target state="new">requeue<ph id="ph1">&lt;/b&gt;</ph> – 立即终止任务并将其放回作业队列，以便重新计划这些任务。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>terminate<ph id="ph1">&lt;/b&gt;</ph> – 立即终止任务并从作业队列中删除它们。</source>
          <target state="new">terminate<ph id="ph1">&lt;/b&gt;</ph> – 立即终止任务并从作业队列中删除它们。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>taskcompletion<ph id="ph1">&lt;/b&gt;</ph> – 等待当前运行的任务完成，然后从池中删除节点。</source>
          <target state="new">taskcompletion<ph id="ph1">&lt;/b&gt;</ph> – 等待当前运行的任务完成，然后从池中删除节点。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>retaineddata<ph id="ph1">&lt;/b&gt;</ph><ph id="ph2"> -</ph> 等待清理节点上的本地任务保留的所有数据，然后从池中删除节点。</source>
          <target state="new">retaineddata<ph id="ph1">&lt;/b&gt;</ph><ph id="ph2"> -</ph> 等待清理节点上的本地任务保留的所有数据，然后从池中删除节点。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>获取<ept id="p1">*</ept> 这些<bpt id="p2">**</bpt>系统定义变量<ept id="p2">**</ept>的值即可根据 Batch 服务中的度量值进行调整：</source>
          <target state="new"><bpt id="p1">*</bpt>获取<ept id="p1">*</ept> 这些<bpt id="p2">**</bpt>系统定义变量<ept id="p2">**</ept>的值即可根据 Batch 服务中的度量值进行调整：</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>变量（只读）</source>
          <target state="new">变量（只读）</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>说明</source>
          <target state="new">说明</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>$CPUPercent</source>
          <target state="new">$CPUPercent</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>CPU 使用率的平均百分比</source>
          <target state="new">CPU 使用率的平均百分比</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>$WallClockSeconds</source>
          <target state="new">$WallClockSeconds</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>使用的秒数</source>
          <target state="new">使用的秒数</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>$MemoryBytes</source>
          <target state="new">$MemoryBytes</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>使用的平均 MB 数</source>
          <target state="new">使用的平均 MB 数</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>$DiskBytes</source>
          <target state="new">$DiskBytes</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>本地磁盘上使用的平均 GB 数</source>
          <target state="new">本地磁盘上使用的平均 GB 数</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>$DiskReadBytes</source>
          <target state="new">$DiskReadBytes</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>读取的字节数</source>
          <target state="new">读取的字节数</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>$DiskWriteBytes</source>
          <target state="new">$DiskWriteBytes</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>写入的字节数</source>
          <target state="new">写入的字节数</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>$DiskReadOps</source>
          <target state="new">$DiskReadOps</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>执行的读取磁盘操作数</source>
          <target state="new">执行的读取磁盘操作数</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>$DiskWriteOps</source>
          <target state="new">$DiskWriteOps</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>执行的写入磁盘操作数</source>
          <target state="new">执行的写入磁盘操作数</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>$NetworkInBytes</source>
          <target state="new">$NetworkInBytes</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>入站字节数</source>
          <target state="new">入站字节数</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>$NetworkInBytes</source>
          <target state="new">$NetworkInBytes</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>出站字节数</source>
          <target state="new">出站字节数</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>$SampleNodeCount</source>
          <target state="new">$SampleNodeCount</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>计算节点数</source>
          <target state="new">计算节点数</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>$ActiveTasks</source>
          <target state="new">$ActiveTasks</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>处于活动状态的任务数</source>
          <target state="new">处于活动状态的任务数</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>$RunningTasks</source>
          <target state="new">$RunningTasks</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>处于运行状态的任务数</source>
          <target state="new">处于运行状态的任务数</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>$SucceededTasks</source>
          <target state="new">$SucceededTasks</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>成功完成的任务数</source>
          <target state="new">成功完成的任务数</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>$FailedTasks</source>
          <target state="new">$FailedTasks</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>失败的任务数</source>
          <target state="new">失败的任务数</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>$CurrentDedicated</source>
          <target state="new">$CurrentDedicated</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>当前的专用计算节点数</source>
          <target state="new">当前的专用计算节点数</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.TIP]</ph> 上面所示的只读系统定义变量是可提供各种方法来访问相互关联数据的 <bpt id="p1">*</bpt>对象<ept id="p1">*</ept> 。有关详细信息，请参阅下面的<bpt id="p2">[</bpt>获取样本数据<ept id="p2">](#getsampledata)</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.TIP]</ph> 上面所示的只读系统定义变量是可提供各种方法来访问相互关联数据的 <bpt id="p1">*</bpt>对象<ept id="p1">*</ept> 。有关详细信息，请参阅下面的<bpt id="p2">[</bpt>获取样本数据<ept id="p2">](#getsampledata)</ept>。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>类型</source>
          <target state="new">类型</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>公式支持以下<bpt id="p1">**</bpt>类型<ept id="p1">**</ept>：</source>
          <target state="new">公式支持以下<bpt id="p1">**</bpt>类型<ept id="p1">**</ept>：</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>double</source>
          <target state="new">double</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>doubleVec</source>
          <target state="new">doubleVec</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>doubleVecList</source>
          <target state="new">doubleVecList</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>字符串</source>
          <target state="new">字符串</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>timestamp -- timestamp 是包含以下成员的复合结构：</source>
          <target state="new">timestamp -- timestamp 是包含以下成员的复合结构：</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>year</source>
          <target state="new">year</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>month (1-12)</source>
          <target state="new">month (1-12)</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>day (1-31)</source>
          <target state="new">day (1-31)</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>weekday（采用数字格式，例如 1 表示星期一）</source>
          <target state="new">weekday（采用数字格式，例如 1 表示星期一）</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>hour（采用 24 时制数字格式，例如 13 表示下午 1 点）</source>
          <target state="new">hour（采用 24 时制数字格式，例如 13 表示下午 1 点）</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>minute (00-59)</source>
          <target state="new">minute (00-59)</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>second (00-59)</source>
          <target state="new">second (00-59)</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>timeinterval</source>
          <target state="new">timeinterval</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>TimeInterval\_Zero</source>
          <target state="new">TimeInterval\_Zero</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>TimeInterval\_100ns</source>
          <target state="new">TimeInterval\_100ns</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>TimeInterval\_Microsecond</source>
          <target state="new">TimeInterval\_Microsecond</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>TimeInterval\_Millisecond</source>
          <target state="new">TimeInterval\_Millisecond</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>TimeInterval\_Second</source>
          <target state="new">TimeInterval\_Second</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>TimeInterval\_Minute</source>
          <target state="new">TimeInterval\_Minute</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>TimeInterval\_Hour</source>
          <target state="new">TimeInterval\_Hour</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>TimeInterval\_Day</source>
          <target state="new">TimeInterval\_Day</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>TimeInterval\_Week</source>
          <target state="new">TimeInterval\_Week</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>TimeInterval\_Year</source>
          <target state="new">TimeInterval\_Year</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>操作</source>
          <target state="new">操作</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>上面所列的类型允许的<bpt id="p1">**</bpt>操作<ept id="p1">**</ept>：</source>
          <target state="new">上面所列的类型允许的<bpt id="p1">**</bpt>操作<ept id="p1">**</ept>：</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>操作</source>
          <target state="new">操作</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>允许的操作</source>
          <target state="new">允许的操作</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>double &amp;lt;运算符&gt; double =&gt; double</source>
          <target state="new">double &amp;lt;运算符&gt; double =&gt; double</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>+, -, *, /</source>
          <target state="new">+, -, *, /</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>double &amp;lt;运算符&gt; timeinterval =&gt; timeinterval</source>
          <target state="new">double &amp;lt;运算符&gt; timeinterval =&gt; timeinterval</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>doubleVec &amp;lt;运算符&gt; double =&gt; doubleVec</source>
          <target state="new">doubleVec &amp;lt;运算符&gt; double =&gt; doubleVec</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>+, -, *, /</source>
          <target state="new">+, -, *, /</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>doubleVec &amp;lt;运算符&gt; doubleVec =&gt; doubleVec</source>
          <target state="new">doubleVec &amp;lt;运算符&gt; doubleVec =&gt; doubleVec</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>+, -, *, /</source>
          <target state="new">+, -, *, /</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>timeinterval &amp;lt;运算符&gt; double =&gt; timeinterval</source>
          <target state="new">timeinterval &amp;lt;运算符&gt; double =&gt; timeinterval</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>*, /</source>
          <target state="new">*, /</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>timeinterval &amp;lt;运算符&gt; timeinterval =&gt; timeinterval</source>
          <target state="new">timeinterval &amp;lt;运算符&gt; timeinterval =&gt; timeinterval</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>+, -</source>
          <target state="new">+, -</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>timeinterval &amp;lt;运算符&gt; timestamp =&gt; timestamp</source>
          <target state="new">timeinterval &amp;lt;运算符&gt; timestamp =&gt; timestamp</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>timestamp &amp;lt;运算符&gt; timeinterval =&gt; timestamp</source>
          <target state="new">timestamp &amp;lt;运算符&gt; timeinterval =&gt; timestamp</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>timestamp &amp;lt;运算符&gt; timestamp =&gt; timeinterval</source>
          <target state="new">timestamp &amp;lt;运算符&gt; timestamp =&gt; timeinterval</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>&amp;lt;运算符&gt;double =&gt; double</source>
          <target state="new">&amp;lt;运算符&gt;double =&gt; double</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>-, !</source>
          <target state="new">-, !</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>&amp;lt;运算符&gt;timeinterval =&gt; timeinterval</source>
          <target state="new">&amp;lt;运算符&gt;timeinterval =&gt; timeinterval</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>double &amp;lt;运算符&gt; double =&gt; double</source>
          <target state="new">double &amp;lt;运算符&gt; double =&gt; double</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>&amp;lt;, &amp;lt;=, ==, &gt;=, &gt;, !=</source>
          <target state="new">&amp;lt;, &amp;lt;=, ==, &gt;=, &gt;, !=</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>string &amp;lt;运算符&gt; string =&gt; double</source>
          <target state="new">string &amp;lt;运算符&gt; string =&gt; double</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>&amp;lt;, &amp;lt;=, ==, &gt;=, &gt;, !=</source>
          <target state="new">&amp;lt;, &amp;lt;=, ==, &gt;=, &gt;, !=</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>timestamp &amp;lt;运算符&gt; timestamp =&gt; double</source>
          <target state="new">timestamp &amp;lt;运算符&gt; timestamp =&gt; double</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>&amp;lt;, &amp;lt;=, ==, &gt;=, &gt;, !=</source>
          <target state="new">&amp;lt;, &amp;lt;=, ==, &gt;=, &gt;, !=</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>timeinterval &amp;lt;运算符&gt; timeinterval =&gt; double</source>
          <target state="new">timeinterval &amp;lt;运算符&gt; timeinterval =&gt; double</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>&amp;lt;, &amp;lt;=, ==, &gt;=, &gt;, !=</source>
          <target state="new">&amp;lt;, &amp;lt;=, ==, &gt;=, &gt;, !=</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>double &amp;lt;运算符&gt; double =&gt; double</source>
          <target state="new">double &amp;lt;运算符&gt; double =&gt; double</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>&amp;amp;&amp;amp;, ||</source>
          <target state="new">&amp;amp;&amp;amp;, ||</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>测试仅限 double（非零值为 true，零值为 false）</source>
          <target state="new">测试仅限 double（非零值为 true，零值为 false）</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="new">:</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>函数</source>
          <target state="new">函数</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>可以使用以下预定义<bpt id="p1">**</bpt>函数<ept id="p1">**</ept>来定义自动缩放公式。</source>
          <target state="new">可以使用以下预定义<bpt id="p1">**</bpt>函数<ept id="p1">**</ept>来定义自动缩放公式。</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>函数</source>
          <target state="new">函数</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>说明</source>
          <target state="new">说明</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>avg<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>avg<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>DoubleVecList 中所有值的平均值。</source>
          <target state="new">DoubleVecList 中所有值的平均值。</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>len<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>len<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>从 doubleVecList 创建的向量的长度。</source>
          <target state="new">从 doubleVecList 创建的向量的长度。</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>lg<ph id="ph2">&lt;/b&gt;</ph>(double)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>lg<ph id="ph2">&lt;/b&gt;</ph>(double)</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>对数底数为 2。</source>
          <target state="new">对数底数为 2。</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>doubleVec <ph id="ph1">&lt;b&gt;</ph>lg<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</source>
          <target state="new">doubleVec <ph id="ph1">&lt;b&gt;</ph>lg<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>分量对数底数 2。必须为单个 double 参数显式传递 vec(double)，否则将采用 double lg(double) 版本。</source>
          <target state="new">分量对数底数 2。必须为单个 double 参数显式传递 vec(double)，否则将采用 double lg(double) 版本。</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>ln<ph id="ph2">&lt;/b&gt;</ph>(double)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>ln<ph id="ph2">&lt;/b&gt;</ph>(double)</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>自然对数。</source>
          <target state="new">自然对数。</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>doubleVec <ph id="ph1">&lt;b&gt;</ph>ln<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</source>
          <target state="new">doubleVec <ph id="ph1">&lt;b&gt;</ph>ln<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>分量对数底数 2。必须为单个 double 参数显式传递 vec(double)，否则将采用 double lg(double) 版本。</source>
          <target state="new">分量对数底数 2。必须为单个 double 参数显式传递 vec(double)，否则将采用 double lg(double) 版本。</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>log<ph id="ph2">&lt;/b&gt;</ph>(double)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>log<ph id="ph2">&lt;/b&gt;</ph>(double)</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>对数底数为 10。</source>
          <target state="new">对数底数为 10。</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>doubleVec <ph id="ph1">&lt;b&gt;</ph>log<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</source>
          <target state="new">doubleVec <ph id="ph1">&lt;b&gt;</ph>log<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>分量对数底数 10。必须为单个 double 参数显式传递 vec(double)，否则将采用 double log(double) 版本。</source>
          <target state="new">分量对数底数 10。必须为单个 double 参数显式传递 vec(double)，否则将采用 double log(double) 版本。</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>max<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>max<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>doubleVecList 中的最大值。</source>
          <target state="new">doubleVecList 中的最大值。</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>min<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>min<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>doubleVecList 中的最小值。</source>
          <target state="new">doubleVecList 中的最小值。</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>norm<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>norm<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>从 doubleVecList 创建的向量的二范数。</source>
          <target state="new">从 doubleVecList 创建的向量的二范数。</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>percentile<ph id="ph2">&lt;/b&gt;</ph>(doubleVec v, double p)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>percentile<ph id="ph2">&lt;/b&gt;</ph>(doubleVec v, double p)</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>向量 v 百分位元素。</source>
          <target state="new">向量 v 百分位元素。</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>rand<ph id="ph2">&lt;/b&gt;</ph>()</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>rand<ph id="ph2">&lt;/b&gt;</ph>()</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>介于 0.0 和 1.0 之间的随机值。</source>
          <target state="new">介于 0.0 和 1.0 之间的随机值。</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>range<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>range<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>doubleVecList 中最小值和最大值之间的差。</source>
          <target state="new">doubleVecList 中最小值和最大值之间的差。</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>std<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>std<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>doubleVecList 中值的样本标准偏差。</source>
          <target state="new">doubleVecList 中值的样本标准偏差。</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>stop<ph id="ph1">&lt;/b&gt;</ph>()</source>
          <target state="new">stop<ph id="ph1">&lt;/b&gt;</ph>()</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>停止自动缩放表达式计算。</source>
          <target state="new">停止自动缩放表达式计算。</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>sum<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>sum<ph id="ph2">&lt;/b&gt;</ph>(doubleVecList)</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>doubleVecList 的所有组成部分之和。</source>
          <target state="new">doubleVecList 的所有组成部分之和。</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>timestamp <ph id="ph1">&lt;b&gt;</ph>time<ph id="ph2">&lt;/b&gt;</ph>(string dateTime="")</source>
          <target state="new">timestamp <ph id="ph1">&lt;b&gt;</ph>time<ph id="ph2">&lt;/b&gt;</ph>(string dateTime="")</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>如果未传递参数，则为当前时间的时间戳；如果传递了参数，则为 dateTime 字符串的时间戳。支持的 dateTime 格式为 W3CDTF 和 RFC1123。</source>
          <target state="new">如果未传递参数，则为当前时间的时间戳；如果传递了参数，则为 dateTime 字符串的时间戳。支持的 dateTime 格式为 W3CDTF 和 RFC1123。</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>double <ph id="ph1">&lt;b&gt;</ph>val<ph id="ph2">&lt;/b&gt;</ph>(doubleVec v, double i)</source>
          <target state="new">double <ph id="ph1">&lt;b&gt;</ph>val<ph id="ph2">&lt;/b&gt;</ph>(doubleVec v, double i)</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>在起始索引为零的向量 v 中，位置 i 处的元素的值。</source>
          <target state="new">在起始索引为零的向量 v 中，位置 i 处的元素的值。</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>上表中描述的某些函数可以接受列表作为参数。逗号分隔列表为 <bpt id="p1">*</bpt>double<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>doubleVec<ept id="p2">*</ept> 的任意组合。例如：</source>
          <target state="new">上表中描述的某些函数可以接受列表作为参数。逗号分隔列表为 <bpt id="p1">*</bpt>double<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>doubleVec<ept id="p2">*</ept> 的任意组合。例如：</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>doubleVecList<ept id="p1">*</ept> 值在计算之前将转换为单个 <bpt id="p2">*</bpt>doubleVec<ept id="p2">*</ept>。例如，如果 <ph id="ph1">`v = [1,2,3]`</ph>，则调用 <ph id="ph2">`avg(v)`</ph> 等效于调用 <ph id="ph3">`avg(1,2,3)`</ph>，调用 <ph id="ph4">`avg(v, 7)`</ph> 等效于调用 <ph id="ph5">`avg(1,2,3,7)`</ph>。</source>
          <target state="new"><bpt id="p1">*</bpt>doubleVecList<ept id="p1">*</ept> 值在计算之前将转换为单个 <bpt id="p2">*</bpt>doubleVec<ept id="p2">*</ept>。例如，如果 <ph id="ph1">`v = [1,2,3]`</ph>，则调用 <ph id="ph2">`avg(v)`</ph> 等效于调用 <ph id="ph3">`avg(1,2,3)`</ph>，调用 <ph id="ph4">`avg(v, 7)`</ph> 等效于调用 <ph id="ph5">`avg(1,2,3,7)`</ph>。</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="getsampledata"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>获取样本数据</source>
          <target state="new"><ph id="ph1">&lt;a name="getsampledata"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>获取样本数据</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>自动缩放公式对 Batch 服务提供的度量值数据（样本）产生作用，并根据从服务获取的值扩大或缩减池大小。上述系统定义的变量是可提供各种方法来访问与该对象关联的数据的对象。例如，以下表达式显示了一个用于获取过去五分钟 CPU 使用率的请求：</source>
          <target state="new">自动缩放公式对 Batch 服务提供的度量值数据（样本）产生作用，并根据从服务获取的值扩大或缩减池大小。上述系统定义的变量是可提供各种方法来访问与该对象关联的数据的对象。例如，以下表达式显示了一个用于获取过去五分钟 CPU 使用率的请求：</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>这些方法可用于获取样本数据。</source>
          <target state="new">这些方法可用于获取样本数据。</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>方法</source>
          <target state="new">方法</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>说明</source>
          <target state="new">说明</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Count()</source>
          <target state="new">Count()</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>返回度量值历史记录中的样本总数。</source>
          <target state="new">返回度量值历史记录中的样本总数。</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>GetSample()</source>
          <target state="new">GetSample()</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>GetSample()<ph id="ph1">&lt;/b&gt;</ph> 方法返回数据样本的向量。</source>
          <target state="new">GetSample()<ph id="ph1">&lt;/b&gt;</ph> 方法返回数据样本的向量。</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>一个样本最好包含 30 秒钟的度量值数据。换而言之，将每隔 30 秒获取样本一次，但如下所述，每收集一个样本后并且该样本可供公式使用时，会存在一定的延迟。因此，并非一段指定时间内的所有样本都可用于公式求值。</source>
          <target state="new">一个样本最好包含 30 秒钟的度量值数据。换而言之，将每隔 30 秒获取样本一次，但如下所述，每收集一个样本后并且该样本可供公式使用时，会存在一定的延迟。因此，并非一段指定时间内的所有样本都可用于公式求值。</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>doubleVec GetSample(double count)<ph id="ph1">&lt;/b&gt;</ph><ph id="ph2"> -</ph> 在最近的收集的样本中指定要获取的样本数。</source>
          <target state="new">doubleVec GetSample(double count)<ph id="ph1">&lt;/b&gt;</ph><ph id="ph2"> -</ph> 在最近的收集的样本中指定要获取的样本数。</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>GetSample(1) 返回最后一个可用样本。但对于像 $CPUPercent 这样的度量值，你不应使用此方法，因为无法知道样本是<ph id="ph1">&lt;em&gt;</ph>何时<ph id="ph2">&lt;/em&gt;</ph>收集的 - 它可能是最近收集的，也可能由于系统问题而变得很旧。最好使用如下所示的时间间隔。</source>
          <target state="new">GetSample(1) 返回最后一个可用样本。但对于像 $CPUPercent 这样的度量值，你不应使用此方法，因为无法知道样本是<ph id="ph1">&lt;em&gt;</ph>何时<ph id="ph2">&lt;/em&gt;</ph>收集的 - 它可能是最近收集的，也可能由于系统问题而变得很旧。最好使用如下所示的时间间隔。</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>doubleVec GetSample((timestamp | timeinterval) startTime [, double samplePercent])<ph id="ph1">&lt;/b&gt;</ph> – 指定收集样本数据的时间范围，并选择性地指定必须在请求时间范围内可用的样本百分比。</source>
          <target state="new">doubleVec GetSample((timestamp | timeinterval) startTime [, double samplePercent])<ph id="ph1">&lt;/b&gt;</ph> – 指定收集样本数据的时间范围，并选择性地指定必须在请求时间范围内可用的样本百分比。</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>如果 CPUPercent 历史记录中存在过去十分钟的所在样本，<ph id="ph1">&lt;em&gt;</ph>$CPUPercent.GetSample(TimeInterval_Minute * 10)<ph id="ph2">&lt;/em&gt;</ph> 将返回 20 个样本。如果最后一分钟的历史记录不可用，则只返回 18 个样本，在这种情况下：</source>
          <target state="new">如果 CPUPercent 历史记录中存在过去十分钟的所在样本，<ph id="ph1">&lt;em&gt;</ph>$CPUPercent.GetSample(TimeInterval_Minute * 10)<ph id="ph2">&lt;/em&gt;</ph> 将返回 20 个样本。如果最后一分钟的历史记录不可用，则只返回 18 个样本，在这种情况下：</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
          &amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;em&gt;</ph>$CPUPercent.GetSample(TimeInterval_Minute * 10, 95)<ph id="ph2">&lt;/em&gt;</ph> 将会失败，因为只有 90% 的样本可用；</source>
          <target state="new"><ph id="ph1">
          &amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;em&gt;</ph>$CPUPercent.GetSample(TimeInterval_Minute * 10, 95)<ph id="ph2">&lt;/em&gt;</ph> 将会失败，因为只有 90% 的样本可用；</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
          &amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;em&gt;</ph>$CPUPercent.GetSample(TimeInterval_Minute * 10, 80)<ph id="ph2">&lt;/em&gt;</ph> 将会成功。</source>
          <target state="new"><ph id="ph1">
          &amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;em&gt;</ph>$CPUPercent.GetSample(TimeInterval_Minute * 10, 80)<ph id="ph2">&lt;/em&gt;</ph> 将会成功。</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>doubleVec GetSample((timestamp | timeinterval) startTime, (timestamp | timeinterval) endTime [, double samplePercent])<ph id="ph1">&lt;/b&gt;</ph> – 指定收集数据的时间范围，包括开始时间和结束时间。</source>
          <target state="new">doubleVec GetSample((timestamp | timeinterval) startTime, (timestamp | timeinterval) endTime [, double samplePercent])<ph id="ph1">&lt;/b&gt;</ph> – 指定收集数据的时间范围，包括开始时间和结束时间。</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>如前所述，每收集一个样本后并且该样本可供公式使用时，会存在一定的延迟。在使用 <ph id="ph1">&lt;em&gt;</ph>GetSample<ph id="ph2">&lt;/em&gt;</ph> 方法时，必须考虑这个因素 - 请参阅下面的 <ph id="ph3">&lt;em&gt;</ph>GetSamplePercent<ph id="ph4">&lt;/em&gt;</ph>。</source>
          <target state="new">如前所述，每收集一个样本后并且该样本可供公式使用时，会存在一定的延迟。在使用 <ph id="ph1">&lt;em&gt;</ph>GetSample<ph id="ph2">&lt;/em&gt;</ph> 方法时，必须考虑这个因素 - 请参阅下面的 <ph id="ph3">&lt;em&gt;</ph>GetSamplePercent<ph id="ph4">&lt;/em&gt;</ph>。</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>GetSamplePeriod()</source>
          <target state="new">GetSamplePeriod()</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>返回在历史样本数据集中采样的期间。</source>
          <target state="new">返回在历史样本数据集中采样的期间。</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Count()</source>
          <target state="new">Count()</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>返回度量值历史记录中的样本总数。</source>
          <target state="new">返回度量值历史记录中的样本总数。</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>HistoryBeginTime()</source>
          <target state="new">HistoryBeginTime()</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>返回度量值最旧可用数据样本的时间戳。</source>
          <target state="new">返回度量值最旧可用数据样本的时间戳。</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>GetSamplePercent()</source>
          <target state="new">GetSamplePercent()</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>返回给定时间间隔的可用样本百分比。例如：</source>
          <target state="new">返回给定时间间隔的可用样本百分比。例如：</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>doubleVec GetSamplePercent( (timestamp | timeinterval) startTime [, (timestamp | timeinterval) endTime] )<ph id="ph1">&lt;/b&gt;</ph><ph id="ph2">
    </ph></source>
          <target state="new">doubleVec GetSamplePercent( (timestamp | timeinterval) startTime [, (timestamp | timeinterval) endTime] )<ph id="ph1">&lt;/b&gt;</ph><ph id="ph2">
    </ph></target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>由于当返回的样本百分比小于指定的 samplePercent 时 GetSample 方法会失败，因此，你可以使用 GetSamplePercent 方法执行初始检查，然后在没有足够样本的情况下，不暂停样本自动缩放评估并执行备选操作。</source>
          <target state="new">由于当返回的样本百分比小于指定的 samplePercent 时 GetSample 方法会失败，因此，你可以使用 GetSamplePercent 方法执行初始检查，然后在没有足够样本的情况下，不暂停样本自动缩放评估并执行备选操作。</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>样本、样本百分比和 <bpt id="p1">*</bpt>GetSample()<ept id="p1">*</ept> 方法</source>
          <target state="new">样本、样本百分比和 <bpt id="p1">*</bpt>GetSample()<ept id="p1">*</ept> 方法</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>自动缩放公式的核心操作是获取任务和资源度量值数据，并根据该数据调整池大小。因此，请务必明确知道自动缩放公式如何与度量值数据或“样本”交互。</source>
          <target state="new">自动缩放公式的核心操作是获取任务和资源度量值数据，并根据该数据调整池大小。因此，请务必明确知道自动缩放公式如何与度量值数据或“样本”交互。</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>示例</source>
          <target state="new">示例</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Batch 服务定期获取任务和资源度量值的 <bpt id="p1">*</bpt>样本<ept id="p1">*</ept> ，使其可供自动缩放公式使用。Batch 服务每隔 30 秒记录这些样本一次，但是，通常有一些滞后，以致记录样本的时间与样本可供自动缩放公式使用（与读取）的时间之间有所延迟。此外，由于各种因素（例如网络或其他基础结构问题），可能无法记录特定间隔的样本，从而导致样本“遗漏”。</source>
          <target state="new">Batch 服务定期获取任务和资源度量值的 <bpt id="p1">*</bpt>样本<ept id="p1">*</ept> ，使其可供自动缩放公式使用。Batch 服务每隔 30 秒记录这些样本一次，但是，通常有一些滞后，以致记录样本的时间与样本可供自动缩放公式使用（与读取）的时间之间有所延迟。此外，由于各种因素（例如网络或其他基础结构问题），可能无法记录特定间隔的样本，从而导致样本“遗漏”。</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>样本百分比</source>
          <target state="new">样本百分比</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>将 <ph id="ph1">`samplePercent`</ph> 传递到 <ph id="ph2">`GetSample()`</ph> 方法，或调用 <ph id="ph3">`GetSamplePercent()`</ph> 方法时，“percent”是指 Batch 服务 <bpt id="p1">*</bpt>可能<ept id="p1">*</ept> 记录的样本总数与自动缩放公式实际 <bpt id="p2">*</bpt>可用<ept id="p2">*</ept> 的样本数目之间的比较。</source>
          <target state="new">将 <ph id="ph1">`samplePercent`</ph> 传递到 <ph id="ph2">`GetSample()`</ph> 方法，或调用 <ph id="ph3">`GetSamplePercent()`</ph> 方法时，“percent”是指 Batch 服务 <bpt id="p1">*</bpt>可能<ept id="p1">*</ept> 记录的样本总数与自动缩放公式实际 <bpt id="p2">*</bpt>可用<ept id="p2">*</ept> 的样本数目之间的比较。</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>让我们以 10 分钟的时间跨度为例。由于每隔 30 秒记录样本一次，因此在 10 分钟的时间跨度内，Batch 服务所记录的样本总数将达到 20 个（每分钟 2 个）。但是，由于报告机制固有的延迟，或者 Azure 基础结构出现的其他一些问题，可能只有 15 个样本可供自动缩放公式读取。这意味着，在这 10 分钟的期间内，记录的样本总数只有 <bpt id="p1">**</bpt>75%<ept id="p1">**</ept> 实际可供公式使用。</source>
          <target state="new">让我们以 10 分钟的时间跨度为例。由于每隔 30 秒记录样本一次，因此在 10 分钟的时间跨度内，Batch 服务所记录的样本总数将达到 20 个（每分钟 2 个）。但是，由于报告机制固有的延迟，或者 Azure 基础结构出现的其他一些问题，可能只有 15 个样本可供自动缩放公式读取。这意味着，在这 10 分钟的期间内，记录的样本总数只有 <bpt id="p1">**</bpt>75%<ept id="p1">**</ept> 实际可供公式使用。</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>GetSample() 和样本范围</source>
          <target state="new">GetSample() 和样本范围</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>自动缩放公式即将扩大和缩减池 - 添加节点或删除节点。由于节点为付费使用，想要确保公式使用根据充足数据的明智的分析方法。因此，建议在公式中使用趋势类型分析，此类型根据所收集样本的 <bpt id="p1">*</bpt>范围<ept id="p1">*</ept> 来扩大和缩减池。</source>
          <target state="new">自动缩放公式即将扩大和缩减池 - 添加节点或删除节点。由于节点为付费使用，想要确保公式使用根据充足数据的明智的分析方法。因此，建议在公式中使用趋势类型分析，此类型根据所收集样本的 <bpt id="p1">*</bpt>范围<ept id="p1">*</ept> 来扩大和缩减池。</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>为此，请使用 <ph id="ph1">`GetSample(interval look-back start, interval look-back end)`</ph> 返回样本的<bpt id="p1">**</bpt>向量<ept id="p1">**</ept>：</source>
          <target state="new">为此，请使用 <ph id="ph1">`GetSample(interval look-back start, interval look-back end)`</ph> 返回样本的<bpt id="p1">**</bpt>向量<ept id="p1">**</ept>：</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Batch 评估上述代码行后，它以值的向量形式返回样本范围，例如：</source>
          <target state="new">Batch 评估上述代码行后，它以值的向量形式返回样本范围，例如：</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>收集样本向量后，便可使用 <ph id="ph1">`min()`</ph>、<ph id="ph2">`max()`</ph> 和 <ph id="ph3">`avg()`</ph> 等函数从所收集的范围派生有意义的值。</source>
          <target state="new">收集样本向量后，便可使用 <ph id="ph1">`min()`</ph>、<ph id="ph2">`max()`</ph> 和 <ph id="ph3">`avg()`</ph> 等函数从所收集的范围派生有意义的值。</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>为了提高安全性，如果特定时间段可用的样本数小于特定百分比，你可以强制将公式评估为 <bpt id="p1">*</bpt>失败<ept id="p1">*</ept> 。强制将公式评估为失败会指示 Batch 在指定的样本百分比不可用时停止进一步的公式评估，而且不更改池大小。若要指定评估成功所需的样本百分比，请将其指定为 <ph id="ph1">`GetSample()`</ph> 的第三个参数。下面指定要求 75% 的样本：</source>
          <target state="new">为了提高安全性，如果特定时间段可用的样本数小于特定百分比，你可以强制将公式评估为 <bpt id="p1">*</bpt>失败<ept id="p1">*</ept> 。强制将公式评估为失败会指示 Batch 在指定的样本百分比不可用时停止进一步的公式评估，而且不更改池大小。若要指定评估成功所需的样本百分比，请将其指定为 <ph id="ph1">`GetSample()`</ph> 的第三个参数。下面指定要求 75% 的样本：</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>此外，由于先前提到的样本可用性延迟问题，请务必记得指定回查开始时间早于一分钟的时间范围。这是由于样本需要花大约一分钟的时间才能传播到整个系统，因此通常无法使用 <ph id="ph1">`(0 * TimeInterval_Second, 60 * TimeInterval_Second)`</ph> 范围内的样本。同样地，可以使用 <ph id="ph2">`GetSample()`</ph> 百分比参数来强制实施特定样本百分比要求。</source>
          <target state="new">此外，由于先前提到的样本可用性延迟问题，请务必记得指定回查开始时间早于一分钟的时间范围。这是由于样本需要花大约一分钟的时间才能传播到整个系统，因此通常无法使用 <ph id="ph1">`(0 * TimeInterval_Second, 60 * TimeInterval_Second)`</ph> 范围内的样本。同样地，可以使用 <ph id="ph2">`GetSample()`</ph> 百分比参数来强制实施特定样本百分比要求。</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph> <bpt id="p1">**</bpt>强烈建议****不要 <bpt id="p2">*</bpt>只<ept id="p2">*</ept> 依赖于自动缩放公式中的 <ph id="ph2">`GetSample(1)`</ph><ept id="p1">**</ept>。这是因为，<ph id="ph3">`GetSample(1)`</ph> 基本上只是向 Batch 服务表明：“不论多久以前获取最后一个样本，请将它提供给我。” 由于它只是单个样本，而且可能是较旧的样本，因此可能无法代表最近任务或资源状态的全貌。如果使用 <ph id="ph4">`GetSample(1)`</ph>，请确保它是较大语句的一部分，而不是公式所依赖的唯一数据点。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph> <bpt id="p1">**</bpt>强烈建议****不要 <bpt id="p2">*</bpt>只<ept id="p2">*</ept> 依赖于自动缩放公式中的 <ph id="ph2">`GetSample(1)`</ph><ept id="p1">**</ept>。这是因为，<ph id="ph3">`GetSample(1)`</ph> 基本上只是向 Batch 服务表明：“不论多久以前获取最后一个样本，请将它提供给我。” 由于它只是单个样本，而且可能是较旧的样本，因此可能无法代表最近任务或资源状态的全貌。如果使用 <ph id="ph4">`GetSample(1)`</ph>，请确保它是较大语句的一部分，而不是公式所依赖的唯一数据点。</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>度量值</source>
          <target state="new">度量值</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>可以在定义公式时使用<bpt id="p1">**</bpt>资源<ept id="p1">**</ept>和<bpt id="p2">**</bpt>任务度量值<ept id="p2">**</ept>，根据获取和评估的度量值数据来调整池中专用节点的目标数目。有关每个度量值的详细信息，请参阅上面的<bpt id="p3">[</bpt>变量<ept id="p3">](#variables)</ept>部分。</source>
          <target state="new">可以在定义公式时使用<bpt id="p1">**</bpt>资源<ept id="p1">**</ept>和<bpt id="p2">**</bpt>任务度量值<ept id="p2">**</ept>，根据获取和评估的度量值数据来调整池中专用节点的目标数目。有关每个度量值的详细信息，请参阅上面的<bpt id="p3">[</bpt>变量<ept id="p3">](#variables)</ept>部分。</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>度量值</source>
          <target state="new">度量值</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>说明</source>
          <target state="new">说明</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>资源</source>
          <target state="new">资源</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>资源度量值<ph id="ph1">&lt;/b&gt;</ph>基于计算节点的 CPU、带宽和内存使用量，以及节点数目。</source>
          <target state="new">资源度量值<ph id="ph1">&lt;/b&gt;</ph>基于计算节点的 CPU、带宽和内存使用量，以及节点数目。</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>这些系统定义的变量可用于根据节点计数进行调整：</source>
          <target state="new">这些系统定义的变量可用于根据节点计数进行调整：</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>$TargetDedicated</source>
          <target state="new">$TargetDedicated</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>$CurrentDedicated</source>
          <target state="new">$CurrentDedicated</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>$SampleNodeCount</source>
          <target state="new">$SampleNodeCount</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>这些系统定义的变量可用于根据节点资源使用量进行调整：</source>
          <target state="new">这些系统定义的变量可用于根据节点资源使用量进行调整：</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>$CPUPercent</source>
          <target state="new">$CPUPercent</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>$WallClockSeconds</source>
          <target state="new">$WallClockSeconds</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>$MemoryBytes</source>
          <target state="new">$MemoryBytes</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>$DiskBytes</source>
          <target state="new">$DiskBytes</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>$DiskReadBytes</source>
          <target state="new">$DiskReadBytes</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>$DiskWriteBytes</source>
          <target state="new">$DiskWriteBytes</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>$DiskReadOps</source>
          <target state="new">$DiskReadOps</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>$DiskWriteOps</source>
          <target state="new">$DiskWriteOps</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>$NetworkInBytes</source>
          <target state="new">$NetworkInBytes</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>$NetworkInBytes</source>
          <target state="new">$NetworkInBytes</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>任务</source>
          <target state="new">任务</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>任务度量值<ph id="ph1">&lt;/b&gt;</ph>基于任务的状态，例如“活动”、“挂起”和“已完成”。以下系统定义变量可用于根据任务度量值调整池大小：</source>
          <target state="new">任务度量值<ph id="ph1">&lt;/b&gt;</ph>基于任务的状态，例如“活动”、“挂起”和“已完成”。以下系统定义变量可用于根据任务度量值调整池大小：</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>$ActiveTasks</source>
          <target state="new">$ActiveTasks</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>$RunningTasks</source>
          <target state="new">$RunningTasks</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>$SucceededTasks</source>
          <target state="new">$SucceededTasks</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>$FailedTasks</source>
          <target state="new">$FailedTasks</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>构建自动缩放公式</source>
          <target state="new">构建自动缩放公式</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>构造自动缩放公式时，可以使用上述组件来生成语句，然后将这些语句组合成完整的公式即可。例如，在这里，我们在构造公式时，会先定义对公式的要求：</source>
          <target state="new">构造自动缩放公式时，可以使用上述组件来生成语句，然后将这些语句组合成完整的公式即可。例如，在这里，我们在构造公式时，会先定义对公式的要求：</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>如果 CPU 使用率高，则增加池中计算节点的目标数</source>
          <target state="new">如果 CPU 使用率高，则增加池中计算节点的目标数</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>如果 CPU 使用率低，则降低池中计算节点的目标数</source>
          <target state="new">如果 CPU 使用率低，则降低池中计算节点的目标数</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>始终将最大节点数限制为 400</source>
          <target state="new">始终将最大节点数限制为 400</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>为了在 CPU 使用率高时<bpt id="p1">*</bpt>增加<ept id="p1">*</ept> 节点数，我们定义了一个语句，如果在过去 10 分钟内最小平均 CPU 使用率高于 70%，该语句就会向用户定义变量 ($TotalNodes) 填充一个值，值的大小为节点当前目标数的 110%：</source>
          <target state="new">为了在 CPU 使用率高时<bpt id="p1">*</bpt>增加<ept id="p1">*</ept> 节点数，我们定义了一个语句，如果在过去 10 分钟内最小平均 CPU 使用率高于 70%，该语句就会向用户定义变量 ($TotalNodes) 填充一个值，值的大小为节点当前目标数的 110%：</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>如果过去 60 分钟的平均 CPU 使用率<bpt id="p1">*</bpt>低于<ept id="p1">*</ept> 20%，则下一个语句会将同一变量设置为节点当前目标数的 90%，降低 CPU 使用率低时的目标数。请注意，此语句还引用以上语句中的用户定义变量 <bpt id="p2">*</bpt>$TotalNodes<ept id="p2">*</ept>。</source>
          <target state="new">如果过去 60 分钟的平均 CPU 使用率<bpt id="p1">*</bpt>低于<ept id="p1">*</ept> 20%，则下一个语句会将同一变量设置为节点当前目标数的 90%，降低 CPU 使用率低时的目标数。请注意，此语句还引用以上语句中的用户定义变量 <bpt id="p2">*</bpt>$TotalNodes<ept id="p2">*</ept>。</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>现在，将专用计算节点的目标数限制为<bpt id="p1">**</bpt>最大值<ept id="p1">**</ept> 400：</source>
          <target state="new">现在，将专用计算节点的目标数限制为<bpt id="p1">**</bpt>最大值<ept id="p1">**</ept> 400：</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>下面是完整公式：</source>
          <target state="new">下面是完整公式：</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 自动缩放公式由 <bpt id="p1">[</bpt>Batch REST<ept id="p1">][rest_api]</ept> API 变量、类型、操作和函数组成。即使是在使用 <bpt id="p2">[</bpt>Batch .NET<ept id="p2">][net_api]</ept> 库的时候，也会在公式字符串中使用这些组成元素。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 自动缩放公式由 <bpt id="p1">[</bpt>Batch REST<ept id="p1">][rest_api]</ept> API 变量、类型、操作和函数组成。即使是在使用 <bpt id="p2">[</bpt>Batch .NET<ept id="p2">][net_api]</ept> 库的时候，也会在公式字符串中使用这些组成元素。</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>在启用自动缩放的情况下创建池</source>
          <target state="new">在启用自动缩放的情况下创建池</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>若要在创建池时启用自动缩放功能，请使用以下方法之一：</source>
          <target state="new">若要在创建池时启用自动缩放功能，请使用以下方法之一：</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>New-AzureBatchPool<ept id="p1">](https://msdn.microsoft.com/library/azure/mt125936.aspx)</ept> – 此 Azure PowerShell cmdlet 使用 AutoScaleFormula 参数来指定自动缩放公式。</source>
          <target state="new"><bpt id="p1">[</bpt>New-AzureBatchPool<ept id="p1">](https://msdn.microsoft.com/library/azure/mt125936.aspx)</ept> – 此 Azure PowerShell cmdlet 使用 AutoScaleFormula 参数来指定自动缩放公式。</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BatchClient.PoolOperations.CreatePool<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.createpool.aspx)</ept> – 在调用此 .NET 方法创建池后，将设置池的 <bpt id="p2">[</bpt>CloudPool.AutoScaleEnabled<ept id="p2">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleenabled.aspx)</ept> 和 <bpt id="p3">[</bpt>CloudPool.AutoScaleFormula<ept id="p3">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleformula.aspx)</ept> 属性，以启用自动缩放。</source>
          <target state="new"><bpt id="p1">[</bpt>BatchClient.PoolOperations.CreatePool<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.createpool.aspx)</ept> – 在调用此 .NET 方法创建池后，将设置池的 <bpt id="p2">[</bpt>CloudPool.AutoScaleEnabled<ept id="p2">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleenabled.aspx)</ept> 和 <bpt id="p3">[</bpt>CloudPool.AutoScaleFormula<ept id="p3">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleformula.aspx)</ept> 属性，以启用自动缩放。</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>将池添加到帐户<ept id="p1">](https://msdn.microsoft.com/library/azure/dn820174.aspx)</ept> – 创建池后，此 REST API 请求中使用的 enableAutoScale 和 autoScaleFormula 元素将为池设置自动缩放。</source>
          <target state="new"><bpt id="p1">[</bpt>将池添加到帐户<ept id="p1">](https://msdn.microsoft.com/library/azure/dn820174.aspx)</ept> – 创建池后，此 REST API 请求中使用的 enableAutoScale 和 autoScaleFormula 元素将为池设置自动缩放。</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph> 如果你使用上述方法之一创建了支持自动缩放的池，则<bpt id="p1">**</bpt>不得<ept id="p1">**</ept>指定该池的 <bpt id="p2">*</bpt>targetDedicated<ept id="p2">*</ept> 参数。另请注意，如果你希望手动调整启用自动缩放功能的池的大小（例如，使用 <bpt id="p3">[</bpt>BatchClient.PoolOperations.ResizePool<ept id="p3">][net_poolops_resizepool]</ept> 来调整），则必须先<bpt id="p4">**</bpt>禁用<ept id="p4">**</ept>该池的自动缩放功能，然后再调整池的大小。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph> 如果你使用上述方法之一创建了支持自动缩放的池，则<bpt id="p1">**</bpt>不得<ept id="p1">**</ept>指定该池的 <bpt id="p2">*</bpt>targetDedicated<ept id="p2">*</ept> 参数。另请注意，如果你希望手动调整启用自动缩放功能的池的大小（例如，使用 <bpt id="p3">[</bpt>BatchClient.PoolOperations.ResizePool<ept id="p3">][net_poolops_resizepool]</ept> 来调整），则必须先<bpt id="p4">**</bpt>禁用<ept id="p4">**</ept>该池的自动缩放功能，然后再调整池的大小。</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>以下代码段显示了如何创建启用自动缩放功能的 <bpt id="p1">[</bpt>CloudPool<ept id="p1">][net_cloudpool]</ept>，创建时使用 <bpt id="p2">[</bpt>Batch .NET<ept id="p2">][net_api]</ept> 库，其公式将节点的目标数设置为 5（周一）和 1（除周一外的其他时间）。此外，自动缩放间隔设置为 30 分钟（请参阅下面的<bpt id="p3">[</bpt>自动缩放间隔<ept id="p3">](#interval)</ept>）。在本文的此部分与其他 C# 代码段中，“myBatchClient”是适当初始化的 <bpt id="p4">[</bpt>BatchClient<ept id="p4">][net_batchclient]</ept> 实例。</source>
          <target state="new">以下代码段显示了如何创建启用自动缩放功能的 <bpt id="p1">[</bpt>CloudPool<ept id="p1">][net_cloudpool]</ept>，创建时使用 <bpt id="p2">[</bpt>Batch .NET<ept id="p2">][net_api]</ept> 库，其公式将节点的目标数设置为 5（周一）和 1（除周一外的其他时间）。此外，自动缩放间隔设置为 30 分钟（请参阅下面的<bpt id="p3">[</bpt>自动缩放间隔<ept id="p3">](#interval)</ept>）。在本文的此部分与其他 C# 代码段中，“myBatchClient”是适当初始化的 <bpt id="p4">[</bpt>BatchClient<ept id="p4">][net_batchclient]</ept> 实例。</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="interval"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>自动缩放间隔</source>
          <target state="new"><ph id="ph1">&lt;a name="interval"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>自动缩放间隔</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>默认情况下，Batch 服务根据其自动缩放公式每隔 <bpt id="p1">**</bpt>15 分钟<ept id="p1">**</ept>调整池大小。但是，可使用以下池属性配置此间隔：</source>
          <target state="new">默认情况下，Batch 服务根据其自动缩放公式每隔 <bpt id="p1">**</bpt>15 分钟<ept id="p1">**</ept>调整池大小。但是，可使用以下池属性配置此间隔：</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>REST API - <bpt id="p1">[</bpt>autoScaleEvaluationInterval<ept id="p1">][rest_autoscaleinterval]</ept></source>
          <target state="new">REST API - <bpt id="p1">[</bpt>autoScaleEvaluationInterval<ept id="p1">][rest_autoscaleinterval]</ept></target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>.NET API - <bpt id="p1">[</bpt>CloudPool.AutoScaleEvaluationInterval<ept id="p1">][net_cloudpool_autoscaleevalinterval]</ept></source>
          <target state="new">.NET API - <bpt id="p1">[</bpt>CloudPool.AutoScaleEvaluationInterval<ept id="p1">][net_cloudpool_autoscaleevalinterval]</ept></target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>最小间隔为 5 分钟，最大间隔为 168 小时。如果指定的间隔超出此范围，Batch 服务将返回“错误的请求(400)”错误。</source>
          <target state="new">最小间隔为 5 分钟，最大间隔为 168 小时。如果指定的间隔超出此范围，Batch 服务将返回“错误的请求(400)”错误。</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 自动缩放目前不能以低于一分钟的时间响应更改，而是在你运行工作负荷时逐步调整池大小。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 自动缩放目前不能以低于一分钟的时间响应更改，而是在你运行工作负荷时逐步调整池大小。</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>创建池后启用自动缩放</source>
          <target state="new">创建池后启用自动缩放</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>如果你使用 <bpt id="p1">*</bpt>targetDedicated<ept id="p1">*</ept> 参数设置了包含指定计算节点数的池，则以后可以更新现有池以自动缩放。通过以下方法之一执行这种检查：</source>
          <target state="new">如果你使用 <bpt id="p1">*</bpt>targetDedicated<ept id="p1">*</ept> 参数设置了包含指定计算节点数的池，则以后可以更新现有池以自动缩放。通过以下方法之一执行这种检查：</target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BatchClient.PoolOperations.EnableAutoScale<ept id="p1">][net_enableautoscale]</ept> – 此 .NET 方法需要现有池的 ID 和自动缩放公式才能应用到池。</source>
          <target state="new"><bpt id="p1">[</bpt>BatchClient.PoolOperations.EnableAutoScale<ept id="p1">][net_enableautoscale]</ept> – 此 .NET 方法需要现有池的 ID 和自动缩放公式才能应用到池。</target>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>允许对池进行自动缩放<ept id="p1">][rest_enableautoscale]</ept> – 此 REST API 请求要求 URI 中存在现有池的 ID，以及请求正文中存在自动缩放公式。</source>
          <target state="new"><bpt id="p1">[</bpt>允许对池进行自动缩放<ept id="p1">][rest_enableautoscale]</ept> – 此 REST API 请求要求 URI 中存在现有池的 ID，以及请求正文中存在自动缩放公式。</target>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 如果某个值是在创建池时为 <bpt id="p1">*</bpt>targetDedicated<ept id="p1">*</ept> 参数指定的，则会在评估自动缩放公式时忽略该值。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 如果某个值是在创建池时为 <bpt id="p1">*</bpt>targetDedicated<ept id="p1">*</ept> 参数指定的，则会在评估自动缩放公式时忽略该值。</target>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>此代码段演示了如何在现有池上通过 <bpt id="p1">[</bpt>Batch .NET<ept id="p1">][net_api]</ept> 库启用自动缩放功能。请注意，针对现有池启用公式和更新公式使用相同的方法。因此，如果已启用自动缩放功能，则此方法会针对指定池 <bpt id="p2">*</bpt>更新<ept id="p2">*</ept> 公式。该代码段假设“mypool”是现有 <bpt id="p3">[</bpt>CloudPool<ept id="p3">][net_cloudpool]</ept> 的 ID。</source>
          <target state="new">此代码段演示了如何在现有池上通过 <bpt id="p1">[</bpt>Batch .NET<ept id="p1">][net_api]</ept> 库启用自动缩放功能。请注意，针对现有池启用公式和更新公式使用相同的方法。因此，如果已启用自动缩放功能，则此方法会针对指定池 <bpt id="p2">*</bpt>更新<ept id="p2">*</ept> 公式。该代码段假设“mypool”是现有 <bpt id="p3">[</bpt>CloudPool<ept id="p3">][net_cloudpool]</ept> 的 ID。</target>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>评估自动缩放公式</source>
          <target state="new">评估自动缩放公式</target>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>在应用程序中使用公式之前，最好先对它进行评估。评估公式时，可以针对现有池对公式进行“测试性运行”。执行此操作时，可通过以下方式：</source>
          <target state="new">在应用程序中使用公式之前，最好先对它进行评估。评估公式时，可以针对现有池对公式进行“测试性运行”。执行此操作时，可通过以下方式：</target>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BatchClient.PoolOperations.EvaluateAutoScale<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.evaluateautoscale.aspx)</ept> 或 <bpt id="p2">[</bpt>BatchClient.PoolOperations.EvaluateAutoScaleAsync<ept id="p2">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.evaluateautoscaleasync.aspx)</ept> – 这些 .NET 方法需要现有池的 ID，并需要包含自动缩放公式的字符串。调用的结果将包含在 <bpt id="p3">[</bpt>AutoScaleEvaluation<ept id="p3">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscaleevaluation.aspx)</ept> 类的实例中。</source>
          <target state="new"><bpt id="p1">[</bpt>BatchClient.PoolOperations.EvaluateAutoScale<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.evaluateautoscale.aspx)</ept> 或 <bpt id="p2">[</bpt>BatchClient.PoolOperations.EvaluateAutoScaleAsync<ept id="p2">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.evaluateautoscaleasync.aspx)</ept> – 这些 .NET 方法需要现有池的 ID，并需要包含自动缩放公式的字符串。调用的结果将包含在 <bpt id="p3">[</bpt>AutoScaleEvaluation<ept id="p3">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscaleevaluation.aspx)</ept> 类的实例中。</target>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>评估自动缩放公式<ept id="p1">](https://msdn.microsoft.com/library/azure/dn820183.aspx)</ept> – 在这个 REST API 请求中，池 ID 已在 URI 中指定，自动缩放公式已在请求正文的 <bpt id="p2">*</bpt>autoScaleFormula<ept id="p2">*</ept> 元素中指定。操作的响应包含任何可能与该公式相关的错误信息。</source>
          <target state="new"><bpt id="p1">[</bpt>评估自动缩放公式<ept id="p1">](https://msdn.microsoft.com/library/azure/dn820183.aspx)</ept> – 在这个 REST API 请求中，池 ID 已在 URI 中指定，自动缩放公式已在请求正文的 <bpt id="p2">*</bpt>autoScaleFormula<ept id="p2">*</ept> 元素中指定。操作的响应包含任何可能与该公式相关的错误信息。</target>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 若要评估某个自动缩放公式，你必须先通过有效的公式对池启用了自动缩放功能。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 若要评估某个自动缩放公式，你必须先通过有效的公式对池启用了自动缩放功能。</target>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>在这个使用 <bpt id="p1">[</bpt>Batch .NET<ept id="p1">][net_api]</ept> 库的代码段中，我们先对公式进行评估，然后将其应用到 <bpt id="p2">[</bpt>CloudPool<ept id="p2">][net_cloudpool]</ept>。</source>
          <target state="new">在这个使用 <bpt id="p1">[</bpt>Batch .NET<ept id="p1">][net_api]</ept> 库的代码段中，我们先对公式进行评估，然后将其应用到 <bpt id="p2">[</bpt>CloudPool<ept id="p2">][net_cloudpool]</ept>。</target>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>成功对此代码段中的公式进行评估以后，将生成如下所示的输出：</source>
          <target state="new">成功对此代码段中的公式进行评估以后，将生成如下所示的输出：</target>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>获取有关自动缩放运行的信息</source>
          <target state="new">获取有关自动缩放运行的信息</target>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>定期检查自动缩放的运行结果，以确保公式按预期执行。</source>
          <target state="new">定期检查自动缩放的运行结果，以确保公式按预期执行。</target>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CloudPool.AutoScaleRun<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscalerun.aspx)</ept> – 使用 .NET 库时，池的此属性将提供 <bpt id="p2">[</bpt>AutoScaleRun<ept id="p2">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscalerun.aspx)</ept> 类的一个实例，该类提供最新自动缩放运行的以下属性：</source>
          <target state="new"><bpt id="p1">[</bpt>CloudPool.AutoScaleRun<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscalerun.aspx)</ept> – 使用 .NET 库时，池的此属性将提供 <bpt id="p2">[</bpt>AutoScaleRun<ept id="p2">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscalerun.aspx)</ept> 类的一个实例，该类提供最新自动缩放运行的以下属性：</target>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>AutoScaleRun.Error</source>
          <target state="new">AutoScaleRun.Error</target>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>AutoScaleRun.Results</source>
          <target state="new">AutoScaleRun.Results</target>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>AutoScaleRun.Timestamp</source>
          <target state="new">AutoScaleRun.Timestamp</target>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>获取有关池的信息<ept id="p1">](https://msdn.microsoft.com/library/dn820165.aspx)</ept> – 此 REST API 请求返回有关池的信息，包括最近的自动缩放运行结果。</source>
          <target state="new"><bpt id="p1">[</bpt>获取有关池的信息<ept id="p1">](https://msdn.microsoft.com/library/dn820165.aspx)</ept> – 此 REST API 请求返回有关池的信息，包括最近的自动缩放运行结果。</target>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="examples"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例公式</source>
          <target state="new"><ph id="ph1">&lt;a name="examples"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例公式</target>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>让我们看看一些示例，了解如何通过多种方式使用公式来自动缩放池中的计算资源。</source>
          <target state="new">让我们看看一些示例，了解如何通过多种方式使用公式来自动缩放池中的计算资源。</target>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>示例 1：基于时间的调整</source>
          <target state="new">示例 1：基于时间的调整</target>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>也许，你希望能够根据星期几和一天的具体时间来调整池的大小，相应地增加或减少池中节点的数目：</source>
          <target state="new">也许，你希望能够根据星期几和一天的具体时间来调整池的大小，相应地增加或减少池中节点的数目：</target>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>此公式首先获取当前时间。如果日期是工作日（周一到周五）且时间是工作时间（早 8 点到晚 6 点），则会将目标池大小设置为 20 个节点。否则，目标池大小将设置为 10 个节点。</source>
          <target state="new">此公式首先获取当前时间。如果日期是工作日（周一到周五）且时间是工作时间（早 8 点到晚 6 点），则会将目标池大小设置为 20 个节点。否则，目标池大小将设置为 10 个节点。</target>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>示例 2：基于任务的调整</source>
          <target state="new">示例 2：基于任务的调整</target>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>在此示例中，池大小是根据队列中的任务数来调整的。请注意，在公式字符串中，注释和分行符都是可以接受的。</source>
          <target state="new">在此示例中，池大小是根据队列中的任务数来调整的。请注意，在公式字符串中，注释和分行符都是可以接受的。</target>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>示例 3：考虑并行任务</source>
          <target state="new">示例 3：考虑并行任务</target>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>另一个根据任务数来调整池大小的示例就是，此公式还会考虑为池设置的 <bpt id="p1">[</bpt>MaxTasksPerComputeNode<ept id="p1">][net_maxtasks]</ept> 值。在对池启用了<bpt id="p2">[</bpt>并行任务执行<ept id="p2">](batch-parallel-node-tasks.md)</ept>的情况下，此公式特别有用。</source>
          <target state="new">另一个根据任务数来调整池大小的示例就是，此公式还会考虑为池设置的 <bpt id="p1">[</bpt>MaxTasksPerComputeNode<ept id="p1">][net_maxtasks]</ept> 值。在对池启用了<bpt id="p2">[</bpt>并行任务执行<ept id="p2">](batch-parallel-node-tasks.md)</ept>的情况下，此公式特别有用。</target>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>示例 4：设置初始池大小</source>
          <target state="new">示例 4：设置初始池大小</target>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>此示例显示 C# 代码段中的自动缩放公式在初始时间段将池大小设置为一定的节点数目，然后在初始时间段过后，根据正在运行和处于活动状态的任务数目调整池大小。</source>
          <target state="new">此示例显示 C# 代码段中的自动缩放公式在初始时间段将池大小设置为一定的节点数目，然后在初始时间段过后，根据正在运行和处于活动状态的任务数目调整池大小。</target>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>上述代码段中的公式具有以下特征：</source>
          <target state="new">上述代码段中的公式具有以下特征：</target>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>将初始池大小设置为 4 个节点</source>
          <target state="new">将初始池大小设置为 4 个节点</target>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>在池生命周期的最初 10 分钟内不调整池大小</source>
          <target state="new">在池生命周期的最初 10 分钟内不调整池大小</target>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>10 分钟后，获取过去 60 分钟内正在运行和处于活动状态的任务数目的最大值</source>
          <target state="new">10 分钟后，获取过去 60 分钟内正在运行和处于活动状态的任务数目的最大值</target>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>如果这两个值均为 0（表示过去 60 分钟没有正在运行或处于活动状态的任务），则池大小将设置为 0</source>
          <target state="new">如果这两个值均为 0（表示过去 60 分钟没有正在运行或处于活动状态的任务），则池大小将设置为 0</target>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>如果其中一个值大于零，则不进行任何更改</source>
          <target state="new">如果其中一个值大于零，则不进行任何更改</target>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>若要完全评估应用程序的效率，你可能需要访问计算节点。若要利用远程访问，必须将一个用户帐户添加到你要访问的节点，并且必须为该节点检索 RDP 文件。</source>
          <target state="new">若要完全评估应用程序的效率，你可能需要访问计算节点。若要利用远程访问，必须将一个用户帐户添加到你要访问的节点，并且必须为该节点检索 RDP 文件。</target>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>通过以下方法之一添加用户帐户：</source>
          <target state="new">通过以下方法之一添加用户帐户：</target>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>New-AzureBatchVMUser<ept id="p1">](https://msdn.microsoft.com/library/mt149846.aspx)</ept> – 此 PowerShell cmdlet 使用池名称、计算节点名称、帐户名和密码作为参数。</source>
          <target state="new"><bpt id="p1">[</bpt>New-AzureBatchVMUser<ept id="p1">](https://msdn.microsoft.com/library/mt149846.aspx)</ept> – 此 PowerShell cmdlet 使用池名称、计算节点名称、帐户名和密码作为参数。</target>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BatchClient.PoolOperations.CreateComputeNodeUser<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.createcomputenodeuser.aspx)</ept> – 此 .NET 方法会创建 <bpt id="p2">[</bpt>ComputeNodeUser<ept id="p2">](https://msdn.microsoft.com/library/microsoft.azure.batch.computenodeuser.aspx)</ept> 类的一个实例，你可以在该实例上针对计算节点设置帐户名和密码，然后再在该实例上调用 <bpt id="p3">[</bpt>ComputeNodeUser.Commit<ept id="p3">](https://msdn.microsoft.com/library/microsoft.azure.batch.computenodeuser.commit.aspx)</ept>，以便在该节点上创建用户。</source>
          <target state="new"><bpt id="p1">[</bpt>BatchClient.PoolOperations.CreateComputeNodeUser<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.createcomputenodeuser.aspx)</ept> – 此 .NET 方法会创建 <bpt id="p2">[</bpt>ComputeNodeUser<ept id="p2">](https://msdn.microsoft.com/library/microsoft.azure.batch.computenodeuser.aspx)</ept> 类的一个实例，你可以在该实例上针对计算节点设置帐户名和密码，然后再在该实例上调用 <bpt id="p3">[</bpt>ComputeNodeUser.Commit<ept id="p3">](https://msdn.microsoft.com/library/microsoft.azure.batch.computenodeuser.commit.aspx)</ept>，以便在该节点上创建用户。</target>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>将用户帐户添加到节点<ept id="p1">](https://msdn.microsoft.com/library/dn820137.aspx)</ept> – 池和计算节点的名称在 URI 中指定，帐户名和密码将发送到此 REST API 请求的请求正文中的节点。</source>
          <target state="new"><bpt id="p1">[</bpt>将用户帐户添加到节点<ept id="p1">](https://msdn.microsoft.com/library/dn820137.aspx)</ept> – 池和计算节点的名称在 URI 中指定，帐户名和密码将发送到此 REST API 请求的请求正文中的节点。</target>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>获取 RDP 文件：</source>
          <target state="new">获取 RDP 文件：</target>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BatchClient.PoolOperations.GetRDPFile<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.getrdpfile.aspx)</ept> – 此 .NET 方法需要池 ID、节点 ID 以及要创建的 RDP 文件的名称。</source>
          <target state="new"><bpt id="p1">[</bpt>BatchClient.PoolOperations.GetRDPFile<ept id="p1">](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.getrdpfile.aspx)</ept> – 此 .NET 方法需要池 ID、节点 ID 以及要创建的 RDP 文件的名称。</target>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>从节点获取远程桌面协议文件<ept id="p1">](https://msdn.microsoft.com/library/dn820120.aspx)</ept> – 此 REST API 请求需要池的名称以及计算节点的名称。响应包含 RDP 文件的内容。</source>
          <target state="new"><bpt id="p1">[</bpt>从节点获取远程桌面协议文件<ept id="p1">](https://msdn.microsoft.com/library/dn820120.aspx)</ept> – 此 REST API 请求需要池的名称以及计算节点的名称。响应包含 RDP 文件的内容。</target>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Get-AzureBatchRDPFile<ept id="p1">](https://msdn.microsoft.com/library/mt149851.aspx)</ept> – 此 PowerShell cmdlet 从指定的计算节点获取 RDP 文件，并将其保存到指定的文件位置或流。</source>
          <target state="new"><bpt id="p1">[</bpt>Get-AzureBatchRDPFile<ept id="p1">](https://msdn.microsoft.com/library/mt149851.aspx)</ept> – 此 PowerShell cmdlet 从指定的计算节点获取 RDP 文件，并将其保存到指定的文件位置或流。</target>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>某些应用程序会生成大量难以处理的数据。解决此问题的方法之一是进行<bpt id="p1">[</bpt>有效的列表查询<ept id="p1">](/documentation/articles/batch-efficient-list-queries)</ept>。</source>
          <target state="new">某些应用程序会生成大量难以处理的数据。解决此问题的方法之一是进行<bpt id="p1">[</bpt>有效的列表查询<ept id="p1">](/documentation/articles/batch-efficient-list-queries)</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>