<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2a78c1ce65de24c3efcad684d694665013f72b0a</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 Ruby 使用服务总线队列 | Azure</source>
          <target state="new">如何通过 Ruby 使用服务总线队列 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何在 Azure 中使用 Service Bus 队列。用 Ruby 编写的代码示例。</source>
          <target state="new">了解如何在 Azure 中使用 Service Bus 队列。用 Ruby 编写的代码示例。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何使用 Service Bus 队列</source>
          <target state="new">如何使用 Service Bus 队列</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>本指南介绍如何使用服务总线队列。相关示例通过 Ruby 编写并使用 Azure gem。涉及的任务包括<bpt id="p1">**</bpt>创建队列、发送和接收消息<ept id="p1">**</ept>以及<bpt id="p2">**</bpt>删除队列<ept id="p2">**</ept>。有关队列的详细信息，请参阅<bpt id="p3">[</bpt>后续步骤<ept id="p3">](#next-steps)</ept>部分。</source>
          <target state="new">本指南介绍如何使用服务总线队列。相关示例通过 Ruby 编写并使用 Azure gem。涉及的任务包括<bpt id="p1">**</bpt>创建队列、发送和接收消息<ept id="p1">**</ept>以及<bpt id="p2">**</bpt>删除队列<ept id="p2">**</ept>。有关队列的详细信息，请参阅<bpt id="p3">[</bpt>后续步骤<ept id="p3">](#next-steps)</ept>部分。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>什么是 Service Bus 队列？</source>
          <target state="new">什么是 Service Bus 队列？</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Service Bus 队列支持<bpt id="p1">*</bpt>中转消息<ept id="p1">*</ept>通信模型。在使用队列时，分布式应用程序的组件不会直接相互通信，而是通过充当中介的队列交换消息。消息创建方（发送方）将消息传送到队列，然后继续对其进行处理。消息使用方（接收方）以异步方式从队列中提取消息并处理它。创建方不必等待使用方的答复即可继续处理并发送更多消息。队列为一个或多个竞争使用方提供<bpt id="p2">**</bpt>先入先出 (FIFO)<ept id="p2">**</ept> 消息传递方式。也就是说，接收方通常会按照消息添加到队列中的顺序来接收并处理消息，并且每条消息仅由一个消息使用方接收并处理。</source>
          <target state="new">Service Bus 队列支持<bpt id="p1">*</bpt>中转消息<ept id="p1">*</ept>通信模型。在使用队列时，分布式应用程序的组件不会直接相互通信，而是通过充当中介的队列交换消息。消息创建方（发送方）将消息传送到队列，然后继续对其进行处理。消息使用方（接收方）以异步方式从队列中提取消息并处理它。创建方不必等待使用方的答复即可继续处理并发送更多消息。队列为一个或多个竞争使用方提供<bpt id="p2">**</bpt>先入先出 (FIFO)<ept id="p2">**</ept> 消息传递方式。也就是说，接收方通常会按照消息添加到队列中的顺序来接收并处理消息，并且每条消息仅由一个消息使用方接收并处理。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>QueueConcepts</source>
          <target state="new">QueueConcepts</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Service Bus 队列是一种可用于各种应用场景的通用技术：</source>
          <target state="new">Service Bus 队列是一种可用于各种应用场景的通用技术：</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>多层 Azure 应用程序<ept id="p1">](/documentation/articles/service-bus-dotnet-multi-tier-app-using-service-bus-queues)</ept>中 Web 角色和辅助角色之间的通信。</source>
          <target state="new"><bpt id="p1">[</bpt>多层 Azure 应用程序<ept id="p1">](/documentation/articles/service-bus-dotnet-multi-tier-app-using-service-bus-queues)</ept>中 Web 角色和辅助角色之间的通信。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>混合解决方案<ept id="p1">](/documentation/articles/service-bus-dotnet-hybrid-app-using-service-bus-relay)</ept>中本地应用程序和 Azure 托管应用程序之间的通信。</source>
          <target state="new"><bpt id="p1">[</bpt>混合解决方案<ept id="p1">](/documentation/articles/service-bus-dotnet-hybrid-app-using-service-bus-relay)</ept>中本地应用程序和 Azure 托管应用程序之间的通信。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>在不同组织或组织的各部门中本地运行的分布式应用程序组件之间的通信</source>
          <target state="new">在不同组织或组织的各部门中本地运行的分布式应用程序组件之间的通信</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>利用队列，您可以更好地向外扩展应用程序，并增强您的体系结构的恢复能力。</source>
          <target state="new">利用队列，您可以更好地向外扩展应用程序，并增强您的体系结构的恢复能力。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>创建服务命名空间</source>
          <target state="new">创建服务命名空间</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>若要开始在 Azure 中使用服务总线队列，必须先创建一个服务命名空间。服务命名空间提供了用于对应用程序中的服务总线资源进行寻址的范围容器。必须通过命令行界面创建命名空间，因为 Azure 经典门户不会使用 ACS 连接创建命名空间。</source>
          <target state="new">若要开始在 Azure 中使用服务总线队列，必须先创建一个服务命名空间。服务命名空间提供了用于对应用程序中的服务总线资源进行寻址的范围容器。必须通过命令行界面创建命名空间，因为 Azure 经典门户不会使用 ACS 连接创建命名空间。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>创建服务命名空间：</source>
          <target state="new">创建服务命名空间：</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>打开 Azure PowerShell 控制台。</source>
          <target state="new">打开 Azure PowerShell 控制台。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>键入以下命令以创建服务总线命名空间。提供你自己的命名空间值，并指定与应用程序相同的区域。</source>
          <target state="new">键入以下命令以创建服务总线命名空间。提供你自己的命名空间值，并指定与应用程序相同的区域。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>New-AzureSBNamespace -Name 'yourexamplenamespace' -Location 'China East' -NamespaceType 'Messaging' -CreateACSNamespace $true</source>
          <target state="new">New-AzureSBNamespace -Name 'yourexamplenamespace' -Location 'China East' -NamespaceType 'Messaging' -CreateACSNamespace $true</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>创建命名空间</source>
          <target state="new">创建命名空间</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>获取命名空间的管理凭据</source>
          <target state="new">获取命名空间的管理凭据</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>若要在新命名空间上执行管理操作（如创建队列），则必须获取该命名空间的管理凭据。</source>
          <target state="new">若要在新命名空间上执行管理操作（如创建队列），则必须获取该命名空间的管理凭据。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>你运行的用于创建 Azure 服务总线命名空间的 PowerShell cmdlet 将显示可用于管理命名空间的密钥。复制 <bpt id="p1">**</bpt>DefaultKey<ept id="p1">**</ept> 值。你将本教程稍后的代码中使用此值。</source>
          <target state="new">你运行的用于创建 Azure 服务总线命名空间的 PowerShell cmdlet 将显示可用于管理命名空间的密钥。复制 <bpt id="p1">**</bpt>DefaultKey<ept id="p1">**</ept> 值。你将本教程稍后的代码中使用此值。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Copy key</source>
          <target state="new">Copy key</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>登录到 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">](http://manage.windowsazure.cn/)</ept>并导航到服务总线命名空间的连接信息后，也可以看到此密钥。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>登录到 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">](http://manage.windowsazure.cn/)</ept>并导航到服务总线命名空间的连接信息后，也可以看到此密钥。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>创建 Ruby 应用程序</source>
          <target state="new">创建 Ruby 应用程序</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>创建 Ruby 应用程序。有关说明，请参阅<bpt id="p1">[</bpt>在 Azure 上创建 Ruby 应用程序<ept id="p1">](/zh-cn/documentation/articles/virtual-machines-ruby-rails-web-app-linux)</ept>。</source>
          <target state="new">创建 Ruby 应用程序。有关说明，请参阅<bpt id="p1">[</bpt>在 Azure 上创建 Ruby 应用程序<ept id="p1">](/zh-cn/documentation/articles/virtual-machines-ruby-rails-web-app-linux)</ept>。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>配置应用程序以使用 Service Bus</source>
          <target state="new">配置应用程序以使用 Service Bus</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>要使用 Azure 服务总线，你需要使用 Ruby Azure 包，其中包括一组便于与存储 REST 服务进行通信的库。</source>
          <target state="new">要使用 Azure 服务总线，你需要使用 Ruby Azure 包，其中包括一组便于与存储 REST 服务进行通信的库。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>使用 RubyGems 获取该程序包</source>
          <target state="new">使用 RubyGems 获取该程序包</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>使用命令行接口，例如 <bpt id="p1">**</bpt>PowerShell<ept id="p1">**</ept> (Windows)、<bpt id="p2">**</bpt>Terminal<ept id="p2">**</ept> (Mac) 或 <bpt id="p3">**</bpt>Bash<ept id="p3">**</ept> (Unix)。</source>
          <target state="new">使用命令行接口，例如 <bpt id="p1">**</bpt>PowerShell<ept id="p1">**</ept> (Windows)、<bpt id="p2">**</bpt>Terminal<ept id="p2">**</ept> (Mac) 或 <bpt id="p3">**</bpt>Bash<ept id="p3">**</ept> (Unix)。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>在命令窗口中键入“gem install azure”以安装 gem 和依赖项。</source>
          <target state="new">在命令窗口中键入“gem install azure”以安装 gem 和依赖项。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>导入包</source>
          <target state="new">导入包</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>使用常用的文本编辑器将以下内容添加到你要在其中使用存储的 Ruby 文件的顶部：</source>
          <target state="new">使用常用的文本编辑器将以下内容添加到你要在其中使用存储的 Ruby 文件的顶部：</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>设置 Azure 服务总线连接</source>
          <target state="new">设置 Azure 服务总线连接</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Azure 模块将读取环境变量 <bpt id="p1">**</bpt>AZURE_SERVICEBUS_NAMESPACE<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>AZURE_SERVICEBUS_ACCESS_KEY<ept id="p2">**</ept> 以获取连接到你的 Azure 服务总线命名空间所需的信息。如果未设置这些环境变量，则在使用 <bpt id="p3">**</bpt>Azure::ServiceBusService<ept id="p3">**</ept> 之前必须通过以下代码指定命名空间信息：</source>
          <target state="new">Azure 模块将读取环境变量 <bpt id="p1">**</bpt>AZURE_SERVICEBUS_NAMESPACE<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>AZURE_SERVICEBUS_ACCESS_KEY<ept id="p2">**</ept> 以获取连接到你的 Azure 服务总线命名空间所需的信息。如果未设置这些环境变量，则在使用 <bpt id="p3">**</bpt>Azure::ServiceBusService<ept id="p3">**</ept> 之前必须通过以下代码指定命名空间信息：</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>将服务总线命名空间值设置为你创建的值，而不是整个 URL 的值。例如，使用 <bpt id="p1">**</bpt>"yourexamplenamespace"<ept id="p1">**</ept>，而不是 "yourexamplenamespace.servicebus.chinacloudapi.cn"。</source>
          <target state="new">将服务总线命名空间值设置为你创建的值，而不是整个 URL 的值。例如，使用 <bpt id="p1">**</bpt>"yourexamplenamespace"<ept id="p1">**</ept>，而不是 "yourexamplenamespace.servicebus.chinacloudapi.cn"。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>如何创建队列</source>
          <target state="new">如何创建队列</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>可以通过 <bpt id="p1">**</bpt>Azure::ServiceBusService<ept id="p1">**</ept> 对象处理队列。若要创建队列，请使用 <bpt id="p2">**</bpt>create_queue()<ept id="p2">**</ept> 方法。以下示例将创建一个队列或输出任何错误。</source>
          <target state="new">可以通过 <bpt id="p1">**</bpt>Azure::ServiceBusService<ept id="p1">**</ept> 对象处理队列。若要创建队列，请使用 <bpt id="p2">**</bpt>create_queue()<ept id="p2">**</ept> 方法。以下示例将创建一个队列或输出任何错误。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>还可以通过其他选项传递 <bpt id="p1">**</bpt>Azure::ServiceBus::Queue<ept id="p1">**</ept> 对象，这些选项可让你重写默认队列设置，如消息保存时间或最大队列大小。以下示例演示如何将最大队列大小设置为 5GB，将生存时间设置为 1 分钟：</source>
          <target state="new">还可以通过其他选项传递 <bpt id="p1">**</bpt>Azure::ServiceBus::Queue<ept id="p1">**</ept> 对象，这些选项可让你重写默认队列设置，如消息保存时间或最大队列大小。以下示例演示如何将最大队列大小设置为 5GB，将生存时间设置为 1 分钟：</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>如何向队列发送消息</source>
          <target state="new">如何向队列发送消息</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>若要向服务总线队列发送消息，你的应用程序需要对 <bpt id="p1">**</bpt>Azure::ServiceBusService<ept id="p1">**</ept> 对象调用 <bpt id="p2">**</bpt>send_queue_message()<ept id="p2">**</ept> 方法。发往服务总线队列的消息以及从服务总线队列接收的消息是 <bpt id="p3">**</bpt>Azure::ServiceBus::BrokeredMessage<ept id="p3">**</ept> 对象，它们具有一组标准属性（如 <bpt id="p4">**</bpt>label<ept id="p4">**</ept> 和 <bpt id="p5">**</bpt>time_to_live<ept id="p5">**</ept>）、一个用于保存自定义应用程序特定属性的字典和一段任意应用程序数据正文。应用程序可以通过将字符串值作为消息传送来设置消息正文，任何必需的标准属性将用默认值来填充。</source>
          <target state="new">若要向服务总线队列发送消息，你的应用程序需要对 <bpt id="p1">**</bpt>Azure::ServiceBusService<ept id="p1">**</ept> 对象调用 <bpt id="p2">**</bpt>send_queue_message()<ept id="p2">**</ept> 方法。发往服务总线队列的消息以及从服务总线队列接收的消息是 <bpt id="p3">**</bpt>Azure::ServiceBus::BrokeredMessage<ept id="p3">**</ept> 对象，它们具有一组标准属性（如 <bpt id="p4">**</bpt>label<ept id="p4">**</ept> 和 <bpt id="p5">**</bpt>time_to_live<ept id="p5">**</ept>）、一个用于保存自定义应用程序特定属性的字典和一段任意应用程序数据正文。应用程序可以通过将字符串值作为消息传送来设置消息正文，任何必需的标准属性将用默认值来填充。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>以下示例演示了如何使用 <bpt id="p1">**</bpt>send_queue_message()<ept id="p1">**</ept> 向名为“test-queue”的队列发送测试消息：</source>
          <target state="new">以下示例演示了如何使用 <bpt id="p1">**</bpt>send_queue_message()<ept id="p1">**</ept> 向名为“test-queue”的队列发送测试消息：</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Service Bus 队列支持最大为 256 KB 的消息（标头最大为 64 KB，其中包括标准和自定义应用程序属性）。一个队列可包含的消息数不受限制，但消息的总大小受限。此队列大小是在创建时定义的，上限为 5 GB。</source>
          <target state="new">Service Bus 队列支持最大为 256 KB 的消息（标头最大为 64 KB，其中包括标准和自定义应用程序属性）。一个队列可包含的消息数不受限制，但消息的总大小受限。此队列大小是在创建时定义的，上限为 5 GB。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>如何从队列接收消息</source>
          <target state="new">如何从队列接收消息</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>可通过对 <bpt id="p1">**</bpt>Azure::ServiceBusService<ept id="p1">**</ept> 对象使用 <bpt id="p2">**</bpt>receive_queue_message()<ept id="p2">**</ept> 方法从队列接收消息。默认情况下，消息在被读取的同时会被锁定，从而无法从队列中删除。但是，你可以通过将 <bpt id="p3">**</bpt>:peek_lock<ept id="p3">**</ept> 选项设置为 <bpt id="p4">**</bpt>false<ept id="p4">**</ept>，在读取消息时将其从队列中删除。</source>
          <target state="new">可通过对 <bpt id="p1">**</bpt>Azure::ServiceBusService<ept id="p1">**</ept> 对象使用 <bpt id="p2">**</bpt>receive_queue_message()<ept id="p2">**</ept> 方法从队列接收消息。默认情况下，消息在被读取的同时会被锁定，从而无法从队列中删除。但是，你可以通过将 <bpt id="p3">**</bpt>:peek_lock<ept id="p3">**</ept> 选项设置为 <bpt id="p4">**</bpt>false<ept id="p4">**</ept>，在读取消息时将其从队列中删除。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>默认行为使读取和删除变成一个两阶段操作，从而也有可能支持不允许遗漏消息的应用程序。当 Service Bus 收到请求时，它会查找下一条要使用的消息，锁定该消息以防其他使用者接收，然后将该消息返回到应用程序。应用程序处理完该消息（或将其可靠地存储起来留待将来处理）后，会通过调用 <bpt id="p1">**</bpt>delete_queue_message()<ept id="p1">**</ept> 方法并提供要删除的消息作为参数来完成接收过程的第二阶段。<bpt id="p2">**</bpt>delete_queue_message()<ept id="p2">**</ept> 方法将该消息标记为“已使用”并将其从队列中删除。</source>
          <target state="new">默认行为使读取和删除变成一个两阶段操作，从而也有可能支持不允许遗漏消息的应用程序。当 Service Bus 收到请求时，它会查找下一条要使用的消息，锁定该消息以防其他使用者接收，然后将该消息返回到应用程序。应用程序处理完该消息（或将其可靠地存储起来留待将来处理）后，会通过调用 <bpt id="p1">**</bpt>delete_queue_message()<ept id="p1">**</ept> 方法并提供要删除的消息作为参数来完成接收过程的第二阶段。<bpt id="p2">**</bpt>delete_queue_message()<ept id="p2">**</ept> 方法将该消息标记为“已使用”并将其从队列中删除。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>如果 <bpt id="p1">**</bpt>:peek_lock<ept id="p1">**</ept> 参数设置为 <bpt id="p2">**</bpt>false<ept id="p2">**</ept>，读取并删除消息将是最简单的模式，并且最适合在发生故障时应用程序允许不处理消息的情况。为了理解这一点，可以考虑这样一种情形：使用方发出接收请求，但在处理该请求前发生了崩溃。因为服务总线会将消息标记为“已使用”，所以在应用程序重新启动并开始再次使用消息时，它会遗漏在崩溃之前使用过的消息。</source>
          <target state="new">如果 <bpt id="p1">**</bpt>:peek_lock<ept id="p1">**</ept> 参数设置为 <bpt id="p2">**</bpt>false<ept id="p2">**</ept>，读取并删除消息将是最简单的模式，并且最适合在发生故障时应用程序允许不处理消息的情况。为了理解这一点，可以考虑这样一种情形：使用方发出接收请求，但在处理该请求前发生了崩溃。因为服务总线会将消息标记为“已使用”，所以在应用程序重新启动并开始再次使用消息时，它会遗漏在崩溃之前使用过的消息。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>以下示例演示了如何使用 <bpt id="p1">**</bpt>receive_queue_message()<ept id="p1">**</ept> 接收和处理消息。该示例先通过将 <bpt id="p2">**</bpt>:peek_lock<ept id="p2">**</ept> 设置为 <bpt id="p3">**</bpt>false<ept id="p3">**</ept> 接收并删除一条消息，然后再接收另一条消息，最后使用 <bpt id="p4">**</bpt>delete_queue_message()<ept id="p4">**</ept> 删除该消息：</source>
          <target state="new">以下示例演示了如何使用 <bpt id="p1">**</bpt>receive_queue_message()<ept id="p1">**</ept> 接收和处理消息。该示例先通过将 <bpt id="p2">**</bpt>:peek_lock<ept id="p2">**</ept> 设置为 <bpt id="p3">**</bpt>false<ept id="p3">**</ept> 接收并删除一条消息，然后再接收另一条消息，最后使用 <bpt id="p4">**</bpt>delete_queue_message()<ept id="p4">**</ept> 删除该消息：</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>如何处理应用程序崩溃和不可读消息</source>
          <target state="new">如何处理应用程序崩溃和不可读消息</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Service Bus 提供了相关功能来帮助你轻松地从应用程序错误或消息处理问题中恢复。如果接收方应用程序因某种原因无法处理消息，则它可以对 <bpt id="p1">**</bpt>Azure::ServiceBusService<ept id="p1">**</ept> 对象调用 <bpt id="p2">**</bpt>unlock\_queue\_message()<ept id="p2">**</ept> 方法。这将导致服务总线解锁队列中的消息并使其能够重新被同一个正在使用的应用程序或其他正在使用的应用程序接收。</source>
          <target state="new">Service Bus 提供了相关功能来帮助你轻松地从应用程序错误或消息处理问题中恢复。如果接收方应用程序因某种原因无法处理消息，则它可以对 <bpt id="p1">**</bpt>Azure::ServiceBusService<ept id="p1">**</ept> 对象调用 <bpt id="p2">**</bpt>unlock\_queue\_message()<ept id="p2">**</ept> 方法。这将导致服务总线解锁队列中的消息并使其能够重新被同一个正在使用的应用程序或其他正在使用的应用程序接收。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>还存在与队列中已锁定消息关联的超时，并且如果应用程序无法在锁定超时到期之前处理消息（例如，如果应用程序崩溃），服务总线将自动解锁该消息并使它可再次被接收。</source>
          <target state="new">还存在与队列中已锁定消息关联的超时，并且如果应用程序无法在锁定超时到期之前处理消息（例如，如果应用程序崩溃），服务总线将自动解锁该消息并使它可再次被接收。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>如果应用程序在处理消息之后，但在调用 <bpt id="p1">**</bpt>delete_queue_message()<ept id="p1">**</ept> 方法之前崩溃，则在应用程序重新启动时，该消息将重新传送给应用程序。此情况通常称作<bpt id="p2">**</bpt>至少处理一次<ept id="p2">**</ept>，即每条消息将至少被处理一次，但在某些情况下，同一消息可能会被重新传送。如果方案无法容忍重复处理，则应用程序开发人员应向其应用程序添加更多逻辑以处理重复消息传送。这通常可以通过使用消息的 <bpt id="p3">**</bpt>message_id<ept id="p3">**</ept> 属性来实现，该属性在多次传送尝试中保持不变。</source>
          <target state="new">如果应用程序在处理消息之后，但在调用 <bpt id="p1">**</bpt>delete_queue_message()<ept id="p1">**</ept> 方法之前崩溃，则在应用程序重新启动时，该消息将重新传送给应用程序。此情况通常称作<bpt id="p2">**</bpt>至少处理一次<ept id="p2">**</ept>，即每条消息将至少被处理一次，但在某些情况下，同一消息可能会被重新传送。如果方案无法容忍重复处理，则应用程序开发人员应向其应用程序添加更多逻辑以处理重复消息传送。这通常可以通过使用消息的 <bpt id="p3">**</bpt>message_id<ept id="p3">**</ept> 属性来实现，该属性在多次传送尝试中保持不变。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>现在，你已了解有关 Service Bus 队列的基础知识，单击下面的链接可了解更多信息。</source>
          <target state="new">现在，你已了解有关 Service Bus 队列的基础知识，单击下面的链接可了解更多信息。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>队列、主题和订阅<ept id="p1">](/documentation/articles/service-bus-queues-topics-subscriptions)</ept>的概述</source>
          <target state="new"><bpt id="p1">[</bpt>队列、主题和订阅<ept id="p1">](/documentation/articles/service-bus-queues-topics-subscriptions)</ept>的概述</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>访问 GitHub 上的 <bpt id="p1">[</bpt>Azure SDK for Ruby<ept id="p1">](https://github.com/WindowsAzure/azure-sdk-for-ruby)</ept> 存储库</source>
          <target state="new">访问 GitHub 上的 <bpt id="p1">[</bpt>Azure SDK for Ruby<ept id="p1">](https://github.com/WindowsAzure/azure-sdk-for-ruby)</ept> 存储库</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>有关本文中讨论的 Azure 服务总线队列与<bpt id="p1">[</bpt>如何使用 Azure 队列服务<ept id="p1">](/develop/ruby/)</ept>一文中讨论的 Azure 队列的比较，请参阅 <bpt id="p2">[</bpt>Azure 队列和 Azure 服务总线队列 - 比较与对照<ept id="p2">](/documentation/articles/service-bus-azure-and-service-bus-queues-compared-contrasted)</ept></source>
          <target state="new">有关本文中讨论的 Azure 服务总线队列与<bpt id="p1">[</bpt>如何使用 Azure 队列服务<ept id="p1">](/develop/ruby/)</ept>一文中讨论的 Azure 队列的比较，请参阅 <bpt id="p2">[</bpt>Azure 队列和 Azure 服务总线队列 - 比较与对照<ept id="p2">](/documentation/articles/service-bus-azure-and-service-bus-queues-compared-contrasted)</ept></target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>