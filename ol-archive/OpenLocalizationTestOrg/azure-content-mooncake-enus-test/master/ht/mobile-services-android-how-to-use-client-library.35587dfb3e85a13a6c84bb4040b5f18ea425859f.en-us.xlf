<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5821e9989d0ab71be45aacbc5581da371ab9ac29</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>使用移动服务 Android 客户端库</source>
          <target state="new">使用移动服务 Android 客户端库</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何使用适用于 Azure 移动服务的 Android 客户端。</source>
          <target state="new">了解如何使用适用于 Azure 移动服务的 Android 客户端。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何使用适用于移动服务的 Android 客户端库</source>
          <target state="new">如何使用适用于移动服务的 Android 客户端库</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;</source>
          <target state="new">&amp;nbsp;</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本指南说明如何使用适用于 Azure 移动服务的 Android 客户端执行常见任务。所述的任务包括：查询数据；插入、更新和删除数据；对用户进行身份验证；处理错误；自定义客户端。</source>
          <target state="new">本指南说明如何使用适用于 Azure 移动服务的 Android 客户端执行常见任务。所述的任务包括：查询数据；插入、更新和删除数据；对用户进行身份验证；处理错误；自定义客户端。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>如果你移动服务的新手，应该先完成<bpt id="p1">[</bpt><ept id="p1">移动服务入门]</ept>教程。成功完成该教程可确保你会安装 Android Studio；该软件可帮助你配置帐户并创建第一个移动服务，安装支持 Android 2.2 或更高版本的移动服务 SDK，但我们建议你针对 Android 4.2 或更高版本进行生成。</source>
          <target state="new">如果你移动服务的新手，应该先完成<bpt id="p1">[</bpt><ept id="p1">移动服务入门]</ept>教程。成功完成该教程可确保你会安装 Android Studio；该软件可帮助你配置帐户并创建第一个移动服务，安装支持 Android 2.2 或更高版本的移动服务 SDK，但我们建议你针对 Android 4.2 或更高版本进行生成。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="setup"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>安装与先决条件</source>
          <target state="new"><ph id="ph1">&lt;a name="setup"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>安装与先决条件</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>假设你已创建一个移动服务和一个表。有关详细信息，请参阅<bpt id="p1">[</bpt>创建表<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/azure/jj193162.aspx)</ept>。在本主题使用的代码中，我们假设表的名称为 <bpt id="p2">*</bpt>ToDoItem<ept id="p2">*</ept>，其中包含以下列：</source>
          <target state="new">假设你已创建一个移动服务和一个表。有关详细信息，请参阅<bpt id="p1">[</bpt>创建表<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/azure/jj193162.aspx)</ept>。在本主题使用的代码中，我们假设表的名称为 <bpt id="p2">*</bpt>ToDoItem<ept id="p2">*</ept>，其中包含以下列：</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>ID</source>
          <target state="new">ID</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>text</source>
          <target state="new">text</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>complete</source>
          <target state="new">complete</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>相应的类型化客户端对象如下：</source>
          <target state="new">相应的类型化客户端对象如下：</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>启用动态架构后，Azure 移动服务将基于 insert 或 update 请求中的对象自动生成新列。有关详细信息，请参阅<bpt id="p1">[</bpt>动态架构<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/azure/jj193175.aspx)</ept>。</source>
          <target state="new">启用动态架构后，Azure 移动服务将基于 insert 或 update 请求中的对象自动生成新列。有关详细信息，请参阅<bpt id="p1">[</bpt>动态架构<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/azure/jj193175.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="create-client"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何创建移动服务客户端</source>
          <target state="new"><ph id="ph1">&lt;a name="create-client"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何创建移动服务客户端</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>以下代码将创建用于访问移动服务的 <bpt id="p1">[</bpt>MobileServiceClient<ept id="p1">](http://dl.windowsazure.com/androiddocs/com/microsoft/windowsazure/mobileservices/MobileServiceClient.html)</ept> 对象。代码会进入在 <bpt id="p2">*</bpt>AndroidManifest.xml<ept id="p2">*</ept> 中指定为 <bpt id="p3">**</bpt>MAIN<ept id="p3">**</ept> 操作和 <bpt id="p4">**</bpt>LAUNCHER<ept id="p4">**</ept> 类别的 Activity 类的 <ph id="ph1">`onCreate`</ph> 方法。</source>
          <target state="new">以下代码将创建用于访问移动服务的 <bpt id="p1">[</bpt>MobileServiceClient<ept id="p1">](http://dl.windowsazure.com/androiddocs/com/microsoft/windowsazure/mobileservices/MobileServiceClient.html)</ept> 对象。代码会进入在 <bpt id="p2">*</bpt>AndroidManifest.xml<ept id="p2">*</ept> 中指定为 <bpt id="p3">**</bpt>MAIN<ept id="p3">**</ept> 操作和 <bpt id="p4">**</bpt>LAUNCHER<ept id="p4">**</ept> 类别的 Activity 类的 <ph id="ph1">`onCreate`</ph> 方法。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>在上面的代码中，请将 <ph id="ph1">`MobileServiceUrl`</ph> 和 <ph id="ph2">`AppKey`</ph> 依次替换为移动服务 URL 和应用程序密钥。在 Azure 经典门户中选择你的移动服务，然后单击“仪表板”即可获取这两个值。</source>
          <target state="new">在上面的代码中，请将 <ph id="ph1">`MobileServiceUrl`</ph> 和 <ph id="ph2">`AppKey`</ph> 依次替换为移动服务 URL 和应用程序密钥。在 Azure 经典门户中选择你的移动服务，然后单击“仪表板”即可获取这两个值。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="instantiating"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何创建表引用</source>
          <target state="new"><ph id="ph1">&lt;a name="instantiating"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何创建表引用</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>在移动服务中查询或修改数据的最简单方法就是使用<bpt id="p1">*</bpt>类型化编程模型<ept id="p1">*</ept>，因为 Java 是强类型化语言（稍后我们将会介绍<bpt id="p2">*</bpt>非类型化<ept id="p2">*</ept>模型）。在客户端和移动服务之间发送数据时，此模型使用 <bpt id="p3">[</bpt>gson<ept id="p3">](http://go.microsoft.com/fwlink/p/?LinkId=290801)</ept> 库提供对 JSON 的无缝序列化和反序列化：开发人员无需执行任何操作，该框架将处理一切。</source>
          <target state="new">在移动服务中查询或修改数据的最简单方法就是使用<bpt id="p1">*</bpt>类型化编程模型<ept id="p1">*</ept>，因为 Java 是强类型化语言（稍后我们将会介绍<bpt id="p2">*</bpt>非类型化<ept id="p2">*</ept>模型）。在客户端和移动服务之间发送数据时，此模型使用 <bpt id="p3">[</bpt>gson<ept id="p3">](http://go.microsoft.com/fwlink/p/?LinkId=290801)</ept> 库提供对 JSON 的无缝序列化和反序列化：开发人员无需执行任何操作，该框架将处理一切。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>查询或修改数据所要执行的第一项操作就是通过对 <bpt id="p1">**</bpt>MobileServiceClient<ept id="p1">**</ept> 调用 <bpt id="p2">**</bpt>getTable<ept id="p2">**</ept> 方法来创建一个 <bpt id="p3">**</bpt>MobileServiceTable<ept id="p3">**</ept> 对象。下面是此方法的两个重载：</source>
          <target state="new">查询或修改数据所要执行的第一项操作就是通过对 <bpt id="p1">**</bpt>MobileServiceClient<ept id="p1">**</ept> 调用 <bpt id="p2">**</bpt>getTable<ept id="p2">**</ept> 方法来创建一个 <bpt id="p3">**</bpt>MobileServiceTable<ept id="p3">**</ept> 对象。下面是此方法的两个重载：</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>在以下代码中，<bpt id="p1">*</bpt>mClient<ept id="p1">*</ept> 是对移动服务客户端的引用。</source>
          <target state="new">在以下代码中，<bpt id="p1">*</bpt>mClient<ept id="p1">*</ept> 是对移动服务客户端的引用。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>如果类名称与表名称相同，则使用<bpt id="p1">**</bpt>第一个重载<ept id="p1">**</ept>：</source>
          <target state="new">如果类名称与表名称相同，则使用<bpt id="p1">**</bpt>第一个重载<ept id="p1">**</ept>：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>如果表名称与类型名称不同，则使用<bpt id="p1">**</bpt>第二个重载<ept id="p1">**</ept>。</source>
          <target state="new">如果表名称与类型名称不同，则使用<bpt id="p1">**</bpt>第二个重载<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="api"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>API 结构</source>
          <target state="new"><ph id="ph1">&lt;a name="api"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>API 结构</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>从 2.0 版客户端库开始，移动服务表操作将在所有异步作业（例如涉及查询的方法）和操作（例如插入、更新和删除）中使用 <bpt id="p1">[</bpt>Future<ept id="p1">](http://developer.android.com/reference/java/util/concurrent/Future.html)</ept> 和 <bpt id="p2">[</bpt>AsyncTask<ept id="p2">](http://developer.android.com/reference/android/os/AsyncTask.html)</ept> 对象。这就可以更方便地（在后台线程上）执行多个操作，而无需处理多个嵌套回调。</source>
          <target state="new">从 2.0 版客户端库开始，移动服务表操作将在所有异步作业（例如涉及查询的方法）和操作（例如插入、更新和删除）中使用 <bpt id="p1">[</bpt>Future<ept id="p1">](http://developer.android.com/reference/java/util/concurrent/Future.html)</ept> 和 <bpt id="p2">[</bpt>AsyncTask<ept id="p2">](http://developer.android.com/reference/android/os/AsyncTask.html)</ept> 对象。这就可以更方便地（在后台线程上）执行多个操作，而无需处理多个嵌套回调。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="querying"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何从移动服务查询数据</source>
          <target state="new"><ph id="ph1">&lt;a name="querying"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何从移动服务查询数据</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>本部分介绍如何向移动服务发出查询。其中的小节介绍了排序、筛选和分页等不同操作。最后，我们将介绍如何将这些操作连接起来。</source>
          <target state="new">本部分介绍如何向移动服务发出查询。其中的小节介绍了排序、筛选和分页等不同操作。最后，我们将介绍如何将这些操作连接起来。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="showAll"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何返回表中的所有项</source>
          <target state="new"><ph id="ph1">&lt;a name="showAll"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何返回表中的所有项</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>以下代码将返回 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 表中的所有项。它会通过将项添加到适配器在 UI 中显示这些项。此代码类似于<bpt id="p2">[</bpt><ept id="p2">移动服务快速入门]</ept>教程中的内容。</source>
          <target state="new">以下代码将返回 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 表中的所有项。它会通过将项添加到适配器在 UI 中显示这些项。此代码类似于<bpt id="p2">[</bpt><ept id="p2">移动服务快速入门]</ept>教程中的内容。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>与此类似的查询使用 <bpt id="p1">[</bpt>AsyncTask<ept id="p1">](http://developer.android.com/reference/android/os/AsyncTask.html)</ept> 对象。</source>
          <target state="new">与此类似的查询使用 <bpt id="p1">[</bpt>AsyncTask<ept id="p1">](http://developer.android.com/reference/android/os/AsyncTask.html)</ept> 对象。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>result<ept id="p1">*</ept> 变量返回查询的结果，<ph id="ph1">`mToDoTable.execute().get()`</ph> 语句后面的代码演示如何显示单个行。</source>
          <target state="new"><bpt id="p1">*</bpt>result<ept id="p1">*</ept> 变量返回查询的结果，<ph id="ph1">`mToDoTable.execute().get()`</ph> 语句后面的代码演示如何显示单个行。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="filtering"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何筛选返回的数据</source>
          <target state="new"><ph id="ph1">&lt;a name="filtering"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何筛选返回的数据</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>以下代码将返回 <bpt id="p1">*</bpt>complete<ept id="p1">*</ept> 字段等于 <bpt id="p2">*</bpt>false<ept id="p2">*</ept> 的 <bpt id="p3">*</bpt>ToDoItem<ept id="p3">*</ept> 表中的所有项。<bpt id="p4">*</bpt>mToDoTable<ept id="p4">*</ept> 是对前面创建的移动服务表的引用。</source>
          <target state="new">以下代码将返回 <bpt id="p1">*</bpt>complete<ept id="p1">*</ept> 字段等于 <bpt id="p2">*</bpt>false<ept id="p2">*</ept> 的 <bpt id="p3">*</bpt>ToDoItem<ept id="p3">*</ept> 表中的所有项。<bpt id="p4">*</bpt>mToDoTable<ept id="p4">*</ept> 是对前面创建的移动服务表的引用。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>通过对表引用执行 <bpt id="p1">**</bpt>where<ept id="p1">**</ept> 方法调用来启动筛选器。然后，依次执行 <bpt id="p2">**</bpt>field<ept id="p2">**</ept> 方法调用和用于指定逻辑谓词的方法调用。可能的谓词方法包括 <bpt id="p3">**</bpt>eq<ept id="p3">**</ept>、<bpt id="p4">**</bpt>ne<ept id="p4">**</ept>、<bpt id="p5">**</bpt>gt<ept id="p5">**</ept>、<bpt id="p6">**</bpt>ge<ept id="p6">**</ept>、<bpt id="p7">**</bpt>lt<ept id="p7">**</ept>、<bpt id="p8">**</bpt>le<ept id="p8">**</ept> 等。</source>
          <target state="new">通过对表引用执行 <bpt id="p1">**</bpt>where<ept id="p1">**</ept> 方法调用来启动筛选器。然后，依次执行 <bpt id="p2">**</bpt>field<ept id="p2">**</ept> 方法调用和用于指定逻辑谓词的方法调用。可能的谓词方法包括 <bpt id="p3">**</bpt>eq<ept id="p3">**</ept>、<bpt id="p4">**</bpt>ne<ept id="p4">**</ept>、<bpt id="p5">**</bpt>gt<ept id="p5">**</ept>、<bpt id="p6">**</bpt>ge<ept id="p6">**</ept>、<bpt id="p7">**</bpt>lt<ept id="p7">**</ept>、<bpt id="p8">**</bpt>le<ept id="p8">**</ept> 等。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>执行这些操作便足以将数字和字符串字段与特定值进行比较。不过，你还可以执行其他许多操作。</source>
          <target state="new">执行这些操作便足以将数字和字符串字段与特定值进行比较。不过，你还可以执行其他许多操作。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>例如，你可以按日期筛选。你可以比较整个日期字段，或者使用 <bpt id="p1">**</bpt>year<ept id="p1">**</ept>、<bpt id="p2">**</bpt>month<ept id="p2">**</ept>、<bpt id="p3">**</bpt>day<ept id="p3">**</ept>、<bpt id="p4">**</bpt>hour<ept id="p4">**</ept>、<bpt id="p5">**</bpt>minute<ept id="p5">**</ept>和<bpt id="p6">**</bpt>second<ept id="p6">**</ept>等方法比较日期的一部分。以下代码片段将会针对“截止日期”等于 2013 的项添加一个筛选器。</source>
          <target state="new">例如，你可以按日期筛选。你可以比较整个日期字段，或者使用 <bpt id="p1">**</bpt>year<ept id="p1">**</ept>、<bpt id="p2">**</bpt>month<ept id="p2">**</ept>、<bpt id="p3">**</bpt>day<ept id="p3">**</ept>、<bpt id="p4">**</bpt>hour<ept id="p4">**</ept>、<bpt id="p5">**</bpt>minute<ept id="p5">**</ept>和<bpt id="p6">**</bpt>second<ept id="p6">**</ept>等方法比较日期的一部分。以下代码片段将会针对“截止日期”等于 2013 的项添加一个筛选器。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>你可以使用 <bpt id="p1">**</bpt>startsWith<ept id="p1">**</ept>、<bpt id="p2">**</bpt>endsWith<ept id="p2">**</ept>、<bpt id="p3">**</bpt>concat<ept id="p3">**</ept>、<bpt id="p4">**</bpt>subString<ept id="p4">**</ept>、<bpt id="p5">**</bpt>indexOf<ept id="p5">**</ept>、<bpt id="p6">**</bpt>replace<ept id="p6">**</ept>、<bpt id="p7">**</bpt>toLower<ept id="p7">**</ept>、<bpt id="p8">**</bpt>toUpper<ept id="p8">**</ept>、<bpt id="p9">**</bpt>trim<ept id="p9">**</ept>和<bpt id="p10">**</bpt>length<ept id="p10">**</ept>等方法对字符串字段运行各种复杂筛选器。以下代码片段将会筛选 <bpt id="p11">*</bpt>text<ept id="p11">*</ept> 列以“PRI0”开头的表行。</source>
          <target state="new">你可以使用 <bpt id="p1">**</bpt>startsWith<ept id="p1">**</ept>、<bpt id="p2">**</bpt>endsWith<ept id="p2">**</ept>、<bpt id="p3">**</bpt>concat<ept id="p3">**</ept>、<bpt id="p4">**</bpt>subString<ept id="p4">**</ept>、<bpt id="p5">**</bpt>indexOf<ept id="p5">**</ept>、<bpt id="p6">**</bpt>replace<ept id="p6">**</ept>、<bpt id="p7">**</bpt>toLower<ept id="p7">**</ept>、<bpt id="p8">**</bpt>toUpper<ept id="p8">**</ept>、<bpt id="p9">**</bpt>trim<ept id="p9">**</ept>和<bpt id="p10">**</bpt>length<ept id="p10">**</ept>等方法对字符串字段运行各种复杂筛选器。以下代码片段将会筛选 <bpt id="p11">*</bpt>text<ept id="p11">*</ept> 列以“PRI0”开头的表行。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>还允许使用  <bpt id="p1">**</bpt>add<ept id="p1">**</ept>、<bpt id="p2">**</bpt>sub<ept id="p2">**</ept>、<bpt id="p3">**</bpt>mul<ept id="p3">**</ept>、<bpt id="p4">**</bpt>div<ept id="p4">**</ept>、<bpt id="p5">**</bpt>mod<ept id="p5">**</ept>、<bpt id="p6">**</bpt>floor<ept id="p6">**</ept>、<bpt id="p7">**</bpt>ceiling<ept id="p7">**</ept>和<bpt id="p8">**</bpt>round<ept id="p8">**</ept> 等方法对数字字段运行各种更复杂的筛选器。以下代码片段将会筛选其中的 <bpt id="p9">*</bpt>duration<ept id="p9">*</ept> 为偶数的表行。</source>
          <target state="new">还允许使用  <bpt id="p1">**</bpt>add<ept id="p1">**</ept>、<bpt id="p2">**</bpt>sub<ept id="p2">**</ept>、<bpt id="p3">**</bpt>mul<ept id="p3">**</ept>、<bpt id="p4">**</bpt>div<ept id="p4">**</ept>、<bpt id="p5">**</bpt>mod<ept id="p5">**</ept>、<bpt id="p6">**</bpt>floor<ept id="p6">**</ept>、<bpt id="p7">**</bpt>ceiling<ept id="p7">**</ept>和<bpt id="p8">**</bpt>round<ept id="p8">**</ept> 等方法对数字字段运行各种更复杂的筛选器。以下代码片段将会筛选其中的 <bpt id="p9">*</bpt>duration<ept id="p9">*</ept> 为偶数的表行。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>你可以使用 <bpt id="p1">**</bpt>and<ept id="p1">**</ept>、<bpt id="p2">**</bpt>or<ept id="p2">**</ept>和<bpt id="p3">**</bpt>not<ept id="p3">**</ept> 等方法来组合谓词。以下代码片段将组合上面的两个示例。</source>
          <target state="new">你可以使用 <bpt id="p1">**</bpt>and<ept id="p1">**</ept>、<bpt id="p2">**</bpt>or<ept id="p2">**</ept>和<bpt id="p3">**</bpt>not<ept id="p3">**</ept> 等方法来组合谓词。以下代码片段将组合上面的两个示例。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>你可以按照以下代码片段所示来组合与嵌套逻辑运算符：</source>
          <target state="new">你可以按照以下代码片段所示来组合与嵌套逻辑运算符：</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>有关筛选操作的更详细介绍和示例，请参阅<bpt id="p1">[</bpt>了解移动服务 Android 客户端查询模型的丰富功能<ept id="p1">](http://hashtagfail.com/post/46493261719/mobile-services-android-querying)</ept>。</source>
          <target state="new">有关筛选操作的更详细介绍和示例，请参阅<bpt id="p1">[</bpt>了解移动服务 Android 客户端查询模型的丰富功能<ept id="p1">](http://hashtagfail.com/post/46493261719/mobile-services-android-querying)</ept>。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="sorting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何为返回的数据排序</source>
          <target state="new"><ph id="ph1">&lt;a name="sorting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何为返回的数据排序</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>以下代码将返回 <bpt id="p1">*</bpt>ToDoItems<ept id="p1">*</ept> 表中的所有项，返回的结果已按 <bpt id="p2">*</bpt>text<ept id="p2">*</ept> 字段的升序排序。<bpt id="p3">*</bpt>mToDoTable<ept id="p3">*</ept> 是对前面创建的移动服务表的引用。</source>
          <target state="new">以下代码将返回 <bpt id="p1">*</bpt>ToDoItems<ept id="p1">*</ept> 表中的所有项，返回的结果已按 <bpt id="p2">*</bpt>text<ept id="p2">*</ept> 字段的升序排序。<bpt id="p3">*</bpt>mToDoTable<ept id="p3">*</ept> 是对前面创建的移动服务表的引用。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>orderBy<ept id="p1">**</ept> 方法的第一个参数是与要排序的字段名称相同的字符串。</source>
          <target state="new"><bpt id="p1">**</bpt>orderBy<ept id="p1">**</ept> 方法的第一个参数是与要排序的字段名称相同的字符串。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>第二个参数使用 <bpt id="p1">**</bpt>QueryOrder<ept id="p1">**</ept> 枚举来指定是按升序还是按降序排序。</source>
          <target state="new">第二个参数使用 <bpt id="p1">**</bpt>QueryOrder<ept id="p1">**</ept> 枚举来指定是按升序还是按降序排序。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>请注意，如果你使用 <bpt id="p1">***</bpt>where<ept id="p1">***</ept> 方法筛选，则必须在调用 <bpt id="p2">***</bpt>orderBy<ept id="p2">***</ept> 方法之前调用 <bpt id="p3">***</bpt>where<ept id="p3">***</ept> 方法。</source>
          <target state="new">请注意，如果你使用 <bpt id="p1">***</bpt>where<ept id="p1">***</ept> 方法筛选，则必须在调用 <bpt id="p2">***</bpt>orderBy<ept id="p2">***</ept> 方法之前调用 <bpt id="p3">***</bpt>where<ept id="p3">***</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="paging"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在页中返回数据</source>
          <target state="new"><ph id="ph1">&lt;a name="paging"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在页中返回数据</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>第一个示例演示了如何选择表中的前 5 个项。该查询将返回 <bpt id="p1">*</bpt>ToDoItems<ept id="p1">*</ept> 表中的项。<bpt id="p2">*</bpt>mToDoTable<ept id="p2">*</ept> 是对前面创建的移动服务表的引用。</source>
          <target state="new">第一个示例演示了如何选择表中的前 5 个项。该查询将返回 <bpt id="p1">*</bpt>ToDoItems<ept id="p1">*</ept> 表中的项。<bpt id="p2">*</bpt>mToDoTable<ept id="p2">*</ept> 是对前面创建的移动服务表的引用。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>接下来，我们定义一个查询，以跳过前 5 个项，返回后 5 个项。</source>
          <target state="new">接下来，我们定义一个查询，以跳过前 5 个项，返回后 5 个项。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="selecting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何选择特定的列</source>
          <target state="new"><ph id="ph1">&lt;a name="selecting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何选择特定的列</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>以下代码演示如何返回 <bpt id="p1">*</bpt>ToDoItems<ept id="p1">*</ept> 表中的所有项，但只显示 <bpt id="p2">*</bpt>complete<ept id="p2">*</ept> 和 <bpt id="p3">*</bpt>text<ept id="p3">*</ept> 字段。<bpt id="p4">*</bpt>mToDoTable<ept id="p4">*</ept> 是对前面创建的移动服务表的引用。</source>
          <target state="new">以下代码演示如何返回 <bpt id="p1">*</bpt>ToDoItems<ept id="p1">*</ept> 表中的所有项，但只显示 <bpt id="p2">*</bpt>complete<ept id="p2">*</ept> 和 <bpt id="p3">*</bpt>text<ept id="p3">*</ept> 字段。<bpt id="p4">*</bpt>mToDoTable<ept id="p4">*</ept> 是对前面创建的移动服务表的引用。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>在这里，select 函数的参数是要返回的表列的字符串名称。</source>
          <target state="new">在这里，select 函数的参数是要返回的表列的字符串名称。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>select<ept id="p1">**</ept> 方法需接在 <bpt id="p2">**</bpt>where<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>orderBy<ept id="p3">**</ept> 等方法（如果存在）的后面。它可以后接 <bpt id="p4">**</bpt>top<ept id="p4">**</ept> 等方法。</source>
          <target state="new"><bpt id="p1">**</bpt>select<ept id="p1">**</ept> 方法需接在 <bpt id="p2">**</bpt>where<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>orderBy<ept id="p3">**</ept> 等方法（如果存在）的后面。它可以后接 <bpt id="p4">**</bpt>top<ept id="p4">**</ept> 等方法。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="chaining"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何连接查询方法</source>
          <target state="new"><ph id="ph1">&lt;a name="chaining"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何连接查询方法</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>可以连接用于查询移动服务表的方法。这样，你便可以执行多种操作，例如，选择已排序并分页的筛选行的特定列。你可以创建相当复杂的逻辑筛选器。</source>
          <target state="new">可以连接用于查询移动服务表的方法。这样，你便可以执行多种操作，例如，选择已排序并分页的筛选行的特定列。你可以创建相当复杂的逻辑筛选器。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>这种操作的工作原理是通过使用的查询方法返回 <bpt id="p1">**</bpt>MobileServiceQuery&amp;lt;T&amp;gt;<ept id="p1">**</ept> 对象，随之又对这些对象调用更多的方法。若要结束方法序列并真正运行查询，你可以调用 <bpt id="p2">**</bpt>execute<ept id="p2">**</ept> 方法。</source>
          <target state="new">这种操作的工作原理是通过使用的查询方法返回 <bpt id="p1">**</bpt>MobileServiceQuery&amp;lt;T&amp;gt;<ept id="p1">**</ept> 对象，随之又对这些对象调用更多的方法。若要结束方法序列并真正运行查询，你可以调用 <bpt id="p2">**</bpt>execute<ept id="p2">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>在以下代码示例中，<bpt id="p1">*</bpt>mToDoTable<ept id="p1">*</ept> 是对移动服务 <bpt id="p2">*</bpt>ToDoItem<ept id="p2">*</ept> 表的引用。</source>
          <target state="new">在以下代码示例中，<bpt id="p1">*</bpt>mToDoTable<ept id="p1">*</ept> 是对移动服务 <bpt id="p2">*</bpt>ToDoItem<ept id="p2">*</ept> 表的引用。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>将方法链接在一起时，最重要的是 <bpt id="p1">*</bpt>where<ept id="p1">*</ept> 方法和谓词必须出现在最前面。然后，你就可以按照最符合应用程序需求的顺序调用后续方法。</source>
          <target state="new">将方法链接在一起时，最重要的是 <bpt id="p1">*</bpt>where<ept id="p1">*</ept> 方法和谓词必须出现在最前面。然后，你就可以按照最符合应用程序需求的顺序调用后续方法。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="inserting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中插入数据</source>
          <target state="new"><ph id="ph1">&lt;a name="inserting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中插入数据</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何在表中插入新行。</source>
          <target state="new">以下代码演示了如何在表中插入新行。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>首先，实例化 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 类的实例并设置该实例的属性。</source>
          <target state="new">首先，实例化 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 类的实例并设置该实例的属性。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>接着执行以下代码：</source>
          <target state="new">接着执行以下代码：</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>此代码将插入新项，并将其添加到适配器以便在 UI 中显示。</source>
          <target state="new">此代码将插入新项，并将其添加到适配器以便在 UI 中显示。</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>移动服务支持为表 ID 使用唯一的自定义字符串值。这样，应用程序便可为移动服务表的 ID 列使用自定义值（如电子邮件地址或用户名）。例如，如果你想要根据电子邮件地址识别每条记录，可以使用以下 JSON 对象。</source>
          <target state="new">移动服务支持为表 ID 使用唯一的自定义字符串值。这样，应用程序便可为移动服务表的 ID 列使用自定义值（如电子邮件地址或用户名）。例如，如果你想要根据电子邮件地址识别每条记录，可以使用以下 JSON 对象。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>如果将新记录插入到表时未提供字符串 ID 值，移动服务将为 ID 生成唯一值。</source>
          <target state="new">如果将新记录插入到表时未提供字符串 ID 值，移动服务将为 ID 生成唯一值。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>支持字符串 ID 为开发人员带来了以下优势</source>
          <target state="new">支持字符串 ID 为开发人员带来了以下优势</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>无需往返访问数据库即可生成 ID。</source>
          <target state="new">无需往返访问数据库即可生成 ID。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>更方便地合并不同表或数据库中的记录。</source>
          <target state="new">更方便地合并不同表或数据库中的记录。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>ID 值能够更好地与应用程序的逻辑相集成。</source>
          <target state="new">ID 值能够更好地与应用程序的逻辑相集成。</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>你也可以使用服务器脚本来设置 ID 值。下面的脚本示例将生成一个自定义 GUID 并将其分配给新记录的 ID。此 ID 类似于你未传入记录的 ID 值时，移动服务生成的 ID 值。</source>
          <target state="new">你也可以使用服务器脚本来设置 ID 值。下面的脚本示例将生成一个自定义 GUID 并将其分配给新记录的 ID。此 ID 类似于你未传入记录的 ID 值时，移动服务生成的 ID 值。</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>如果应用程序提供了某个 ID 的值，移动服务将按原样存储该值，包括前导和尾随空格。不会从值中裁剪掉空格。</source>
          <target state="new">如果应用程序提供了某个 ID 的值，移动服务将按原样存储该值，包括前导和尾随空格。不会从值中裁剪掉空格。</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`id`</ph> 的值必须唯一，并且不能包含以下集中的字符：</source>
          <target state="new"><ph id="ph1">`id`</ph> 的值必须唯一，并且不能包含以下集中的字符：</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>控制字符：[0x0000-0x001F] 和 [0x007F-0x009F]。有关详细信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">ASCII 控制代码 C0 和 C1]</ept>。</source>
          <target state="new">控制字符：[0x0000-0x001F] 和 [0x007F-0x009F]。有关详细信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">ASCII 控制代码 C0 和 C1]</ept>。</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>可打印字符：<bpt id="p1">**</bpt>"<ept id="p1">**</ept>(0x0022), <bpt id="p2">**</bpt>+<ept id="p2">**</ept> (0x002B), <bpt id="p3">**</bpt>/<ept id="p3">**</ept> (0x002F), <bpt id="p4">**</bpt>?<ept id="p4">**</ept></source>
          <target state="new">可打印字符：<bpt id="p1">**</bpt>"<ept id="p1">**</ept>(0x0022), <bpt id="p2">**</bpt>+<ept id="p2">**</ept> (0x002B), <bpt id="p3">**</bpt>/<ept id="p3">**</ept> (0x002F), <bpt id="p4">**</bpt>?<ept id="p4">**</ept></target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>(0x003F), *<bpt id="p1">*</bpt>\*<ept id="p1">*</ept> (0x005C), <bpt id="p2">**</bpt>`<ept id="p2">**</ept> (0x0060)</source>
          <target state="new">(0x003F), *<bpt id="p1">*</bpt>\*<ept id="p1">*</ept> (0x005C), <bpt id="p2">**</bpt>`<ept id="p2">**</ept> (0x0060)</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>ID“.”和“..”</source>
          <target state="new">ID“.”和“..”</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>也可以为表使用整数 ID。若要使用整数 ID，必须使用 <ph id="ph1">`mobile table create`</ph> 命令并结合 <ph id="ph2">`--integerId`</ph> 选项创建表。应在适用于 Azure 的命令行界面 (CLI) 中使用此命令。有关使用 CLI 的详细信息，请参阅 [用于管理移动服务表的 CLI]。</source>
          <target state="new">也可以为表使用整数 ID。若要使用整数 ID，必须使用 <ph id="ph1">`mobile table create`</ph> 命令并结合 <ph id="ph2">`--integerId`</ph> 选项创建表。应在适用于 Azure 的命令行界面 (CLI) 中使用此命令。有关使用 CLI 的详细信息，请参阅 [用于管理移动服务表的 CLI]。</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="updating"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中更新数据</source>
          <target state="new"><ph id="ph1">&lt;a name="updating"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中更新数据</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何更新表中的数据。在此示例中，<bpt id="p1">*</bpt>item<ept id="p1">*</ept> 是对 <bpt id="p2">*</bpt>ToDoItem<ept id="p2">*</ept> 表中某个行的引用，该表包含一些更改。以下方法会更新表和 UI 适配器。</source>
          <target state="new">以下代码演示了如何更新表中的数据。在此示例中，<bpt id="p1">*</bpt>item<ept id="p1">*</ept> 是对 <bpt id="p2">*</bpt>ToDoItem<ept id="p2">*</ept> 表中某个行的引用，该表包含一些更改。以下方法会更新表和 UI 适配器。</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="deleting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中删除数据</source>
          <target state="new"><ph id="ph1">&lt;a name="deleting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中删除数据</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何删除表中的数据。该代码会从 ToDoItem 表中将 UI 上已选中“已完成”复选框的现有项删除。</source>
          <target state="new">以下代码演示了如何删除表中的数据。该代码会从 ToDoItem 表中将 UI 上已选中“已完成”复选框的现有项删除。</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>以下代码演示了执行删除操作的另一种方法。该代码通过指定要删除的行的 ID 字段值（假设等于 "2FA404AB-E458-44CD-BC1B-3BC847EF0902"）来删除 ToDoItem 表中的现有项。在实际的应用程序中，你会以某种方式获取 ID，并将它作为变量传入。此处为了简化测试，你可以在 Azure 经典门户中转到你的服务，单击“数据”并复制你要测试的 ID。</source>
          <target state="new">以下代码演示了执行删除操作的另一种方法。该代码通过指定要删除的行的 ID 字段值（假设等于 "2FA404AB-E458-44CD-BC1B-3BC847EF0902"）来删除 ToDoItem 表中的现有项。在实际的应用程序中，你会以某种方式获取 ID，并将它作为变量传入。此处为了简化测试，你可以在 Azure 经典门户中转到你的服务，单击“数据”并复制你要测试的 ID。</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="lookup"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何查找特定的项</source>
          <target state="new"><ph id="ph1">&lt;a name="lookup"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何查找特定的项</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>有时，你需要按 <bpt id="p1">*</bpt>id<ept id="p1">*</ept> 查找特定的项，这一点不像查询，因为查询通常会返回满足某些条件的项集合。以下代码演示了如何执行此作业，此处假设 <bpt id="p2">*</bpt>id<ept id="p2">*</ept> 值为 <ph id="ph1">`0380BAFB-BCFF-443C-B7D5-30199F730335`</ph>。在实际的应用程序中，你会以某种方式获取 ID，并将它作为变量传入。此处为了简化测试，你可以在 Azure 经典门户中转到你的服务，单击“数据”选项卡并复制你要测试的 ID。</source>
          <target state="new">有时，你需要按 <bpt id="p1">*</bpt>id<ept id="p1">*</ept> 查找特定的项，这一点不像查询，因为查询通常会返回满足某些条件的项集合。以下代码演示了如何执行此作业，此处假设 <bpt id="p2">*</bpt>id<ept id="p2">*</ept> 值为 <ph id="ph1">`0380BAFB-BCFF-443C-B7D5-30199F730335`</ph>。在实际的应用程序中，你会以某种方式获取 ID，并将它作为变量传入。此处为了简化测试，你可以在 Azure 经典门户中转到你的服务，单击“数据”选项卡并复制你要测试的 ID。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="untyped"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何处理非类型化数据</source>
          <target state="new"><ph id="ph1">&lt;a name="untyped"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何处理非类型化数据</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>使用非类型化编程模型可以全面控制 JSON 序列化，在某些情况下，你可能想要使用该模型。例如，你的移动服务表包含大量的列，而你只需要引用其中的某些列。使用类型化模型需要在数据类中定义移动服务表的所有列。但如果使用非类型化模型，只需定义你要使用的列。</source>
          <target state="new">使用非类型化编程模型可以全面控制 JSON 序列化，在某些情况下，你可能想要使用该模型。例如，你的移动服务表包含大量的列，而你只需要引用其中的某些列。使用类型化模型需要在数据类中定义移动服务表的所有列。但如果使用非类型化模型，只需定义你要使用的列。</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>用于访问数据的大多数 API 调用都与类型化编程调用类似。主要差别在于，在非类型化模型中，你要对 <bpt id="p1">**</bpt>MobileServiceJsonTable<ept id="p1">**</ept> 对象而不是 <bpt id="p2">**</bpt>MobileServiceTable<ept id="p2">**</ept> 对象调用方法。</source>
          <target state="new">用于访问数据的大多数 API 调用都与类型化编程调用类似。主要差别在于，在非类型化模型中，你要对 <bpt id="p1">**</bpt>MobileServiceJsonTable<ept id="p1">**</ept> 对象而不是 <bpt id="p2">**</bpt>MobileServiceTable<ept id="p2">**</ept> 对象调用方法。</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="json_instance"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何创建非类型化表的实例</source>
          <target state="new"><ph id="ph1">&lt;a name="json_instance"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何创建非类型化表的实例</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>与使用类型化模型相似，首先需要获取表引用，不过，此时该引用的是一个 <bpt id="p1">**</bpt>MobileServicesJsonTable<ept id="p1">**</ept> 对象。对移动服务客户端的实例调用 <bpt id="p2">**</bpt>getTable()<ept id="p2">**</ept> 方法可获取该引用。</source>
          <target state="new">与使用类型化模型相似，首先需要获取表引用，不过，此时该引用的是一个 <bpt id="p1">**</bpt>MobileServicesJsonTable<ept id="p1">**</ept> 对象。对移动服务客户端的实例调用 <bpt id="p2">**</bpt>getTable()<ept id="p2">**</ept> 方法可获取该引用。</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>首先定义变量：</source>
          <target state="new">首先定义变量：</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>onCreate<ept id="p1">**</ept> 方法中创建移动服务客户端的实例（在此处为 <bpt id="p2">*</bpt>mClient<ept id="p2">*</ept> 变量）后，接下来请使用以下代码创建 <bpt id="p3">**</bpt>MobileServiceJsonTable<ept id="p3">**</ept> 的实例。</source>
          <target state="new">在 <bpt id="p1">**</bpt>onCreate<ept id="p1">**</ept> 方法中创建移动服务客户端的实例（在此处为 <bpt id="p2">*</bpt>mClient<ept id="p2">*</ept> 变量）后，接下来请使用以下代码创建 <bpt id="p3">**</bpt>MobileServiceJsonTable<ept id="p3">**</ept> 的实例。</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>创建 <bpt id="p1">**</bpt>MobileServiceJsonTable<ept id="p1">**</ept> 的实例后，便可以对该实例调用使用类型化编程模型所能调用的几乎所有方法。但是，在某些情况下，这些方法采用非类型化参数，如以下示例所示。</source>
          <target state="new">创建 <bpt id="p1">**</bpt>MobileServiceJsonTable<ept id="p1">**</ept> 的实例后，便可以对该实例调用使用类型化编程模型所能调用的几乎所有方法。但是，在某些情况下，这些方法采用非类型化参数，如以下示例所示。</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="json_insert"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何插入到非类型化表中</source>
          <target state="new"><ph id="ph1">&lt;a name="json_insert"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何插入到非类型化表中</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何执行插入。第一步是创建属于 <ph id="ph1">&lt;a href=" http://go.microsoft.com/fwlink/p/?LinkId=290801" target="_blank"&gt;</ph>gson<ph id="ph2">&lt;/a&gt;</ph> 库的一部分的 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>JsonObject<ept id="p2">**</ept><ept id="p1">](http://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/JsonObject.html)</ept>。</source>
          <target state="new">以下代码演示了如何执行插入。第一步是创建属于 <ph id="ph1">&lt;a href=" http://go.microsoft.com/fwlink/p/?LinkId=290801" target="_blank"&gt;</ph>gson<ph id="ph2">&lt;/a&gt;</ph> 库的一部分的 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>JsonObject<ept id="p2">**</ept><ept id="p1">](http://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/JsonObject.html)</ept>。</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>下一步是插入对象。传递给 <bpt id="p1">**</bpt>insert<ept id="p1">**</ept> 方法的回调函数是 <bpt id="p2">**</bpt>TableJsonOperationCallback<ept id="p2">**</ept> 类的实例。注意，<bpt id="p3">*</bpt>insert<ept id="p3">*</ept> 方法的参数如何成为 JsonObject。</source>
          <target state="new">下一步是插入对象。传递给 <bpt id="p1">**</bpt>insert<ept id="p1">**</ept> 方法的回调函数是 <bpt id="p2">**</bpt>TableJsonOperationCallback<ept id="p2">**</ept> 类的实例。注意，<bpt id="p3">*</bpt>insert<ept id="p3">*</ept> 方法的参数如何成为 JsonObject。</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>如果需要获取所插入对象的ID，请使用此方法调用：</source>
          <target state="new">如果需要获取所插入对象的ID，请使用此方法调用：</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="json_delete"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何从非类型化表中删除数据</source>
          <target state="new"><ph id="ph1">&lt;a name="json_delete"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何从非类型化表中删除数据</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何删除一个实例，在本例中，该实例就是我们在前一个 <bpt id="p1">*</bpt>insert<ept id="p1">*</ept> 示例中创建的 <bpt id="p2">**</bpt>JsonObject<ept id="p2">**</ept> 的实例。请注意该代码与类型化案例相同，但方法具有不同的签名，因为它引用了 <bpt id="p3">**</bpt>JsonObject<ept id="p3">**</ept>。</source>
          <target state="new">以下代码演示了如何删除一个实例，在本例中，该实例就是我们在前一个 <bpt id="p1">*</bpt>insert<ept id="p1">*</ept> 示例中创建的 <bpt id="p2">**</bpt>JsonObject<ept id="p2">**</ept> 的实例。请注意该代码与类型化案例相同，但方法具有不同的签名，因为它引用了 <bpt id="p3">**</bpt>JsonObject<ept id="p3">**</ept>。</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>还可以使用某个实例的 ID 来直接删除该实例：</source>
          <target state="new">还可以使用某个实例的 ID 来直接删除该实例：</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="json_get"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何返回非类型化表中的所有行</source>
          <target state="new"><ph id="ph1">&lt;a name="json_get"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何返回非类型化表中的所有行</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何检索整个表。由于使用的是 Json 数据表，你可以选择性地只检索某些表的列。</source>
          <target state="new">以下代码演示了如何检索整个表。由于使用的是 Json 数据表，你可以选择性地只检索某些表的列。</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>你可以通过连接与类型化编程模型中所用方法同名的方法来执行筛选、排序和分页。</source>
          <target state="new">你可以通过连接与类型化编程模型中所用方法同名的方法来执行筛选、排序和分页。</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="binding"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何将数据绑定到用户界面</source>
          <target state="new"><ph id="ph1">&lt;a name="binding"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何将数据绑定到用户界面</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>数据绑定涉及到三个组件：</source>
          <target state="new">数据绑定涉及到三个组件：</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>数据源</source>
          <target state="new">数据源</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>屏幕布局</source>
          <target state="new">屏幕布局</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>将两者绑定起来的适配器</source>
          <target state="new">将两者绑定起来的适配器</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>在以下示例代码中，我们会将移动服务表 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 中的数据返回到一个数组中。这是数据应用程序经常使用的一种模式：数据库查询通常会返回行的集合，客户将在列表或数组中获取该集合。在此示例中，该数组就是数据源。</source>
          <target state="new">在以下示例代码中，我们会将移动服务表 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 中的数据返回到一个数组中。这是数据应用程序经常使用的一种模式：数据库查询通常会返回行的集合，客户将在列表或数组中获取该集合。在此示例中，该数组就是数据源。</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>代码将指定屏幕布局，用于定义设备中显示的数据视图。</source>
          <target state="new">代码将指定屏幕布局，用于定义设备中显示的数据视图。</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>数据源和屏幕布局通过适配器绑定在一起，在此代码中，该适配器是 <bpt id="p1">*</bpt>ArrayAdapter&amp;lt;ToDoItem&amp;gt;<ept id="p1">*</ept> 类的扩展。</source>
          <target state="new">数据源和屏幕布局通过适配器绑定在一起，在此代码中，该适配器是 <bpt id="p1">*</bpt>ArrayAdapter&amp;lt;ToDoItem&amp;gt;<ept id="p1">*</ept> 类的扩展。</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="layout"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何定义布局</source>
          <target state="new"><ph id="ph1">&lt;a name="layout"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何定义布局</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>布局由多个 XML 代码段定义。以某个现有布局为例，我们假设以下代码表示了要在其中填充服务器数据的 <bpt id="p1">**</bpt>ListView<ept id="p1">**</ept>。</source>
          <target state="new">布局由多个 XML 代码段定义。以某个现有布局为例，我们假设以下代码表示了要在其中填充服务器数据的 <bpt id="p1">**</bpt>ListView<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>在上面的代码中，<bpt id="p1">*</bpt>listitem<ept id="p1">*</ept> 属性指定列表中单个行的布局 ID。以下代码指定了一个复选框及其关联的文本。这些元素将会针对列表中的每个项实例化一次。如果使用更复杂的布局，则会在屏幕中指定更多的字段。以下代码摘自 <bpt id="p2">*</bpt>row\_list\_to\_do.xml<ept id="p2">*</ept> 文件。</source>
          <target state="new">在上面的代码中，<bpt id="p1">*</bpt>listitem<ept id="p1">*</ept> 属性指定列表中单个行的布局 ID。以下代码指定了一个复选框及其关联的文本。这些元素将会针对列表中的每个项实例化一次。如果使用更复杂的布局，则会在屏幕中指定更多的字段。以下代码摘自 <bpt id="p2">*</bpt>row\_list\_to\_do.xml<ept id="p2">*</ept> 文件。</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="adapter"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何定义适配器</source>
          <target state="new"><ph id="ph1">&lt;a name="adapter"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何定义适配器</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>由于此处视图的数据源是一个 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 数组，因此我们需要基于 <bpt id="p2">*</bpt>ArrayAdapter&amp;lt;ToDoItem&amp;gt;<ept id="p2">*</ept> 类子类化适配器。此子类将使用 <bpt id="p3">*</bpt>row_list_to_do<ept id="p3">*</ept> 布局为每个 <bpt id="p4">*</bpt>ToDoItem<ept id="p4">*</ept> 生成一个视图。</source>
          <target state="new">由于此处视图的数据源是一个 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 数组，因此我们需要基于 <bpt id="p2">*</bpt>ArrayAdapter&amp;lt;ToDoItem&amp;gt;<ept id="p2">*</ept> 类子类化适配器。此子类将使用 <bpt id="p3">*</bpt>row_list_to_do<ept id="p3">*</ept> 布局为每个 <bpt id="p4">*</bpt>ToDoItem<ept id="p4">*</ept> 生成一个视图。</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>在代码中，我们可以定义以下类作为 <bpt id="p1">*</bpt>ArrayAdapter&amp;lt;E&amp;gt;<ept id="p1">*</ept> 类的扩展：</source>
          <target state="new">在代码中，我们可以定义以下类作为 <bpt id="p1">*</bpt>ArrayAdapter&amp;lt;E&amp;gt;<ept id="p1">*</ept> 类的扩展：</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>必须重写适配器的 <bpt id="p1">*</bpt>getView<ept id="p1">*</ept> 方法。以下示例代码演示了如何执行此操作：具体的代码根据应用程序而定。</source>
          <target state="new">必须重写适配器的 <bpt id="p1">*</bpt>getView<ept id="p1">*</ept> 方法。以下示例代码演示了如何执行此操作：具体的代码根据应用程序而定。</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>在活动中创建此类的实例，如下所示：</source>
          <target state="new">在活动中创建此类的实例，如下所示：</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>请注意，ToDoItemAdapter 构造函数的第二个参数是对布局的引用。在该构造函数的调用后面添加以下代码，以便先获取对 <bpt id="p1">**</bpt>ListView<ept id="p1">**</ept> 的引用，然后调用 <bpt id="p2">*</bpt>setAdapter<ept id="p2">*</ept>，使该视图将自身配置为使用刚创建的适配器：</source>
          <target state="new">请注意，ToDoItemAdapter 构造函数的第二个参数是对布局的引用。在该构造函数的调用后面添加以下代码，以便先获取对 <bpt id="p1">**</bpt>ListView<ept id="p1">**</ept> 的引用，然后调用 <bpt id="p2">*</bpt>setAdapter<ept id="p2">*</ept>，使该视图将自身配置为使用刚创建的适配器：</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="use-adapter"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何使用适配器</source>
          <target state="new"><ph id="ph1">&lt;a name="use-adapter"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何使用适配器</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>现在，你可以使用数据绑定了。以下代码演示了如何获取移动服务表中的项，清除适配器，然后调用适配器的 <bpt id="p1">*</bpt>add<ept id="p1">*</ept> 方法以在表中填充返回的项。</source>
          <target state="new">现在，你可以使用数据绑定了。以下代码演示了如何获取移动服务表中的项，清除适配器，然后调用适配器的 <bpt id="p1">*</bpt>add<ept id="p1">*</ept> 方法以在表中填充返回的项。</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>每次修改 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 表后，也必须调用该适配器（如果你想要显示执行修改操作后的结果）。由于修改是按记录完成的，因此要处理的是单个行而不是一个集合。插入项时，需要对适配器调用 <bpt id="p2">*</bpt>add<ept id="p2">*</ept> 方法；删除项时，需要调用 <bpt id="p3">*</bpt>remove<ept id="p3">*</ept> 方法。</source>
          <target state="new">每次修改 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 表后，也必须调用该适配器（如果你想要显示执行修改操作后的结果）。由于修改是按记录完成的，因此要处理的是单个行而不是一个集合。插入项时，需要对适配器调用 <bpt id="p2">*</bpt>add<ept id="p2">*</ept> 方法；删除项时，需要调用 <bpt id="p3">*</bpt>remove<ept id="p3">*</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="custom-api"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：调用自定义 API</source>
          <target state="new"><ph id="ph1">&lt;a name="custom-api"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：调用自定义 API</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>自定义 API 可让你定义自定义终结点，这些终结点将会公开不映射到插入、更新、删除或读取操作的服务器功能。使用自定义 API 能够以更大的力度控制消息传送，包括读取和设置 HTTP 消息标头，以及定义除 JSON 以外的消息正文格式。有关如何在移动服务中创建自定义 API 的示例，请参阅<bpt id="p1">[</bpt>如何：定义自定义 API 终结点<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-define-custom-api)</ept>。</source>
          <target state="new">自定义 API 可让你定义自定义终结点，这些终结点将会公开不映射到插入、更新、删除或读取操作的服务器功能。使用自定义 API 能够以更大的力度控制消息传送，包括读取和设置 HTTP 消息标头，以及定义除 JSON 以外的消息正文格式。有关如何在移动服务中创建自定义 API 的示例，请参阅<bpt id="p1">[</bpt>如何：定义自定义 API 终结点<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-define-custom-api)</ept>。</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="authentication"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何对用户进行身份验证</source>
          <target state="new"><ph id="ph1">&lt;a name="authentication"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何对用户进行身份验证</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>移动服务支持使用各种外部标识提供者对应用程序用户进行身份验证和授权，这些提供者包括：Microsoft 帐户和 Azure Active Directory。你可以在表中设置权限，以便将特定操作的访问权限限制给已经过身份验证的用户。你还可以在后端中使用已经过身份验证的用户的标识来实施授权规则。有关详细信息，请参阅<bpt id="p1">[</bpt>身份验证入门<ept id="p1">](/documentation/articles/mobile-services-android-get-started-users/)</ept>。</source>
          <target state="new">移动服务支持使用各种外部标识提供者对应用程序用户进行身份验证和授权，这些提供者包括：Microsoft 帐户和 Azure Active Directory。你可以在表中设置权限，以便将特定操作的访问权限限制给已经过身份验证的用户。你还可以在后端中使用已经过身份验证的用户的标识来实施授权规则。有关详细信息，请参阅<bpt id="p1">[</bpt>身份验证入门<ept id="p1">](/documentation/articles/mobile-services-android-get-started-users/)</ept>。</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>支持两种身份验证流: <bpt id="p1">*</bpt>服务器<ept id="p1">*</ept>流和<bpt id="p2">*</bpt>客户端<ept id="p2">*</ept>流。服务器流依赖于提供者的 Web 身份验证界面，因此可提供最简便的身份验证体验。客户端流依赖于提供者和设备特定的 SDK，因此允许与设备特定的功能（例如单一登录）进行更深入的集成。</source>
          <target state="new">支持两种身份验证流: <bpt id="p1">*</bpt>服务器<ept id="p1">*</ept>流和<bpt id="p2">*</bpt>客户端<ept id="p2">*</ept>流。服务器流依赖于提供者的 Web 身份验证界面，因此可提供最简便的身份验证体验。客户端流依赖于提供者和设备特定的 SDK，因此允许与设备特定的功能（例如单一登录）进行更深入的集成。</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>在应用程序中启用身份验证需要执行以下三个步骤：</source>
          <target state="new">在应用程序中启用身份验证需要执行以下三个步骤：</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>注册你的应用程序以使用提供者进行身份验证，然后配置移动服务</source>
          <target state="new">注册你的应用程序以使用提供者进行身份验证，然后配置移动服务</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>将表权限限制给已经过身份验证的用户</source>
          <target state="new">将表权限限制给已经过身份验证的用户</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>向应用程序添加身份验证代码</source>
          <target state="new">向应用程序添加身份验证代码</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>移动服务支持使用以下现有标识提供者对用户进行身份验证：</source>
          <target state="new">移动服务支持使用以下现有标识提供者对用户进行身份验证：</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Microsoft 帐户</source>
          <target state="new">Microsoft 帐户</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Azure Active Directory</source>
          <target state="new">Azure Active Directory</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>你可以在表中设置权限，以便将特定操作的访问权限限制给已经过身份验证的用户。还可以使用已经过身份验证的用户的 ID 来修改请求。</source>
          <target state="new">你可以在表中设置权限，以便将特定操作的访问权限限制给已经过身份验证的用户。还可以使用已经过身份验证的用户的 ID 来修改请求。</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>前两个任务可使用 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">](https://manage.windowsazure.cn/)</ept>来完成。有关详细信息，请参阅<bpt id="p2">[</bpt>身份验证入门<ept id="p2">](/documentation/articles/mobile-services-android-get-started-users/)</ept>。</source>
          <target state="new">前两个任务可使用 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">](https://manage.windowsazure.cn/)</ept>来完成。有关详细信息，请参阅<bpt id="p2">[</bpt>身份验证入门<ept id="p2">](/documentation/articles/mobile-services-android-get-started-users/)</ept>。</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="caching"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何向应用程序添加身份验证代码</source>
          <target state="new"><ph id="ph1">&lt;a name="caching"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何向应用程序添加身份验证代码</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>将以下 import 语句添加到应用程序的活动文件。</source>
          <target state="new">将以下 import 语句添加到应用程序的活动文件。</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>在活动类的 <bpt id="p1">**</bpt>onCreate<ept id="p1">**</ept> 方法中，在创建 <ph id="ph1">`MobileServiceClient`</ph> 对象的代码后面添加以下代码行：我们假设对 <ph id="ph2">`MobileServiceClient`</ph> 对象的引用为 <bpt id="p2">*</bpt>mClient<ept id="p2">*</ept>。</source>
          <target state="new">在活动类的 <bpt id="p1">**</bpt>onCreate<ept id="p1">**</ept> 方法中，在创建 <ph id="ph1">`MobileServiceClient`</ph> 对象的代码后面添加以下代码行：我们假设对 <ph id="ph2">`MobileServiceClient`</ph> 对象的引用为 <bpt id="p2">*</bpt>mClient<ept id="p2">*</ept>。</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>此代码将使用 Google 登录对用户进行身份验证。此时将出现一个对话框，其中显示了已经过身份验证的用户的 ID。如果未正常完成身份验证，你将无法继续操作。</source>
          <target state="new">此代码将使用 Google 登录对用户进行身份验证。此时将出现一个对话框，其中显示了已经过身份验证的用户的 ID。如果未正常完成身份验证，你将无法继续操作。</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>如果使用的标识提供程序不是 Google，请将传递给上述 <bpt id="p1">**</bpt>login<ept id="p1">**</ept> 方法的值更改为下列其中一项：<bpt id="p2">_</bpt>MicrosoftAccount<ept id="p2">_</ept>或 <bpt id="p3">_</bpt>WindowsAzureActiveDirectory<ept id="p3">_</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>如果使用的标识提供程序不是 Google，请将传递给上述 <bpt id="p1">**</bpt>login<ept id="p1">**</ept> 方法的值更改为下列其中一项：<bpt id="p2">_</bpt>MicrosoftAccount<ept id="p2">_</ept>或 <bpt id="p3">_</bpt>WindowsAzureActiveDirectory<ept id="p3">_</ept>。</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>运行应用程序时，请使用选择的标识提供者登录。</source>
          <target state="new">运行应用程序时，请使用选择的标识提供者登录。</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="caching"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何缓存身份验证令牌</source>
          <target state="new"><ph id="ph1">&lt;a name="caching"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何缓存身份验证令牌</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>本部分说明如何缓存身份验证令牌。执行此操作的目的是避免令牌仍然有效且应用程序处于“休眠”状态时用户必须再次完成身份验证。</source>
          <target state="new">本部分说明如何缓存身份验证令牌。执行此操作的目的是避免令牌仍然有效且应用程序处于“休眠”状态时用户必须再次完成身份验证。</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>缓存身份验证令牌需要将用户 ID 和身份验证令牌存储在设备本地。下一次启动应用程序时，你只需检查缓存，如果这些值存在，则你可以跳过登录过程，并使用这些数据重新进入客户端。但是，这些数据是敏感的，为安全起见，应该以加密形式存储，以防手机失窃。</source>
          <target state="new">缓存身份验证令牌需要将用户 ID 和身份验证令牌存储在设备本地。下一次启动应用程序时，你只需检查缓存，如果这些值存在，则你可以跳过登录过程，并使用这些数据重新进入客户端。但是，这些数据是敏感的，为安全起见，应该以加密形式存储，以防手机失窃。</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>以下代码段演示了如何获取 Microsoft 帐户登录的令牌。该令牌已缓存，以后如果找到了缓存，将重新加载该令牌。</source>
          <target state="new">以下代码段演示了如何获取 Microsoft 帐户登录的令牌。该令牌已缓存，以后如果找到了缓存，将重新加载该令牌。</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>如果令牌过期会发生什么情况呢？ 在这种情况下，如果你尝试使用它来建立连接，将会收到“401 未授权”响应。此时，用户必须登录以获取新令牌。使用筛选器可以截获对移动服务的调用以及来自移动服务的响应，因此不需要在应用程序中调用移动服务的每个位置编写代码来处理这种情况。此时，筛选器代码将测试 401 响应，根据需要触发登录进程，然后恢复生成 401 响应的请求。</source>
          <target state="new">如果令牌过期会发生什么情况呢？ 在这种情况下，如果你尝试使用它来建立连接，将会收到“401 未授权”响应。此时，用户必须登录以获取新令牌。使用筛选器可以截获对移动服务的调用以及来自移动服务的响应，因此不需要在应用程序中调用移动服务的每个位置编写代码来处理这种情况。此时，筛选器代码将测试 401 响应，根据需要触发登录进程，然后恢复生成 401 响应的请求。</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="customizing"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自定义客户端</source>
          <target state="new"><ph id="ph1">&lt;a name="customizing"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自定义客户端</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>你可以通过多种方法自定义移动服务客户端的默认行为。</source>
          <target state="new">你可以通过多种方法自定义移动服务客户端的默认行为。</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="headers"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自定义请求标头</source>
          <target state="new"><ph id="ph1">&lt;a name="headers"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自定义请求标头</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>你可能需要将一个自定义标头附加到每个传出请求。按如下所示配置 <bpt id="p1">**</bpt>ServiceFilter<ept id="p1">**</ept> 可以实现此目的：</source>
          <target state="new">你可能需要将一个自定义标头附加到每个传出请求。按如下所示配置 <bpt id="p1">**</bpt>ServiceFilter<ept id="p1">**</ept> 可以实现此目的：</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="serialization"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自定义序列化</source>
          <target state="new"><ph id="ph1">&lt;a name="serialization"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自定义序列化</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>默认情况下，移动服务假设服务器上与客户端上的表名称、列名称和数据类型都完全匹配。但是，在许多情况下，服务器上和客户端上的名称并不匹配。现举一例：你要更改某个现有的客户端，使其使用移动服务而不是竞争者的产品。</source>
          <target state="new">默认情况下，移动服务假设服务器上与客户端上的表名称、列名称和数据类型都完全匹配。但是，在许多情况下，服务器上和客户端上的名称并不匹配。现举一例：你要更改某个现有的客户端，使其使用移动服务而不是竞争者的产品。</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>此时，你可能需要执行类似于下面的自定义操作：</source>
          <target state="new">此时，你可能需要执行类似于下面的自定义操作：</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>使移动服务表中使用的列名称与你在客户端中使用的名称不匹配</source>
          <target state="new">使移动服务表中使用的列名称与你在客户端中使用的名称不匹配</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>使用一个移动服务表，其名称不同于该表在客户端中映射到的类</source>
          <target state="new">使用一个移动服务表，其名称不同于该表在客户端中映射到的类</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>启用属性自动大写</source>
          <target state="new">启用属性自动大写</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>向对象添加复杂属性</source>
          <target state="new">向对象添加复杂属性</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="columns"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何映射不同的客户端名称和服务器名称</source>
          <target state="new"><ph id="ph1">&lt;a name="columns"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何映射不同的客户端名称和服务器名称</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>假设你的 Java 客户端代码为 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 对象属性使用了类似于下面的标准 Java 样式名称。</source>
          <target state="new">假设你的 Java 客户端代码为 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 对象属性使用了类似于下面的标准 Java 样式名称。</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>mId</source>
          <target state="new">mId</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>mText</source>
          <target state="new">mText</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>mComplete</source>
          <target state="new">mComplete</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>mDuration</source>
          <target state="new">mDuration</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>则你必须将客户端名称序列化为与服务器上 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 表的列名称匹配的 JSON 名称。以下代码利用 <ph id="ph1">&lt;a href="http://go.microsoft.com/fwlink/p/?LinkId=290801" target="_blank"&gt;</ph>gson<ph id="ph2">&lt;/a&gt;</ph> 库来执行此操作。</source>
          <target state="new">则你必须将客户端名称序列化为与服务器上 <bpt id="p1">*</bpt>ToDoItem<ept id="p1">*</ept> 表的列名称匹配的 JSON 名称。以下代码利用 <ph id="ph1">&lt;a href="http://go.microsoft.com/fwlink/p/?LinkId=290801" target="_blank"&gt;</ph>gson<ph id="ph2">&lt;/a&gt;</ph> 库来执行此操作。</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="table"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在客户端与移动服务之间映射不同的表名称</source>
          <target state="new"><ph id="ph1">&lt;a name="table"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在客户端与移动服务之间映射不同的表名称</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>如以下代码所示，只需使用</source>
          <target state="new">如以下代码所示，只需使用</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>getTable()<ept id="p1">**</ept> 函数的重写之一，就能轻松地将客户端表名称映射为不同的移动服务表名称。</source>
          <target state="new"><bpt id="p1">**</bpt>getTable()<ept id="p1">**</ept> 函数的重写之一，就能轻松地将客户端表名称映射为不同的移动服务表名称。</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="conversions"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自动执行列名称映射</source>
          <target state="new"><ph id="ph1">&lt;a name="conversions"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何自动执行列名称映射</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>如前一部分中所示，映射只包含几个列的简短表的列名称并不复杂。但是，如果表包含大量的列（例如 20 或 30 个列），则我们可以调用 <ph id="ph1">&lt;a href="http://go.microsoft.com/fwlink/p/?LinkId=290801" target="_blank"&gt;</ph>gson<ph id="ph2">&lt;/a&gt;</ph> API 并指定要应用到每个列的转换策略，这样就无需批注每一个列名称。</source>
          <target state="new">如前一部分中所示，映射只包含几个列的简短表的列名称并不复杂。但是，如果表包含大量的列（例如 20 或 30 个列），则我们可以调用 <ph id="ph1">&lt;a href="http://go.microsoft.com/fwlink/p/?LinkId=290801" target="_blank"&gt;</ph>gson<ph id="ph2">&lt;/a&gt;</ph> API 并指定要应用到每个列的转换策略，这样就无需批注每一个列名称。</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>为此，我们需要使用 <ph id="ph1">&lt;a href="http://go.microsoft.com/fwlink/p/?LinkId=290801" target="_blank"&gt;</ph>gson<ph id="ph2">&lt;/a&gt;</ph> 库，Android 客户端库在幕后使用该库将 Java 对象序列化为要发送到 Azure 移动服务的 JSON 数据。</source>
          <target state="new">为此，我们需要使用 <ph id="ph1">&lt;a href="http://go.microsoft.com/fwlink/p/?LinkId=290801" target="_blank"&gt;</ph>gson<ph id="ph2">&lt;/a&gt;</ph> 库，Android 客户端库在幕后使用该库将 Java 对象序列化为要发送到 Azure 移动服务的 JSON 数据。</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>以下代码使用 <bpt id="p1">*</bpt>setFieldNamingStrategy()<ept id="p1">*</ept> 方法，我们在其中定义了 <bpt id="p2">*</bpt>FieldNamingStrategy()<ept id="p2">*</ept> 方法。此方法指定删除初始字符（“m”），然后将每个字段名称的下一个字符小写。此代码还启用了输出 JSON 的整齐打印。</source>
          <target state="new">以下代码使用 <bpt id="p1">*</bpt>setFieldNamingStrategy()<ept id="p1">*</ept> 方法，我们在其中定义了 <bpt id="p2">*</bpt>FieldNamingStrategy()<ept id="p2">*</ept> 方法。此方法指定删除初始字符（“m”），然后将每个字段名称的下一个字符小写。此代码还启用了输出 JSON 的整齐打印。</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>必须在对移动服务客户端对象执行任何方法调用之前执行此代码。</source>
          <target state="new">必须在对移动服务客户端对象执行任何方法调用之前执行此代码。</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="complex"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何将对象或数组属性存储到表中</source>
          <target state="new"><ph id="ph1">&lt;a name="complex"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何将对象或数组属性存储到表中</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>到目前为止，我们的所有序列化示例都使用了可轻松序列化成 JSON 和移动服务表的基元类型（例如整数和字符串）。假设我们要将一个不能自动序列化成 JSON 和表的复杂对象添加到客户端类型。例如，我们要将一个字符串数组添加到客户端对象。此时，我们需要指定如何执行序列化，以及如何将数组存储到移动服务表中。</source>
          <target state="new">到目前为止，我们的所有序列化示例都使用了可轻松序列化成 JSON 和移动服务表的基元类型（例如整数和字符串）。假设我们要将一个不能自动序列化成 JSON 和表的复杂对象添加到客户端类型。例如，我们要将一个字符串数组添加到客户端对象。此时，我们需要指定如何执行序列化，以及如何将数组存储到移动服务表中。</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>若要查看有关如何执行此操作的示例，请阅读博客文章<ph id="ph1">&lt;a href="http://hashtagfail.com/post/44606137082/mobile-services-android-serialization-gson" target="_blank"&gt;</ph>在移动服务 Android 客户端中使用 <ph id="ph2">&lt;a href="http://go.microsoft.com/fwlink/p/?LinkId=290801" target="_blank"&gt;</ph>gson<ph id="ph3">&lt;/a&gt;</ph> 库自定义序列化<ph id="ph4">&lt;/a&gt;</ph>。</source>
          <target state="new">若要查看有关如何执行此操作的示例，请阅读博客文章<ph id="ph1">&lt;a href="http://hashtagfail.com/post/44606137082/mobile-services-android-serialization-gson" target="_blank"&gt;</ph>在移动服务 Android 客户端中使用 <ph id="ph2">&lt;a href="http://go.microsoft.com/fwlink/p/?LinkId=290801" target="_blank"&gt;</ph>gson<ph id="ph3">&lt;/a&gt;</ph> 库自定义序列化<ph id="ph4">&lt;/a&gt;</ph>。</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>每当我们要使用一个不能自动序列化成 JSON 和移动服务表的复杂对象时，就可以使用此常规方法。</source>
          <target state="new">每当我们要使用一个不能自动序列化成 JSON 和移动服务表的复杂对象时，就可以使用此常规方法。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>