<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">64639107916593e9565e6814a868ef40aab7e5b5</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 Node.js 使用队列存储 | Azure</source>
          <target state="new">如何通过 Node.js 使用队列存储 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何使用 Azure 队列服务创建和删除队列，以及插入、获取和删除消息。相关示例是使用 Node.js 编写的。</source>
          <target state="new">了解如何使用 Azure 队列服务创建和删除队列，以及插入、获取和删除消息。相关示例是使用 Node.js 编写的。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何通过 Node.js 使用队列存储</source>
          <target state="new">如何通过 Node.js 使用队列存储</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本指南将演示如何使用 Azure 队列服务执行常见方案。相关示例是使用 Node.js API 编写的。介绍的方案包括“插入”、“扫视”、“获取”和“删除”队列消息以及“创建”和“删除”队列。</source>
          <target state="new">本指南将演示如何使用 Azure 队列服务执行常见方案。相关示例是使用 Node.js API 编写的。介绍的方案包括“插入”、“扫视”、“获取”和“删除”队列消息以及“创建”和“删除”队列。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>创建 Node.js 应用程序</source>
          <target state="new">创建 Node.js 应用程序</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>创建一个空的 Node.js 应用程序。有关创建 Node.js 应用程序的说明，请参阅 <bpt id="p1">[</bpt><ept id="p1">创建 Node.js 应用程序并将其部署到 Azure Web 应用]</ept>、<bpt id="p2">[</bpt>Node.js 云服务<ept id="p2">][Node.js 云服务]</ept>（使用 Windows PowerShell）或 <bpt id="p3">[</bpt><ept id="p3">使用 WebMatrix 构建 Web 应用]</ept>。</source>
          <target state="new">创建一个空的 Node.js 应用程序。有关创建 Node.js 应用程序的说明，请参阅 <bpt id="p1">[</bpt><ept id="p1">创建 Node.js 应用程序并将其部署到 Azure Web 应用]</ept>、<bpt id="p2">[</bpt>Node.js 云服务<ept id="p2">][Node.js 云服务]</ept>（使用 Windows PowerShell）或 <bpt id="p3">[</bpt><ept id="p3">使用 WebMatrix 构建 Web 应用]</ept>。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>配置应用程序以访问存储</source>
          <target state="new">配置应用程序以访问存储</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>若要使用 Azure 存储空间，你需要 Azure Storage SDK for Node.js，其中包括一组便于与存储 REST 服务进行通信的库。</source>
          <target state="new">若要使用 Azure 存储空间，你需要 Azure Storage SDK for Node.js，其中包括一组便于与存储 REST 服务进行通信的库。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>使用 Node 包管理器 (NPM) 可获取该程序包</source>
          <target state="new">使用 Node 包管理器 (NPM) 可获取该程序包</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>PowerShell<ept id="p1">**</ept> (Windows)、<bpt id="p2">**</bpt>Terminal<ept id="p2">**</ept> (Mac) 或 <bpt id="p3">**</bpt>Bash<ept id="p3">**</ept> (Unix) 等命令行界面导航到您在其中创建了示例应用程序的文件夹。</source>
          <target state="new">使用 <bpt id="p1">**</bpt>PowerShell<ept id="p1">**</ept> (Windows)、<bpt id="p2">**</bpt>Terminal<ept id="p2">**</ept> (Mac) 或 <bpt id="p3">**</bpt>Bash<ept id="p3">**</ept> (Unix) 等命令行界面导航到您在其中创建了示例应用程序的文件夹。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>在命令窗口中键入 <bpt id="p1">**</bpt>npm install azure-storage<ept id="p1">**</ept>。该命令的输出类似于以下示例。</source>
          <target state="new">在命令窗口中键入 <bpt id="p1">**</bpt>npm install azure-storage<ept id="p1">**</ept>。该命令的输出类似于以下示例。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>可以手动运行 <bpt id="p1">**</bpt>ls<ept id="p1">**</ept> 命令来验证是否创建了</source>
          <target state="new">可以手动运行 <bpt id="p1">**</bpt>ls<ept id="p1">**</ept> 命令来验证是否创建了</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>node_modules<ept id="p1">**</ept> 文件夹。在该文件夹中，你会</source>
          <target state="new"><bpt id="p1">**</bpt>node_modules<ept id="p1">**</ept> 文件夹。在该文件夹中，你会</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>找到 <bpt id="p1">**</bpt>azure-storage<ept id="p1">**</ept> 包，其中包含你访问</source>
          <target state="new">找到 <bpt id="p1">**</bpt>azure-storage<ept id="p1">**</ept> 包，其中包含你访问</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>存储所需的库。</source>
          <target state="new">存储所需的库。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>导入包</source>
          <target state="new">导入包</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>使用记事本或其他文本编辑器将以下内容添加到应用程序的</source>
          <target state="new">使用记事本或其他文本编辑器将以下内容添加到应用程序的</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>server.js<ept id="p1">**</ept> 文件的顶部，以便在其中使用存储：</source>
          <target state="new"><bpt id="p1">**</bpt>server.js<ept id="p1">**</ept> 文件的顶部，以便在其中使用存储：</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>设置 Azure 存储连接</source>
          <target state="new">设置 Azure 存储连接</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Azure 模块将读取环境变量 AZURE_STORAGE_ACCOUNT 和 AZURE_STORAGE_ACCESS_KEY 或 AZURE_STORAGE_CONNECTION_STRING 以获取连接到您的 Azure 存储帐户所需的信息。如果未设置这些环境变量，则在调用 <bpt id="p1">**</bpt>createQueueService<ept id="p1">**</ept> 时必须指定帐户信息。</source>
          <target state="new">Azure 模块将读取环境变量 AZURE_STORAGE_ACCOUNT 和 AZURE_STORAGE_ACCESS_KEY 或 AZURE_STORAGE_CONNECTION_STRING 以获取连接到您的 Azure 存储帐户所需的信息。如果未设置这些环境变量，则在调用 <bpt id="p1">**</bpt>createQueueService<ept id="p1">**</ept> 时必须指定帐户信息。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>有关在管理门户中为 Azure Web 应用设置环境变量的示例，请参阅<bpt id="p1">[</bpt><ept id="p1">使用存储构建 Node.js Web 应用]</ept></source>
          <target state="new">有关在管理门户中为 Azure Web 应用设置环境变量的示例，请参阅<bpt id="p1">[</bpt><ept id="p1">使用存储构建 Node.js Web 应用]</ept></target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>如何：创建队列</source>
          <target state="new">如何：创建队列</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>以下代码将创建一个 <bpt id="p1">**</bpt>QueueService<ept id="p1">**</ept> 对象，您可通过该对象来操作队列。</source>
          <target state="new">以下代码将创建一个 <bpt id="p1">**</bpt>QueueService<ept id="p1">**</ept> 对象，您可通过该对象来操作队列。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>createQueueIfNotExists<ept id="p1">**</ept> 方法，该方法将返回指定队列（如果它存在），或创建具有指定名称的新队列（如果它尚不存在）。</source>
          <target state="new">使用 <bpt id="p1">**</bpt>createQueueIfNotExists<ept id="p1">**</ept> 方法，该方法将返回指定队列（如果它存在），或创建具有指定名称的新队列（如果它尚不存在）。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>如果创建了队列，则 <ph id="ph1">`result`</ph> 为 true。如果队列已存在，则 <ph id="ph2">`result`</ph> 为 false。</source>
          <target state="new">如果创建了队列，则 <ph id="ph1">`result`</ph> 为 true。如果队列已存在，则 <ph id="ph2">`result`</ph> 为 false。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>筛选器</source>
          <target state="new">筛选器</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>可以向使用 <bpt id="p1">**</bpt>QueueService<ept id="p1">**</ept> 执行的操作应用可选的筛选操作。筛选操作可包括日志记录、自动重试等。筛选器是实现具有签名的方法的对象：</source>
          <target state="new">可以向使用 <bpt id="p1">**</bpt>QueueService<ept id="p1">**</ept> 执行的操作应用可选的筛选操作。筛选操作可包括日志记录、自动重试等。筛选器是实现具有签名的方法的对象：</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>在对请求选项执行预处理后，该方法需要调用“next”并且传递具有以下签名的回调：</source>
          <target state="new">在对请求选项执行预处理后，该方法需要调用“next”并且传递具有以下签名的回调：</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>在此回调中并且在处理 returnObject（来自对服务器请求的响应）后，回调需要调用 next（如果它存在以便继续处理其他筛选器）或只调用 finalCallback 以便结束服务调用。</source>
          <target state="new">在此回调中并且在处理 returnObject（来自对服务器请求的响应）后，回调需要调用 next（如果它存在以便继续处理其他筛选器）或只调用 finalCallback 以便结束服务调用。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Azure SDK for Node.js 中附带了两个实现了重试逻辑的筛选器，分别是 <bpt id="p1">**</bpt>ExponentialRetryPolicyFilter<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>LinearRetryPolicyFilter<ept id="p2">**</ept>。下面的代码将创建一个 <bpt id="p3">**</bpt>QueueService<ept id="p3">**</ept> 对象，该对象使用 <bpt id="p4">**</bpt>ExponentialRetryPolicyFilter<ept id="p4">**</ept>：</source>
          <target state="new">Azure SDK for Node.js 中附带了两个实现了重试逻辑的筛选器，分别是 <bpt id="p1">**</bpt>ExponentialRetryPolicyFilter<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>LinearRetryPolicyFilter<ept id="p2">**</ept>。下面的代码将创建一个 <bpt id="p3">**</bpt>QueueService<ept id="p3">**</ept> 对象，该对象使用 <bpt id="p4">**</bpt>ExponentialRetryPolicyFilter<ept id="p4">**</ept>：</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>如何：在队列中插入消息</source>
          <target state="new">如何：在队列中插入消息</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>若要在队列中插入消息，可使用 <bpt id="p1">**</bpt>createMessage<ept id="p1">**</ept> 方法创建一条新消息并将其添加到队列中。</source>
          <target state="new">若要在队列中插入消息，可使用 <bpt id="p1">**</bpt>createMessage<ept id="p1">**</ept> 方法创建一条新消息并将其添加到队列中。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>如何：扫视下一条消息</source>
          <target state="new">如何：扫视下一条消息</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>通过调用 peekMessages 方法，可以查看队列前面的消息，而不必从队列中将其删除。默认情况下，</source>
          <target state="new">通过调用 peekMessages 方法，可以查看队列前面的消息，而不必从队列中将其删除。默认情况下，</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>peekMessages<ept id="p1">**</ept> 查看单个消息。</source>
          <target state="new"><bpt id="p1">**</bpt>peekMessages<ept id="p1">**</ept> 查看单个消息。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`result`</ph> 包含该消息。</source>
          <target state="new"><ph id="ph1">`result`</ph> 包含该消息。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 在队列中没有消息时使用 <bpt id="p1">**</bpt>peekMessages<ept id="p1">**</ept> 不会返回错误，但也不会返回消息。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 在队列中没有消息时使用 <bpt id="p1">**</bpt>peekMessages<ept id="p1">**</ept> 不会返回错误，但也不会返回消息。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>如何：取消对下一条消息的排队</source>
          <target state="new">如何：取消对下一条消息的排队</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>处理消息是一个两阶段过程：</source>
          <target state="new">处理消息是一个两阶段过程：</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>取消消息的排队。</source>
          <target state="new">取消消息的排队。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>删除该消息。</source>
          <target state="new">删除该消息。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>若要取消消息的排队，请使用 <bpt id="p1">**</bpt>getMessages<ept id="p1">**</ept>。这会使消息在队列中不可见，因此其他客户端无法处理它们。一旦应用程序处理完某个消息，即可调用 <bpt id="p2">**</bpt>deleteMessage<ept id="p2">**</ept> 将其从队列中删除。下面的示例获取了一条消息，然后又将其删除：</source>
          <target state="new">若要取消消息的排队，请使用 <bpt id="p1">**</bpt>getMessages<ept id="p1">**</ept>。这会使消息在队列中不可见，因此其他客户端无法处理它们。一旦应用程序处理完某个消息，即可调用 <bpt id="p2">**</bpt>deleteMessage<ept id="p2">**</ept> 将其从队列中删除。下面的示例获取了一条消息，然后又将其删除：</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 默认情况下，一条消息只会隐藏 30 秒，然后其他客户端就可以看见它。您可以将 <ph id="ph2">`options.visibilityTimeout`</ph> 与 <bpt id="p1">**</bpt>getMessages<ept id="p1">**</ept> 一起使用，以便指定其他值。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 默认情况下，一条消息只会隐藏 30 秒，然后其他客户端就可以看见它。您可以将 <ph id="ph2">`options.visibilityTimeout`</ph> 与 <bpt id="p1">**</bpt>getMessages<ept id="p1">**</ept> 一起使用，以便指定其他值。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 在队列中没有消息时使用 <bpt id="p1">**</bpt>getMessages<ept id="p1">**</ept> 不会返回错误，但也不会返回消息。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 在队列中没有消息时使用 <bpt id="p1">**</bpt>getMessages<ept id="p1">**</ept> 不会返回错误，但也不会返回消息。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>如何：更改已排队消息的内容</source>
          <target state="new">如何：更改已排队消息的内容</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>您可以更改队列中现有消息的内容，只需使用 <bpt id="p1">**</bpt>updateMessage<ept id="p1">**</ept> 即可。以下示例将更新消息文本：</source>
          <target state="new">您可以更改队列中现有消息的内容，只需使用 <bpt id="p1">**</bpt>updateMessage<ept id="p1">**</ept> 即可。以下示例将更新消息文本：</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>如何：用于对消息取消排队的其他选项</source>
          <target state="new">如何：用于对消息取消排队的其他选项</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>你可以通过两种方式自定义队列中的消息检索：</source>
          <target state="new">你可以通过两种方式自定义队列中的消息检索：</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`options.numOfMessages`</ph> - 您可以获取一批消息（最多 32 条）。</source>
          <target state="new"><ph id="ph1">`options.numOfMessages`</ph> - 您可以获取一批消息（最多 32 条）。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`options.visibilityTimeout`</ph> - 设置较长或较短的不可见性超时。</source>
          <target state="new"><ph id="ph1">`options.visibilityTimeout`</ph> - 设置较长或较短的不可见性超时。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>以下示例使用 <bpt id="p1">**</bpt>getMessages<ept id="p1">**</ept> 方法通过一次调用获取 15 条消息。然后，它会使用 for 循环处理每条消息。它还将通过此方法返回的所有消息的不可见性超时设置为 5 分钟。</source>
          <target state="new">以下示例使用 <bpt id="p1">**</bpt>getMessages<ept id="p1">**</ept> 方法通过一次调用获取 15 条消息。然后，它会使用 for 循环处理每条消息。它还将通过此方法返回的所有消息的不可见性超时设置为 5 分钟。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>如何：获取队列长度</source>
          <target state="new">如何：获取队列长度</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>getQueueMetadata<ept id="p1">**</ept> 返回有关队列的元数据，其中包括队列中等待的消息的大致数目。</source>
          <target state="new"><bpt id="p1">**</bpt>getQueueMetadata<ept id="p1">**</ept> 返回有关队列的元数据，其中包括队列中等待的消息的大致数目。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>如何：列出队列</source>
          <target state="new">如何：列出队列</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>若要检索队列的列表，请使用 <bpt id="p1">**</bpt>listQueuesSegmented<ept id="p1">**</ept>。若要检索按特定前缀筛选的列表，请使用 <bpt id="p2">**</bpt>listQueuesSegmentedWithPrefix<ept id="p2">**</ept>。</source>
          <target state="new">若要检索队列的列表，请使用 <bpt id="p1">**</bpt>listQueuesSegmented<ept id="p1">**</ept>。若要检索按特定前缀筛选的列表，请使用 <bpt id="p2">**</bpt>listQueuesSegmentedWithPrefix<ept id="p2">**</ept>。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>如果无法返回所有队列，则可使用 <ph id="ph1">`result.continuationToken`</ph> 作为 <bpt id="p1">**</bpt>listQueuesSegmented<ept id="p1">**</ept> 的第一个参数或 <bpt id="p2">**</bpt>listQueuesSegmentedWithPrefix<ept id="p2">**</ept> 的第二个参数，以便检索更多结果。</source>
          <target state="new">如果无法返回所有队列，则可使用 <ph id="ph1">`result.continuationToken`</ph> 作为 <bpt id="p1">**</bpt>listQueuesSegmented<ept id="p1">**</ept> 的第一个参数或 <bpt id="p2">**</bpt>listQueuesSegmentedWithPrefix<ept id="p2">**</ept> 的第二个参数，以便检索更多结果。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>如何：删除队列</source>
          <target state="new">如何：删除队列</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>若要删除队列及其中包含的所有消息，请对队列对象调用 <bpt id="p1">**</bpt>deleteQueue<ept id="p1">**</ept> 方法。</source>
          <target state="new">若要删除队列及其中包含的所有消息，请对队列对象调用 <bpt id="p1">**</bpt>deleteQueue<ept id="p1">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>若要清除队列中的所有消息而不删除该队列，则可使用 <bpt id="p1">**</bpt>clearMessages<ept id="p1">**</ept>。</source>
          <target state="new">若要清除队列中的所有消息而不删除该队列，则可使用 <bpt id="p1">**</bpt>clearMessages<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>如何：使用共享访问签名</source>
          <target state="new">如何：使用共享访问签名</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>共享访问签名 (SAS) 是一种安全的方法，用于对队列进行细致访问而无需提供你的存储帐户名或密钥。通常使用 SAS 来提供对你的队列的有限访问权限，例如允许移动应用程序提交消息。</source>
          <target state="new">共享访问签名 (SAS) 是一种安全的方法，用于对队列进行细致访问而无需提供你的存储帐户名或密钥。通常使用 SAS 来提供对你的队列的有限访问权限，例如允许移动应用程序提交消息。</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>受信任的应用程序（例如基于云的服务）可使用 <bpt id="p1">**</bpt>QueueService<ept id="p1">**</ept> 的 <bpt id="p2">**</bpt>generateSharedAccessSignature<ept id="p2">**</ept> 生成 SAS，然后将其提供给不受信任的或不完全受信任的应用程序。例如，移动应用程序。SAS 可使用策略生成，该策略描述了 SAS 的生效日期和失效日期，以及授予 SAS 持有者的访问级别。</source>
          <target state="new">受信任的应用程序（例如基于云的服务）可使用 <bpt id="p1">**</bpt>QueueService<ept id="p1">**</ept> 的 <bpt id="p2">**</bpt>generateSharedAccessSignature<ept id="p2">**</ept> 生成 SAS，然后将其提供给不受信任的或不完全受信任的应用程序。例如，移动应用程序。SAS 可使用策略生成，该策略描述了 SAS 的生效日期和失效日期，以及授予 SAS 持有者的访问级别。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>下面的示例生成了一个新的共享访问策略，该策略将允许 SAS 持有者向队列添加消息，在创建后 100 分钟过期。</source>
          <target state="new">下面的示例生成了一个新的共享访问策略，该策略将允许 SAS 持有者向队列添加消息，在创建后 100 分钟过期。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>请注意，还必须提供主机信息，因为 SAS 持有者尝试访问队列时，必须提供该信息。</source>
          <target state="new">请注意，还必须提供主机信息，因为 SAS 持有者尝试访问队列时，必须提供该信息。</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>然后，客户端应用程序将 SAS 用于 <bpt id="p1">**</bpt>QueueServiceWithSAS<ept id="p1">**</ept>，以便针对队列执行操作。下面的示例连接到该队列，并创建一条消息。</source>
          <target state="new">然后，客户端应用程序将 SAS 用于 <bpt id="p1">**</bpt>QueueServiceWithSAS<ept id="p1">**</ept>，以便针对队列执行操作。下面的示例连接到该队列，并创建一条消息。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>由于 SAS 在生成时只具有添加访问权限，因此如果尝试读取、更新或删除消息，则会返回错误。</source>
          <target state="new">由于 SAS 在生成时只具有添加访问权限，因此如果尝试读取、更新或删除消息，则会返回错误。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>访问控制列表</source>
          <target state="new">访问控制列表</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>你还可以使用访问控制列表 (ACL) 为 SAS 设置访问策略。如果你希望允许多个客户端访问某个队列，但为每个客户端提供了不同的访问策略，则访问控制列表会很有用。</source>
          <target state="new">你还可以使用访问控制列表 (ACL) 为 SAS 设置访问策略。如果你希望允许多个客户端访问某个队列，但为每个客户端提供了不同的访问策略，则访问控制列表会很有用。</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>ACL 是使用一组访问策略实施的，每个策略都有一个关联的 ID。下面的示例定义了两个策略，一个用于“user1”，一个用于“user2”：</source>
          <target state="new">ACL 是使用一组访问策略实施的，每个策略都有一个关联的 ID。下面的示例定义了两个策略，一个用于“user1”，一个用于“user2”：</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>下面的示例获取 <bpt id="p1">**</bpt>myqueue<ept id="p1">**</ept> 的当前 ACL，然后使用 <bpt id="p2">**</bpt>setQueueAcl<ept id="p2">**</ept> 添加新策略。此方法具有以下用途：</source>
          <target state="new">下面的示例获取 <bpt id="p1">**</bpt>myqueue<ept id="p1">**</ept> 的当前 ACL，然后使用 <bpt id="p2">**</bpt>setQueueAcl<ept id="p2">**</ept> 添加新策略。此方法具有以下用途：</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>设置 ACL 后，你可以根据某个策略的 ID 创建 SAS。以下示例为“user2”创建新的 SAS：</source>
          <target state="new">设置 ACL 后，你可以根据某个策略的 ID 创建 SAS。以下示例为“user2”创建新的 SAS：</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>现在，您已了解有关队列存储的基础知识，可单击下面的链接来了解更复杂的存储任务。</source>
          <target state="new">现在，您已了解有关队列存储的基础知识，可单击下面的链接来了解更复杂的存储任务。</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>访问 <bpt id="p1">[</bpt>Azure 存储空间团队博客<ept id="p1">][]</ept>。</source>
          <target state="new">访问 <bpt id="p1">[</bpt>Azure 存储空间团队博客<ept id="p1">][]</ept>。</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>访问 GitHub 上的 <bpt id="p1">[</bpt>Azure Storage SDK for Node<ept id="p1">][]</ept> 存储库。</source>
          <target state="new">访问 GitHub 上的 <bpt id="p1">[</bpt>Azure Storage SDK for Node<ept id="p1">][]</ept> 存储库。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>