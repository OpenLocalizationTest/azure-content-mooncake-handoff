<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d390f2a7a329b00c7e56c55769aec7fec48f1084</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>使用 Storm on HDInsight 从事件中心处理事件 | Azure</source>
          <target state="new">使用 Storm on HDInsight 从事件中心处理事件 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何使用在 Visual Studio 中通过 HDInsight Tools for Visual Studio 创建的 C# Storm 拓扑处理事件中心数据。</source>
          <target state="new">了解如何使用在 Visual Studio 中通过 HDInsight Tools for Visual Studio 创建的 C# Storm 拓扑处理事件中心数据。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>使用 Storm on HDInsight 从 Azure 事件中心处理事件 (C#)</source>
          <target state="new">使用 Storm on HDInsight 从 Azure 事件中心处理事件 (C#)</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Azure 事件中心可让你处理 Web 应用、应用程序和设备中的大量数据。借助事件中心 Spout，你可以轻松使用 Apache Storm on HDInsight 实时分析这些数据。你还可以使用事件中心 Bolt 从 Storm 向事件中心写入数据。</source>
          <target state="new">Azure 事件中心可让你处理 Web 应用、应用程序和设备中的大量数据。借助事件中心 Spout，你可以轻松使用 Apache Storm on HDInsight 实时分析这些数据。你还可以使用事件中心 Bolt 从 Storm 向事件中心写入数据。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>在本教程中，你将学习如何使用 HDInsight Tools for Visual Studio 和事件中心 Spout 和 Bolt 创建两个混合 C#/Java 拓扑：</source>
          <target state="new">在本教程中，你将学习如何使用 HDInsight Tools for Visual Studio 和事件中心 Spout 和 Bolt 创建两个混合 C#/Java 拓扑：</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>EventHubWriter<ept id="p1">**</ept>：随机生成数据，并将其写入事件中心</source>
          <target state="new"><bpt id="p1">**</bpt>EventHubWriter<ept id="p1">**</ept>：随机生成数据，并将其写入事件中心</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>EventHubReader<ept id="p1">**</ept>：从事件中心读取数据，并将其存储在 Azure 表存储中</source>
          <target state="new"><bpt id="p1">**</bpt>EventHubReader<ept id="p1">**</ept>：从事件中心读取数据，并将其存储在 Azure 表存储中</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>先决条件</source>
          <target state="new">先决条件</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>一个 <bpt id="p1">[</bpt>Apache Storm on HDInsight 群集<ept id="p1">](/documentation/articles/hdinsight-apache-storm-tutorial-get-started)</ept></source>
          <target state="new">一个 <bpt id="p1">[</bpt>Apache Storm on HDInsight 群集<ept id="p1">](/documentation/articles/hdinsight-apache-storm-tutorial-get-started)</ept></target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>一个 <bpt id="p1">[</bpt>Azure 事件中心<ept id="p1">](/documentation/articles/event-hubs-csharp-ephcs-getstarted)</ept></source>
          <target state="new">一个 <bpt id="p1">[</bpt>Azure 事件中心<ept id="p1">](/documentation/articles/event-hubs-csharp-ephcs-getstarted)</ept></target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Azure .NET SDK</source>
          <target state="new">Azure .NET SDK</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>HDInsight Tools for Visual Studio</source>
          <target state="new">HDInsight Tools for Visual Studio</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>已完成的项目</source>
          <target state="new">已完成的项目</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>你可以从 GitHub 下载本教程中所创建的项目的完整版本：<bpt id="p1">[</bpt>eventhub-storm-hybrid<ept id="p1">](https://github.com/Blackmist/eventhub-storm-hybrid)</ept>。不过，你仍然必须根据本教程中的步骤提供配置设置。</source>
          <target state="new">你可以从 GitHub 下载本教程中所创建的项目的完整版本：<bpt id="p1">[</bpt>eventhub-storm-hybrid<ept id="p1">](https://github.com/Blackmist/eventhub-storm-hybrid)</ept>。不过，你仍然必须根据本教程中的步骤提供配置设置。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>在使用已完成的项目时，你必须使用 <bpt id="p1">**</bpt>NuGet 包管理器<ept id="p1">**</ept>来还原此解决方案所需的程序包。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>在使用已完成的项目时，你必须使用 <bpt id="p1">**</bpt>NuGet 包管理器<ept id="p1">**</ept>来还原此解决方案所需的程序包。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>事件中心 Spout 和 Bolt</source>
          <target state="new">事件中心 Spout 和 Bolt</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>事件中心 Spout 和 Bolt 是可让你轻松从 Apache Storm 使用事件中心的 Java 组件。虽然这些组件是用 Java 语言编写的，但 HDInsight Tools for Visual Studio 允许你创建混用 C# 和 Java 组件的混合拓扑。</source>
          <target state="new">事件中心 Spout 和 Bolt 是可让你轻松从 Apache Storm 使用事件中心的 Java 组件。虽然这些组件是用 Java 语言编写的，但 HDInsight Tools for Visual Studio 允许你创建混用 C# 和 Java 组件的混合拓扑。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Spout 和 Bolt 以名为 <bpt id="p1">**</bpt>eventhubs-storm-spout-0.9-jar-with-dependencies.jar<ept id="p1">**</ept> 的单个 Java 存档 (.jar) 文件的形式分发。</source>
          <target state="new">Spout 和 Bolt 以名为 <bpt id="p1">**</bpt>eventhubs-storm-spout-0.9-jar-with-dependencies.jar<ept id="p1">**</ept> 的单个 Java 存档 (.jar) 文件的形式分发。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>下载 .jar 文件</source>
          <target state="new">下载 .jar 文件</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a href="https://github.com/hdinsight/hdinsight-storm-examples" target="_blank"&gt;</ph>HDInsight Storm 示例<ph id="ph2">&lt;/a&gt;</ph>项目中 <bpt id="p1">**</bpt>lib<ept id="p1">**</ept> 文件夹下包含了最新版本的 <bpt id="p2">**</bpt>eventhubs-storm-Spout-0.9-jar-with-dependencies.jar<ept id="p2">**</ept> 文件。若要下载该文件，请使用以下方法之一。</source>
          <target state="new"><ph id="ph1">&lt;a href="https://github.com/hdinsight/hdinsight-storm-examples" target="_blank"&gt;</ph>HDInsight Storm 示例<ph id="ph2">&lt;/a&gt;</ph>项目中 <bpt id="p1">**</bpt>lib<ept id="p1">**</ept> 文件夹下包含了最新版本的 <bpt id="p2">**</bpt>eventhubs-storm-Spout-0.9-jar-with-dependencies.jar<ept id="p2">**</ept> 文件。若要下载该文件，请使用以下方法之一。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>已提交 Spout 和 Bolt 以包含在 Apache Storm 项目中。有关详细信息，请参阅 GitHub 中的 <ph id="ph2">&lt;a href="https://github.com/apache/storm/pull/336/files"&gt;</ph>STORM-583：Storm 事件中心的初始签入<ph id="ph3">&lt;/a&gt;</ph>。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>已提交 Spout 和 Bolt 以包含在 Apache Storm 项目中。有关详细信息，请参阅 GitHub 中的 <ph id="ph2">&lt;a href="https://github.com/apache/storm/pull/336/files"&gt;</ph>STORM-583：Storm 事件中心的初始签入<ph id="ph3">&lt;/a&gt;</ph>。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>下载 ZIP 文件<ept id="p1">**</ept>：在 <ph id="ph1">&lt;a href="https://github.com/hdinsight/hdinsight-storm-examples" target="_blank"&gt;</ph>HDInsight Storm 示例<ph id="ph2">&lt;/a&gt;</ph>站点中，选择右窗格中的“下载 ZIP”来下载包含项目的 .zip 文件。</source>
          <target state="new"><bpt id="p1">**</bpt>下载 ZIP 文件<ept id="p1">**</ept>：在 <ph id="ph1">&lt;a href="https://github.com/hdinsight/hdinsight-storm-examples" target="_blank"&gt;</ph>HDInsight Storm 示例<ph id="ph2">&lt;/a&gt;</ph>站点中，选择右窗格中的“下载 ZIP”来下载包含项目的 .zip 文件。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>下载 zip 按钮</source>
          <target state="new">下载 zip 按钮</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>下载文件后，你可以解压缩存档，该文件位于 <bpt id="p1">**</bpt>lib<ept id="p1">**</ept> 目录中。</source>
          <target state="new">下载文件后，你可以解压缩存档，该文件位于 <bpt id="p1">**</bpt>lib<ept id="p1">**</ept> 目录中。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>克隆项目<ept id="p1">**</ept>：如果你已安装 <ph id="ph1">&lt;a href="http://git-scm.com/" target="_blank"&gt;</ph>Git<ph id="ph2">&lt;/a&gt;</ph>，请使用以下命令在本地克隆存储库，然后查找 <bpt id="p2">**</bpt>lib<ept id="p2">**</ept> 目录中的文件。</source>
          <target state="new"><bpt id="p1">**</bpt>克隆项目<ept id="p1">**</ept>：如果你已安装 <ph id="ph1">&lt;a href="http://git-scm.com/" target="_blank"&gt;</ph>Git<ph id="ph2">&lt;/a&gt;</ph>，请使用以下命令在本地克隆存储库，然后查找 <bpt id="p2">**</bpt>lib<ept id="p2">**</ept> 目录中的文件。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>配置事件中心</source>
          <target state="new">配置事件中心</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>事件中心是此示例的数据源。按照下列步骤创建一个新的事件中心。</source>
          <target state="new">事件中心是此示例的数据源。按照下列步骤创建一个新的事件中心。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](https://manage.windowsazure.cn)</ept>中，选择“新建”&gt;“服务总线”&gt;“事件中心”&gt;“自定义创建”。</source>
          <target state="new">在 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](https://manage.windowsazure.cn)</ept>中，选择“新建”&gt;“服务总线”&gt;“事件中心”&gt;“自定义创建”。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>在“添加新事件中心”屏幕中，输入“事件中心名称”，选择要在其中创建中心的“区域”，然后创建新的命名空间或选择现有的命名空间。单击<bpt id="p1">**</bpt>箭头<ept id="p1">**</ept>继续。</source>
          <target state="new">在“添加新事件中心”屏幕中，输入“事件中心名称”，选择要在其中创建中心的“区域”，然后创建新的命名空间或选择现有的命名空间。单击<bpt id="p1">**</bpt>箭头<ept id="p1">**</ept>继续。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>向导页 1</source>
          <target state="new">向导页 1</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>应该选择与 Storm on HDInsight 服务器相同的<bpt id="p1">**</bpt>位置<ept id="p1">**</ept>，以降低延迟和成本。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>应该选择与 Storm on HDInsight 服务器相同的<bpt id="p1">**</bpt>位置<ept id="p1">**</ept>，以降低延迟和成本。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>在“配置事件中心”屏幕中，输入“分区计数”和“消息保留期”值。对于本示例，请使用分区计数 10，消息保留期 1。记下分区计数，因为稍后需要用到。</source>
          <target state="new">在“配置事件中心”屏幕中，输入“分区计数”和“消息保留期”值。对于本示例，请使用分区计数 10，消息保留期 1。记下分区计数，因为稍后需要用到。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>向导页 2</source>
          <target state="new">向导页 2</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>创建事件中心之后，请选择命名空间，选择“事件中心”，然后选择你前面创建的事件中心。</source>
          <target state="new">创建事件中心之后，请选择命名空间，选择“事件中心”，然后选择你前面创建的事件中心。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>选择“配置”，然后使用以下信息创建两个新的访问策略。</source>
          <target state="new">选择“配置”，然后使用以下信息创建两个新的访问策略。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="new">Name</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>权限</source>
          <target state="new">权限</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>写入器</source>
          <target state="new">写入器</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>发送</source>
          <target state="new">发送</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>读取器</source>
          <target state="new">读取器</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>侦听</source>
          <target state="new">侦听</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>创建权限后，在页面底部选择“保存”图标。这将会创建共享访问策略，用于对此事件中心进行发送 (writer) 和侦听 (reader)。</source>
          <target state="new">创建权限后，在页面底部选择“保存”图标。这将会创建共享访问策略，用于对此事件中心进行发送 (writer) 和侦听 (reader)。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>保存策略后，使用页面底部的“共享访问密钥生成器”检索 <bpt id="p1">**</bpt>writer<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>reader<ept id="p2">**</ept> 策略的密钥。保存这些密钥，因为稍后将要用到。</source>
          <target state="new">保存策略后，使用页面底部的“共享访问密钥生成器”检索 <bpt id="p1">**</bpt>writer<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>reader<ept id="p2">**</ept> 策略的密钥。保存这些密钥，因为稍后将要用到。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>配置表存储</source>
          <target state="new">配置表存储</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>表存储用于保存从事件中心读取的值，你可以轻松地在 Visual Studio 中通过“服务器资源管理器”查看表存储。使用以下步骤创建新的表存储：</source>
          <target state="new">表存储用于保存从事件中心读取的值，你可以轻松地在 Visual Studio 中通过“服务器资源管理器”查看表存储。使用以下步骤创建新的表存储：</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](https://manage.windowsazure.cn)</ept>中，选择“新建”&gt;“数据服务”&gt;“存储”&gt;“快速创建”。</source>
          <target state="new">在 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](https://manage.windowsazure.cn)</ept>中，选择“新建”&gt;“数据服务”&gt;“存储”&gt;“快速创建”。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>快速创建存储</source>
          <target state="new">快速创建存储</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>输入存储帐户的<bpt id="p1">**</bpt>名称<ept id="p1">**</ept>，选择一个<bpt id="p2">**</bpt>位置<ept id="p2">**</ept>，然后单击<bpt id="p3">**</bpt>复选标记<ept id="p3">**</ept>以创建存储帐户。</source>
          <target state="new">输入存储帐户的<bpt id="p1">**</bpt>名称<ept id="p1">**</ept>，选择一个<bpt id="p2">**</bpt>位置<ept id="p2">**</ept>，然后单击<bpt id="p3">**</bpt>复选标记<ept id="p3">**</ept>以创建存储帐户。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>应该选择与事件中心和 Storm on HDInsight 服务器相同的<bpt id="p1">**</bpt>位置<ept id="p1">**</ept>，以降低延迟和成本。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>应该选择与事件中心和 Storm on HDInsight 服务器相同的<bpt id="p1">**</bpt>位置<ept id="p1">**</ept>，以降低延迟和成本。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>预配新的存储帐户后，请选择该帐户，然后使用页面底部的“管理访问密钥”链接检索“存储帐户名称”和“主访问密钥”。保存此信息，因为稍后将要用到。</source>
          <target state="new">预配新的存储帐户后，请选择该帐户，然后使用页面底部的“管理访问密钥”链接检索“存储帐户名称”和“主访问密钥”。保存此信息，因为稍后将要用到。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>访问密钥</source>
          <target state="new">访问密钥</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>创建 EventHubWriter</source>
          <target state="new">创建 EventHubWriter</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>在本部分中，你将要使用事件中心 Bolt 创建向事件中心写入数据的拓扑。</source>
          <target state="new">在本部分中，你将要使用事件中心 Bolt 创建向事件中心写入数据的拓扑。</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>如果你尚未安装最新版本的 HDInsight Tools for Visual Studio，请参阅<ph id="ph1">&lt;a href="/documentation/articles/hdinsight-hadoop-visual-studio-tools-get-started" target="_blank"&gt;</ph>开始使用 HDInsight Tools for Visual Studio<ph id="ph2">&lt;/a&gt;</ph>。</source>
          <target state="new">如果你尚未安装最新版本的 HDInsight Tools for Visual Studio，请参阅<ph id="ph1">&lt;a href="/documentation/articles/hdinsight-hadoop-visual-studio-tools-get-started" target="_blank"&gt;</ph>开始使用 HDInsight Tools for Visual Studio<ph id="ph2">&lt;/a&gt;</ph>。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>打开 Visual Studio，选择“文件”&gt;“新建”&gt;“项目”。</source>
          <target state="new">打开 Visual Studio，选择“文件”&gt;“新建”&gt;“项目”。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>在“新建项目”屏幕中，展开“已安装”&gt;“模板”，然后选择“HDInsight”。从模板列表中，选择“Storm 应用程序”。在屏幕底部，输入 <bpt id="p1">**</bpt>EventHubWriter<ept id="p1">**</ept> 作为应用程序名称。</source>
          <target state="new">在“新建项目”屏幕中，展开“已安装”&gt;“模板”，然后选择“HDInsight”。从模板列表中，选择“Storm 应用程序”。在屏幕底部，输入 <bpt id="p1">**</bpt>EventHubWriter<ept id="p1">**</ept> 作为应用程序名称。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>图像</source>
          <target state="new">图像</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>创建项目后，你应该会获得以下文件：</source>
          <target state="new">创建项目后，你应该会获得以下文件：</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept>：定义项目的拓扑。请注意，默认情况下会创建包含一个 Spout 和一个 Bolt 的默认拓扑。</source>
          <target state="new"><bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept>：定义项目的拓扑。请注意，默认情况下会创建包含一个 Spout 和一个 Bolt 的默认拓扑。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Spout.cs<ept id="p1">**</ept>：示例 Spout。</source>
          <target state="new"><bpt id="p1">**</bpt>Spout.cs<ept id="p1">**</ept>：示例 Spout。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Bolt.cs<ept id="p1">**</ept>：示例 Bolt。稍后需要删除此文件，因为你要使用事件中心 Bolt 向事件中心写入数据</source>
          <target state="new"><bpt id="p1">**</bpt>Bolt.cs<ept id="p1">**</ept>：示例 Bolt。稍后需要删除此文件，因为你要使用事件中心 Bolt 向事件中心写入数据</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>配置</source>
          <target state="new">配置</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中，右键单击“EventHubWriter”，然后选择“属性”。</source>
          <target state="new">在“解决方案资源管理器”中，右键单击“EventHubWriter”，然后选择“属性”。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>在项目属性中，选择“设置”，然后选择“此项目不包含默认的设置文件。单击此处可创建一个”。</source>
          <target state="new">在项目属性中，选择“设置”，然后选择“此项目不包含默认的设置文件。单击此处可创建一个”。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>输入以下设置。在“值”列中使用前面创建的事件中心的信息。</source>
          <target state="new">输入以下设置。在“值”列中使用前面创建的事件中心的信息。</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="new">Name</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>类型</source>
          <target state="new">类型</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>范围</source>
          <target state="new">范围</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>EventHubPolicyName</source>
          <target state="new">EventHubPolicyName</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>字符串</source>
          <target state="new">字符串</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>应用程序</source>
          <target state="new">应用程序</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>EventHubPolicyKey</source>
          <target state="new">EventHubPolicyKey</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>字符串</source>
          <target state="new">字符串</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>应用程序</source>
          <target state="new">应用程序</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>EventHubNamespace</source>
          <target state="new">EventHubNamespace</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>字符串</source>
          <target state="new">字符串</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>应用程序</source>
          <target state="new">应用程序</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>EventHubName</source>
          <target state="new">EventHubName</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>字符串</source>
          <target state="new">字符串</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>应用程序</source>
          <target state="new">应用程序</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>EventHubPartitionCount</source>
          <target state="new">EventHubPartitionCount</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>int</source>
          <target state="new">int</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>应用程序</source>
          <target state="new">应用程序</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>保存并关闭“属性”页。</source>
          <target state="new">保存并关闭“属性”页。</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>定义拓扑</source>
          <target state="new">定义拓扑</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中，右键单击“Bolt.cs”并选择“删除”。由于你使用的是 Java 事件中心 Bolt，因此不需要此文件。</source>
          <target state="new">在“解决方案资源管理器”中，右键单击“Bolt.cs”并选择“删除”。由于你使用的是 Java 事件中心 Bolt，因此不需要此文件。</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>打开 <bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept> 文件，并紧接在 <ph id="ph1">`TopologyBuilder topologyBuilder = new TopologyBuilder("EventHubWriter");`</ph> 行后添加以下内容。</source>
          <target state="new">打开 <bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept> 文件，并紧接在 <ph id="ph1">`TopologyBuilder topologyBuilder = new TopologyBuilder("EventHubWriter");`</ph> 行后添加以下内容。</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>第一行从前面定义的属性中读取分区计数。第二行定义一个反序列化程序，用于将 Spout 生成的 JSON 数据反序列化为 <ph id="ph1">`java.lang.String`</ph>，使 Java 组件可以使用数据。</source>
          <target state="new">第一行从前面定义的属性中读取分区计数。第二行定义一个反序列化程序，用于将 Spout 生成的 JSON 数据反序列化为 <ph id="ph1">`java.lang.String`</ph>，使 Java 组件可以使用数据。</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>找到以下代码：</source>
          <target state="new">找到以下代码：</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>将它替换为以下代码：</source>
          <target state="new">将它替换为以下代码：</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>这将会创建一个 Spout，并使用事件中心分区计数作为此组件的并行度提示。这还应该为每个分区创建 Spout 的实例。</source>
          <target state="new">这将会创建一个 Spout，并使用事件中心分区计数作为此组件的并行度提示。这还应该为每个分区创建 Spout 的实例。</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>这还会将前面创建的反序列化程序与此组件的输出流相关联。这样，下游 EventHubSpout 组件便可以使用 C# Spout 生成的数据。</source>
          <target state="new">这还会将前面创建的反序列化程序与此组件的输出流相关联。这样，下游 EventHubSpout 组件便可以使用 C# Spout 生成的数据。</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>紧接在上述代码的后面添加以下代码：</source>
          <target state="new">紧接在上述代码的后面添加以下代码：</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>这将为 Java Bolt 创建一个新的构造函数，在运行时，将使用此构造函数配置 Bolt 的新实例。在这种情况下，你将要通过 <ph id="ph1">&lt;a href="http://storm.apache.org/documentation/Clojure-DSL.html" target="_blank"&gt;</ph>Apache Storm Clojure DSL<ph id="ph2">&lt;/a&gt;</ph> 使用前面添加的事件中心配置信息来配置 Spout。更具体地说，HDInsight 在运行时将使用此代码执行以下操作：</source>
          <target state="new">这将为 Java Bolt 创建一个新的构造函数，在运行时，将使用此构造函数配置 Bolt 的新实例。在这种情况下，你将要通过 <ph id="ph1">&lt;a href="http://storm.apache.org/documentation/Clojure-DSL.html" target="_blank"&gt;</ph>Apache Storm Clojure DSL<ph id="ph2">&lt;/a&gt;</ph> 使用前面添加的事件中心配置信息来配置 Spout。更具体地说，HDInsight 在运行时将使用此代码执行以下操作：</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>使用你提供的事件中心信息创建 <bpt id="p1">**</bpt>com.microsoft.eventhubs.bolt.EventHubBoltConfig<ept id="p1">**</ept> 的新实例。</source>
          <target state="new">使用你提供的事件中心信息创建 <bpt id="p1">**</bpt>com.microsoft.eventhubs.bolt.EventHubBoltConfig<ept id="p1">**</ept> 的新实例。</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>创建 <bpt id="p1">**</bpt>com.microsoft.eventhubs.bolt.EventHubBolt<ept id="p1">**</ept> 的新实例并传入 <bpt id="p2">**</bpt>EventHubBoltConfig<ept id="p2">**</ept> 实例。</source>
          <target state="new">创建 <bpt id="p1">**</bpt>com.microsoft.eventhubs.bolt.EventHubBolt<ept id="p1">**</ept> 的新实例并传入 <bpt id="p2">**</bpt>EventHubBoltConfig<ept id="p2">**</ept> 实例。</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>找到以下代码：</source>
          <target state="new">找到以下代码：</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>将它替换为以下代码：</source>
          <target state="new">将它替换为以下代码：</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>这会指示拓扑使用上述步骤中的 <bpt id="p1">**</bpt>JavaComponentConstructor<ept id="p1">**</ept> 作为 Bolt。可以在此拓扑中使用友好名称“EventHubBolt”引用该组件。 并行度提示设置为事件集线器的分区数，它订阅 Spout（“Spout”）生成的数据。</source>
          <target state="new">这会指示拓扑使用上述步骤中的 <bpt id="p1">**</bpt>JavaComponentConstructor<ept id="p1">**</ept> 作为 Bolt。可以在此拓扑中使用友好名称“EventHubBolt”引用该组件。 并行度提示设置为事件集线器的分区数，它订阅 Spout（“Spout”）生成的数据。</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>此时，你已完成了 <bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept>。已经定义了拓扑，但现在，你必须修改 <bpt id="p2">**</bpt>Spout.cs<ept id="p2">**</ept>，使它能够以事件中心 Bolt 可以使用的格式生成数据。</source>
          <target state="new">此时，你已完成了 <bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept>。已经定义了拓扑，但现在，你必须修改 <bpt id="p2">**</bpt>Spout.cs<ept id="p2">**</ept>，使它能够以事件中心 Bolt 可以使用的格式生成数据。</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>此拓扑将默认为创建一个工作进程，这足以满足示例目的。如果要针对生产群集改写此拓拟，应添加以下代码以更改工作线程数目：</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>此拓扑将默认为创建一个工作进程，这足以满足示例目的。如果要针对生产群集改写此拓拟，应添加以下代码以更改工作线程数目：</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>修改 Spout</source>
          <target state="new">修改 Spout</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>事件中心 Bolt 需要单个字符串值，该值将路由到事件中心。在以下示例中，你将要修改默认的 <bpt id="p1">**</bpt>Spout.cs<ept id="p1">**</ept> 文件以生成 JSON 字符串。</source>
          <target state="new">事件中心 Bolt 需要单个字符串值，该值将路由到事件中心。在以下示例中，你将要修改默认的 <bpt id="p1">**</bpt>Spout.cs<ept id="p1">**</ept> 文件以生成 JSON 字符串。</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中，打开“Spout.cs”，在该文件的顶部添加以下内容：</source>
          <target state="new">在“解决方案资源管理器”中，打开“Spout.cs”，在该文件的顶部添加以下内容：</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>这样，我们便可以更轻松地使用 JSON 数据。</source>
          <target state="new">这样，我们便可以更轻松地使用 JSON 数据。</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>JSON.NET 包应已安装，因为它是用于 C# Storm 拓扑的 SCP.NET 框架所必需的。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>JSON.NET 包应已安装，因为它是用于 C# Storm 拓扑的 SCP.NET 框架所必需的。</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>找到以下代码：</source>
          <target state="new">找到以下代码：</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>将它替换为以下代码：</source>
          <target state="new">将它替换为以下代码：</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>这会更改 Spout 创建的数据定义，以使用<bpt id="p1">**</bpt>字符串<ept id="p1">**</ept>数据以及前面在拓扑中声明的 <bpt id="p2">**</bpt>CustomizedInteropJSONSerializer<ept id="p2">**</ept>（在 program.cs 中）。</source>
          <target state="new">这会更改 Spout 创建的数据定义，以使用<bpt id="p1">**</bpt>字符串<ept id="p1">**</ept>数据以及前面在拓扑中声明的 <bpt id="p2">**</bpt>CustomizedInteropJSONSerializer<ept id="p2">**</ept>（在 program.cs 中）。</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>将 <bpt id="p1">**</bpt>NextTuple<ept id="p1">**</ept> 方法替换为以下内容：</source>
          <target state="new">将 <bpt id="p1">**</bpt>NextTuple<ept id="p1">**</ept> 方法替换为以下内容：</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>这将随机生成一个设备 ID 和一个值，并使用 Json.NET 发出使用这些值的 JSON 对象。</source>
          <target state="new">这将随机生成一个设备 ID 和一个值，并使用 Json.NET 发出使用这些值的 JSON 对象。</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>保存 <bpt id="p1">**</bpt>Spout.cs<ept id="p1">**</ept> 文件。</source>
          <target state="new">保存 <bpt id="p1">**</bpt>Spout.cs<ept id="p1">**</ept> 文件。</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>此时，你已创建了一个基本拓扑，该拓扑将生成随机数据，并使用事件中心 Bolt 将其存储在事件中心。接下来，你要创建读取器。</source>
          <target state="new">此时，你已创建了一个基本拓扑，该拓扑将生成随机数据，并使用事件中心 Bolt 将其存储在事件中心。接下来，你要创建读取器。</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>创建 EventHubReader</source>
          <target state="new">创建 EventHubReader</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>在本部分中，你将要使用事件中心 Spout 创建从事件中心读取数据的拓扑。</source>
          <target state="new">在本部分中，你将要使用事件中心 Spout 创建从事件中心读取数据的拓扑。</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>打开 Visual Studio，选择“文件”&gt;“新建”&gt;“项目”。</source>
          <target state="new">打开 Visual Studio，选择“文件”&gt;“新建”&gt;“项目”。</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>在“新建项目”屏幕中，展开“已安装”&gt;“模板”，然后选择“HDInsight”。从模板列表中，选择“Storm 应用程序”。在屏幕底部，输入 <bpt id="p1">**</bpt>EventHubReader<ept id="p1">**</ept> 作为应用程序名称。</source>
          <target state="new">在“新建项目”屏幕中，展开“已安装”&gt;“模板”，然后选择“HDInsight”。从模板列表中，选择“Storm 应用程序”。在屏幕底部，输入 <bpt id="p1">**</bpt>EventHubReader<ept id="p1">**</ept> 作为应用程序名称。</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>配置</source>
          <target state="new">配置</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中，右键单击“EventHubReader”，然后选择“属性”。</source>
          <target state="new">在“解决方案资源管理器”中，右键单击“EventHubReader”，然后选择“属性”。</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>在项目属性中，选择“设置”，然后选择“此项目不包含默认的设置文件。单击此处可创建一个”。</source>
          <target state="new">在项目属性中，选择“设置”，然后选择“此项目不包含默认的设置文件。单击此处可创建一个”。</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>输入以下设置。在“值”列中使用前面创建的事件中心和存储帐户的信息。</source>
          <target state="new">输入以下设置。在“值”列中使用前面创建的事件中心和存储帐户的信息。</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="new">Name</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>类型</source>
          <target state="new">类型</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>范围</source>
          <target state="new">范围</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>EventHubPolicyName</source>
          <target state="new">EventHubPolicyName</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>字符串</source>
          <target state="new">字符串</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>应用程序</source>
          <target state="new">应用程序</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>EventHubPolicyKey</source>
          <target state="new">EventHubPolicyKey</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>字符串</source>
          <target state="new">字符串</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>应用程序</source>
          <target state="new">应用程序</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>EventHubNamespace</source>
          <target state="new">EventHubNamespace</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>字符串</source>
          <target state="new">字符串</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>应用程序</source>
          <target state="new">应用程序</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>EventHubName</source>
          <target state="new">EventHubName</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>字符串</source>
          <target state="new">字符串</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>应用程序</source>
          <target state="new">应用程序</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>EventHubPartitionCount</source>
          <target state="new">EventHubPartitionCount</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>int</source>
          <target state="new">int</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>应用程序</source>
          <target state="new">应用程序</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>StorageConnection</source>
          <target state="new">StorageConnection</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>（连接字符串）</source>
          <target state="new">（连接字符串）</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>应用程序</source>
          <target state="new">应用程序</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>TableName</source>
          <target state="new">TableName</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>字符串</source>
          <target state="new">字符串</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>应用程序</source>
          <target state="new">应用程序</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>对于 <bpt id="p1">**</bpt>TableName<ept id="p1">**</ept>，请输入要在其中存储事件的表的名称。</source>
          <target state="new">对于 <bpt id="p1">**</bpt>TableName<ept id="p1">**</ept>，请输入要在其中存储事件的表的名称。</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>对于 <bpt id="p1">**</bpt>StorageConnection<ept id="p1">**</ept>，请输入值 <ph id="ph1">`DefaultEndpointsProtocol=https;AccountName=myAccount;AccountKey=myKey;`</ph>。将 <bpt id="p2">**</bpt>myAccount<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>myKey<ept id="p3">**</ept> 分别替换为前面获取的存储帐户名和密钥。</source>
          <target state="new">对于 <bpt id="p1">**</bpt>StorageConnection<ept id="p1">**</ept>，请输入值 <ph id="ph1">`DefaultEndpointsProtocol=https;AccountName=myAccount;AccountKey=myKey;`</ph>。将 <bpt id="p2">**</bpt>myAccount<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>myKey<ept id="p3">**</ept> 分别替换为前面获取的存储帐户名和密钥。</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>拓扑将使用这些值来与事件中心和表存储通信。</source>
          <target state="new">拓扑将使用这些值来与事件中心和表存储通信。</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>保存并关闭“属性”页。</source>
          <target state="new">保存并关闭“属性”页。</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>定义拓扑</source>
          <target state="new">定义拓扑</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中，右键单击“Spout.cs”并选择“删除”。由于你使用的是 Java 事件中心 Spout，因此不需要此文件。</source>
          <target state="new">在“解决方案资源管理器”中，右键单击“Spout.cs”并选择“删除”。由于你使用的是 Java 事件中心 Spout，因此不需要此文件。</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>打开 <bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept> 文件，并紧接在 <ph id="ph1">`TopologyBuilder topologyBuilder = new TopologyBuilder("EventHubReader");`</ph> 行后添加以下代码：</source>
          <target state="new">打开 <bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept> 文件，并紧接在 <ph id="ph1">`TopologyBuilder topologyBuilder = new TopologyBuilder("EventHubReader");`</ph> 行后添加以下代码：</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>将读取分区计数并将其分配到本地变量。该计数将多次使用。</source>
          <target state="new">将读取分区计数并将其分配到本地变量。该计数将多次使用。</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`EventHubSpoutConfig`</ph> 定义事件中心 Spout 的配置。在本例中，此为你在前面添加的事件中心配置信息。此代码在幕后使用 Java 事件中心 Spout，并使用事件中心信息创建 <bpt id="p1">**</bpt>com.microsoft.eventhubs.spout.EventHubSpoutConfig<ept id="p1">**</ept> 的新实例。</source>
          <target state="new"><ph id="ph1">`EventHubSpoutConfig`</ph> 定义事件中心 Spout 的配置。在本例中，此为你在前面添加的事件中心配置信息。此代码在幕后使用 Java 事件中心 Spout，并使用事件中心信息创建 <bpt id="p1">**</bpt>com.microsoft.eventhubs.spout.EventHubSpoutConfig<ept id="p1">**</ept> 的新实例。</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>找到以下代码：</source>
          <target state="new">找到以下代码：</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>将它替换为以下代码：</source>
          <target state="new">将它替换为以下代码：</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>这会指示拓扑创建新的事件中心 Spout 并使用前一个步骤的 <ph id="ph1">`EventHubSpoutConfig`</ph> 作为配置。“EventHubSpout”设置 Spout 的友好名称，<ph id="ph2">`partitionCount`</ph> 用于设置并行度提示。此代码在幕后使用提供的配置信息来创建 <bpt id="p1">**</bpt>com.microsoft.eventhubs.Spout.EventHubSpout<ept id="p1">**</ept> Java 组件的新实例。</source>
          <target state="new">这会指示拓扑创建新的事件中心 Spout 并使用前一个步骤的 <ph id="ph1">`EventHubSpoutConfig`</ph> 作为配置。“EventHubSpout”设置 Spout 的友好名称，<ph id="ph2">`partitionCount`</ph> 用于设置并行度提示。此代码在幕后使用提供的配置信息来创建 <bpt id="p1">**</bpt>com.microsoft.eventhubs.Spout.EventHubSpout<ept id="p1">**</ept> Java 组件的新实例。</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>紧接在上述代码的后面添加以下内容：</source>
          <target state="new">紧接在上述代码的后面添加以下内容：</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>这创建一个自定义的序列化程序，可用来将 Java 组件（例如 ）生成的信息序列化为下游 C# 组件可使用的 JSON 格式。</source>
          <target state="new">这创建一个自定义的序列化程序，可用来将 Java 组件（例如 ）生成的信息序列化为下游 C# 组件可使用的 JSON 格式。</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>找到以下代码：</source>
          <target state="new">找到以下代码：</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>将它替换为以下代码：</source>
          <target state="new">将它替换为以下代码：</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>此代码指示拓扑使用某个 Bolt（在 Bolt.cs 中定义）。此处使用前面定义的自定义序列化程序，以便此 Bolt 可使用上游 Java 组件生成的数据。在此情况下为 EventHubSpout。</source>
          <target state="new">此代码指示拓扑使用某个 Bolt（在 Bolt.cs 中定义）。此处使用前面定义的自定义序列化程序，以便此 Bolt 可使用上游 Java 组件生成的数据。在此情况下为 EventHubSpout。</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>SetBolt 的最后一个参数（值为 <ph id="ph2">`true`</ph>）启用此 Bolt 的 ACK 功能。这是必需的 EventHubSpout 组件需要它会发出的数据的 ACK。如果下游组件不会返回确认，Spout 将停止处理大约 1000 个消息后接收。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>SetBolt 的最后一个参数（值为 <ph id="ph2">`true`</ph>）启用此 Bolt 的 ACK 功能。这是必需的 EventHubSpout 组件需要它会发出的数据的 ACK。如果下游组件不会返回确认，Spout 将停止处理大约 1000 个消息后接收。</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>此时，你已完成了 <bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept>。已经定义了拓扑，但现在，你必须创建一个帮助器类，以将数据写入表存储，然后，必须修改 <bpt id="p2">**</bpt>Bolt.cs<ept id="p2">**</ept>，以便它可以理解 Spout 生成的数据。</source>
          <target state="new">此时，你已完成了 <bpt id="p1">**</bpt>Program.cs<ept id="p1">**</ept>。已经定义了拓扑，但现在，你必须创建一个帮助器类，以将数据写入表存储，然后，必须修改 <bpt id="p2">**</bpt>Bolt.cs<ept id="p2">**</ept>，以便它可以理解 Spout 生成的数据。</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>此拓扑将默认为创建一个工作进程，这足以满足示例目的。如果要针对生产群集改写此拓拟，应添加以下代码以更改工作线程数目：</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>此拓扑将默认为创建一个工作进程，这足以满足示例目的。如果要针对生产群集改写此拓拟，应添加以下代码以更改工作线程数目：</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>创建帮助器类</source>
          <target state="new">创建帮助器类</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>将数据写入表存储时，你必须创建一个类来描述要写入的数据。</source>
          <target state="new">将数据写入表存储时，你必须创建一个类来描述要写入的数据。</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中，右键单击“EventHubReader”项目，然后依次选择“添加”和“新建类”。将新类命名为 <bpt id="p1">**</bpt>Devices.cs<ept id="p1">**</ept>。</source>
          <target state="new">在“解决方案资源管理器”中，右键单击“EventHubReader”项目，然后依次选择“添加”和“新建类”。将新类命名为 <bpt id="p1">**</bpt>Devices.cs<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>打开 <bpt id="p1">**</bpt>Devices.cs<ept id="p1">**</ept>，将默认代码替换为以下代码：</source>
          <target state="new">打开 <bpt id="p1">**</bpt>Devices.cs<ept id="p1">**</ept>，将默认代码替换为以下代码：</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>这将在表存储中创建由分区键（设置为从事件中心读取的设备 ID）、唯一行键和从事件中心读取的值构成的实体。每个实体还有一个时间戳，在表中插入实体时将自动创建该时间戳。</source>
          <target state="new">这将在表存储中创建由分区键（设置为从事件中心读取的设备 ID）、唯一行键和从事件中心读取的值构成的实体。每个实体还有一个时间戳，在表中插入实体时将自动创建该时间戳。</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>修改 Bolt</source>
          <target state="new">修改 Bolt</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中，展开 <bpt id="p1">**</bpt>EventHubReader<ept id="p1">**</ept> 项目，然后打开 <bpt id="p2">**</bpt>Bolt.cs<ept id="p2">**</ept> 文件。在该文件的顶部，添加以下内容：</source>
          <target state="new">在“解决方案资源管理器”中，展开 <bpt id="p1">**</bpt>EventHubReader<ept id="p1">**</ept> 项目，然后打开 <bpt id="p2">**</bpt>Bolt.cs<ept id="p2">**</ept> 文件。在该文件的顶部，添加以下内容：</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>这样，我们便可以更轻松地处理来自 Bolt 的 JSON 数据并将数据写入表存储。</source>
          <target state="new">这样，我们便可以更轻松地处理来自 Bolt 的 JSON 数据并将数据写入表存储。</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>找到 <ph id="ph1">`private int count;`</ph> 语句，并将它替换为以下内容：</source>
          <target state="new">找到 <ph id="ph1">`private int count;`</ph> 语句，并将它替换为以下内容：</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>连接到表时将使用这些代码。</source>
          <target state="new">连接到表时将使用这些代码。</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>找到以下代码：</source>
          <target state="new">找到以下代码：</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>将它替换为以下代码：</source>
          <target state="new">将它替换为以下代码：</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>这会指示 Bolt 接收<bpt id="p1">**</bpt>字符串<ept id="p1">**</ept>值而不是 <bpt id="p2">**</bpt>int<ept id="p2">**</ept> 值，并且应该使用前面在拓扑中声明的 <bpt id="p3">**</bpt>CustomizedInteropJSONDeserialzer<ept id="p3">**</ept>（在 program.cs 文件中）反序列化数据。</source>
          <target state="new">这会指示 Bolt 接收<bpt id="p1">**</bpt>字符串<ept id="p1">**</ept>值而不是 <bpt id="p2">**</bpt>int<ept id="p2">**</ept> 值，并且应该使用前面在拓扑中声明的 <bpt id="p3">**</bpt>CustomizedInteropJSONDeserialzer<ept id="p3">**</ept>（在 program.cs 文件中）反序列化数据。</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>紧接在上述代码的后面添加以下代码：</source>
          <target state="new">紧接在上述代码的后面添加以下代码：</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>这将使用前面配置的连接字符串连接到 <bpt id="p1">**</bpt>events<ept id="p1">**</ept> 表。如果该表不存在，将创建该表。</source>
          <target state="new">这将使用前面配置的连接字符串连接到 <bpt id="p1">**</bpt>events<ept id="p1">**</ept> 表。如果该表不存在，将创建该表。</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>找到 <bpt id="p1">**</bpt>Execute<ept id="p1">**</ept> 方法，并将它替换为以下内容：</source>
          <target state="new">找到 <bpt id="p1">**</bpt>Execute<ept id="p1">**</ept> 方法，并将它替换为以下内容：</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>这会使用 Json.NET 分析来自 Spout 的 JSON 数据，然后找出 <bpt id="p1">**</bpt>deviceId<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>deviceValue<ept id="p2">**</ept> 字段。然后，在初始化期间，将使用 <bpt id="p3">**</bpt>deviceId<ept id="p3">**</ept> 创建新的 <bpt id="p4">**</bpt>Device<ept id="p4">**</ept> 对象，以设置表的分区键。然后，将值设置为 <bpt id="p5">**</bpt>deviceValue<ept id="p5">**</ept>，最后，将实体插入表中。</source>
          <target state="new">这会使用 Json.NET 分析来自 Spout 的 JSON 数据，然后找出 <bpt id="p1">**</bpt>deviceId<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>deviceValue<ept id="p2">**</ept> 字段。然后，在初始化期间，将使用 <bpt id="p3">**</bpt>deviceId<ept id="p3">**</ept> 创建新的 <bpt id="p4">**</bpt>Device<ept id="p4">**</ept> 对象，以设置表的分区键。然后，将值设置为 <bpt id="p5">**</bpt>deviceValue<ept id="p5">**</ept>，最后，将实体插入表中。</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>该实体插入到表中后，将为元组调用 <ph id="ph1">`Ack()`</ph>，以通知 Spout 我们已成功处理了数据。</source>
          <target state="new">该实体插入到表中后，将为元组调用 <ph id="ph1">`Ack()`</ph>，以通知 Spout 我们已成功处理了数据。</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>EventHubSpout 组件需要下游组件 Bolt 每个元组的 ACK。如果未收到 ACK，EventHubSpout 将假定元组处理失败。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>EventHubSpout 组件需要下游组件 Bolt 每个元组的 ACK。如果未收到 ACK，EventHubSpout 将假定元组处理失败。</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>此时，你已完成了一个从事件中心读取数据，并将数据存储在表存储中名为 <bpt id="p1">**</bpt>events<ept id="p1">**</ept> 的表内的拓扑。</source>
          <target state="new">此时，你已完成了一个从事件中心读取数据，并将数据存储在表存储中名为 <bpt id="p1">**</bpt>events<ept id="p1">**</ept> 的表内的拓扑。</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>部署拓扑</source>
          <target state="new">部署拓扑</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中，右键单击“EventHubReader”项目，然后选择“提交到 Storm on HDInsight”。</source>
          <target state="new">在“解决方案资源管理器”中，右键单击“EventHubReader”项目，然后选择“提交到 Storm on HDInsight”。</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>提交到 Storm</source>
          <target state="new">提交到 Storm</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>在“提交拓扑”屏幕中，选择你的“Storm 群集”。展开“其他配置”，选择“Java 文件路径”，选择“...”，然后选择前面下载的 <bpt id="p1">**</bpt>eventhubs-storm-spout-0.9-jar-with-dependencies.jar<ept id="p1">**</ept> 文件所在的目录。最后，单击“提交”。</source>
          <target state="new">在“提交拓扑”屏幕中，选择你的“Storm 群集”。展开“其他配置”，选择“Java 文件路径”，选择“...”，然后选择前面下载的 <bpt id="p1">**</bpt>eventhubs-storm-spout-0.9-jar-with-dependencies.jar<ept id="p1">**</ept> 文件所在的目录。最后，单击“提交”。</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>提交对话框的图像</source>
          <target state="new">提交对话框的图像</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>提交拓扑之后，将会出现“Storm 拓扑查看器”。在左窗格中选择 <bpt id="p1">**</bpt>EventHubReader<ept id="p1">**</ept> 拓扑，以查看该拓扑的统计信息。当前应该不会发生任何情况，因为尚未将任何事件写入事件中心。</source>
          <target state="new">提交拓扑之后，将会出现“Storm 拓扑查看器”。在左窗格中选择 <bpt id="p1">**</bpt>EventHubReader<ept id="p1">**</ept> 拓扑，以查看该拓扑的统计信息。当前应该不会发生任何情况，因为尚未将任何事件写入事件中心。</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>示例存储视图</source>
          <target state="new">示例存储视图</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中，右键单击“EventHubReader”项目，然后选择“提交到 Storm on HDInsight”。</source>
          <target state="new">在“解决方案资源管理器”中，右键单击“EventHubReader”项目，然后选择“提交到 Storm on HDInsight”。</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>在“提交拓扑”屏幕中，选择你的“Storm 群集”。展开“其他配置”，选择“Java 文件路径”，选择“...”，然后选择前面下载的 <bpt id="p1">**</bpt>eventhubs-storm-spout-0.9-jar-with-dependencies.jar<ept id="p1">**</ept> 文件所在的目录。最后，单击“提交”。</source>
          <target state="new">在“提交拓扑”屏幕中，选择你的“Storm 群集”。展开“其他配置”，选择“Java 文件路径”，选择“...”，然后选择前面下载的 <bpt id="p1">**</bpt>eventhubs-storm-spout-0.9-jar-with-dependencies.jar<ept id="p1">**</ept> 文件所在的目录。最后，单击“提交”。</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>提交拓扑后，在“Storm 拓扑查看器”中刷新拓扑列表，以检查这两个拓扑是否在群集上运行。</source>
          <target state="new">提交拓扑后，在“Storm 拓扑查看器”中刷新拓扑列表，以检查这两个拓扑是否在群集上运行。</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>如果两个拓扑都在运行，请选择“服务器资源管理器”，展开“Azure”&gt;“存储”，然后选择前面创建的存储帐户。在存储帐户下，展开“表”。最后，双击 <bpt id="p1">**</bpt>events<ept id="p1">**</ept> 表以打开该表。你应会看到，来自 <bpt id="p2">**</bpt>EventHubReader<ept id="p2">**</ept> 拓扑的数据已存储在该表中。</source>
          <target state="new">如果两个拓扑都在运行，请选择“服务器资源管理器”，展开“Azure”&gt;“存储”，然后选择前面创建的存储帐户。在存储帐户下，展开“表”。最后，双击 <bpt id="p1">**</bpt>events<ept id="p1">**</ept> 表以打开该表。你应会看到，来自 <bpt id="p2">**</bpt>EventHubReader<ept id="p2">**</ept> 拓扑的数据已存储在该表中。</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>EventHubWriter<ept id="p1">**</ept> 拓扑正在生成事件，并将这些事件写入事件中心。</source>
          <target state="new"><bpt id="p1">**</bpt>EventHubWriter<ept id="p1">**</ept> 拓扑正在生成事件，并将这些事件写入事件中心。</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>然后，<bpt id="p1">**</bpt>EventHubReader<ept id="p1">**</ept> 将从事件中心读取事件，并将其存储在表存储中的 <bpt id="p2">**</bpt>events<ept id="p2">**</ept> 表内。</source>
          <target state="new">然后，<bpt id="p1">**</bpt>EventHubReader<ept id="p1">**</ept> 将从事件中心读取事件，并将其存储在表存储中的 <bpt id="p2">**</bpt>events<ept id="p2">**</ept> 表内。</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>停止拓扑</source>
          <target state="new">停止拓扑</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>若要停止拓扑，请在“Storm 拓扑查看器”中选择每个拓扑，然后单击“终止”。</source>
          <target state="new">若要停止拓扑，请在“Storm 拓扑查看器”中选择每个拓扑，然后单击“终止”。</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>终止拓扑的图像</source>
          <target state="new">终止拓扑的图像</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>说明</source>
          <target state="new">说明</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>检查点</source>
          <target state="new">检查点</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>EventHubSpout 定期检查点其状态为 Zookeeper 节点，将保存当前的偏移量的消息从队列中读取。这样，要开始在以下情况下接收已保存的偏移量处的消息的组件：</source>
          <target state="new">EventHubSpout 定期检查点其状态为 Zookeeper 节点，将保存当前的偏移量的消息从队列中读取。这样，要开始在以下情况下接收已保存的偏移量处的消息的组件：</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>组件实例失败，并已重新启动。</source>
          <target state="new">组件实例失败，并已重新启动。</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>通过添加或删除节点扩大或收缩群集。</source>
          <target state="new">通过添加或删除节点扩大或收缩群集。</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>拓扑已终止并已<bpt id="p1">**</bpt>使用相同的名称<ept id="p1">**</ept>重新启动。</source>
          <target state="new">拓扑已终止并已<bpt id="p1">**</bpt>使用相同的名称<ept id="p1">**</ept>重新启动。</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>你还可以将持久性检查点导入和导出到 WASB（HDInsight 群集使用的 Azure 存储。） 用于执行此操作的脚本位于 Storm on HDInsight 上的 <bpt id="p1">**</bpt>c:\\apps\\dist\\storm-0.9.3.2.2.1.0-2340\\zkdatatool-1.0\\bin<ept id="p1">**</ept> 中。</source>
          <target state="new">你还可以将持久性检查点导入和导出到 WASB（HDInsight 群集使用的 Azure 存储。） 用于执行此操作的脚本位于 Storm on HDInsight 上的 <bpt id="p1">**</bpt>c:\\apps\\dist\\storm-0.9.3.2.2.1.0-2340\\zkdatatool-1.0\\bin<ept id="p1">**</ept> 中。</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>路径中的版本号可能不同，因为群集上安装的 Storm 版本将来可能会更改。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>路径中的版本号可能不同，因为群集上安装的 Storm 版本将来可能会更改。</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>此目录中的脚本是：</source>
          <target state="new">此目录中的脚本是：</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>stormmeta\_import.cmd<ept id="p1">**</ept>：将所有 Storm 元数据从群集默认存储容器导入 Zookeeper。</source>
          <target state="new"><bpt id="p1">**</bpt>stormmeta\_import.cmd<ept id="p1">**</ept>：将所有 Storm 元数据从群集默认存储容器导入 Zookeeper。</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>stormmeta\_export.cmd<ept id="p1">**</ept>：将所有 Storm 元数据从 Zookeeper 导出到群集默认存储容器。</source>
          <target state="new"><bpt id="p1">**</bpt>stormmeta\_export.cmd<ept id="p1">**</ept>：将所有 Storm 元数据从 Zookeeper 导出到群集默认存储容器。</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>stormmeta\_delete.cmd<ept id="p1">**</ept>：从 Zookeeper 中删除所有 Storm 元数据。</source>
          <target state="new"><bpt id="p1">**</bpt>stormmeta\_delete.cmd<ept id="p1">**</ept>：从 Zookeeper 中删除所有 Storm 元数据。</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>当你需要删除群集，但在将新群集重新联机的情况下想要从中心的当前偏移量恢复处理时，可以使用导出和导入来保存检查点数据。</source>
          <target state="new">当你需要删除群集，但在将新群集重新联机的情况下想要从中心的当前偏移量恢复处理时，可以使用导出和导入来保存检查点数据。</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>由于数据将保存到默认的存储容器，新群集<bpt id="p1">**</bpt>必须<ept id="p1">**</ept>使用前一群集所用的同一个存储帐户和容器。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>由于数据将保存到默认的存储容器，新群集<bpt id="p1">**</bpt>必须<ept id="p1">**</ept>使用前一群集所用的同一个存储帐户和容器。</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>摘要</source>
          <target state="new">摘要</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>在本文档中，你已学习如何使用 C# 拓扑中的 Java 事件中心 Spout 和 Bolt 处理 Azure 事件中心内的数据。若要了解有关创建 C# 拓扑的详细信息，请参阅以下主题。</source>
          <target state="new">在本文档中，你已学习如何使用 C# 拓扑中的 Java 事件中心 Spout 和 Bolt 处理 Azure 事件中心内的数据。若要了解有关创建 C# 拓扑的详细信息，请参阅以下主题。</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>使用 Visual Studio 开发 Apache Storm on HDInsight 的 C# 拓扑</source>
          <target state="new">使用 Visual Studio 开发 Apache Storm on HDInsight 的 C# 拓扑</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Storm on HDInsight 的示例拓扑</source>
          <target state="new">Storm on HDInsight 的示例拓扑</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>