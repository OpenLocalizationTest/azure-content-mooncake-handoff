<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c242e77c7295cf1a9688b3f76b4a1a7baf49dc79</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>开始使用队列存储和 Visual Studio 连接服务（WebJob 项目）| Azure</source>
          <target state="new">开始使用队列存储和 Visual Studio 连接服务（WebJob 项目）| Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>在使用 Visual Studio 连接服务连接到存储帐户后，如何开始使用 WebJob 项目中的 Azure 队列存储</source>
          <target state="new">在使用 Visual Studio 连接服务连接到存储帐户后，如何开始使用 WebJob 项目中的 Azure 队列存储</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>开始使用 Azure 队列存储和 Visual Studio 连接服务（WebJob 项目）</source>
          <target state="new">开始使用 Azure 队列存储和 Visual Studio 连接服务（WebJob 项目）</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本文介绍通过使用 Visual Studio 中的“添加连接服务”对话框创建或引用 Azure 存储帐户之后，如何开始在 Visual Studio Azure WebJob 项目中使用 Azure 队列存储。当你使用 Visual Studio“添加连接服务”对话框将存储帐户添加到 WebJob 项目中时，会安装相应的 Azure 存储 NuGet 包，相应的.NET 引用会添加到项目中，并会在 App.config 文件中更新存储帐户的连接字符串。</source>
          <target state="new">本文介绍通过使用 Visual Studio 中的“添加连接服务”对话框创建或引用 Azure 存储帐户之后，如何开始在 Visual Studio Azure WebJob 项目中使用 Azure 队列存储。当你使用 Visual Studio“添加连接服务”对话框将存储帐户添加到 WebJob 项目中时，会安装相应的 Azure 存储 NuGet 包，相应的.NET 引用会添加到项目中，并会在 App.config 文件中更新存储帐户的连接字符串。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>本文提供了 C# 代码示例，用于演示如何在 Azure 队列存储服务中使用 Azure WebJobs SDK 版本 1.x。</source>
          <target state="new">本文提供了 C# 代码示例，用于演示如何在 Azure 队列存储服务中使用 Azure WebJobs SDK 版本 1.x。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Azure 队列存储是一项可存储大量消息的服务，用户可以通过经验证的呼叫，使用 HTTP 或 HTTPS 从世界任何地方访问这些消息。一条队列消息的大小最多可为 64 KB，一个队列中可以包含数百万条消息，直至达到存储帐户的总容量限值。有关详细信息，请参阅<bpt id="p1">[</bpt>如何通过 .NET 使用队列存储<ept id="p1">](/documentation/articles/storage-dotnet-how-to-use-queues)</ept>。有关 ASP.NET 的详细信息，请参阅 <bpt id="p2">[</bpt>ASP.NET<ept id="p2">](http://www.asp.net)</ept>。</source>
          <target state="new">Azure 队列存储是一项可存储大量消息的服务，用户可以通过经验证的呼叫，使用 HTTP 或 HTTPS 从世界任何地方访问这些消息。一条队列消息的大小最多可为 64 KB，一个队列中可以包含数百万条消息，直至达到存储帐户的总容量限值。有关详细信息，请参阅<bpt id="p1">[</bpt>如何通过 .NET 使用队列存储<ept id="p1">](/documentation/articles/storage-dotnet-how-to-use-queues)</ept>。有关 ASP.NET 的详细信息，请参阅 <bpt id="p2">[</bpt>ASP.NET<ept id="p2">](http://www.asp.net)</ept>。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>如何在接收队列消息时触发函数</source>
          <target state="new">如何在接收队列消息时触发函数</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>若要编写接收队列消息时 WebJobs SDK 调用的函数，请使用 <bpt id="p1">**</bpt>QueueTrigger<ept id="p1">**</ept> 属性。该属性构造函数使用一个字符串参数来指定要轮询的队列名称。你也可以<bpt id="p2">[</bpt>动态设置队列名称<ept id="p2">](#how-to-set-configuration-options)</ept>。</source>
          <target state="new">若要编写接收队列消息时 WebJobs SDK 调用的函数，请使用 <bpt id="p1">**</bpt>QueueTrigger<ept id="p1">**</ept> 属性。该属性构造函数使用一个字符串参数来指定要轮询的队列名称。你也可以<bpt id="p2">[</bpt>动态设置队列名称<ept id="p2">](#how-to-set-configuration-options)</ept>。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>字符串队列消息</source>
          <target state="new">字符串队列消息</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>在下面的示例中，队列中包含一个字符串消息，因此，<bpt id="p1">**</bpt>QueueTrigger<ept id="p1">**</ept> 已应用到包含队列消息内容的 <bpt id="p2">**</bpt>logMessage<ept id="p2">**</ept> 字符串参数。该函数<bpt id="p3">[</bpt>向仪表板写入一条日志消息<ept id="p3">](#how-to-write-logs)</ept>。</source>
          <target state="new">在下面的示例中，队列中包含一个字符串消息，因此，<bpt id="p1">**</bpt>QueueTrigger<ept id="p1">**</ept> 已应用到包含队列消息内容的 <bpt id="p2">**</bpt>logMessage<ept id="p2">**</ept> 字符串参数。该函数<bpt id="p3">[</bpt>向仪表板写入一条日志消息<ept id="p3">](#how-to-write-logs)</ept>。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>除了 <bpt id="p1">**</bpt>string<ept id="p1">**</ept> 以外，参数还可以是字节数组、<bpt id="p2">**</bpt>CloudQueueMessage<ept id="p2">**</ept> 对象或你定义的 POCO。</source>
          <target state="new">除了 <bpt id="p1">**</bpt>string<ept id="p1">**</ept> 以外，参数还可以是字节数组、<bpt id="p2">**</bpt>CloudQueueMessage<ept id="p2">**</ept> 对象或你定义的 POCO。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>POCO<bpt id="p1">[</bpt>（无格式传统 CLR 对象<ept id="p1">](http://zh.wikipedia.org/wiki/Plain_Old_CLR_Object)</ept>）队列消息</source>
          <target state="new">POCO<bpt id="p1">[</bpt>（无格式传统 CLR 对象<ept id="p1">](http://zh.wikipedia.org/wiki/Plain_Old_CLR_Object)</ept>）队列消息</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>在下面的示例中，队列消息包含 <bpt id="p1">**</bpt>BlobInformation<ept id="p1">**</ept> 对象的 JSON，该对象包含一个 <bpt id="p2">**</bpt>BlobName<ept id="p2">**</ept> 属性。SDK 会自动反序列化该对象。</source>
          <target state="new">在下面的示例中，队列消息包含 <bpt id="p1">**</bpt>BlobInformation<ept id="p1">**</ept> 对象的 JSON，该对象包含一个 <bpt id="p2">**</bpt>BlobName<ept id="p2">**</ept> 属性。SDK 会自动反序列化该对象。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>SDK 使用 <bpt id="p1">[</bpt>Newtonsoft.Json NuGet 包<ept id="p1">](http://www.nuget.org/packages/Newtonsoft.Json)</ept>序列化和反序列化消息。如果你在不使用 WebJobs SDK 的程序中创建队列消息，则可以如以下示例所示编写代码，以创建 SDK 可以分析的 POCO 队列消息。</source>
          <target state="new">SDK 使用 <bpt id="p1">[</bpt>Newtonsoft.Json NuGet 包<ept id="p1">](http://www.nuget.org/packages/Newtonsoft.Json)</ept>序列化和反序列化消息。如果你在不使用 WebJobs SDK 的程序中创建队列消息，则可以如以下示例所示编写代码，以创建 SDK 可以分析的 POCO 队列消息。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>异步函数</source>
          <target state="new">异步函数</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>以下异步函数<bpt id="p1">[</bpt>将日志写入仪表板<ept id="p1">](#how-to-write-logs)</ept>。</source>
          <target state="new">以下异步函数<bpt id="p1">[</bpt>将日志写入仪表板<ept id="p1">](#how-to-write-logs)</ept>。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>异步函数可以采用<bpt id="p1">[</bpt>取消标记<ept id="p1">](http://www.asp.net/mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4#CancelToken)</ept>，如以下用于复制 blob 的示例中所示。（有关 <bpt id="p2">**</bpt>queueTrigger<ept id="p2">**</ept> 占位符的说明，请参阅 <bpt id="p3">[</bpt>Blob<ept id="p3">](#how-to-read-and-write-blobs-and-tables-while-processing-a-queue-message)</ept> 部分。）</source>
          <target state="new">异步函数可以采用<bpt id="p1">[</bpt>取消标记<ept id="p1">](http://www.asp.net/mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4#CancelToken)</ept>，如以下用于复制 blob 的示例中所示。（有关 <bpt id="p2">**</bpt>queueTrigger<ept id="p2">**</ept> 占位符的说明，请参阅 <bpt id="p3">[</bpt>Blob<ept id="p3">](#how-to-read-and-write-blobs-and-tables-while-processing-a-queue-message)</ept> 部分。）</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>QueueTrigger 属性适用的类型</source>
          <target state="new">QueueTrigger 属性适用的类型</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>可以将 <bpt id="p1">**</bpt>QueueTrigger<ept id="p1">**</ept> 用于以下类型：</source>
          <target state="new">可以将 <bpt id="p1">**</bpt>QueueTrigger<ept id="p1">**</ept> 用于以下类型：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>序列化为 JSON 的 POCO 类型</source>
          <target state="new">序列化为 JSON 的 POCO 类型</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>轮询算法</source>
          <target state="new">轮询算法</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>SDK 实现了随机指数退让算法，以降低空闲队列轮询对存储事务成本造成的影响。当找到消息时，SDK 将等待两秒钟，然后检查另一条消息；如果未找到消息，它将等待大约四秒，然后重试。如果后续尝试获取队列消息失败，则等待时间会继续增加，直到达到最长等待时间（默认为 1 分钟）。<bpt id="p1">[</bpt>最长等待时间可配置<ept id="p1">](#how-to-set-configuration-options)</ept>。</source>
          <target state="new">SDK 实现了随机指数退让算法，以降低空闲队列轮询对存储事务成本造成的影响。当找到消息时，SDK 将等待两秒钟，然后检查另一条消息；如果未找到消息，它将等待大约四秒，然后重试。如果后续尝试获取队列消息失败，则等待时间会继续增加，直到达到最长等待时间（默认为 1 分钟）。<bpt id="p1">[</bpt>最长等待时间可配置<ept id="p1">](#how-to-set-configuration-options)</ept>。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>多个实例</source>
          <target state="new">多个实例</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>如果网站在多个实例上运行，则每台计算机上都会运行一个连续 Web 作业，并且每台计算机将等待触发器并尝试运行函数。在某些情况下，这可能会导致某些函数处理相同的数据两次，因此函数应该是幂等的（编写的这些函数在使用相同输入数据重复调用时不会生成重复的结果）。</source>
          <target state="new">如果网站在多个实例上运行，则每台计算机上都会运行一个连续 Web 作业，并且每台计算机将等待触发器并尝试运行函数。在某些情况下，这可能会导致某些函数处理相同的数据两次，因此函数应该是幂等的（编写的这些函数在使用相同输入数据重复调用时不会生成重复的结果）。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>并行执行</source>
          <target state="new">并行执行</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>如果有多个函数在侦听不同的队列，SDK 将在同时接收消息时并行调用这些函数。</source>
          <target state="new">如果有多个函数在侦听不同的队列，SDK 将在同时接收消息时并行调用这些函数。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>接收单个队列的多个消息时，也是如此。默认情况下，SDK 每次获取包含 16 个队列消息的批，然后并行执行处理这些消息的函数。<bpt id="p1">[</bpt>批大小是可配置的<ept id="p1">](#how-to-set-configuration-options)</ept>。当处理的数量达到批大小的一半时，SDK 将获取另一个批，并开始处理这些消息。因此，每个函数处理的最大并发消息数是批大小的 1.5 倍。此限制分别应用于各个包含 <bpt id="p2">**</bpt>QueueTrigger<ept id="p2">**</ept> 属性的函数。如果不希望在收到一个队列的消息时并行执行，请将批大小设置为 1。</source>
          <target state="new">接收单个队列的多个消息时，也是如此。默认情况下，SDK 每次获取包含 16 个队列消息的批，然后并行执行处理这些消息的函数。<bpt id="p1">[</bpt>批大小是可配置的<ept id="p1">](#how-to-set-configuration-options)</ept>。当处理的数量达到批大小的一半时，SDK 将获取另一个批，并开始处理这些消息。因此，每个函数处理的最大并发消息数是批大小的 1.5 倍。此限制分别应用于各个包含 <bpt id="p2">**</bpt>QueueTrigger<ept id="p2">**</ept> 属性的函数。如果不希望在收到一个队列的消息时并行执行，请将批大小设置为 1。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>获取队列或队列消息元数据</source>
          <target state="new">获取队列或队列消息元数据</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>你可以通过将参数添加到方法签名来获取以下消息属性：</source>
          <target state="new">你可以通过将参数添加到方法签名来获取以下消息属性：</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>DateTimeOffset<ept id="p1">**</ept> expirationTime</source>
          <target state="new"><bpt id="p1">**</bpt>DateTimeOffset<ept id="p1">**</ept> expirationTime</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>DateTimeOffset<ept id="p1">**</ept> insertionTime</source>
          <target state="new"><bpt id="p1">**</bpt>DateTimeOffset<ept id="p1">**</ept> insertionTime</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>DateTimeOffset<ept id="p1">**</ept> nextVisibleTime</source>
          <target state="new"><bpt id="p1">**</bpt>DateTimeOffset<ept id="p1">**</ept> nextVisibleTime</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>string<ept id="p1">**</ept> queueTrigger（包含消息文本）</source>
          <target state="new"><bpt id="p1">**</bpt>string<ept id="p1">**</ept> queueTrigger（包含消息文本）</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>string<ept id="p1">**</ept> id</source>
          <target state="new"><bpt id="p1">**</bpt>string<ept id="p1">**</ept> id</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>string<ept id="p1">**</ept> popReceipt</source>
          <target state="new"><bpt id="p1">**</bpt>string<ept id="p1">**</ept> popReceipt</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>int<ept id="p1">**</ept> dequeueCount</source>
          <target state="new"><bpt id="p1">**</bpt>int<ept id="p1">**</ept> dequeueCount</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>如果你想直接使用 Azure 存储 API，则还可以添加 <bpt id="p1">**</bpt>CloudStorageAccount<ept id="p1">**</ept> 参数。</source>
          <target state="new">如果你想直接使用 Azure 存储 API，则还可以添加 <bpt id="p1">**</bpt>CloudStorageAccount<ept id="p1">**</ept> 参数。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>下面的示例将所有这些元数据写入 INFO 应用程序日志。在该示例中，logMessage 和 queueTrigger 包含队列消息的内容。</source>
          <target state="new">下面的示例将所有这些元数据写入 INFO 应用程序日志。在该示例中，logMessage 和 queueTrigger 包含队列消息的内容。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>下面是示例代码编写的示例日志：</source>
          <target state="new">下面是示例代码编写的示例日志：</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>正常关闭</source>
          <target state="new">正常关闭</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>在连续的 WebJob 中运行的函数可以接受 <bpt id="p1">**</bpt>CancellationToken<ept id="p1">**</ept> 参数，以使操作系统能够在 WebJob 即将终止时通知该函数。你可以使用此通知来确保该函数不会意外终止，导致数据处于不一致状态。</source>
          <target state="new">在连续的 WebJob 中运行的函数可以接受 <bpt id="p1">**</bpt>CancellationToken<ept id="p1">**</ept> 参数，以使操作系统能够在 WebJob 即将终止时通知该函数。你可以使用此通知来确保该函数不会意外终止，导致数据处于不一致状态。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>下面的示例演示了如何在函数中检查即将发生的 Web 作业终止。</source>
          <target state="new">下面的示例演示了如何在函数中检查即将发生的 Web 作业终止。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>注意<ept id="p1">**</ept>：仪表板可能会错误显示已关闭函数的的状态和输出。</source>
          <target state="new"><bpt id="p1">**</bpt>注意<ept id="p1">**</ept>：仪表板可能会错误显示已关闭函数的的状态和输出。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>有关详细信息，请参阅 <bpt id="p1">[</bpt>WebJobs 正常关闭<ept id="p1">](http://blog.amitapple.com/post/2014/05/webjobs-graceful-shutdown/#.VCt1GXl0wpR)</ept>。</source>
          <target state="new">有关详细信息，请参阅 <bpt id="p1">[</bpt>WebJobs 正常关闭<ept id="p1">](http://blog.amitapple.com/post/2014/05/webjobs-graceful-shutdown/#.VCt1GXl0wpR)</ept>。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>如何在处理队列消息时创建队列消息</source>
          <target state="new">如何在处理队列消息时创建队列消息</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>若要编写创建新队列消息的函数，请使用 <bpt id="p1">**</bpt>Queue<ept id="p1">**</ept> 属性。与 <bpt id="p2">**</bpt>QueueTrigger<ept id="p2">**</ept> 一样，你可以传入字符串形式的队列名称，或者<bpt id="p3">[</bpt>动态设置队列名称<ept id="p3">](#how-to-set-configuration-options)</ept>。</source>
          <target state="new">若要编写创建新队列消息的函数，请使用 <bpt id="p1">**</bpt>Queue<ept id="p1">**</ept> 属性。与 <bpt id="p2">**</bpt>QueueTrigger<ept id="p2">**</ept> 一样，你可以传入字符串形式的队列名称，或者<bpt id="p3">[</bpt>动态设置队列名称<ept id="p3">](#how-to-set-configuration-options)</ept>。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>字符串队列消息</source>
          <target state="new">字符串队列消息</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>下面的非异步代码示例在名为“outputqueue”的队列中创建新的队列消息，该消息的内容与名为“inputqueue”的队列中收到的队列消息相同。（对于异步函数，请按照本部分稍后将介绍的方法使用 <bpt id="p1">**</bpt>IAsyncCollector<ph id="ph1">&lt;T&gt;</ph><ept id="p1">**</ept>。）</source>
          <target state="new">下面的非异步代码示例在名为“outputqueue”的队列中创建新的队列消息，该消息的内容与名为“inputqueue”的队列中收到的队列消息相同。（对于异步函数，请按照本部分稍后将介绍的方法使用 <bpt id="p1">**</bpt>IAsyncCollector<ph id="ph1">&lt;T&gt;</ph><ept id="p1">**</ept>。）</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>POCO<bpt id="p1">[</bpt>（普通旧 CLR 对象<ept id="p1">](http://zh.wikipedia.org/wiki/Plain_Old_CLR_Object)</ept>）队列消息</source>
          <target state="new">POCO<bpt id="p1">[</bpt>（普通旧 CLR 对象<ept id="p1">](http://zh.wikipedia.org/wiki/Plain_Old_CLR_Object)</ept>）队列消息</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>若要创建包含 POCO（而不是字符串）的队列消息，请将 POCO 类型作为输出参数传递给 <bpt id="p1">**</bpt>Queue<ept id="p1">**</ept> 属性构造函数。</source>
          <target state="new">若要创建包含 POCO（而不是字符串）的队列消息，请将 POCO 类型作为输出参数传递给 <bpt id="p1">**</bpt>Queue<ept id="p1">**</ept> 属性构造函数。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>SDK 会自动将对象序列化为 JSON。即使对象为 null，也始终会创建队列消息。</source>
          <target state="new">SDK 会自动将对象序列化为 JSON。即使对象为 null，也始终会创建队列消息。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>在异步函数中创建多个消息</source>
          <target state="new">在异步函数中创建多个消息</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>若要创建多个消息，请设置输出队列 <bpt id="p1">**</bpt>ICollector<ph id="ph1">&lt;T&gt;</ph><ept id="p1">**</ept> 或 <bpt id="p2">**</bpt>IAsyncCollector<ph id="ph2">&lt;T&gt;</ph><ept id="p2">**</ept> 的参数类型，如以下示例所示。</source>
          <target state="new">若要创建多个消息，请设置输出队列 <bpt id="p1">**</bpt>ICollector<ph id="ph1">&lt;T&gt;</ph><ept id="p1">**</ept> 或 <bpt id="p2">**</bpt>IAsyncCollector<ph id="ph2">&lt;T&gt;</ph><ept id="p2">**</ept> 的参数类型，如以下示例所示。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>调用 <bpt id="p1">**</bpt>Add<ept id="p1">**</ept> 方法时，将立即创建每个队列消息。</source>
          <target state="new">调用 <bpt id="p1">**</bpt>Add<ept id="p1">**</ept> 方法时，将立即创建每个队列消息。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Queue 属性适用的类型</source>
          <target state="new">Queue 属性适用的类型</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>可对以下参数类型使用 <bpt id="p1">**</bpt>Queue<ept id="p1">**</ept> 属性：</source>
          <target state="new">可对以下参数类型使用 <bpt id="p1">**</bpt>Queue<ept id="p1">**</ept> 属性：</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>out string<ept id="p1">**</ept>（如果函数结束时参数值非 null，则创建队列消息）</source>
          <target state="new"><bpt id="p1">**</bpt>out string<ept id="p1">**</ept>（如果函数结束时参数值非 null，则创建队列消息）</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>out byte<ept id="p1">**</ept>（用法类似于 <bpt id="p2">**</bpt>string<ept id="p2">**</ept>）</source>
          <target state="new"><bpt id="p1">**</bpt>out byte<ept id="p1">**</ept>（用法类似于 <bpt id="p2">**</bpt>string<ept id="p2">**</ept>）</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>out CloudQueueMessage<ept id="p1">**</ept>（用法类似于 <bpt id="p2">**</bpt>string<ept id="p2">**</ept>）</source>
          <target state="new"><bpt id="p1">**</bpt>out CloudQueueMessage<ept id="p1">**</ept>（用法类似于 <bpt id="p2">**</bpt>string<ept id="p2">**</ept>）</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>out POCO<ept id="p1">**</ept>（一种可序列化类型，如果函数结束时参数为 null，则创建一个包含 null 对象的消息）</source>
          <target state="new"><bpt id="p1">**</bpt>out POCO<ept id="p1">**</ept>（一种可序列化类型，如果函数结束时参数为 null，则创建一个包含 null 对象的消息）</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>ICollector</source>
          <target state="new">ICollector</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>IAsyncCollector</source>
          <target state="new">IAsyncCollector</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CloudQueue<ept id="p1">**</ept>（用于直接通过 Azure 存储 API 手动创建消息）</source>
          <target state="new"><bpt id="p1">**</bpt>CloudQueue<ept id="p1">**</ept>（用于直接通过 Azure 存储 API 手动创建消息）</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>在函数正文中使用 WebJobs SDK 属性</source>
          <target state="new">在函数正文中使用 WebJobs SDK 属性</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>如果你需要在使用 <bpt id="p1">**</bpt>Queue<ept id="p1">**</ept>、<bpt id="p2">**</bpt>Blob<ept id="p2">**</ept> 或 <bpt id="p3">**</bpt>Table<ept id="p3">**</ept> 等 WebJobs SDK 属性之前在函数中执行某项操作，可以使用 <bpt id="p4">**</bpt>IBinder<ept id="p4">**</ept> 接口。</source>
          <target state="new">如果你需要在使用 <bpt id="p1">**</bpt>Queue<ept id="p1">**</ept>、<bpt id="p2">**</bpt>Blob<ept id="p2">**</ept> 或 <bpt id="p3">**</bpt>Table<ept id="p3">**</ept> 等 WebJobs SDK 属性之前在函数中执行某项操作，可以使用 <bpt id="p4">**</bpt>IBinder<ept id="p4">**</ept> 接口。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>下面的示例采用一个输入队列消息，并在输出队列中创建具有相同内容的新消息。输出队列名称由函数正文中的代码设置。</source>
          <target state="new">下面的示例采用一个输入队列消息，并在输出队列中创建具有相同内容的新消息。输出队列名称由函数正文中的代码设置。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>IBinder<ept id="p1">**</ept> 接口也可用于 <bpt id="p2">**</bpt>Table<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>Blob<ept id="p3">**</ept> 属性。</source>
          <target state="new"><bpt id="p1">**</bpt>IBinder<ept id="p1">**</ept> 接口也可用于 <bpt id="p2">**</bpt>Table<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>Blob<ept id="p3">**</ept> 属性。</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>如何在处理队列消息时读取和写入 Blob 和表</source>
          <target state="new">如何在处理队列消息时读取和写入 Blob 和表</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>可以使用 <bpt id="p1">**</bpt>Blob<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>Table<ept id="p2">**</ept> 属性读取与写入 blob 和表。本部分中的示例适用于 Blob。有关展示如何在创建或更新 blob 时触发进程的代码示例，请参阅<bpt id="p3">[</bpt>如何结合使用 Azure blob 存储和 WebJobs SDK<ept id="p3">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-blobs-how-to)</ept>；有关用于读取和写入表的代码示例，请参阅<bpt id="p4">[</bpt>如何结合使用 Azure 表存储和 WebJobs SDK<ept id="p4">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-tables-how-to)</ept>。</source>
          <target state="new">可以使用 <bpt id="p1">**</bpt>Blob<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>Table<ept id="p2">**</ept> 属性读取与写入 blob 和表。本部分中的示例适用于 Blob。有关展示如何在创建或更新 blob 时触发进程的代码示例，请参阅<bpt id="p3">[</bpt>如何结合使用 Azure blob 存储和 WebJobs SDK<ept id="p3">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-blobs-how-to)</ept>；有关用于读取和写入表的代码示例，请参阅<bpt id="p4">[</bpt>如何结合使用 Azure 表存储和 WebJobs SDK<ept id="p4">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-tables-how-to)</ept>。</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>触发 Blob 操作的字符串队列消息</source>
          <target state="new">触发 Blob 操作的字符串队列消息</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>对于包含字符串的队列消息，<bpt id="p1">**</bpt>queueTrigger<ept id="p1">**</ept> 是占位符，可以用于包含消息内容的 <bpt id="p2">**</bpt>Blob<ept id="p2">**</ept> 属性的 <bpt id="p3">**</bpt>blobPath<ept id="p3">**</ept> 参数。</source>
          <target state="new">对于包含字符串的队列消息，<bpt id="p1">**</bpt>queueTrigger<ept id="p1">**</ept> 是占位符，可以用于包含消息内容的 <bpt id="p2">**</bpt>Blob<ept id="p2">**</ept> 属性的 <bpt id="p3">**</bpt>blobPath<ept id="p3">**</ept> 参数。</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>下面的示例使用 <bpt id="p1">**</bpt>Stream<ept id="p1">**</ept> 对象读取和写入 blob。队列消息是位于 textBlobs 容器中的 Blob 名称。将在同一个容器中创建 Blob 的副本，并在其名称后面附加“-new”。</source>
          <target state="new">下面的示例使用 <bpt id="p1">**</bpt>Stream<ept id="p1">**</ept> 对象读取和写入 blob。队列消息是位于 textBlobs 容器中的 Blob 名称。将在同一个容器中创建 Blob 的副本，并在其名称后面附加“-new”。</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Blob<ept id="p1">**</ept> 属性构造函数采用指定容器和 blob 名称的 <bpt id="p2">**</bpt>blobPath<ept id="p2">**</ept> 参数。有关此占位符的详细信息，请参阅<bpt id="p3">[</bpt>如何结合使用 Azure blob 存储和 WebJobs SDK<ept id="p3">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-blobs-how-to)</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>Blob<ept id="p1">**</ept> 属性构造函数采用指定容器和 blob 名称的 <bpt id="p2">**</bpt>blobPath<ept id="p2">**</ept> 参数。有关此占位符的详细信息，请参阅<bpt id="p3">[</bpt>如何结合使用 Azure blob 存储和 WebJobs SDK<ept id="p3">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-blobs-how-to)</ept>。</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>当属性修饰 <bpt id="p1">**</bpt>Stream<ept id="p1">**</ept> 对象时，另一个构造函数参数会将 <bpt id="p2">**</bpt>FileAccess<ept id="p2">**</ept> 模式指定为读取、写入或读取/写入。</source>
          <target state="new">当属性修饰 <bpt id="p1">**</bpt>Stream<ept id="p1">**</ept> 对象时，另一个构造函数参数会将 <bpt id="p2">**</bpt>FileAccess<ept id="p2">**</ept> 模式指定为读取、写入或读取/写入。</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>下面的示例使用 <bpt id="p1">**</bpt>CloudBlockBlob<ept id="p1">**</ept> 对象删除 blob。队列消息是 Blob 的名称。</source>
          <target state="new">下面的示例使用 <bpt id="p1">**</bpt>CloudBlockBlob<ept id="p1">**</ept> 对象删除 blob。队列消息是 Blob 的名称。</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>POCO<bpt id="p1">[</bpt>（普通旧 CLR 对象<ept id="p1">](http://zh.wikipedia.org/wiki/Plain_Old_CLR_Object)</ept>）队列消息</source>
          <target state="new">POCO<bpt id="p1">[</bpt>（普通旧 CLR 对象<ept id="p1">](http://zh.wikipedia.org/wiki/Plain_Old_CLR_Object)</ept>）队列消息</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>对于队列消息中存储为 JSON 的 POCO，可以使用对 <bpt id="p1">**</bpt>Queue<ept id="p1">**</ept> 属性的 <bpt id="p2">**</bpt>blobPath<ept id="p2">**</ept> 参数中的对象属性进行命名的占位符。还可以将<bpt id="p3">[</bpt>队列元数据属性名称<ept id="p3">](#get-queue-or-queue-message-metadata)</ept>用作占位符。</source>
          <target state="new">对于队列消息中存储为 JSON 的 POCO，可以使用对 <bpt id="p1">**</bpt>Queue<ept id="p1">**</ept> 属性的 <bpt id="p2">**</bpt>blobPath<ept id="p2">**</ept> 参数中的对象属性进行命名的占位符。还可以将<bpt id="p3">[</bpt>队列元数据属性名称<ept id="p3">](#get-queue-or-queue-message-metadata)</ept>用作占位符。</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>下面的示例将 Blob 复制到具有不同扩展名的新 Blob。队列消息是 <bpt id="p1">**</bpt>BlobInformation<ept id="p1">**</ept> 对象，其中包括 <bpt id="p2">**</bpt>BlobName<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>BlobNameWithoutExtension<ept id="p3">**</ept> 属性。属性名称用作 <bpt id="p4">**</bpt>Blob<ept id="p4">**</ept> 属性的 blob 路径中的占位符。</source>
          <target state="new">下面的示例将 Blob 复制到具有不同扩展名的新 Blob。队列消息是 <bpt id="p1">**</bpt>BlobInformation<ept id="p1">**</ept> 对象，其中包括 <bpt id="p2">**</bpt>BlobName<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>BlobNameWithoutExtension<ept id="p3">**</ept> 属性。属性名称用作 <bpt id="p4">**</bpt>Blob<ept id="p4">**</ept> 属性的 blob 路径中的占位符。</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>SDK 使用 <bpt id="p1">[</bpt>Newtonsoft.Json NuGet 包<ept id="p1">](http://www.nuget.org/packages/Newtonsoft.Json)</ept>序列化和反序列化消息。如果你在不使用 WebJobs SDK 的程序中创建队列消息，则可以如以下示例所示编写代码，以创建 SDK 可以分析的 POCO 队列消息。</source>
          <target state="new">SDK 使用 <bpt id="p1">[</bpt>Newtonsoft.Json NuGet 包<ept id="p1">](http://www.nuget.org/packages/Newtonsoft.Json)</ept>序列化和反序列化消息。如果你在不使用 WebJobs SDK 的程序中创建队列消息，则可以如以下示例所示编写代码，以创建 SDK 可以分析的 POCO 队列消息。</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>如果在将 blob 绑定到对象之前，你需要在函数中执行某项操作，则可以使用函数正文中的属性，<bpt id="p1">[</bpt>如前面 Queue 属性中所示<ept id="p1">](#use-webjobs-sdk-attributes-in-the-body-of-a-function)</ept>。</source>
          <target state="new">如果在将 blob 绑定到对象之前，你需要在函数中执行某项操作，则可以使用函数正文中的属性，<bpt id="p1">[</bpt>如前面 Queue 属性中所示<ept id="p1">](#use-webjobs-sdk-attributes-in-the-body-of-a-function)</ept>。</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>可以使用 Blob 属性的类型</source>
          <target state="new">可以使用 Blob 属性的类型</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Blob<ept id="p1">**</ept> 属性可用于以下类型：</source>
          <target state="new"><bpt id="p1">**</bpt>Blob<ept id="p1">**</ept> 属性可用于以下类型：</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Stream<ept id="p1">**</ept>（读取或写入，通过使用 FileAccess 构造函数参数指定）</source>
          <target state="new"><bpt id="p1">**</bpt>Stream<ept id="p1">**</ept>（读取或写入，通过使用 FileAccess 构造函数参数指定）</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>TextReader</source>
          <target state="new">TextReader</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>TextWriter</source>
          <target state="new">TextWriter</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>string<ept id="p1">**</ept>（读取）</source>
          <target state="new"><bpt id="p1">**</bpt>string<ept id="p1">**</ept>（读取）</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>out string<ept id="p1">**</ept>（写入；仅当函数返回时字符串参数非 null 的情况下，才创建 Blob）</source>
          <target state="new"><bpt id="p1">**</bpt>out string<ept id="p1">**</ept>（写入；仅当函数返回时字符串参数非 null 的情况下，才创建 Blob）</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>POCO（读取）</source>
          <target state="new">POCO（读取）</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>out POCO（写入；始终创建 Blob，如果函数返回时 POCO 参数为 null，则创建 null 对象）</source>
          <target state="new">out POCO（写入；始终创建 Blob，如果函数返回时 POCO 参数为 null，则创建 null 对象）</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CloudBlobStream<ept id="p1">**</ept>（写入）</source>
          <target state="new"><bpt id="p1">**</bpt>CloudBlobStream<ept id="p1">**</ept>（写入）</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>ICloudBlob<ept id="p1">**</ept>（读取或写入）</source>
          <target state="new"><bpt id="p1">**</bpt>ICloudBlob<ept id="p1">**</ept>（读取或写入）</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CloudBlockBlob<ept id="p1">**</ept>（读取或写入）</source>
          <target state="new"><bpt id="p1">**</bpt>CloudBlockBlob<ept id="p1">**</ept>（读取或写入）</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CloudPageBlob<ept id="p1">**</ept>（读取或写入）</source>
          <target state="new"><bpt id="p1">**</bpt>CloudPageBlob<ept id="p1">**</ept>（读取或写入）</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>如何处理有害消息</source>
          <target state="new">如何处理有害消息</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>内容导致函数失败的消息称为<bpt id="p1">*</bpt>有害消息<ept id="p1">*</ept>。当函数失败时，将不删除并最终再次选择队列消息，从而导致周期重复。在达到限制的迭代次数后，SDK 可自动中断周期，你也可以手动中断。</source>
          <target state="new">内容导致函数失败的消息称为<bpt id="p1">*</bpt>有害消息<ept id="p1">*</ept>。当函数失败时，将不删除并最终再次选择队列消息，从而导致周期重复。在达到限制的迭代次数后，SDK 可自动中断周期，你也可以手动中断。</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>自动处理有害消息</source>
          <target state="new">自动处理有害消息</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>SDK 在处理一个队列消息时最多会调用某个函数 5 次。如果第五次尝试失败，消息将移到有害队列。<bpt id="p1">[</bpt>最大重试次数可配置<ept id="p1">](#how-to-set-configuration-options)</ept>。</source>
          <target state="new">SDK 在处理一个队列消息时最多会调用某个函数 5 次。如果第五次尝试失败，消息将移到有害队列。<bpt id="p1">[</bpt>最大重试次数可配置<ept id="p1">](#how-to-set-configuration-options)</ept>。</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>病毒队列的名称为 <bpt id="p1">*</bpt>{originalqueuename}<ept id="p1">*</ept>-poison。你可以编写一个函数来处理有害队列中的消息，并记录这些消息，或者发送需要注意的通知。</source>
          <target state="new">病毒队列的名称为 <bpt id="p1">*</bpt>{originalqueuename}<ept id="p1">*</ept>-poison。你可以编写一个函数来处理有害队列中的消息，并记录这些消息，或者发送需要注意的通知。</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>在下面的示例中，如果队列消息包含不存在的 blob 名称，则 <bpt id="p1">**</bpt>CopyBlob<ept id="p1">**</ept> 函数会失败。在这种情况，消息将从 copyBlobqueue 队列移到 copyBlobqueue-poison 队列。然后 <bpt id="p2">**</bpt>ProcessPoisonMessage<ept id="p2">**</ept> 会记录有害消息。</source>
          <target state="new">在下面的示例中，如果队列消息包含不存在的 blob 名称，则 <bpt id="p1">**</bpt>CopyBlob<ept id="p1">**</ept> 函数会失败。在这种情况，消息将从 copyBlobqueue 队列移到 copyBlobqueue-poison 队列。然后 <bpt id="p2">**</bpt>ProcessPoisonMessage<ept id="p2">**</ept> 会记录有害消息。</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>下图显示了处理有害消息时这些函数的控制台输出。</source>
          <target state="new">下图显示了处理有害消息时这些函数的控制台输出。</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>用于处理有害消息的控制台输出</source>
          <target state="new">用于处理有害消息的控制台输出</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>手动处理有害消息</source>
          <target state="new">手动处理有害消息</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>你可以向你的函数添加名为 <bpt id="p1">**</bpt>dequeueCount<ept id="p1">**</ept> 的 <bpt id="p2">**</bpt>int<ept id="p2">**</ept> 参数，获取选择处理某消息的次数。然后，你可以检查函数代码中的取消排队计数，并在处理次数超过阈值时执行自己的有害消息处理，如以下示例中所示。</source>
          <target state="new">你可以向你的函数添加名为 <bpt id="p1">**</bpt>dequeueCount<ept id="p1">**</ept> 的 <bpt id="p2">**</bpt>int<ept id="p2">**</ept> 参数，获取选择处理某消息的次数。然后，你可以检查函数代码中的取消排队计数，并在处理次数超过阈值时执行自己的有害消息处理，如以下示例中所示。</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>如何设置配置选项</source>
          <target state="new">如何设置配置选项</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>你可以使用 <bpt id="p1">**</bpt>JobHostConfiguration<ept id="p1">**</ept> 类型设置以下配置选项：</source>
          <target state="new">你可以使用 <bpt id="p1">**</bpt>JobHostConfiguration<ept id="p1">**</ept> 类型设置以下配置选项：</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>在代码中设置 SDK 连接字符串。</source>
          <target state="new">在代码中设置 SDK 连接字符串。</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>配置 <bpt id="p1">**</bpt>QueueTrigger<ept id="p1">**</ept> 设置，例如最大取消排队计数。</source>
          <target state="new">配置 <bpt id="p1">**</bpt>QueueTrigger<ept id="p1">**</ept> 设置，例如最大取消排队计数。</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>从配置中获取队列名称。</source>
          <target state="new">从配置中获取队列名称。</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>在代码中设置 SDK 连接字符串</source>
          <target state="new">在代码中设置 SDK 连接字符串</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>在代码中设置 SDK 连接字符串可以在配置文件或环境变量中使用自己的连接字符串名称，如以下示例中所示。</source>
          <target state="new">在代码中设置 SDK 连接字符串可以在配置文件或环境变量中使用自己的连接字符串名称，如以下示例中所示。</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>配置 QueueTrigger 设置</source>
          <target state="new">配置 QueueTrigger 设置</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>你可以配置以下用于处理队列消息的设置：</source>
          <target state="new">你可以配置以下用于处理队列消息的设置：</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>同时选择的、要并行执行的最大队列消息数（默认值为 16）。</source>
          <target state="new">同时选择的、要并行执行的最大队列消息数（默认值为 16）。</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>在将队列消息发送到有害队列之前要重试的最大次数（默认值为 5）。</source>
          <target state="new">在将队列消息发送到有害队列之前要重试的最大次数（默认值为 5）。</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>当队列为空时，再次轮询之前要等待的最长时间（默认值为 1 分钟）。</source>
          <target state="new">当队列为空时，再次轮询之前要等待的最长时间（默认值为 1 分钟）。</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>下面的示例演示如何配置这些设置：</source>
          <target state="new">下面的示例演示如何配置这些设置：</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>在代码中设置 WebJobs SDK 构造函数参数的值</source>
          <target state="new">在代码中设置 WebJobs SDK 构造函数参数的值</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>有时，你想要在代码中指定队列名称、Blob 名称、容器或表名称，而不是进行硬编码。例如，你可能想在配置文件或环境变量中指定 <bpt id="p1">**</bpt>QueueTrigger<ept id="p1">**</ept> 的队列名称。</source>
          <target state="new">有时，你想要在代码中指定队列名称、Blob 名称、容器或表名称，而不是进行硬编码。例如，你可能想在配置文件或环境变量中指定 <bpt id="p1">**</bpt>QueueTrigger<ept id="p1">**</ept> 的队列名称。</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>你可以通过将 <bpt id="p1">**</bpt>NameResolver<ept id="p1">**</ept> 对象传递给 <bpt id="p2">**</bpt>JobHostConfiguration<ept id="p2">**</ept> 类型来执行该操作。此时，你可以在 WebJobs SDK 属性构造函数参数中包含以百分号 (%) 括住的特殊占位符，你的 <bpt id="p3">**</bpt>NameResolver<ept id="p3">**</ept> 代码将指定要用于取代这些占位符的实际值。</source>
          <target state="new">你可以通过将 <bpt id="p1">**</bpt>NameResolver<ept id="p1">**</ept> 对象传递给 <bpt id="p2">**</bpt>JobHostConfiguration<ept id="p2">**</ept> 类型来执行该操作。此时，你可以在 WebJobs SDK 属性构造函数参数中包含以百分号 (%) 括住的特殊占位符，你的 <bpt id="p3">**</bpt>NameResolver<ept id="p3">**</ept> 代码将指定要用于取代这些占位符的实际值。</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>例如，假设你要在测试环境中使用名为 logqueuetest 的队列，并在生产环境中使用名为 logqueueprod 的队列。你希望在具有实际队列名称的 <bpt id="p1">**</bpt>appSettings<ept id="p1">**</ept> 集合中指定条目名称，而不是硬编码的队列名称。如果 <bpt id="p2">**</bpt>appSettings<ept id="p2">**</ept> 键为 logqueue，则函数如以下示例所示。</source>
          <target state="new">例如，假设你要在测试环境中使用名为 logqueuetest 的队列，并在生产环境中使用名为 logqueueprod 的队列。你希望在具有实际队列名称的 <bpt id="p1">**</bpt>appSettings<ept id="p1">**</ept> 集合中指定条目名称，而不是硬编码的队列名称。如果 <bpt id="p2">**</bpt>appSettings<ept id="p2">**</ept> 键为 logqueue，则函数如以下示例所示。</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>然后，<bpt id="p1">**</bpt>NameResolver<ept id="p1">**</ept> 类可以从 <bpt id="p2">**</bpt>appSettings<ept id="p2">**</ept> 获取队列名称，如以下示例所示：</source>
          <target state="new">然后，<bpt id="p1">**</bpt>NameResolver<ept id="p1">**</ept> 类可以从 <bpt id="p2">**</bpt>appSettings<ept id="p2">**</ept> 获取队列名称，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>将 <bpt id="p1">**</bpt>NameResolver<ept id="p1">**</ept> 类传入 <bpt id="p2">**</bpt>JobHost<ept id="p2">**</ept> 对象，如以下示例中所示。</source>
          <target state="new">将 <bpt id="p1">**</bpt>NameResolver<ept id="p1">**</ept> 类传入 <bpt id="p2">**</bpt>JobHost<ept id="p2">**</ept> 对象，如以下示例中所示。</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>注意：<ept id="p1">**</ept>每次调用函数，都会解析队列名称、表名称和 blob 名称，但 blob 容器名称只会在应用程序启动时进行解析。作业运行时，无法更改 blob 容器名称。</source>
          <target state="new"><bpt id="p1">**</bpt>注意：<ept id="p1">**</ept>每次调用函数，都会解析队列名称、表名称和 blob 名称，但 blob 容器名称只会在应用程序启动时进行解析。作业运行时，无法更改 blob 容器名称。</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>如何手动触发函数</source>
          <target state="new">如何手动触发函数</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>若要手动触发某个函数，请对 <bpt id="p1">**</bpt>JobHost<ept id="p1">**</ept> 对象使用 <bpt id="p2">**</bpt>Call<ept id="p2">**</ept> 或 <bpt id="p3">**</bpt>CallAsync<ept id="p3">**</ept> 方法，并对函数使用 <bpt id="p4">**</bpt>NoAutomaticTrigger<ept id="p4">**</ept> 属性，如以下示例所示。</source>
          <target state="new">若要手动触发某个函数，请对 <bpt id="p1">**</bpt>JobHost<ept id="p1">**</ept> 对象使用 <bpt id="p2">**</bpt>Call<ept id="p2">**</ept> 或 <bpt id="p3">**</bpt>CallAsync<ept id="p3">**</ept> 方法，并对函数使用 <bpt id="p4">**</bpt>NoAutomaticTrigger<ept id="p4">**</ept> 属性，如以下示例所示。</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>如何写入日志</source>
          <target state="new">如何写入日志</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>仪表板在两个位置显示日志：针对 Web 作业的页，以及针对特定 Web 作业调用的页。</source>
          <target state="new">仪表板在两个位置显示日志：针对 Web 作业的页，以及针对特定 Web 作业调用的页。</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>WebJob 页中的日志</source>
          <target state="new">WebJob 页中的日志</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>函数调用页中的日志</source>
          <target state="new">函数调用页中的日志</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>在函数或 <bpt id="p1">**</bpt>Main()<ept id="p1">**</ept> 方法中调用的控制台方法的输出在 Web 作业的仪表板页面上显示，而不是在特定方法调用页面上显示。从方法签名的参数中获取的 TextWriter 对象的输出在方法调用的仪表板页中显示。</source>
          <target state="new">在函数或 <bpt id="p1">**</bpt>Main()<ept id="p1">**</ept> 方法中调用的控制台方法的输出在 Web 作业的仪表板页面上显示，而不是在特定方法调用页面上显示。从方法签名的参数中获取的 TextWriter 对象的输出在方法调用的仪表板页中显示。</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>无法将控制台输出链接到特定的方法调用，因为控制台是单线程的，而许多作业函数可能同时运行。正因如此，SDK 为每个函数调用提供了自身唯一的日志写入器对象。</source>
          <target state="new">无法将控制台输出链接到特定的方法调用，因为控制台是单线程的，而许多作业函数可能同时运行。正因如此，SDK 为每个函数调用提供了自身唯一的日志写入器对象。</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>若要写入<bpt id="p1">[</bpt>应用程序跟踪日志<ept id="p1">](/documentation/articles/web-sites-dotnet-troubleshoot-visual-studio#logsoverview)</ept>，请使用 <bpt id="p2">**</bpt>Console.Out<ept id="p2">**</ept>（创建标记为 INFO 的日志）和 <bpt id="p3">**</bpt>Console.Error<ept id="p3">**</ept>（创建标记为 ERROR 的日志）。或者，您可以使用 <bpt id="p4">[</bpt>Trace 或 TraceSource<ept id="p4">](http://blogs.msdn.com/b/mcsuksoldev/archive/2014/09/04/adding-trace-to-azure-web-sites-and-web-jobs.aspx)</ept>，它除了提供“信息”和“错误”外，还提供“详细”、“警告”和“严重级别”。应用程序跟踪日志显示在网站日志文件、Azure 表或 Azure Blob 中，具体取决于你如何配置 Azure 网站。与所有控制台输出一样，最近的 100 条应用程序日志也会显示在 Web 作业的仪表板页中，而不是显示在函数调用的页中。</source>
          <target state="new">若要写入<bpt id="p1">[</bpt>应用程序跟踪日志<ept id="p1">](/documentation/articles/web-sites-dotnet-troubleshoot-visual-studio#logsoverview)</ept>，请使用 <bpt id="p2">**</bpt>Console.Out<ept id="p2">**</ept>（创建标记为 INFO 的日志）和 <bpt id="p3">**</bpt>Console.Error<ept id="p3">**</ept>（创建标记为 ERROR 的日志）。或者，您可以使用 <bpt id="p4">[</bpt>Trace 或 TraceSource<ept id="p4">](http://blogs.msdn.com/b/mcsuksoldev/archive/2014/09/04/adding-trace-to-azure-web-sites-and-web-jobs.aspx)</ept>，它除了提供“信息”和“错误”外，还提供“详细”、“警告”和“严重级别”。应用程序跟踪日志显示在网站日志文件、Azure 表或 Azure Blob 中，具体取决于你如何配置 Azure 网站。与所有控制台输出一样，最近的 100 条应用程序日志也会显示在 Web 作业的仪表板页中，而不是显示在函数调用的页中。</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>仅当程序在 Azure Web 作业中运行（而不是在本地运行或者在其他某个环境中运行）时，控制台输出才显示在仪表板中。</source>
          <target state="new">仅当程序在 Azure Web 作业中运行（而不是在本地运行或者在其他某个环境中运行）时，控制台输出才显示在仪表板中。</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>可以通过<bpt id="p1">[</bpt>将仪表板连接字符串设置为 null<ept id="p1">](#how-to-set-configuration-options)</ept>禁用日志记录。</source>
          <target state="new">可以通过<bpt id="p1">[</bpt>将仪表板连接字符串设置为 null<ept id="p1">](#how-to-set-configuration-options)</ept>禁用日志记录。</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>下面的示例演示了写入日志的多种方法：</source>
          <target state="new">下面的示例演示了写入日志的多种方法：</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>在 WebJobs SDK 仪表板中，当你转到特定函数调用页面并单击“切换输出”时，你会看到 <bpt id="p1">**</bpt>TextWriter<ept id="p1">**</ept> 对象的输出：</source>
          <target state="new">在 WebJobs SDK 仪表板中，当你转到特定函数调用页面并单击“切换输出”时，你会看到 <bpt id="p1">**</bpt>TextWriter<ept id="p1">**</ept> 对象的输出：</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>单击函数调用链接</source>
          <target state="new">单击函数调用链接</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>函数调用页中的日志</source>
          <target state="new">函数调用页中的日志</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>在 WebJobs SDK 仪表板中，当您转到 Web 作业（而不是函数调用）页面并单击“切换输出”时，您会看到最近的 100 行控制台输出。</source>
          <target state="new">在 WebJobs SDK 仪表板中，当您转到 Web 作业（而不是函数调用）页面并单击“切换输出”时，您会看到最近的 100 行控制台输出。</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>单击“切换输出”</source>
          <target state="new">单击“切换输出”</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>在连续 Web 作业中，应用程序日志显示在网站文件系统的 /data/jobs/continuous/<bpt id="p1">*</bpt>{webjobname}<ept id="p1">*</ept>/job\_log.txt 中。</source>
          <target state="new">在连续 Web 作业中，应用程序日志显示在网站文件系统的 /data/jobs/continuous/<bpt id="p1">*</bpt>{webjobname}<ept id="p1">*</ept>/job\_log.txt 中。</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>在 Azure blob 中，应用程序日志如下所示：</source>
          <target state="new">在 Azure blob 中，应用程序日志如下所示：</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>2014-09-26T21:01:13,Information,contosoadsnew,491e54,635473620738373502,0,17404,17,Console.Write - Hello world!,</source>
          <target state="new">2014-09-26T21:01:13,Information,contosoadsnew,491e54,635473620738373502,0,17404,17,Console.Write - Hello world!,</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>2014-09-26T21:01:13,Error,contosoadsnew,491e54,635473620738373502,0,17404,19,Console.Error - Hello world!,</source>
          <target state="new">2014-09-26T21:01:13,Error,contosoadsnew,491e54,635473620738373502,0,17404,19,Console.Error - Hello world!,</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>2014-09-26T21:01:13,Information,contosoadsnew,491e54,635473620738529920,0,17404,17,Console.Out - Hello world!,</source>
          <target state="new">2014-09-26T21:01:13,Information,contosoadsnew,491e54,635473620738529920,0,17404,17,Console.Out - Hello world!,</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>在 Azure 表中，<bpt id="p1">**</bpt>Console.Out<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>Console.Error<ept id="p2">**</ept> 日志如下所示：</source>
          <target state="new">在 Azure 表中，<bpt id="p1">**</bpt>Console.Out<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>Console.Error<ept id="p2">**</ept> 日志如下所示：</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>表中的信息日志</source>
          <target state="new">表中的信息日志</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>表中的错误日志</source>
          <target state="new">表中的错误日志</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>本文章提供了代码示例，演示如何处理用于操作 Azure 队列的常见方案。有关如何使用 Azure WebJobs 和 WebJobs SDK 的详细信息，请参阅 <bpt id="p1">[</bpt>Azure WebJobs 推荐资源<ept id="p1">](/documentation/articles/websites-webjobs-resources)</ept>。</source>
          <target state="new">本文章提供了代码示例，演示如何处理用于操作 Azure 队列的常见方案。有关如何使用 Azure WebJobs 和 WebJobs SDK 的详细信息，请参阅 <bpt id="p1">[</bpt>Azure WebJobs 推荐资源<ept id="p1">](/documentation/articles/websites-webjobs-resources)</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>