<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ad4fa3dfaf083570878b4eedb3768e4211d6c532</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何使用 HTML 客户端 | Azure</source>
          <target state="new">如何使用 HTML 客户端 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何使用适用于 Azure 移动服务的 HTML 客户端。</source>
          <target state="new">了解如何使用适用于 Azure 移动服务的 HTML 客户端。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何使用适用于 Azure 移动服务的 HTML/JavaScript 客户端</source>
          <target state="new">如何使用适用于 Azure 移动服务的 HTML/JavaScript 客户端</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本指南说明如何使用适用于 Azure 移动服务的 HTML/JavaScript 客户端（包括 Windows 应用商店 JavaScript 和 PhoneGap/Cordova 应用程序）执行常见任务。所述的任务包括查询数据、插入、更新和删除数据、对用户进行身份验证和处理错误。如果你是第一次使用移动服务，最好先完成<bpt id="p1">[</bpt>移动服务快速入门<ept id="p1">](/documentation/articles/mobile-services-html-get-started)</ept>。快速入门教程可帮助你配置帐户并创建第一个移动服务。</source>
          <target state="new">本指南说明如何使用适用于 Azure 移动服务的 HTML/JavaScript 客户端（包括 Windows 应用商店 JavaScript 和 PhoneGap/Cordova 应用程序）执行常见任务。所述的任务包括查询数据、插入、更新和删除数据、对用户进行身份验证和处理错误。如果你是第一次使用移动服务，最好先完成<bpt id="p1">[</bpt>移动服务快速入门<ept id="p1">](/documentation/articles/mobile-services-html-get-started)</ept>。快速入门教程可帮助你配置帐户并创建第一个移动服务。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="create-client"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何创建移动服务客户端</source>
          <target state="new"><ph id="ph1">&lt;a name="create-client"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何创建移动服务客户端</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>添加移动服务客户端引用的方式取决于应用程序平台，其中包括：</source>
          <target state="new">添加移动服务客户端引用的方式取决于应用程序平台，其中包括：</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>对于 Web 的应用程序，请打开 HTML 文件，然后将以下代码添加到页的脚本引用中：</source>
          <target state="new">对于 Web 的应用程序，请打开 HTML 文件，然后将以下代码添加到页的脚本引用中：</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>对于使用 JavaScript/HTML 编写的 Windows 应用商店应用程序，请将 <bpt id="p1">**</bpt>WindowsAzure.MobileServices.WinJS NuGet<ept id="p1">**</ept> 包添加到你的项目。</source>
          <target state="new">对于使用 JavaScript/HTML 编写的 Windows 应用商店应用程序，请将 <bpt id="p1">**</bpt>WindowsAzure.MobileServices.WinJS NuGet<ept id="p1">**</ept> 包添加到你的项目。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>对于 PhoneGap 或 Cordova 应用程序，请在项目中添加<bpt id="p1">[</bpt>移动服务插件<ept id="p1">](https://github.com/Azure/azure-mobile-services-cordova)</ept>。此插件支持<bpt id="p2">[</bpt>推送通知<ept id="p2">](#push-notifications)</ept>。</source>
          <target state="new">对于 PhoneGap 或 Cordova 应用程序，请在项目中添加<bpt id="p1">[</bpt>移动服务插件<ept id="p1">](https://github.com/Azure/azure-mobile-services-cordova)</ept>。此插件支持<bpt id="p2">[</bpt>推送通知<ept id="p2">](#push-notifications)</ept>。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>在编辑器中，打开或创建一个 JavaScript 文件，添加以下代码以定义 <ph id="ph1">`MobileServiceClient`</ph> 变量，然后在 <ph id="ph2">`MobileServiceClient`</ph> 构造函数中按顺序提供移动服务的应用程序 URL 和应用程序密钥。</source>
          <target state="new">在编辑器中，打开或创建一个 JavaScript 文件，添加以下代码以定义 <ph id="ph1">`MobileServiceClient`</ph> 变量，然后在 <ph id="ph2">`MobileServiceClient`</ph> 构造函数中按顺序提供移动服务的应用程序 URL 和应用程序密钥。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>必须将占位符 <ph id="ph1">`AppUrl`</ph> 替换为移动服务的应用程序 URL，将 <ph id="ph2">`AppKey`</ph> 替换为你从 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">](http://manage.windowsazure.cn/)</ept>获取的应用程序密钥。</source>
          <target state="new">必须将占位符 <ph id="ph1">`AppUrl`</ph> 替换为移动服务的应用程序 URL，将 <ph id="ph2">`AppKey`</ph> 替换为你从 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">](http://manage.windowsazure.cn/)</ept>获取的应用程序密钥。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>应用程序密钥用于针对移动服务筛选出随机请求，将随应用程序一起分发。由于此密钥未加密，因此不能被认为是安全的。为确保安全访问你的移动服务数据，你必须改为在允许用户访问前对用户进行身份验证。有关详细信息，请参阅<bpt id="p1">[</bpt>如何：对用户进行身份验证<ept id="p1">](#authentication)</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>应用程序密钥用于针对移动服务筛选出随机请求，将随应用程序一起分发。由于此密钥未加密，因此不能被认为是安全的。为确保安全访问你的移动服务数据，你必须改为在允许用户访问前对用户进行身份验证。有关详细信息，请参阅<bpt id="p1">[</bpt>如何：对用户进行身份验证<ept id="p1">](#authentication)</ept>。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="querying"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何从移动服务查询数据</source>
          <target state="new"><ph id="ph1">&lt;a name="querying"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何从移动服务查询数据</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>访问或修改 SQL 数据库表中数据的所有代码均将调用 <ph id="ph1">`MobileServiceTable`</ph> 对象的函数。可通过对 <ph id="ph2">`MobileServiceClient`</ph> 实例调用 <ph id="ph3">`getTable()`</ph> 函数来获取对表的引用。</source>
          <target state="new">访问或修改 SQL 数据库表中数据的所有代码均将调用 <ph id="ph1">`MobileServiceTable`</ph> 对象的函数。可通过对 <ph id="ph2">`MobileServiceClient`</ph> 实例调用 <ph id="ph3">`getTable()`</ph> 函数来获取对表的引用。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="filtering"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何筛选返回的数据</source>
          <target state="new"><ph id="ph1">&lt;a name="filtering"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何筛选返回的数据</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何通过在查询中包含 <ph id="ph1">`where`</ph> 子句来筛选数据。该代码将返回 complete 字段等于 <ph id="ph2">`false`</ph> 的 <ph id="ph3">`todoItemTable`</ph> 中的所有项。<ph id="ph4">`todoItemTable`</ph> 是对前面创建的移动服务表的引用。where 函数针对该表将一个行筛选谓词应用到查询。该函数接受 JSON 对象或定义行筛选器的函数作为其参数，并返回可进一步编写的查询。</source>
          <target state="new">以下代码演示了如何通过在查询中包含 <ph id="ph1">`where`</ph> 子句来筛选数据。该代码将返回 complete 字段等于 <ph id="ph2">`false`</ph> 的 <ph id="ph3">`todoItemTable`</ph> 中的所有项。<ph id="ph4">`todoItemTable`</ph> 是对前面创建的移动服务表的引用。where 函数针对该表将一个行筛选谓词应用到查询。该函数接受 JSON 对象或定义行筛选器的函数作为其参数，并返回可进一步编写的查询。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>通过在 Query 对象中调用 <ph id="ph1">`where`</ph> 并传递一个对象作为参数，我们可以指示移动服务仅返回 <ph id="ph2">`complete`</ph> 列包含 <ph id="ph3">`false`</ph> 值的行。另外，请查看以下请求 URI，可以看出，我们正在修改查询字符串本身：</source>
          <target state="new">通过在 Query 对象中调用 <ph id="ph1">`where`</ph> 并传递一个对象作为参数，我们可以指示移动服务仅返回 <ph id="ph2">`complete`</ph> 列包含 <ph id="ph3">`false`</ph> 值的行。另外，请查看以下请求 URI，可以看出，我们正在修改查询字符串本身：</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>可以使用消息检查软件（例如浏览器开发人员工具或 Fiddler）来查看发送到移动服务的请求的 URI。</source>
          <target state="new">可以使用消息检查软件（例如浏览器开发人员工具或 Fiddler）来查看发送到移动服务的请求的 URI。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>在服务器端，此请求通常会粗略地转换成以下 SQL 查询：</source>
          <target state="new">在服务器端，此请求通常会粗略地转换成以下 SQL 查询：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>传递给 <ph id="ph1">`where`</ph> 方法的对象可以包含任意数目的参数，所有这些参数都将解释为查询的 AND 子句。例如，以下行：</source>
          <target state="new">传递给 <ph id="ph1">`where`</ph> 方法的对象可以包含任意数目的参数，所有这些参数都将解释为查询的 AND 子句。例如，以下行：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>将粗略地转换为（针对前面显示的同一请求）</source>
          <target state="new">将粗略地转换为（针对前面显示的同一请求）</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>上述 <ph id="ph1">`where`</ph> 语句和上述 SQL 查询将查找分配给“david”、难度为“medium”的不完整项。</source>
          <target state="new">上述 <ph id="ph1">`where`</ph> 语句和上述 SQL 查询将查找分配给“david”、难度为“medium”的不完整项。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>不过，还可以通过另一种方法来编写相同的查询。对 Query 对象的 <ph id="ph1">`.where`</ph> 调用将在 <ph id="ph2">`WHERE`</ph> 子句中添加一个 <ph id="ph3">`AND`</ph> 表达式，因此，我们也可以在三个行中编写该查询：</source>
          <target state="new">不过，还可以通过另一种方法来编写相同的查询。对 Query 对象的 <ph id="ph1">`.where`</ph> 调用将在 <ph id="ph2">`WHERE`</ph> 子句中添加一个 <ph id="ph3">`AND`</ph> 表达式，因此，我们也可以在三个行中编写该查询：</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>或者使用 Fluent API：</source>
          <target state="new">或者使用 Fluent API：</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>这两种方法是等效的，可以换用。到目前为止，所有 <ph id="ph1">`where`</ph> 调用都使用了带有某些参数的对象，并且会根据数据库中的数据比较相等性。但是，查询方法的另一个重载使用函数而不是对象。在这种情况下，我们可以在此函数中使用“不等于”等运算符和其他关系运算来编写更复杂的表达式。在这些函数中，关键字 <ph id="ph2">`this`</ph> 将绑定到服务器对象。</source>
          <target state="new">这两种方法是等效的，可以换用。到目前为止，所有 <ph id="ph1">`where`</ph> 调用都使用了带有某些参数的对象，并且会根据数据库中的数据比较相等性。但是，查询方法的另一个重载使用函数而不是对象。在这种情况下，我们可以在此函数中使用“不等于”等运算符和其他关系运算来编写更复杂的表达式。在这些函数中，关键字 <ph id="ph2">`this`</ph> 将绑定到服务器对象。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>函数的正文将转换为开放数据协议 (OData) 布尔表达式，该表达式将传递给查询字符串参数。可以传入不带参数的函数，例如：</source>
          <target state="new">函数的正文将转换为开放数据协议 (OData) 布尔表达式，该表达式将传递给查询字符串参数。可以传入不带参数的函数，例如：</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>如果传入带参数的函数，则 <ph id="ph1">`where`</ph> 子句后面的所有参数都将按顺序绑定到函数参数。来自函数范围以外的任何对象都必须作为参数传递 - 函数无法捕获任何外部变量。在接下来的两个示例中，自变量“david”将绑定到参数 <ph id="ph2">`name`</ph>，在第一个示例中，自变量“medium”也绑定到参数 <ph id="ph3">`level`</ph>。另外，函数必须包含带受支持表达式的单个 <ph id="ph4">`return`</ph> 语句，例如：</source>
          <target state="new">如果传入带参数的函数，则 <ph id="ph1">`where`</ph> 子句后面的所有参数都将按顺序绑定到函数参数。来自函数范围以外的任何对象都必须作为参数传递 - 函数无法捕获任何外部变量。在接下来的两个示例中，自变量“david”将绑定到参数 <ph id="ph2">`name`</ph>，在第一个示例中，自变量“medium”也绑定到参数 <ph id="ph3">`level`</ph>。另外，函数必须包含带受支持表达式的单个 <ph id="ph4">`return`</ph> 语句，例如：</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>因此，只要我们遵守规则，就能将更复杂的筛选器添加到数据库查询，例如：</source>
          <target state="new">因此，只要我们遵守规则，就能将更复杂的筛选器添加到数据库查询，例如：</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>可以将 <ph id="ph1">`where`</ph> 与 <ph id="ph2">`orderBy`</ph>、<ph id="ph3">`take`</ph> 和 <ph id="ph4">`skip`</ph> 组合使用。有关详细信息，请参阅下一节。</source>
          <target state="new">可以将 <ph id="ph1">`where`</ph> 与 <ph id="ph2">`orderBy`</ph>、<ph id="ph3">`take`</ph> 和 <ph id="ph4">`skip`</ph> 组合使用。有关详细信息，请参阅下一节。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="sorting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何为返回的数据排序</source>
          <target state="new"><ph id="ph1">&lt;a name="sorting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何为返回的数据排序</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何通过在查询中包含 <ph id="ph1">`orderBy`</ph> 或 <ph id="ph2">`orderByDescending`</ph> 函数来为数据排序。该代码将返回 <ph id="ph3">`todoItemTable`</ph> 中的项，这些项已按 <ph id="ph4">`text`</ph> 字段的升序排序。默认情况下，服务器只返回前 50 个元素。</source>
          <target state="new">以下代码演示了如何通过在查询中包含 <ph id="ph1">`orderBy`</ph> 或 <ph id="ph2">`orderByDescending`</ph> 函数来为数据排序。该代码将返回 <ph id="ph3">`todoItemTable`</ph> 中的项，这些项已按 <ph id="ph4">`text`</ph> 字段的升序排序。默认情况下，服务器只返回前 50 个元素。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>默认情况下，将使用服务器驱动的页大小来防止返回所有元素。这可以防止对大型数据集发出的默认请求对服务造成负面影响。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>默认情况下，将使用服务器驱动的页大小来防止返回所有元素。这可以防止对大型数据集发出的默认请求对服务造成负面影响。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>你可以根据下一节中所述，通过调用 <ph id="ph1">`take`</ph> 来增加返回的项数。<ph id="ph2">`todoItemTable`</ph> 是对前面创建的移动服务表的引用。</source>
          <target state="new">你可以根据下一节中所述，通过调用 <ph id="ph1">`take`</ph> 来增加返回的项数。<ph id="ph2">`todoItemTable`</ph> 是对前面创建的移动服务表的引用。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="paging"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在页中返回数据</source>
          <target state="new"><ph id="ph1">&lt;a name="paging"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在页中返回数据</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>默认情况下，移动服务只在给定的请求中返回 50 行，除非客户端显式要求在响应中返回更多的数据。以下代码演示了如何通过在查询中使用 <ph id="ph1">`take`</ph> 和 <ph id="ph2">`skip`</ph> 子句来实现返回数据的分页。执行以下查询后，将返回表中的前三个项。</source>
          <target state="new">默认情况下，移动服务只在给定的请求中返回 50 行，除非客户端显式要求在响应中返回更多的数据。以下代码演示了如何通过在查询中使用 <ph id="ph1">`take`</ph> 和 <ph id="ph2">`skip`</ph> 子句来实现返回数据的分页。执行以下查询后，将返回表中的前三个项。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>请注意，<ph id="ph1">`take(3)`</ph> 方法已转换成查询 URI 中的查询选项 <ph id="ph2">`$top=3`</ph>。</source>
          <target state="new">请注意，<ph id="ph1">`take(3)`</ph> 方法已转换成查询 URI 中的查询选项 <ph id="ph2">`$top=3`</ph>。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>以下经过修改的查询将跳过前三个结果，返回其后的三个结果。实际上这是数据的第二“页”，其页大小为三个项。</source>
          <target state="new">以下经过修改的查询将跳过前三个结果，返回其后的三个结果。实际上这是数据的第二“页”，其页大小为三个项。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>同样，你可以查看发送到移动服务的请求的 URI。请注意，<ph id="ph1">`skip(3)`</ph> 方法已转换成查询 URI 中的查询选项 <ph id="ph2">`$skip=3`</ph>。</source>
          <target state="new">同样，你可以查看发送到移动服务的请求的 URI。请注意，<ph id="ph1">`skip(3)`</ph> 方法已转换成查询 URI 中的查询选项 <ph id="ph2">`$skip=3`</ph>。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>这是将硬编码分页值传递给 <ph id="ph1">`take`</ph> 和 <ph id="ph2">`skip`</ph> 函数的简化方案。在实际应用中，你可以对页导航控件或类似的 UI 使用类似于上面的查询，让用户导航到上一页和下一页。</source>
          <target state="new">这是将硬编码分页值传递给 <ph id="ph1">`take`</ph> 和 <ph id="ph2">`skip`</ph> 函数的简化方案。在实际应用中，你可以对页导航控件或类似的 UI 使用类似于上面的查询，让用户导航到上一页和下一页。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="selecting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何选择特定的列</source>
          <target state="new"><ph id="ph1">&lt;a name="selecting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何选择特定的列</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>你可以通过在查询中添加 <ph id="ph1">`select`</ph> 子句来指定要包含在结果中的属性集。例如，以下代码将从 <ph id="ph2">`todoItemTable`</ph> 的每一行中返回 <ph id="ph3">`id`</ph>、<ph id="ph4">`complete`</ph> 和 <ph id="ph5">`text`</ph> 属性：</source>
          <target state="new">你可以通过在查询中添加 <ph id="ph1">`select`</ph> 子句来指定要包含在结果中的属性集。例如，以下代码将从 <ph id="ph2">`todoItemTable`</ph> 的每一行中返回 <ph id="ph3">`id`</ph>、<ph id="ph4">`complete`</ph> 和 <ph id="ph5">`text`</ph> 属性：</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>此处，select 函数的参数是要返回的表列的名称。</source>
          <target state="new">此处，select 函数的参数是要返回的表列的名称。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>到目前为止所述的所有函数都是加性函数，我们可以不断地调用它们，每次调用都能进一步影响查询。再提供一个示例：</source>
          <target state="new">到目前为止所述的所有函数都是加性函数，我们可以不断地调用它们，每次调用都能进一步影响查询。再提供一个示例：</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="lookingup"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：按 ID 查找数据</source>
          <target state="new"><ph id="ph1">&lt;a name="lookingup"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：按 ID 查找数据</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`lookup`</ph> 函数只使用 <ph id="ph2">`id`</ph> 值，并从数据库返回具有该 ID 的对象。创建数据库表时使用了整数或字符串 <ph id="ph3">`id`</ph> 列。默认使用字符串 <ph id="ph4">`id`</ph> 列。</source>
          <target state="new"><ph id="ph1">`lookup`</ph> 函数只使用 <ph id="ph2">`id`</ph> 值，并从数据库返回具有该 ID 的对象。创建数据库表时使用了整数或字符串 <ph id="ph3">`id`</ph> 列。默认使用字符串 <ph id="ph4">`id`</ph> 列。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="odata-query"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>执行 OData 查询操作</source>
          <target state="new"><ph id="ph1">&lt;a name="odata-query"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>执行 OData 查询操作</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>移动服务使用 OData 查询 URI 约定编写和执行 REST 查询。并非所有 OData 查询都可使用内置查询函数编写，尤其是复杂的筛选器操作，如搜索属性中的子字符串。对于这些类型的复杂查询，可以将任何有效的 OData 查询选项字符串传递给 <ph id="ph1">`read`</ph> 函数，如下所示：</source>
          <target state="new">移动服务使用 OData 查询 URI 约定编写和执行 REST 查询。并非所有 OData 查询都可使用内置查询函数编写，尤其是复杂的筛选器操作，如搜索属性中的子字符串。对于这些类型的复杂查询，可以将任何有效的 OData 查询选项字符串传递给 <ph id="ph1">`read`</ph> 函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>在 <ph id="ph2">`read`</ph> 函数中提供原始 OData 查询选项字符串时，不能在同一查询中使用查询生成器方法。在这种情况下，必须将整个查询编写为 OData 查询字符串。有关 OData 系统查询选项的详细信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">OData 系统查询选项参考]</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>在 <ph id="ph2">`read`</ph> 函数中提供原始 OData 查询选项字符串时，不能在同一查询中使用查询生成器方法。在这种情况下，必须将整个查询编写为 OData 查询字符串。有关 OData 系统查询选项的详细信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">OData 系统查询选项参考]</ept>。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="inserting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中插入数据</source>
          <target state="new"><ph id="ph1">&lt;a name="inserting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中插入数据</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何在表中插入新行。客户端通过将 POST 请求发送到移动服务来请求插入数据行。请求正文包含要插入的、JSON 对象形式的数据。</source>
          <target state="new">以下代码演示了如何在表中插入新行。客户端通过将 POST 请求发送到移动服务来请求插入数据行。请求正文包含要插入的、JSON 对象形式的数据。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>以上代码会将提供的 JSON 对象中的数据插入到表中。你还可以指定完成插入时要调用的回调函数：</source>
          <target state="new">以上代码会将提供的 JSON 对象中的数据插入到表中。你还可以指定完成插入时要调用的回调函数：</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>使用 ID 值</source>
          <target state="new">使用 ID 值</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>移动服务支持为表的 <bpt id="p1">**</bpt>ID<ept id="p1">**</ept> 列使用唯一的自定义字符串值。这样，应用程序便可为 ID 使用自定义值（如电子邮件地址或用户名）。例如，以下代码将插入 JSON 对象形式的新项，其中，唯一 ID 是电子邮件地址：</source>
          <target state="new">移动服务支持为表的 <bpt id="p1">**</bpt>ID<ept id="p1">**</ept> 列使用唯一的自定义字符串值。这样，应用程序便可为 ID 使用自定义值（如电子邮件地址或用户名）。例如，以下代码将插入 JSON 对象形式的新项，其中，唯一 ID 是电子邮件地址：</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>字符串 ID 可提供以下优势：</source>
          <target state="new">字符串 ID 可提供以下优势：</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>无需往返访问数据库即可生成 ID。</source>
          <target state="new">无需往返访问数据库即可生成 ID。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>更方便地合并不同表或数据库中的记录。</source>
          <target state="new">更方便地合并不同表或数据库中的记录。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>ID 值能够更好地与应用程序的逻辑相集成。</source>
          <target state="new">ID 值能够更好地与应用程序的逻辑相集成。</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>如果插入的记录中尚未设置字符串 ID 值，移动服务将为 ID 生成唯一值。有关如何在客户端上或 .NET 后端中生成自己的 ID 值的详细信息，请参阅<bpt id="p1">[</bpt>如何：生成唯一 ID 值<ept id="p1">](/documentation/articles/mobile-services-how-to-use-server-scripts/#generate-guids)</ept>。</source>
          <target state="new">如果插入的记录中尚未设置字符串 ID 值，移动服务将为 ID 生成唯一值。有关如何在客户端上或 .NET 后端中生成自己的 ID 值的详细信息，请参阅<bpt id="p1">[</bpt>如何：生成唯一 ID 值<ept id="p1">](/documentation/articles/mobile-services-how-to-use-server-scripts/#generate-guids)</ept>。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>也可以为表使用整数 ID。若要使用整数 ID，必须结合 <ph id="ph1">`--integerId`</ph> 选项使用 <ph id="ph2">`mobile table create`</ph> 命令创建表。应在适用于 Azure 的命令行界面 (CLI) 中使用此命令。有关使用 CLI 的详细信息，请参阅<bpt id="p1">[</bpt>用于管理移动服务表的 CLI<ept id="p1">](/documentation/articles/virtual-machines-command-line-tools/#Mobile_Tables)</ept>。</source>
          <target state="new">也可以为表使用整数 ID。若要使用整数 ID，必须结合 <ph id="ph1">`--integerId`</ph> 选项使用 <ph id="ph2">`mobile table create`</ph> 命令创建表。应在适用于 Azure 的命令行界面 (CLI) 中使用此命令。有关使用 CLI 的详细信息，请参阅<bpt id="p1">[</bpt>用于管理移动服务表的 CLI<ept id="p1">](/documentation/articles/virtual-machines-command-line-tools/#Mobile_Tables)</ept>。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="modifying"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：在移动服务中修改数据</source>
          <target state="new"><ph id="ph1">&lt;a name="modifying"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：在移动服务中修改数据</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何更新表中的数据。客户端通过将 PATCH 请求发送到移动服务来请求更新数据行。请求正文包含要更新的、JSON 对象形式的特定字段。该代码将更新表 <ph id="ph1">`todoItemTable`</ph> 中的某个现有项。</source>
          <target state="new">以下代码演示了如何更新表中的数据。客户端通过将 PATCH 请求发送到移动服务来请求更新数据行。请求正文包含要更新的、JSON 对象形式的特定字段。该代码将更新表 <ph id="ph1">`todoItemTable`</ph> 中的某个现有项。</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>第一个参数使用 ID 指定了表中要更新的实例。</source>
          <target state="new">第一个参数使用 ID 指定了表中要更新的实例。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>你还可以指定在完成更新时要调用的回调函数：</source>
          <target state="new">你还可以指定在完成更新时要调用的回调函数：</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="deleting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中删除数据</source>
          <target state="new"><ph id="ph1">&lt;a name="deleting"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何在移动服务中删除数据</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>以下代码演示了如何删除表中的数据。客户端通过将 DELETE 请求发送到移动服务来请求删除数据行。该代码将删除表 todoItemTable 中的某个现有项。</source>
          <target state="new">以下代码演示了如何删除表中的数据。客户端通过将 DELETE 请求发送到移动服务来请求删除数据行。该代码将删除表 todoItemTable 中的某个现有项。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>第一个参数使用 ID 指定了表中要删除的实例。</source>
          <target state="new">第一个参数使用 ID 指定了表中要删除的实例。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>你还可以指定在完成删除时要调用的回调函数：</source>
          <target state="new">你还可以指定在完成删除时要调用的回调函数：</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="binding"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：在用户界面中显示数据</source>
          <target state="new"><ph id="ph1">&lt;a name="binding"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：在用户界面中显示数据</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>本部分说明如何使用 UI 元素显示返回的数据对象。若要查询 <ph id="ph1">`todoItemTable`</ph> 中的项并在极简单的列表中显示这些项，可以运行以下示例代码。这里未执行任何形式的选择、筛选或排序操作。</source>
          <target state="new">本部分说明如何使用 UI 元素显示返回的数据对象。若要查询 <ph id="ph1">`todoItemTable`</ph> 中的项并在极简单的列表中显示这些项，可以运行以下示例代码。这里未执行任何形式的选择、筛选或排序操作。</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>在 Windows 应用商店应用程序中，可以使用查询的结果来创建 [WinJS.Binding.List] 对象，该对象可绑定为 <bpt id="p1">[</bpt><ept id="p1">ListView]</ept> 对象的数据源。有关详细信息，请参阅<bpt id="p2">[</bpt><ept id="p2">数据绑定（使用 JavaScript 和 HTML 的 Windows 应用商店应用程序）]</ept>。</source>
          <target state="new">在 Windows 应用商店应用程序中，可以使用查询的结果来创建 [WinJS.Binding.List] 对象，该对象可绑定为 <bpt id="p1">[</bpt><ept id="p1">ListView]</ept> 对象的数据源。有关详细信息，请参阅<bpt id="p2">[</bpt><ept id="p2">数据绑定（使用 JavaScript 和 HTML 的 Windows 应用商店应用程序）]</ept>。</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="custom-api"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：调用自定义 API</source>
          <target state="new"><ph id="ph1">&lt;a name="custom-api"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：调用自定义 API</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>自定义 API 可让你定义自定义终结点，这些终结点将会公开不映射到插入、更新、删除或读取操作的服务器功能。使用自定义 API 能够以更大的力度控制消息传送，包括读取和设置 HTTP 消息标头，以及定义除 JSON 以外的消息正文格式。有关如何在移动服务中创建自定义 API 的示例，请参阅<bpt id="p1">[</bpt>如何：定义自定义 API 终结点<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-define-custom-api)</ept>。</source>
          <target state="new">自定义 API 可让你定义自定义终结点，这些终结点将会公开不映射到插入、更新、删除或读取操作的服务器功能。使用自定义 API 能够以更大的力度控制消息传送，包括读取和设置 HTTP 消息标头，以及定义除 JSON 以外的消息正文格式。有关如何在移动服务中创建自定义 API 的示例，请参阅<bpt id="p1">[</bpt>如何：定义自定义 API 终结点<ept id="p1">](/documentation/articles/mobile-services-dotnet-backend-define-custom-api)</ept>。</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>通过对 <bpt id="p1">**</bpt>MobileServiceClient<ept id="p1">**</ept> 调用 <bpt id="p2">[</bpt>invokeApi<ept id="p2">](https://github.com/Azure/azure-mobile-services/blob/master/sdk/Javascript/src/MobileServiceClient.js#L337)</ept> 方法，从客户端调用自定义 API。例如，以下代码行向移动服务上的 <bpt id="p3">**</bpt>completeAll<ept id="p3">**</ept> API 发送 POST 请求：</source>
          <target state="new">通过对 <bpt id="p1">**</bpt>MobileServiceClient<ept id="p1">**</ept> 调用 <bpt id="p2">[</bpt>invokeApi<ept id="p2">](https://github.com/Azure/azure-mobile-services/blob/master/sdk/Javascript/src/MobileServiceClient.js#L337)</ept> 方法，从客户端调用自定义 API。例如，以下代码行向移动服务上的 <bpt id="p3">**</bpt>completeAll<ept id="p3">**</ept> API 发送 POST 请求：</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>有关更现实可行的示例和对 <bpt id="p1">**</bpt>invokeApi<ept id="p1">**</ept> 更完整的介绍，请参阅<bpt id="p2">[</bpt>Azure 移动服务客户端 SDK 中的自定义 API<ept id="p2">](http://blogs.msdn.com/b/carlosfigueira/archive/2013/06/19/custom-api-in-azure-mobile-services-client-sdks.aspx)</ept>。</source>
          <target state="new">有关更现实可行的示例和对 <bpt id="p1">**</bpt>invokeApi<ept id="p1">**</ept> 更完整的介绍，请参阅<bpt id="p2">[</bpt>Azure 移动服务客户端 SDK 中的自定义 API<ept id="p2">](http://blogs.msdn.com/b/carlosfigueira/archive/2013/06/19/custom-api-in-azure-mobile-services-client-sdks.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="authentication"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何对用户进行身份验证</source>
          <target state="new"><ph id="ph1">&lt;a name="authentication"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何对用户进行身份验证</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>移动服务支持使用各种外部标识提供者对应用程序用户进行身份验证和授权，这些提供者包括：Facebook、Google、Microsoft 帐户和 Twitter。你可以在表中设置权限，以便将特定操作的访问权限限制给已经过身份验证的用户。你还可以在服务器脚本中使用已经过身份验证的用户的标识来实施授权规则。有关详细信息，请参阅 [身份验证入门] 教程。</source>
          <target state="new">移动服务支持使用各种外部标识提供者对应用程序用户进行身份验证和授权，这些提供者包括：Facebook、Google、Microsoft 帐户和 Twitter。你可以在表中设置权限，以便将特定操作的访问权限限制给已经过身份验证的用户。你还可以在服务器脚本中使用已经过身份验证的用户的标识来实施授权规则。有关详细信息，请参阅 [身份验证入门] 教程。</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>在 PhoneGap 或 Cordova 应用程序中使用身份验证时，还必须向项目中添加以下插件：</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>在 PhoneGap 或 Cordova 应用程序中使用身份验证时，还必须向项目中添加以下插件：</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>https://git-wip-us.apache.org/repos/asf/cordova-plugin-device.git</source>
          <target state="new">https://git-wip-us.apache.org/repos/asf/cordova-plugin-device.git</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>https://git-wip-us.apache.org/repos/asf/cordova-plugin-inappbrowser.git</source>
          <target state="new">https://git-wip-us.apache.org/repos/asf/cordova-plugin-inappbrowser.git</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>支持两种身份验证流：<bpt id="p1">_</bpt>服务器流<ept id="p1">_</ept>和<bpt id="p2">_</bpt>客户端流<ept id="p2">_</ept>。服务器流依赖于提供者的 Web 身份验证界面，因此可提供最简便的身份验证体验。客户端流依赖于提供者和设备特定的 SDK，因此允许与设备特定的功能（例如单一登录）进行更深入的集成。</source>
          <target state="new">支持两种身份验证流：<bpt id="p1">_</bpt>服务器流<ept id="p1">_</ept>和<bpt id="p2">_</bpt>客户端流<ept id="p2">_</ept>。服务器流依赖于提供者的 Web 身份验证界面，因此可提供最简便的身份验证体验。客户端流依赖于提供者和设备特定的 SDK，因此允许与设备特定的功能（例如单一登录）进行更深入的集成。</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>服务器流</source>
          <target state="new">服务器流</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>若要让移动服务管理 Windows 应用商店或 HTML5 应用程序中的身份验证过程，必须将你的应用程序注册到标识提供者。然后，需要在移动服务中配置提供者提供的应用程序 ID 和机密。有关详细信息，请参阅<bpt id="p1">[</bpt>向应用程序添加身份验证<ept id="p1">](/documentation/articles/mobile-services-html-get-started-users)</ept>教程。</source>
          <target state="new">若要让移动服务管理 Windows 应用商店或 HTML5 应用程序中的身份验证过程，必须将你的应用程序注册到标识提供者。然后，需要在移动服务中配置提供者提供的应用程序 ID 和机密。有关详细信息，请参阅<bpt id="p1">[</bpt>向应用程序添加身份验证<ept id="p1">](/documentation/articles/mobile-services-html-get-started-users)</ept>教程。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>注册标识提供者后，只需结合提供者的 [MobileServiceAuthenticationProvider] 值调用 [LoginAsync 方法]。例如，若要使用 Facebook 登录，请使用以下代码。</source>
          <target state="new">注册标识提供者后，只需结合提供者的 [MobileServiceAuthenticationProvider] 值调用 [LoginAsync 方法]。例如，若要使用 Facebook 登录，请使用以下代码。</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>如果你使用的标识提供者不是 Facebook，请将传递给上述 <ph id="ph1">`login`</ph> 方法的值更改为下列项之一：<ph id="ph2">`microsoftaccount`</ph>、<ph id="ph3">`facebook`</ph>、<ph id="ph4">`twitter`</ph>、<ph id="ph5">`google`</ph> 或 <ph id="ph6">`windowsazureactivedirectory`</ph>。</source>
          <target state="new">如果你使用的标识提供者不是 Facebook，请将传递给上述 <ph id="ph1">`login`</ph> 方法的值更改为下列项之一：<ph id="ph2">`microsoftaccount`</ph>、<ph id="ph3">`facebook`</ph>、<ph id="ph4">`twitter`</ph>、<ph id="ph5">`google`</ph> 或 <ph id="ph6">`windowsazureactivedirectory`</ph>。</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>在此情况下，移动服务将通过以下方式管理 OAuth 2.0 身份验证流：显示选定提供者的登录页，并在用户成功使用标识提供者登录后生成移动服务身份验证令牌。<bpt id="p1">[</bpt><ept id="p1">login]</ept> 函数在完成时将返回一个 JSON 对象 (<bpt id="p2">**</bpt>user<ept id="p2">**</ept>)，该对象分别在 <bpt id="p3">**</bpt>userId<ept id="p3">**</ept> 和 <bpt id="p4">**</bpt>authenticationToken<ept id="p4">**</ept> 字段中公开用户 ID 和移动服务身份验证令牌。你可以缓存此令牌，并在它过期之前重复使用。有关详细信息，请参阅“缓存身份验证令牌”。</source>
          <target state="new">在此情况下，移动服务将通过以下方式管理 OAuth 2.0 身份验证流：显示选定提供者的登录页，并在用户成功使用标识提供者登录后生成移动服务身份验证令牌。<bpt id="p1">[</bpt><ept id="p1">login]</ept> 函数在完成时将返回一个 JSON 对象 (<bpt id="p2">**</bpt>user<ept id="p2">**</ept>)，该对象分别在 <bpt id="p3">**</bpt>userId<ept id="p3">**</ept> 和 <bpt id="p4">**</bpt>authenticationToken<ept id="p4">**</ept> 字段中公开用户 ID 和移动服务身份验证令牌。你可以缓存此令牌，并在它过期之前重复使用。有关详细信息，请参阅“缓存身份验证令牌”。</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>客户端流</source>
          <target state="new">客户端流</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>你的应用程序还能够独立联系标识提供者，然后将返回的令牌提供给移动服务以进行身份验证。使用此客户端流可为用户提供单一登录体验，或者从标识提供者中检索其他用户数据。</source>
          <target state="new">你的应用程序还能够独立联系标识提供者，然后将返回的令牌提供给移动服务以进行身份验证。使用此客户端流可为用户提供单一登录体验，或者从标识提供者中检索其他用户数据。</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Facebook/Google SDK 基本示例</source>
          <target state="new">Facebook/Google SDK 基本示例</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>此示例使用 Facebook 客户端 SDK 进行身份验证：</source>
          <target state="new">此示例使用 Facebook 客户端 SDK 进行身份验证：</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>此示例假定由相应的提供程序 SDK 提供的令牌存储在 <ph id="ph1">`token`</ph> 变量中。目前，不能使用 Twitter 进行客户端身份验证。</source>
          <target state="new">此示例假定由相应的提供程序 SDK 提供的令牌存储在 <ph id="ph1">`token`</ph> 变量中。目前，不能使用 Twitter 进行客户端身份验证。</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Microsoft 帐户基本示例</source>
          <target state="new">Microsoft 帐户基本示例</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>以下示例使用 Live SDK，该 SDK 使用 Microsoft 帐户来支持 Windows 应用商店应用程序的单一登录：</source>
          <target state="new">以下示例使用 Live SDK，该 SDK 使用 Microsoft 帐户来支持 Windows 应用商店应用程序的单一登录：</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>这个简化的示例将从 Live Connect 获取一个令牌，并通过调用 <bpt id="p1">[</bpt><ept id="p1">login]</ept> 函数将该令牌提供给移动服务。</source>
          <target state="new">这个简化的示例将从 Live Connect 获取一个令牌，并通过调用 <bpt id="p1">[</bpt><ept id="p1">login]</ept> 函数将该令牌提供给移动服务。</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Microsoft 帐户完整示例</source>
          <target state="new">Microsoft 帐户完整示例</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>以下示例演示如何使用 Live SDK 和 WinJS API 来提供增强的单一登录体验：</source>
          <target state="new">以下示例演示如何使用 Live SDK 和 WinJS API 来提供增强的单一登录体验：</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>此代码初始化 Live Connect 客户端，向 Microsoft 帐户发送一个新的登录请求，将返回的身份验证令牌发送到移动服务，然后显示有关已登录用户的信息。在身份验证成功之前，该应用不会启动。</source>
          <target state="new">此代码初始化 Live Connect 客户端，向 Microsoft 帐户发送一个新的登录请求，将返回的身份验证令牌发送到移动服务，然后显示有关已登录用户的信息。在身份验证成功之前，该应用不会启动。</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="push-notifications"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：注册推送通知</source>
          <target state="new"><ph id="ph1">&lt;a name="push-notifications"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：注册推送通知</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>如果你的应用程序是 PhoneGap 或 Apache Cordova HTML/JavaScript 应用程序，则你可以使用本机移动平台在设备上接收推送通知。<bpt id="p1">[</bpt>Azure 移动服务的 Apache Cordova 插件<ept id="p1">](https://github.com/Azure/azure-mobile-services-cordova)</ept>可让你向 Azure 通知中心注册推送通知。使用的具体通知服务取决于执行代码的本机设备平台。有关如何执行此操作的示例，请参阅<bpt id="p2">[</bpt>使用 Azure 将通知推送到 Cordova 应用程序<ept id="p2">](https://github.com/Azure/mobile-services-samples/tree/master/CordovaNotificationsArticle)</ept>。</source>
          <target state="new">如果你的应用程序是 PhoneGap 或 Apache Cordova HTML/JavaScript 应用程序，则你可以使用本机移动平台在设备上接收推送通知。<bpt id="p1">[</bpt>Azure 移动服务的 Apache Cordova 插件<ept id="p1">](https://github.com/Azure/azure-mobile-services-cordova)</ept>可让你向 Azure 通知中心注册推送通知。使用的具体通知服务取决于执行代码的本机设备平台。有关如何执行此操作的示例，请参阅<bpt id="p2">[</bpt>使用 Azure 将通知推送到 Cordova 应用程序<ept id="p2">](https://github.com/Azure/mobile-services-samples/tree/master/CordovaNotificationsArticle)</ept>。</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>此插件目前仅支持 iOS 和 Android 设备。有关也包含 Windows 设备的解决方案，请参阅文章<bpt id="p1">[</bpt>使用通知中心集成将通知推送到 PhoneGap 应用程序<ept id="p1">](http://blogs.msdn.com/b/azuremobile/archive/2014/06/17/push-notifications-to-phonegap-apps-using-notification-hubs-integration.aspx)</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>此插件目前仅支持 iOS 和 Android 设备。有关也包含 Windows 设备的解决方案，请参阅文章<bpt id="p1">[</bpt>使用通知中心集成将通知推送到 PhoneGap 应用程序<ept id="p1">](http://blogs.msdn.com/b/azuremobile/archive/2014/06/17/push-notifications-to-phonegap-apps-using-notification-hubs-integration.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="errors"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：处理错误</source>
          <target state="new"><ph id="ph1">&lt;a name="errors"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：处理错误</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>在移动服务中，你可能会遇到各种形式的错误，并且可以通过多种方式来验证和解决这些错误。</source>
          <target state="new">在移动服务中，你可能会遇到各种形式的错误，并且可以通过多种方式来验证和解决这些错误。</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>例如，你可以在移动服务中注册服务器脚本，然后使用这些脚本对所要插入和更新的数据执行各种操作，包括验证和数据修改。你可以按如下所示定义并注册一个用于验证和修改数据的服务器脚本：</source>
          <target state="new">例如，你可以在移动服务中注册服务器脚本，然后使用这些脚本对所要插入和更新的数据执行各种操作，包括验证和数据修改。你可以按如下所示定义并注册一个用于验证和修改数据的服务器脚本：</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>此服务器端脚本将验证发送到移动服务的字符串数据长度，并拒绝过长（在本例中为 10 个字符以上）的字符串。</source>
          <target state="new">此服务器端脚本将验证发送到移动服务的字符串数据长度，并拒绝过长（在本例中为 10 个字符以上）的字符串。</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>由于移动服务能够在服务器端验证数据和发送错误响应，因此你可以更新你的 HTML 应用程序，使其能够处理验证后生成的错误响应。</source>
          <target state="new">由于移动服务能够在服务器端验证数据和发送错误响应，因此你可以更新你的 HTML 应用程序，使其能够处理验证后生成的错误响应。</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>更明白地说，每次执行数据访问时，你都可以传入错误处理程序作为第二个参数：</source>
          <target state="new">更明白地说，每次执行数据访问时，你都可以传入错误处理程序作为第二个参数：</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="promises"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：使用约定</source>
          <target state="new"><ph id="ph1">&lt;a name="promises"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：使用约定</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>约定提供了一种机制，让你基于尚未计算的值安排有待完成的工作。它是用于管理与异步 API 的交互的抽象。</source>
          <target state="new">约定提供了一种机制，让你基于尚未计算的值安排有待完成的工作。它是用于管理与异步 API 的交互的抽象。</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>每当提供给 <ph id="ph1">`done`</ph> 约定的函数已成功完成或者收到错误时，就会立即执行该约定。与 <ph id="ph2">`then`</ph> 约定不同，它肯定会引发无法在函数内部处理的错误；当处理程序完成执行后，此函数将引发当某个约定处于错误状态时返回的错误。有关详细信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">done]</ept>。</source>
          <target state="new">每当提供给 <ph id="ph1">`done`</ph> 约定的函数已成功完成或者收到错误时，就会立即执行该约定。与 <ph id="ph2">`then`</ph> 约定不同，它肯定会引发无法在函数内部处理的错误；当处理程序完成执行后，此函数将引发当某个约定处于错误状态时返回的错误。有关详细信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">done]</ept>。</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>例如：</source>
          <target state="new">例如：</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`then`</ph> 约定与 <ph id="ph2">`done`</ph> 约定类似，而与 <ph id="ph3">`then`</ph> 约定的不同之处在于，<ph id="ph4">`done`</ph> 肯定会引发无法在函数内部处理的错误。如果你未向 <ph id="ph5">`then`</ph> 提供错误处理程序，当操作出错时，它不会引发异常，而是返回一个处于错误状态的约定。有关详细信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">then]</ept>。</source>
          <target state="new"><ph id="ph1">`then`</ph> 约定与 <ph id="ph2">`done`</ph> 约定类似，而与 <ph id="ph3">`then`</ph> 约定的不同之处在于，<ph id="ph4">`done`</ph> 肯定会引发无法在函数内部处理的错误。如果你未向 <ph id="ph5">`then`</ph> 提供错误处理程序，当操作出错时，它不会引发异常，而是返回一个处于错误状态的约定。有关详细信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">then]</ept>。</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>例如：</source>
          <target state="new">例如：</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>你可以通过许多不同的方式使用约定。你可以通过对前一个 <ph id="ph1">`then`</ph> 函数返回的约定调用 <ph id="ph2">`then`</ph> 或 <ph id="ph3">`done`</ph> 来链接约定操作。对于操作的中间阶段使用 <ph id="ph4">`then`</ph>（例如 <ph id="ph5">`.then().then()`</ph>），对于操作的最后阶段使用 <ph id="ph6">`done`</ph>（例如 <ph id="ph7">`.then().then().done()`</ph>）。你可以链接多个 <ph id="ph8">`then`</ph> 函数，因为 <ph id="ph9">`then`</ph> 返回约定。无法链接多个 <ph id="ph10">`done`</ph> 方法，因为该方法返回 undefined。<bpt id="p1">[</bpt><ept id="p1">详细了解 then 和 done 之间的差别]</ept>。</source>
          <target state="new">你可以通过许多不同的方式使用约定。你可以通过对前一个 <ph id="ph1">`then`</ph> 函数返回的约定调用 <ph id="ph2">`then`</ph> 或 <ph id="ph3">`done`</ph> 来链接约定操作。对于操作的中间阶段使用 <ph id="ph4">`then`</ph>（例如 <ph id="ph5">`.then().then()`</ph>），对于操作的最后阶段使用 <ph id="ph6">`done`</ph>（例如 <ph id="ph7">`.then().then().done()`</ph>）。你可以链接多个 <ph id="ph8">`then`</ph> 函数，因为 <ph id="ph9">`then`</ph> 返回约定。无法链接多个 <ph id="ph10">`done`</ph> 方法，因为该方法返回 undefined。<bpt id="p1">[</bpt><ept id="p1">详细了解 then 和 done 之间的差别]</ept>。</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="customizing"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：自定义客户端请求标头</source>
          <target state="new"><ph id="ph1">&lt;a name="customizing"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：自定义客户端请求标头</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>你可以使用 <ph id="ph1">`withFilter`</ph> 函数发送自定义请求标头，以便读取和写入筛选器中即将发送的请求的任意属性。如果服务器端脚本需要自定义的 HTTP 标头或者可以使用这种标头增强自身，则你可能需要添加这样的标头。</source>
          <target state="new">你可以使用 <ph id="ph1">`withFilter`</ph> 函数发送自定义请求标头，以便读取和写入筛选器中即将发送的请求的任意属性。如果服务器端脚本需要自定义的 HTTP 标头或者可以使用这种标头增强自身，则你可能需要添加这样的标头。</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>筛选器的作用远远不只是自定义请求标头，它们还可用于检查或更改请求、检查或更改响应、绕过网络调用、发送多个调用，等等。</source>
          <target state="new">筛选器的作用远远不只是自定义请求标头，它们还可用于检查或更改请求、检查或更改响应、绕过网络调用、发送多个调用，等等。</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="hostnames"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：使用跨域资源共享</source>
          <target state="new"><ph id="ph1">&lt;a name="hostnames"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：使用跨域资源共享</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>若要控制允许与移动服务交互以及向其发送请求的网站，请确保将用于托管移动服务的网站主机名添加到跨域资源共享 (CORS) 允许列表。对于 JavaScript 后端移动服务，可以在 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">](https://manage.windowsazure.cn)</ept>的“配置”选项卡中配置允许列表。你可以根据需要使用通配符。默认情况下，新的移动服务将指示浏览器只能允许来自 <ph id="ph1">`localhost`</ph> 的访问，跨域资源共享 (CORS) 允许外部主机名上的浏览器中运行的 JavaScript 代码与移动服务交互。对于 WinJS 应用程序，不需要使用此配置。</source>
          <target state="new">若要控制允许与移动服务交互以及向其发送请求的网站，请确保将用于托管移动服务的网站主机名添加到跨域资源共享 (CORS) 允许列表。对于 JavaScript 后端移动服务，可以在 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">](https://manage.windowsazure.cn)</ept>的“配置”选项卡中配置允许列表。你可以根据需要使用通配符。默认情况下，新的移动服务将指示浏览器只能允许来自 <ph id="ph1">`localhost`</ph> 的访问，跨域资源共享 (CORS) 允许外部主机名上的浏览器中运行的 JavaScript 代码与移动服务交互。对于 WinJS 应用程序，不需要使用此配置。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>