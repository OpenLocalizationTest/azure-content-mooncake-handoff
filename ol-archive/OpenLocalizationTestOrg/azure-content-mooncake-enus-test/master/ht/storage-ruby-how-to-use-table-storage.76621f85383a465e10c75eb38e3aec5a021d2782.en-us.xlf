<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">44ac01921e1bf69e6bfbedeb47801be6cde59c90</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 Ruby 使用表存储 | Azure</source>
          <target state="new">如何通过 Ruby 使用表存储 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何使用 Azure 中的 Azure 表存储。相关代码示例是使用 Ruby API 编写的。</source>
          <target state="new">了解如何使用 Azure 中的 Azure 表存储。相关代码示例是使用 Ruby API 编写的。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何通过 Ruby 使用 Azure 表存储</source>
          <target state="new">如何通过 Ruby 使用 Azure 表存储</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本指南演示如何使用 Azure 表服务执行常见任务。相关示例是使用 Ruby API 编写的。涉及的方案包括“创建和删除表、在表中插入和查询实体”。</source>
          <target state="new">本指南演示如何使用 Azure 表服务执行常见任务。相关示例是使用 Ruby API 编写的。涉及的方案包括“创建和删除表、在表中插入和查询实体”。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>创建 Ruby 应用程序</source>
          <target state="new">创建 Ruby 应用程序</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>有关如何创建 Ruby 应用程序的说明，请参阅<bpt id="p1">[</bpt>在 Azure 中创建 Ruby 应用程序<ept id="p1">](/documentation/articles/virtual-machines-ruby-rails-web-app-linux)</ept>。</source>
          <target state="new">有关如何创建 Ruby 应用程序的说明，请参阅<bpt id="p1">[</bpt>在 Azure 中创建 Ruby 应用程序<ept id="p1">](/documentation/articles/virtual-machines-ruby-rails-web-app-linux)</ept>。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>配置应用程序以访问存储</source>
          <target state="new">配置应用程序以访问存储</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>要使用 Azure 存储空间，你需要下载和使用 Ruby azure 包，其中包括一组便于与存储 REST 服务进行通信的库。</source>
          <target state="new">要使用 Azure 存储空间，你需要下载和使用 Ruby azure 包，其中包括一组便于与存储 REST 服务进行通信的库。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>使用 RubyGems 获取该程序包</source>
          <target state="new">使用 RubyGems 获取该程序包</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>使用命令行接口，例如 <bpt id="p1">**</bpt>PowerShell<ept id="p1">**</ept> (Windows)、<bpt id="p2">**</bpt>Terminal<ept id="p2">**</ept> (Mac) 或 <bpt id="p3">**</bpt>Bash<ept id="p3">**</ept> (Unix)。</source>
          <target state="new">使用命令行接口，例如 <bpt id="p1">**</bpt>PowerShell<ept id="p1">**</ept> (Windows)、<bpt id="p2">**</bpt>Terminal<ept id="p2">**</ept> (Mac) 或 <bpt id="p3">**</bpt>Bash<ept id="p3">**</ept> (Unix)。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>在命令窗口中键入 <bpt id="p1">**</bpt>gem install azure<ept id="p1">**</ept> 以安装 gem 和依赖项。</source>
          <target state="new">在命令窗口中键入 <bpt id="p1">**</bpt>gem install azure<ept id="p1">**</ept> 以安装 gem 和依赖项。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>导入包</source>
          <target state="new">导入包</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>使用常用的文本编辑器将以下内容添加到你要在其中使用存储的 Ruby 文件的顶部：</source>
          <target state="new">使用常用的文本编辑器将以下内容添加到你要在其中使用存储的 Ruby 文件的顶部：</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>设置 Azure 存储连接</source>
          <target state="new">设置 Azure 存储连接</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Azure 模块将读取环境变量 <bpt id="p1">**</bpt>AZURE_STORAGE_ACCOUNT<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>AZURE_STORAGE_ACCESS_KEY<ept id="p2">**</ept>，以便获取连接到 Azure 存储帐户所需的信息。如果未设置这些环境变量，则在使用 <bpt id="p3">**</bpt>Azure::TableService<ept id="p3">**</ept> 之前必须通过以下代码指定帐户信息：</source>
          <target state="new">Azure 模块将读取环境变量 <bpt id="p1">**</bpt>AZURE_STORAGE_ACCOUNT<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>AZURE_STORAGE_ACCESS_KEY<ept id="p2">**</ept>，以便获取连接到 Azure 存储帐户所需的信息。如果未设置这些环境变量，则在使用 <bpt id="p3">**</bpt>Azure::TableService<ept id="p3">**</ept> 之前必须通过以下代码指定帐户信息：</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>获取这些值：</source>
          <target state="new">获取这些值：</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>登录到 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](https://manage.windowsazure.cn/)</ept>。</source>
          <target state="new">登录到 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](https://manage.windowsazure.cn/)</ept>。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>导航到你的存储帐户。</source>
          <target state="new">导航到你的存储帐户。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>单击导航窗格底部的“管理密钥”。</source>
          <target state="new">单击导航窗格底部的“管理密钥”。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>在弹出对话框中，将会看到存储帐户名称、主访问密钥和辅助访问密钥。对于访问密钥，你可以使用主访问密钥，也可以使用辅助访问密钥。</source>
          <target state="new">在弹出对话框中，将会看到存储帐户名称、主访问密钥和辅助访问密钥。对于访问密钥，你可以使用主访问密钥，也可以使用辅助访问密钥。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>创建表</source>
          <target state="new">创建表</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>Azure::TableService<ept id="p1">**</ept> 对象可以对表和实体进行操作。若要创建表，请使用 <bpt id="p2">**</bpt>create_table()<ept id="p2">**</ept> 方法。以下示例将创建一个表或输出存在的错误。</source>
          <target state="new">使用 <bpt id="p1">**</bpt>Azure::TableService<ept id="p1">**</ept> 对象可以对表和实体进行操作。若要创建表，请使用 <bpt id="p2">**</bpt>create_table()<ept id="p2">**</ept> 方法。以下示例将创建一个表或输出存在的错误。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>将实体添加到表</source>
          <target state="new">将实体添加到表</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>若要添加实体，应首先创建一个定义了你的实体属性的哈希对象。请注意，对于每个实体，您必须指定 <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>。这些值是实体的唯一标识符，并且查询它们比查询其他属性快很多。Azure 存储服务使用 <bpt id="p3">**</bpt>PartitionKey<ept id="p3">**</ept> 自动将表的实体分发到多个存储节点上。具有相同的 <bpt id="p4">**</bpt>PartitionKey<ept id="p4">**</ept> 的实体存储在同一个节点上。<bpt id="p5">**</bpt>RowKey<ept id="p5">**</ept> 是实体在其所属分区内的唯一 ID。</source>
          <target state="new">若要添加实体，应首先创建一个定义了你的实体属性的哈希对象。请注意，对于每个实体，您必须指定 <bpt id="p1">**</bpt>PartitionKey<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>RowKey<ept id="p2">**</ept>。这些值是实体的唯一标识符，并且查询它们比查询其他属性快很多。Azure 存储服务使用 <bpt id="p3">**</bpt>PartitionKey<ept id="p3">**</ept> 自动将表的实体分发到多个存储节点上。具有相同的 <bpt id="p4">**</bpt>PartitionKey<ept id="p4">**</ept> 的实体存储在同一个节点上。<bpt id="p5">**</bpt>RowKey<ept id="p5">**</ept> 是实体在其所属分区内的唯一 ID。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>更新实体</source>
          <target state="new">更新实体</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>可使用多种方法来更新现有实体：</source>
          <target state="new">可使用多种方法来更新现有实体：</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>update_entity()：<ept id="p1">**</ept>通过替换现有实体来更新现有实体。</source>
          <target state="new"><bpt id="p1">**</bpt>update_entity()：<ept id="p1">**</ept>通过替换现有实体来更新现有实体。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>merge_entity()：<ept id="p1">**</ept>通过将新属性值合并到现有实体来更新现有实体。</source>
          <target state="new"><bpt id="p1">**</bpt>merge_entity()：<ept id="p1">**</ept>通过将新属性值合并到现有实体来更新现有实体。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>insert_or_merge_entity()：<ept id="p1">**</ept>通过替换现有实体来更新现有实体。如果不存在实体，将插入一个新实体。</source>
          <target state="new"><bpt id="p1">**</bpt>insert_or_merge_entity()：<ept id="p1">**</ept>通过替换现有实体来更新现有实体。如果不存在实体，将插入一个新实体。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>insert_or_replace_entity()：<ept id="p1">**</ept>通过将新属性值合并到现有实体来更新现有实体。如果不存在实体，将插入一个新实体。</source>
          <target state="new"><bpt id="p1">**</bpt>insert_or_replace_entity()：<ept id="p1">**</ept>通过将新属性值合并到现有实体来更新现有实体。如果不存在实体，将插入一个新实体。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>以下示例演示了使用 <bpt id="p1">**</bpt>update_entity()<ept id="p1">**</ept> 更新实体：</source>
          <target state="new">以下示例演示了使用 <bpt id="p1">**</bpt>update_entity()<ept id="p1">**</ept> 更新实体：</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>对于 <bpt id="p1">**</bpt>update_entity()<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>merge_entity()<ept id="p2">**</ept>，如果待更新的实体不存在，则更新操作将失败。因此，如果您希望存储某个实体而不考虑它是否已存在，则应改用 <bpt id="p3">**</bpt>insert_or_replace_entity()<ept id="p3">**</ept> 或 <bpt id="p4">**</bpt>insert_or_merge_entity()<ept id="p4">**</ept>。</source>
          <target state="new">对于 <bpt id="p1">**</bpt>update_entity()<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>merge_entity()<ept id="p2">**</ept>，如果待更新的实体不存在，则更新操作将失败。因此，如果您希望存储某个实体而不考虑它是否已存在，则应改用 <bpt id="p3">**</bpt>insert_or_replace_entity()<ept id="p3">**</ept> 或 <bpt id="p4">**</bpt>insert_or_merge_entity()<ept id="p4">**</ept>。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>使用实体组</source>
          <target state="new">使用实体组</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>有时，有必要成批地同时提交多项操作以确保通过服务器进行原子处理。若要完成此操作，首先要创建一个 <bpt id="p1">**</bpt>Batch<ept id="p1">**</ept> 对象，然后对 <bpt id="p2">**</bpt>TableService<ept id="p2">**</ept> 使用 <bpt id="p3">**</bpt>execute_batch()<ept id="p3">**</ept> 方法。下面的示例演示在一个批次中提交 RowKey 为 2 和 3 的两个实体。请注意，这仅适用于具有相同 PartitionKey 的实体。</source>
          <target state="new">有时，有必要成批地同时提交多项操作以确保通过服务器进行原子处理。若要完成此操作，首先要创建一个 <bpt id="p1">**</bpt>Batch<ept id="p1">**</ept> 对象，然后对 <bpt id="p2">**</bpt>TableService<ept id="p2">**</ept> 使用 <bpt id="p3">**</bpt>execute_batch()<ept id="p3">**</ept> 方法。下面的示例演示在一个批次中提交 RowKey 为 2 和 3 的两个实体。请注意，这仅适用于具有相同 PartitionKey 的实体。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>查询实体</source>
          <target state="new">查询实体</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>若要查询表中的实体，请使用 <bpt id="p1">**</bpt>get_entity()<ept id="p1">**</ept> 方法并传递表名称 <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept>。</source>
          <target state="new">若要查询表中的实体，请使用 <bpt id="p1">**</bpt>get_entity()<ept id="p1">**</ept> 方法并传递表名称 <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>RowKey<ept id="p3">**</ept>。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>查询实体集</source>
          <target state="new">查询实体集</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>若要查询表中的实体集，请创建一个查询哈希对象并使用 <bpt id="p1">**</bpt>query_entities()<ept id="p1">**</ept> 方法。下面的示例演示了如何获取具有相同 <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> 的所有实体：</source>
          <target state="new">若要查询表中的实体集，请创建一个查询哈希对象并使用 <bpt id="p1">**</bpt>query_entities()<ept id="p1">**</ept> 方法。下面的示例演示了如何获取具有相同 <bpt id="p2">**</bpt>PartitionKey<ept id="p2">**</ept> 的所有实体：</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>如果结果集太大，一个查询无法全部返回，将会返回一个继续标记，你可以使用该标记检索后续页面。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>如果结果集太大，一个查询无法全部返回，将会返回一个继续标记，你可以使用该标记检索后续页面。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>查询一部分实体属性</source>
          <target state="new">查询一部分实体属性</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>对表的查询可以只检索实体中的少数几个属性。此方法称为“投影”，可减少带宽并提高查询性能，尤其适用于大型实体。请使用 select 子句并传递你希望显示给客户端的属性的名称。</source>
          <target state="new">对表的查询可以只检索实体中的少数几个属性。此方法称为“投影”，可减少带宽并提高查询性能，尤其适用于大型实体。请使用 select 子句并传递你希望显示给客户端的属性的名称。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="how-to-delete-an-entity"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：删除实体</source>
          <target state="new"><ph id="ph1">&lt;a id="how-to-delete-an-entity"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：删除实体</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>若要删除实体，请使用 <bpt id="p1">**</bpt>delete_entity()<ept id="p1">**</ept> 方法。你需要传入包含该实体的表的名称、实体的 PartitionKey 和 RowKey。</source>
          <target state="new">若要删除实体，请使用 <bpt id="p1">**</bpt>delete_entity()<ept id="p1">**</ept> 方法。你需要传入包含该实体的表的名称、实体的 PartitionKey 和 RowKey。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="how-to-delete-a-table"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：删除表</source>
          <target state="new"><ph id="ph1">&lt;a id="how-to-delete-a-table"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>如何：删除表</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>若要删除表，请使用 <bpt id="p1">**</bpt>delete_table()<ept id="p1">**</ept> 方法并传入要删除的表的名称。</source>
          <target state="new">若要删除表，请使用 <bpt id="p1">**</bpt>delete_table()<ept id="p1">**</ept> 方法并传入要删除的表的名称。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="next-steps"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>后续步骤</source>
          <target state="new"><ph id="ph1">&lt;a id="next-steps"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>后续步骤</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>若要了解有关更复杂存储任务的信息，请访问下面的链接：</source>
          <target state="new">若要了解有关更复杂存储任务的信息，请访问下面的链接：</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Azure 存储团队博客</source>
          <target state="new">Azure 存储团队博客</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>GitHub 上的 <bpt id="p1">[</bpt>Azure SDK for Ruby<ept id="p1">](http://github.com/WindowsAzure/azure-sdk-for-ruby)</ept> 存储库</source>
          <target state="new">GitHub 上的 <bpt id="p1">[</bpt>Azure SDK for Ruby<ept id="p1">](http://github.com/WindowsAzure/azure-sdk-for-ruby)</ept> 存储库</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>