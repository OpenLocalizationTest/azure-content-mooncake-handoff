<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fb1fa2780055d18d511ec306a0afcb7ef2434900</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>数据相关的路由 | Azure</source>
          <target state="new">数据相关的路由 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>如何将 ShardMapManager 用于数据相关的路由（Azure SQL 数据库弹性数据库的一项功能）</source>
          <target state="new">如何将 ShardMapManager 用于数据相关的路由（Azure SQL 数据库弹性数据库的一项功能）</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>依赖于数据的路由</source>
          <target state="new">依赖于数据的路由</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>ShardMapManager<ept id="p1">**</ept> 类使 ADO.NET 应用程序能够轻松地将数据库查询和命令指向分片环境中的相应物理数据库。这称为<bpt id="p2">**</bpt>数据相关的路由<ept id="p2">**</ept>，在使用分片数据库时，它是一种基础模式。将应用程序中使用数据依赖路由的每个特定查询和事务限制为针对每个请求访问单个数据库。</source>
          <target state="new"><bpt id="p1">**</bpt>ShardMapManager<ept id="p1">**</ept> 类使 ADO.NET 应用程序能够轻松地将数据库查询和命令指向分片环境中的相应物理数据库。这称为<bpt id="p2">**</bpt>数据相关的路由<ept id="p2">**</ept>，在使用分片数据库时，它是一种基础模式。将应用程序中使用数据依赖路由的每个特定查询和事务限制为针对每个请求访问单个数据库。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>通过使用数据依赖路由，应用程序无需在分片环境中跟踪与不同的数据片相关联的各种连接字符串或数据库位置。但是，<bpt id="p1">[</bpt>分片映射管理器<ept id="p1">](/documentation/articles/sql-database-elastic-scale-shard-map-management)</ept>有责任在需要时基于分片映射中的数据以及作为应用程序请求目标的分片键值，将开放连接分发给正确的数据库。（该键通常为 <bpt id="p2">*</bpt>customer\_id<ept id="p2">*</ept>、<bpt id="p3">*</bpt>tenant\_id<ept id="p3">*</ept>、<bpt id="p4">*</bpt>date\_key<ept id="p4">*</ept> 或一些作为数据库请求的基础参数的其他特定标识符）。</source>
          <target state="new">通过使用数据依赖路由，应用程序无需在分片环境中跟踪与不同的数据片相关联的各种连接字符串或数据库位置。但是，<bpt id="p1">[</bpt>分片映射管理器<ept id="p1">](/documentation/articles/sql-database-elastic-scale-shard-map-management)</ept>有责任在需要时基于分片映射中的数据以及作为应用程序请求目标的分片键值，将开放连接分发给正确的数据库。（该键通常为 <bpt id="p2">*</bpt>customer\_id<ept id="p2">*</ept>、<bpt id="p3">*</bpt>tenant\_id<ept id="p3">*</ept>、<bpt id="p4">*</bpt>date\_key<ept id="p4">*</ept> 或一些作为数据库请求的基础参数的其他特定标识符）。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>下载客户端库</source>
          <target state="new">下载客户端库</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>若要安装该库，请转到<bpt id="p1">[</bpt>弹性数据库客户端库<ept id="p1">](http://www.nuget.org/packages/Microsoft.Azure.SqlDatabase.ElasticScale.Client/)</ept>。</source>
          <target state="new">若要安装该库，请转到<bpt id="p1">[</bpt>弹性数据库客户端库<ept id="p1">](http://www.nuget.org/packages/Microsoft.Azure.SqlDatabase.ElasticScale.Client/)</ept>。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>在数据相关的路由应用程序中使用 ShardMapManager</source>
          <target state="new">在数据相关的路由应用程序中使用 ShardMapManager</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>对于使用数据相关的路由的应用程序，应在初始化期间使用工厂调用 <bpt id="p1">**</bpt>GetSQLShardMapManager<ept id="p1">**</ept> 针对每个应用域实例化 <bpt id="p2">**</bpt>ShardMapManager<ept id="p2">**</ept> 一次。</source>
          <target state="new">对于使用数据相关的路由的应用程序，应在初始化期间使用工厂调用 <bpt id="p1">**</bpt>GetSQLShardMapManager<ept id="p1">**</ept> 针对每个应用域实例化 <bpt id="p2">**</bpt>ShardMapManager<ept id="p2">**</ept> 一次。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>在本示例中，将同时初始化 <bpt id="p1">**</bpt>ShardMapManager<ept id="p1">**</ept> 以及它所包含的特定 <bpt id="p2">**</bpt>ShardMap<ept id="p2">**</ept>。</source>
          <target state="new">在本示例中，将同时初始化 <bpt id="p1">**</bpt>ShardMapManager<ept id="p1">**</ept> 以及它所包含的特定 <bpt id="p2">**</bpt>ShardMap<ept id="p2">**</ept>。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>对于本身不操作分片映射的应用程序，在工厂方法中用于获取 <bpt id="p1">**</bpt>ShardMapManager<ept id="p1">**</ept>（在上面的示例中为 <bpt id="p2">*</bpt>smmConnectionString<ept id="p2">*</ept>）的凭据在由连接字符串引用的<bpt id="p3">**</bpt>全局分片映射<ept id="p3">**</ept>数据库上，应仅具有只读权限。这些凭据通常与用于到分片映射管理器的开放连接的凭据不同。另请参阅<bpt id="p4">[</bpt>使用弹性数据库客户端库中的凭据<ept id="p4">](/documentation/articles/sql-database-elastic-scale-manage-credentials)</ept>。</source>
          <target state="new">对于本身不操作分片映射的应用程序，在工厂方法中用于获取 <bpt id="p1">**</bpt>ShardMapManager<ept id="p1">**</ept>（在上面的示例中为 <bpt id="p2">*</bpt>smmConnectionString<ept id="p2">*</ept>）的凭据在由连接字符串引用的<bpt id="p3">**</bpt>全局分片映射<ept id="p3">**</ept>数据库上，应仅具有只读权限。这些凭据通常与用于到分片映射管理器的开放连接的凭据不同。另请参阅<bpt id="p4">[</bpt>使用弹性数据库客户端库中的凭据<ept id="p4">](/documentation/articles/sql-database-elastic-scale-manage-credentials)</ept>。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>调用数据相关的路由</source>
          <target state="new">调用数据相关的路由</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>方法 <bpt id="p1">**</bpt>ShardMap.OpenConnectionForKey(key, connectionString, connectionOptions)<ept id="p1">**</ept> 将返回 ADO.Net 连接，该连接可随时基于 <bpt id="p2">**</bpt>key<ept id="p2">**</ept> 参数的值将命令分发到相应的数据库中。<bpt id="p3">**</bpt>ShardMapManager<ept id="p3">**</ept> 将分片信息缓存在应用程序中，因此这些请求通常不会针对<bpt id="p4">**</bpt>全局分片映射<ept id="p4">**</ept>数据库调用数据库查找。</source>
          <target state="new">方法 <bpt id="p1">**</bpt>ShardMap.OpenConnectionForKey(key, connectionString, connectionOptions)<ept id="p1">**</ept> 将返回 ADO.Net 连接，该连接可随时基于 <bpt id="p2">**</bpt>key<ept id="p2">**</ept> 参数的值将命令分发到相应的数据库中。<bpt id="p3">**</bpt>ShardMapManager<ept id="p3">**</ept> 将分片信息缓存在应用程序中，因此这些请求通常不会针对<bpt id="p4">**</bpt>全局分片映射<ept id="p4">**</ept>数据库调用数据库查找。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>key<ept id="p1">**</ept> 参数在分片映射中用作查找键，以确定该请求的相应数据库。</source>
          <target state="new"><bpt id="p1">**</bpt>key<ept id="p1">**</ept> 参数在分片映射中用作查找键，以确定该请求的相应数据库。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>connectionString<ept id="p1">**</ept> 用于仅传递所需连接的用户凭据。此 <bpt id="p2">*</bpt>connectionString<ept id="p2">*</ept> 中不包含数据库名称或服务器名称，因为该方法将使用 <bpt id="p3">**</bpt>ShardMap<ept id="p3">**</ept> 确定数据库和服务器。</source>
          <target state="new"><bpt id="p1">**</bpt>connectionString<ept id="p1">**</ept> 用于仅传递所需连接的用户凭据。此 <bpt id="p2">*</bpt>connectionString<ept id="p2">*</ept> 中不包含数据库名称或服务器名称，因为该方法将使用 <bpt id="p3">**</bpt>ShardMap<ept id="p3">**</ept> 确定数据库和服务器。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>connectionOptions<ept id="p1">**</ept> 枚举用于指示在传送开放连接时是否发生验证。建议使用 <bpt id="p2">**</bpt>ConnectionOptions.Validate<ept id="p2">**</ept>。在以下环境中，验证可确保基于键值的数据库的缓存查找仍然正确：分片映射可能发生更改，以及可能将行作为拆分或合并操作的结果移动到其他数据库。在将连接传送到应用程序之前，验证将涉及在目标数据库上简要查询局部分片映射（而不是全局分片映射）。</source>
          <target state="new"><bpt id="p1">**</bpt>connectionOptions<ept id="p1">**</ept> 枚举用于指示在传送开放连接时是否发生验证。建议使用 <bpt id="p2">**</bpt>ConnectionOptions.Validate<ept id="p2">**</ept>。在以下环境中，验证可确保基于键值的数据库的缓存查找仍然正确：分片映射可能发生更改，以及可能将行作为拆分或合并操作的结果移动到其他数据库。在将连接传送到应用程序之前，验证将涉及在目标数据库上简要查询局部分片映射（而不是全局分片映射）。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>如果针对局部分片映射进行的验证失败（指示缓存不正确），分片映射管理器将查询全局分片映射来获取新的正确值以供查找、更新缓存，以及获取和返回相应的数据库连接。</source>
          <target state="new">如果针对局部分片映射进行的验证失败（指示缓存不正确），分片映射管理器将查询全局分片映射来获取新的正确值以供查找、更新缓存，以及获取和返回相应的数据库连接。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>仅在应用程序处于联机状态时没有按预期进行分片映射更改的情况下，接受 <bpt id="p1">**</bpt>ConnectionOptions.None<ept id="p1">**</ept>（不验证）。在该情况下，可以假设缓存的值始终正确，并且可以安全地跳过对目标数据库的额外双向验证调用。这可能会减少事务延迟和数据库流量。还可以通过配置文件中的某个值设置 <bpt id="p2">**</bpt>connectionOptions<ept id="p2">**</ept>，以指示在此期间是否按预期进行了分片更改。</source>
          <target state="new">仅在应用程序处于联机状态时没有按预期进行分片映射更改的情况下，接受 <bpt id="p1">**</bpt>ConnectionOptions.None<ept id="p1">**</ept>（不验证）。在该情况下，可以假设缓存的值始终正确，并且可以安全地跳过对目标数据库的额外双向验证调用。这可能会减少事务延迟和数据库流量。还可以通过配置文件中的某个值设置 <bpt id="p2">**</bpt>connectionOptions<ept id="p2">**</ept>，以指示在此期间是否按预期进行了分片更改。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>这是一个通过名为 <bpt id="p1">**</bpt>customerShardMap<ept id="p1">**</ept> 的 <bpt id="p2">**</bpt>ShardMap<ept id="p2">**</ept> 对象，基于整数键的值 <bpt id="p3">**</bpt>CustomerID<ept id="p3">**</ept> 使用分片映射管理器执行数据相关的路由的代码示例。</source>
          <target state="new">这是一个通过名为 <bpt id="p1">**</bpt>customerShardMap<ept id="p1">**</ept> 的 <bpt id="p2">**</bpt>ShardMap<ept id="p2">**</ept> 对象，基于整数键的值 <bpt id="p3">**</bpt>CustomerID<ept id="p3">**</ept> 使用分片映射管理器执行数据相关的路由的代码示例。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>示例：数据相关的路由</source>
          <target state="new">示例：数据相关的路由</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>请注意，将使用 <bpt id="p1">**</bpt>OpenConnectionForKey<ept id="p1">**</ept> 方法，它提供了一个新的到正确数据库的已开放连接，而不是使用 <bpt id="p2">**</bpt>SqlConnection<ept id="p2">**</ept> 构造函数，后跟对连接对象的 <bpt id="p3">**</bpt>Open()<ept id="p3">**</ept> 调用。此方法中所采用的连接仍然可以充分利用 ADO.Net 连接池。如果一个分片一次可满足事务和请求，则只需在已使用 ADO.Net 的应用程序中进行此唯一修改。</source>
          <target state="new">请注意，将使用 <bpt id="p1">**</bpt>OpenConnectionForKey<ept id="p1">**</ept> 方法，它提供了一个新的到正确数据库的已开放连接，而不是使用 <bpt id="p2">**</bpt>SqlConnection<ept id="p2">**</ept> 构造函数，后跟对连接对象的 <bpt id="p3">**</bpt>Open()<ept id="p3">**</ept> 调用。此方法中所采用的连接仍然可以充分利用 ADO.Net 连接池。如果一个分片一次可满足事务和请求，则只需在已使用 ADO.Net 的应用程序中进行此唯一修改。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>如果应用程序配合 ADO.Net 使用异步编程，则也可以使用方法 <bpt id="p1">**</bpt>OpenConnectionForKeyAsync<ept id="p1">**</ept>。应用程序的行为等效于 ADO.Net 方法 <bpt id="p2">**</bpt>Connection.OpenAsync<ept id="p2">**</ept> 的数据相关路由。</source>
          <target state="new">如果应用程序配合 ADO.Net 使用异步编程，则也可以使用方法 <bpt id="p1">**</bpt>OpenConnectionForKeyAsync<ept id="p1">**</ept>。应用程序的行为等效于 ADO.Net 方法 <bpt id="p2">**</bpt>Connection.OpenAsync<ept id="p2">**</ept> 的数据相关路由。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>与暂时性故障处理集成</source>
          <target state="new">与暂时性故障处理集成</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>在云中开发数据访问应用程序的最佳做法是，确保连接到数据库或查询数据库时的暂时性故障是由应用引起的，并且确保在引发错误之前重试几次这些操作。<bpt id="p1">[</bpt>暂时性故障处理<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/dn440719(v=pandp.60).aspx)</ept>中讨论了云应用程序的暂时性故障处理。</source>
          <target state="new">在云中开发数据访问应用程序的最佳做法是，确保连接到数据库或查询数据库时的暂时性故障是由应用引起的，并且确保在引发错误之前重试几次这些操作。<bpt id="p1">[</bpt>暂时性故障处理<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/dn440719(v=pandp.60).aspx)</ept>中讨论了云应用程序的暂时性故障处理。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>暂时性故障处理在本质上可以与数据依赖路由模式共存。关键需求是重试整个数据访问请求，包括已获取数据相关的路由连接的 <bpt id="p1">**</bpt>using<ept id="p1">**</ept> 块。可按照如下方式重写上面的示例（请注意突出显示的更改）。</source>
          <target state="new">暂时性故障处理在本质上可以与数据依赖路由模式共存。关键需求是重试整个数据访问请求，包括已获取数据相关的路由连接的 <bpt id="p1">**</bpt>using<ept id="p1">**</ept> 块。可按照如下方式重写上面的示例（请注意突出显示的更改）。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>示例 - 数据相关的路由与暂时性故障处理</source>
          <target state="new">示例 - 数据相关的路由与暂时性故障处理</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;span style="background-color:  #FFFF00"&gt;</ph>Configuration.SqlRetryPolicy.ExecuteAction(() =&gt; <ph id="ph2">&lt;/span&gt;</ph></source>
          <target state="new"><ph id="ph1">&lt;span style="background-color:  #FFFF00"&gt;</ph>Configuration.SqlRetryPolicy.ExecuteAction(() =&gt; <ph id="ph2">&lt;/span&gt;</ph></target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;span style="background-color:  #FFFF00"&gt;</ph>    { <ph id="ph2">&lt;/span&gt;</ph></source>
          <target state="new"><ph id="ph1">&lt;span style="background-color:  #FFFF00"&gt;</ph>    { <ph id="ph2">&lt;/span&gt;</ph></target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>// Connection to the shard for that customer ID</source>
          <target state="new">// Connection to the shard for that customer ID</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>using (SqlConnection conn = customerShardMap.OpenConnectionForKey(customerId,</source>
          <target state="new">using (SqlConnection conn = customerShardMap.OpenConnectionForKey(customerId,</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Configuration.GetCredentialsConnectionString(), ConnectionOptions.Validate))</source>
          <target state="new">Configuration.GetCredentialsConnectionString(), ConnectionOptions.Validate))</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>{</source>
          <target state="new">{</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>// Execute a simple command</source>
          <target state="new">// Execute a simple command</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>SqlCommand cmd = conn.CreateCommand();</source>
          <target state="new">SqlCommand cmd = conn.CreateCommand();</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;span style="background-color:  #FFFF00"&gt;</ph>    }); <ph id="ph2">&lt;/span&gt;</ph></source>
          <target state="new"><ph id="ph1">&lt;span style="background-color:  #FFFF00"&gt;</ph>    }); <ph id="ph2">&lt;/span&gt;</ph></target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>当你生成弹性数据库示例应用程序时，将自动下载需要实现暂时性故障处理的程序包。<bpt id="p1">[</bpt>Enterprise Library - 暂时性故障处理应用程序块<ept id="p1">](http://www.nuget.org/packages/EnterpriseLibrary.TransientFaultHandling/)</ept>也将单独提供程序包。使用版本 6.0 或更高版本。</source>
          <target state="new">当你生成弹性数据库示例应用程序时，将自动下载需要实现暂时性故障处理的程序包。<bpt id="p1">[</bpt>Enterprise Library - 暂时性故障处理应用程序块<ept id="p1">](http://www.nuget.org/packages/EnterpriseLibrary.TransientFaultHandling/)</ept>也将单独提供程序包。使用版本 6.0 或更高版本。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>事务一致性</source>
          <target state="new">事务一致性</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>确保分片的所有局部操作的事务属性。例如，通过数据依赖路由提交的事务将在目标分片范围内执行以供连接。此时，没有提供用于将多个连接包含在一个事务中的功能，因此对于在分片上执行的操作，没有事务保证。</source>
          <target state="new">确保分片的所有局部操作的事务属性。例如，通过数据依赖路由提交的事务将在目标分片范围内执行以供连接。此时，没有提供用于将多个连接包含在一个事务中的功能，因此对于在分片上执行的操作，没有事务保证。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>