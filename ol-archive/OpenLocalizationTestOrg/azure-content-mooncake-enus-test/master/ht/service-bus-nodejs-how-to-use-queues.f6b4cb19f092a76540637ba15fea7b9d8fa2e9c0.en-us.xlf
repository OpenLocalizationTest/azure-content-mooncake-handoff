<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">31d1fbc36cf5ef52366306444f739c980c9ae88e</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 Node.js 使用服务总线队列 | Microsoft Azure</source>
          <target state="new">如何通过 Node.js 使用服务总线队列 | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何在来自 Node.js 应用程序的 Azure 中使用服务总线队列。</source>
          <target state="new">了解如何在来自 Node.js 应用程序的 Azure 中使用服务总线队列。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何使用 Service Bus 队列</source>
          <target state="new">如何使用 Service Bus 队列</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>本文介绍了如何使用服务总线队列。示例用 JavaScript 编写并使用 Node.js Azure 模块。涉及的任务包括<bpt id="p1">**</bpt>创建队列<ept id="p1">**</ept>、<bpt id="p2">**</bpt>发送和接收消息<ept id="p2">**</ept>以及<bpt id="p3">**</bpt>删除队列<ept id="p3">**</ept>。有关队列的详细信息，请参阅 [后续步骤][] 部分。</source>
          <target state="new">本文介绍了如何使用服务总线队列。示例用 JavaScript 编写并使用 Node.js Azure 模块。涉及的任务包括<bpt id="p1">**</bpt>创建队列<ept id="p1">**</ept>、<bpt id="p2">**</bpt>发送和接收消息<ept id="p2">**</ept>以及<bpt id="p3">**</bpt>删除队列<ept id="p3">**</ept>。有关队列的详细信息，请参阅 [后续步骤][] 部分。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>创建 Node.js 应用程序</source>
          <target state="new">创建 Node.js 应用程序</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>创建一个空的 Node.js 应用程序。有关如何创建 Node.js 应用程序的说明，请参阅<bpt id="p1">[</bpt>创建 Node.js 应用程序并将其部署到 Azure 网站<ept id="p1">][]</ept>或 <bpt id="p2">[</bpt>Node.js 云服务<ept id="p2">][]</ept>（使用 Windows PowerShell）。</source>
          <target state="new">创建一个空的 Node.js 应用程序。有关如何创建 Node.js 应用程序的说明，请参阅<bpt id="p1">[</bpt>创建 Node.js 应用程序并将其部署到 Azure 网站<ept id="p1">][]</ept>或 <bpt id="p2">[</bpt>Node.js 云服务<ept id="p2">][]</ept>（使用 Windows PowerShell）。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>配置应用程序以使用 Service Bus</source>
          <target state="new">配置应用程序以使用 Service Bus</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>若要使用 Azure 服务总线，请下载并使用 Node.js Azure 包。此包包括一组用来与服务总线 REST 服务通信的库。</source>
          <target state="new">若要使用 Azure 服务总线，请下载并使用 Node.js Azure 包。此包包括一组用来与服务总线 REST 服务通信的库。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>使用 Node 包管理器 (NPM) 可获取该程序包</source>
          <target state="new">使用 Node 包管理器 (NPM) 可获取该程序包</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>Windows PowerShell for Node.js<ept id="p1">**</ept> 命令窗口导航到你在其中创建了示例应用程序的 <bpt id="p2">**</bpt>c:\\node\\sbqueues\\WebRole1<ept id="p2">**</ept> 文件夹。</source>
          <target state="new">使用 <bpt id="p1">**</bpt>Windows PowerShell for Node.js<ept id="p1">**</ept> 命令窗口导航到你在其中创建了示例应用程序的 <bpt id="p2">**</bpt>c:\\node\\sbqueues\\WebRole1<ept id="p2">**</ept> 文件夹。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>在命令窗口中键入 <bpt id="p1">**</bpt>npm install azure<ept id="p1">**</ept>，这应该产生类似如下的输出：</source>
          <target state="new">在命令窗口中键入 <bpt id="p1">**</bpt>npm install azure<ept id="p1">**</ept>，这应该产生类似如下的输出：</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>可以手动运行 <bpt id="p1">**</bpt>ls<ept id="p1">**</ept> 命令来验证是否创建了 <bpt id="p2">**</bpt>node\_modules<ept id="p2">**</ept> 文件夹。在该文件夹中，找到 <bpt id="p3">**</bpt>azure<ept id="p3">**</ept> 包，其中包含访问服务总线队列所需的库。</source>
          <target state="new">可以手动运行 <bpt id="p1">**</bpt>ls<ept id="p1">**</ept> 命令来验证是否创建了 <bpt id="p2">**</bpt>node\_modules<ept id="p2">**</ept> 文件夹。在该文件夹中，找到 <bpt id="p3">**</bpt>azure<ept id="p3">**</ept> 包，其中包含访问服务总线队列所需的库。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>导入模块</source>
          <target state="new">导入模块</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>使用记事本或其他文本编辑器将以下内容添加到应用程序的 <bpt id="p1">**</bpt>server.js<ept id="p1">**</ept> 文件的顶部：</source>
          <target state="new">使用记事本或其他文本编辑器将以下内容添加到应用程序的 <bpt id="p1">**</bpt>server.js<ept id="p1">**</ept> 文件的顶部：</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>设置 Azure 服务总线连接</source>
          <target state="new">设置 Azure 服务总线连接</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Azure 模块将读取环境变量 AZURE_SERVICEBUS_NAMESPACE 和 AZURE_SERVICEBUS_ACCESS_KEY 以获取连接到服务总线所需的信息。如果未设置这些环境变量，则在调用 <bpt id="p1">**</bpt>createServiceBusService<ept id="p1">**</ept> 时必须指定帐户信息。</source>
          <target state="new">Azure 模块将读取环境变量 AZURE_SERVICEBUS_NAMESPACE 和 AZURE_SERVICEBUS_ACCESS_KEY 以获取连接到服务总线所需的信息。如果未设置这些环境变量，则在调用 <bpt id="p1">**</bpt>createServiceBusService<ept id="p1">**</ept> 时必须指定帐户信息。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>有关在 Azure 云服务的配置文件中设置环境变量的示例，请参阅<bpt id="p1">[</bpt>使用存储构建 Node.js 云服务<ept id="p1">][]</ept>。</source>
          <target state="new">有关在 Azure 云服务的配置文件中设置环境变量的示例，请参阅<bpt id="p1">[</bpt>使用存储构建 Node.js 云服务<ept id="p1">][]</ept>。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>有关在 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">][]</ept>中为 Azure 网站设置环境变量的示例，请参阅<bpt id="p2">[</bpt>使用存储构建 Node.js Web 应用程序<ept id="p2">][]</ept>。</source>
          <target state="new">有关在 <bpt id="p1">[</bpt>Azure 经典门户<ept id="p1">][]</ept>中为 Azure 网站设置环境变量的示例，请参阅<bpt id="p2">[</bpt>使用存储构建 Node.js Web 应用程序<ept id="p2">][]</ept>。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>创建队列</source>
          <target state="new">创建队列</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>可以通过 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 对象处理服务总线队列。以下代码创建 <bpt id="p2">**</bpt>ServiceBusService<ept id="p2">**</ept> 对象。将它添加到靠近 <bpt id="p3">**</bpt>server.js<ept id="p3">**</ept> 文件顶部，用于导入 Azure 模块的语句之后的位置：</source>
          <target state="new">可以通过 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 对象处理服务总线队列。以下代码创建 <bpt id="p2">**</bpt>ServiceBusService<ept id="p2">**</ept> 对象。将它添加到靠近 <bpt id="p3">**</bpt>server.js<ept id="p3">**</ept> 文件顶部，用于导入 Azure 模块的语句之后的位置：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>通过对 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 对象调用 <bpt id="p2">**</bpt>createQueueIfNotExists<ept id="p2">**</ept>，将返回指定的队列（如果存在），否则将使用指定的名称创建一个新队列。以下代码使用 <bpt id="p3">**</bpt>createQueueIfNotExists<ept id="p3">**</ept> 创建或连接到名为 <ph id="ph1">`myqueue`</ph> 的队列：</source>
          <target state="new">通过对 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 对象调用 <bpt id="p2">**</bpt>createQueueIfNotExists<ept id="p2">**</ept>，将返回指定的队列（如果存在），否则将使用指定的名称创建一个新队列。以下代码使用 <bpt id="p3">**</bpt>createQueueIfNotExists<ept id="p3">**</ept> 创建或连接到名为 <ph id="ph1">`myqueue`</ph> 的队列：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>createServiceBusService<ept id="p1">**</ept> 也支持其他选项，这些选项允许你重写默认队列设置，如消息生存时间或最大队列大小。以下示例将最大队列大小设置为 5 GB，将生存时间 (TTL) 值设置为 1 分钟：</source>
          <target state="new"><bpt id="p1">**</bpt>createServiceBusService<ept id="p1">**</ept> 也支持其他选项，这些选项允许你重写默认队列设置，如消息生存时间或最大队列大小。以下示例将最大队列大小设置为 5 GB，将生存时间 (TTL) 值设置为 1 分钟：</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>筛选器</source>
          <target state="new">筛选器</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>可选的筛选操作可应用于使用 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 执行的操作。筛选操作可包括日志记录、自动重试等。筛选器是实现具有签名的方法的对象：</source>
          <target state="new">可选的筛选操作可应用于使用 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 执行的操作。筛选操作可包括日志记录、自动重试等。筛选器是实现具有签名的方法的对象：</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>在对请求选项执行预处理后，该方法必须调用 <ph id="ph1">`next`</ph> 并传递具有以下签名的回调：</source>
          <target state="new">在对请求选项执行预处理后，该方法必须调用 <ph id="ph1">`next`</ph> 并传递具有以下签名的回调：</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>在此回调中并且在处理 <bpt id="p1">**</bpt>returnObject<ept id="p1">**</ept>（来自对服务器请求的响应）后，回调必须调用 <ph id="ph1">`next`</ph>（如果它存在）以便继续处理其他筛选器或只调用 <ph id="ph2">`finalCallback`</ph>，以便结束服务调用。</source>
          <target state="new">在此回调中并且在处理 <bpt id="p1">**</bpt>returnObject<ept id="p1">**</ept>（来自对服务器请求的响应）后，回调必须调用 <ph id="ph1">`next`</ph>（如果它存在）以便继续处理其他筛选器或只调用 <ph id="ph2">`finalCallback`</ph>，以便结束服务调用。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Azure SDK for Node.js 中附带了两个实现了重试逻辑的筛选器，分别是 <bpt id="p1">**</bpt>ExponentialRetryPolicyFilter<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>LinearRetryPolicyFilter<ept id="p2">**</ept>。以下代码创建一个 <bpt id="p3">**</bpt>ServiceBusService<ept id="p3">**</ept> 对象，该对象使用 <bpt id="p4">**</bpt>ExponentialRetryPolicyFilter<ept id="p4">**</ept>：</source>
          <target state="new">Azure SDK for Node.js 中附带了两个实现了重试逻辑的筛选器，分别是 <bpt id="p1">**</bpt>ExponentialRetryPolicyFilter<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>LinearRetryPolicyFilter<ept id="p2">**</ept>。以下代码创建一个 <bpt id="p3">**</bpt>ServiceBusService<ept id="p3">**</ept> 对象，该对象使用 <bpt id="p4">**</bpt>ExponentialRetryPolicyFilter<ept id="p4">**</ept>：</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>向队列发送消息</source>
          <target state="new">向队列发送消息</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>若要向服务总线队列发送消息，你的应用程序需对 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 对象调用 <bpt id="p2">**</bpt>sendQueueMessage<ept id="p2">**</ept> 方法。发往服务总线队列的消息以及从服务总线队列接收的消息是 <bpt id="p3">**</bpt>BrokeredMessage<ept id="p3">**</ept> 对象，它们具有一组标准属性（如 <bpt id="p4">**</bpt>Label<ept id="p4">**</ept> 和 <bpt id="p5">**</bpt>TimeToLive<ept id="p5">**</ept>）、一个用来保存自定义应用程序特定属性的字典和一段任意应用程序数据正文。应用程序可以通过将字符串作为消息传递来设置消息正文。任何必需的标准属性将用默认值来填充。</source>
          <target state="new">若要向服务总线队列发送消息，你的应用程序需对 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 对象调用 <bpt id="p2">**</bpt>sendQueueMessage<ept id="p2">**</ept> 方法。发往服务总线队列的消息以及从服务总线队列接收的消息是 <bpt id="p3">**</bpt>BrokeredMessage<ept id="p3">**</ept> 对象，它们具有一组标准属性（如 <bpt id="p4">**</bpt>Label<ept id="p4">**</ept> 和 <bpt id="p5">**</bpt>TimeToLive<ept id="p5">**</ept>）、一个用来保存自定义应用程序特定属性的字典和一段任意应用程序数据正文。应用程序可以通过将字符串作为消息传递来设置消息正文。任何必需的标准属性将用默认值来填充。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>以下示例演示如何使用 <bpt id="p1">**</bpt>sendQueueMessage<ept id="p1">**</ept> 向名为 <ph id="ph1">`myqueue`</ph> 的队列发送一条测试消息：</source>
          <target state="new">以下示例演示如何使用 <bpt id="p1">**</bpt>sendQueueMessage<ept id="p1">**</ept> 向名为 <ph id="ph1">`myqueue`</ph> 的队列发送一条测试消息：</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Service Bus 队列支持最大为 256 KB 的消息（标头最大为 64 KB，其中包括标准和自定义应用程序属性）。一个队列可包含的消息数不受限制，但消息的总大小受限。此队列大小是在创建时定义的，上限为 5 GB。有关配额的详细信息，请参阅 <bpt id="p1">[</bpt>Azure 队列和服务总线队列<ept id="p1">][]</ept>。</source>
          <target state="new">Service Bus 队列支持最大为 256 KB 的消息（标头最大为 64 KB，其中包括标准和自定义应用程序属性）。一个队列可包含的消息数不受限制，但消息的总大小受限。此队列大小是在创建时定义的，上限为 5 GB。有关配额的详细信息，请参阅 <bpt id="p1">[</bpt>Azure 队列和服务总线队列<ept id="p1">][]</ept>。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>从队列接收消息</source>
          <target state="new">从队列接收消息</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>对 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 对象使用 <bpt id="p2">**</bpt>receiveQueueMessage<ept id="p2">**</ept> 方法可从队列接收消息。默认情况下，消息被读取后即从队列删除；但是你可以读取（速览）并锁定消息而不将其从队列删除，只要将可选参数 <bpt id="p3">**</bpt>isPeekLock<ept id="p3">**</ept> 设置为 <bpt id="p4">**</bpt>true<ept id="p4">**</ept> 即可。</source>
          <target state="new">对 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 对象使用 <bpt id="p2">**</bpt>receiveQueueMessage<ept id="p2">**</ept> 方法可从队列接收消息。默认情况下，消息被读取后即从队列删除；但是你可以读取（速览）并锁定消息而不将其从队列删除，只要将可选参数 <bpt id="p3">**</bpt>isPeekLock<ept id="p3">**</ept> 设置为 <bpt id="p4">**</bpt>true<ept id="p4">**</ept> 即可。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>在接收过程中读取并删除消息的默认行为是最简单的模式，并且最适合在发生故障时应用程序可以容忍不处理消息的情况。为了理解这一点，可以考虑这样一种情形：使用方发出接收请求，但在处理该请求前发生了崩溃。由于 Service Bus 会将消息标记为“将使用”，因此当应用程序重启并重新开始使用消息时，它会丢失在发生崩溃前使用的消息。</source>
          <target state="new">在接收过程中读取并删除消息的默认行为是最简单的模式，并且最适合在发生故障时应用程序可以容忍不处理消息的情况。为了理解这一点，可以考虑这样一种情形：使用方发出接收请求，但在处理该请求前发生了崩溃。由于 Service Bus 会将消息标记为“将使用”，因此当应用程序重启并重新开始使用消息时，它会丢失在发生崩溃前使用的消息。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>如果将 <bpt id="p1">**</bpt>isPeekLock<ept id="p1">**</ept> 参数设置为 <bpt id="p2">**</bpt>true<ept id="p2">**</ept>，则接收将变成一个两阶段操作，这样就可以支持无法允许遗漏消息的应用程序。当 Service Bus 收到请求时，它会查找下一条要使用的消息，锁定该消息以防其他使用者接收，然后将该消息返回到应用程序。应用程序处理完该消息（或将它可靠地存储起来留待将来处理）后，通过调用 <bpt id="p3">**</bpt>deleteMessage<ept id="p3">**</ept> 方法并提供要删除的消息作为参数来完成接收过程的第二阶段。<bpt id="p4">**</bpt>deleteMessage<ept id="p4">**</ept> 方法将此消息标记为“已使用”并将其从队列中删除。</source>
          <target state="new">如果将 <bpt id="p1">**</bpt>isPeekLock<ept id="p1">**</ept> 参数设置为 <bpt id="p2">**</bpt>true<ept id="p2">**</ept>，则接收将变成一个两阶段操作，这样就可以支持无法允许遗漏消息的应用程序。当 Service Bus 收到请求时，它会查找下一条要使用的消息，锁定该消息以防其他使用者接收，然后将该消息返回到应用程序。应用程序处理完该消息（或将它可靠地存储起来留待将来处理）后，通过调用 <bpt id="p3">**</bpt>deleteMessage<ept id="p3">**</ept> 方法并提供要删除的消息作为参数来完成接收过程的第二阶段。<bpt id="p4">**</bpt>deleteMessage<ept id="p4">**</ept> 方法将此消息标记为“已使用”并将其从队列中删除。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>以下示例演示如何使用 <bpt id="p1">**</bpt>receiveQueueMessage<ept id="p1">**</ept> 接收和处理消息。该示例先接收并删除一条消息，然后使用设置为 <bpt id="p2">**</bpt>true<ept id="p2">**</ept> 的 <bpt id="p3">**</bpt>isPeekLock<ept id="p3">**</ept> 接收一条消息，最后使用 <bpt id="p4">**</bpt>deleteMessage<ept id="p4">**</ept> 删除该消息：</source>
          <target state="new">以下示例演示如何使用 <bpt id="p1">**</bpt>receiveQueueMessage<ept id="p1">**</ept> 接收和处理消息。该示例先接收并删除一条消息，然后使用设置为 <bpt id="p2">**</bpt>true<ept id="p2">**</ept> 的 <bpt id="p3">**</bpt>isPeekLock<ept id="p3">**</ept> 接收一条消息，最后使用 <bpt id="p4">**</bpt>deleteMessage<ept id="p4">**</ept> 删除该消息：</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>如何处理应用程序崩溃和不可读消息</source>
          <target state="new">如何处理应用程序崩溃和不可读消息</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Service Bus 提供了相关功能来帮助你轻松地从应用程序错误或消息处理问题中恢复。如果接收方应用程序因某种原因无法处理消息，则它可以对 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 对象调用 <bpt id="p2">**</bpt>unlockMessage<ept id="p2">**</ept> 方法。这将导致 Service Bus 解锁队列中的消息并使其能够重新被同一个正在使用的应用程序或其他正在使用的应用程序接收。</source>
          <target state="new">Service Bus 提供了相关功能来帮助你轻松地从应用程序错误或消息处理问题中恢复。如果接收方应用程序因某种原因无法处理消息，则它可以对 <bpt id="p1">**</bpt>ServiceBusService<ept id="p1">**</ept> 对象调用 <bpt id="p2">**</bpt>unlockMessage<ept id="p2">**</ept> 方法。这将导致 Service Bus 解锁队列中的消息并使其能够重新被同一个正在使用的应用程序或其他正在使用的应用程序接收。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>还存在与队列中已锁定消息关联的超时，并且如果应用程序无法在锁定超时到期之前处理消息（例如，如果应用程序崩溃），Service Bus 将自动解锁该消息并使它可再次被接收。</source>
          <target state="new">还存在与队列中已锁定消息关联的超时，并且如果应用程序无法在锁定超时到期之前处理消息（例如，如果应用程序崩溃），Service Bus 将自动解锁该消息并使它可再次被接收。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>如果应用程序在处理消息之后，调用 <bpt id="p1">**</bpt>deleteMessage<ept id="p1">**</ept> 方法之前崩溃，则在应用程序重新启动时会将该消息重新传送给它。此情况通常称作<bpt id="p2">**</bpt>至少处理一次<ept id="p2">**</ept>，即每条消息将至少被处理一次，但在某些情况下，同一消息可能会被重新传送。如果方案无法容忍重复处理，则应用程序开发人员应向其应用程序添加更多逻辑以处理重复消息传送。这通常可以通过使用消息的 <bpt id="p3">**</bpt>MessageId<ept id="p3">**</ept> 属性来实现，该属性在多次传送尝试中保持不变。</source>
          <target state="new">如果应用程序在处理消息之后，调用 <bpt id="p1">**</bpt>deleteMessage<ept id="p1">**</ept> 方法之前崩溃，则在应用程序重新启动时会将该消息重新传送给它。此情况通常称作<bpt id="p2">**</bpt>至少处理一次<ept id="p2">**</ept>，即每条消息将至少被处理一次，但在某些情况下，同一消息可能会被重新传送。如果方案无法容忍重复处理，则应用程序开发人员应向其应用程序添加更多逻辑以处理重复消息传送。这通常可以通过使用消息的 <bpt id="p3">**</bpt>MessageId<ept id="p3">**</ept> 属性来实现，该属性在多次传送尝试中保持不变。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>若要了解更多信息，请参阅下列资源。</source>
          <target state="new">若要了解更多信息，请参阅下列资源。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>队列、主题和订阅</source>
          <target state="new">队列、主题和订阅</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>GitHub 上的 <bpt id="p1">[</bpt>Azure SDK for Node<ept id="p1">][]</ept> 存储库</source>
          <target state="new">GitHub 上的 <bpt id="p1">[</bpt>Azure SDK for Node<ept id="p1">][]</ept> 存储库</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Node.js 开发人员中心</source>
          <target state="new">Node.js 开发人员中心</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>