<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">12248e4a37b8b0a071609e64aa423a3769f826c8</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>SQL 数据仓库中的 Group By 选项 | Azure</source>
          <target state="new">SQL 数据仓库中的 Group By 选项 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>有关在开发解决方案时实现 Azure SQL 数据仓库中的 Group By 选项的技巧。</source>
          <target state="new">有关在开发解决方案时实现 Azure SQL 数据仓库中的 Group By 选项的技巧。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>SQL 数据仓库中的 Group By 选项</source>
          <target state="new">SQL 数据仓库中的 Group By 选项</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ept id="p1">GROUP BY]</ept> 子句可用于将数据聚合成摘要行集。它还具有一些扩展其功能的选项，但这些选项需要经过处理，因为 Azure SQL 数据仓库不直接支持这些选项。</source>
          <target state="new"><bpt id="p1">[</bpt><ept id="p1">GROUP BY]</ept> 子句可用于将数据聚合成摘要行集。它还具有一些扩展其功能的选项，但这些选项需要经过处理，因为 Azure SQL 数据仓库不直接支持这些选项。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>这些选项为：</source>
          <target state="new">这些选项为：</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>GROUP BY with ROLLUP</source>
          <target state="new">GROUP BY with ROLLUP</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>GROUPING SETS</source>
          <target state="new">GROUPING SETS</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>GROUP BY with CUBE</source>
          <target state="new">GROUP BY with CUBE</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Rollup 和 grouping sets 选项</source>
          <target state="new">Rollup 和 grouping sets 选项</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>此处最简单的选项是改为使用 <ph id="ph1">`UNION ALL`</ph> 来执行汇总，而不是依赖显式语法。结果应完全相同</source>
          <target state="new">此处最简单的选项是改为使用 <ph id="ph1">`UNION ALL`</ph> 来执行汇总，而不是依赖显式语法。结果应完全相同</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>以下是使用 <ph id="ph1">`ROLLUP`</ph> 选项的 Group By 语句示例：</source>
          <target state="new">以下是使用 <ph id="ph1">`ROLLUP`</ph> 选项的 Group By 语句示例：</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>我们已通过使用 ROLLUP 请求以下聚合：</source>
          <target state="new">我们已通过使用 ROLLUP 请求以下聚合：</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Country and Region</source>
          <target state="new">Country and Region</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Country</source>
          <target state="new">Country</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Grand Total</source>
          <target state="new">Grand Total</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>若要替换此语句，需要使用 <ph id="ph1">`UNION ALL`</ph>；显式指定所需的聚合以返回相同的结果：</source>
          <target state="new">若要替换此语句，需要使用 <ph id="ph1">`UNION ALL`</ph>；显式指定所需的聚合以返回相同的结果：</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>对于 GROUPING SETS，我们需要采用相同的主体，但只创建想要查看的聚合级别的 UNION ALL 部分</source>
          <target state="new">对于 GROUPING SETS，我们需要采用相同的主体，但只创建想要查看的聚合级别的 UNION ALL 部分</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Cube 选项</source>
          <target state="new">Cube 选项</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>可以使用 UNION ALL 方法创建 GROUP BY WITH CUBE。问题在于，代码可能很快就会变得庞大且失控。若要避免此情况，可以使用这种更高级的方法。</source>
          <target state="new">可以使用 UNION ALL 方法创建 GROUP BY WITH CUBE。问题在于，代码可能很快就会变得庞大且失控。若要避免此情况，可以使用这种更高级的方法。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>使用上述示例。</source>
          <target state="new">使用上述示例。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>第一步是定义“cube”，它定义我们想要创建的所有聚合级别。请务必记下两个派生表的 CROSS JOIN。这样就会生成所有级别。剩余代码确实可以设置格式。</source>
          <target state="new">第一步是定义“cube”，它定义我们想要创建的所有聚合级别。请务必记下两个派生表的 CROSS JOIN。这样就会生成所有级别。剩余代码确实可以设置格式。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>CTAS 的结果如下所示：</source>
          <target state="new">CTAS 的结果如下所示：</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>第二步是指定目标表用于存储临时结果：</source>
          <target state="new">第二步是指定目标表用于存储临时结果：</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>第三步是是循环访问执行聚合的列 cube。查询将为 #Cube 临时表中的每个行运行一次，并将结果存储在 #Results 临时表中</source>
          <target state="new">第三步是是循环访问执行聚合的列 cube。查询将为 #Cube 临时表中的每个行运行一次，并将结果存储在 #Results 临时表中</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>最后，我们只需读取 #Results 临时表即可返回结果</source>
          <target state="new">最后，我们只需读取 #Results 临时表即可返回结果</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>通过将代码拆分成不同的部分并生成循环构造，代码将更好管理和维护。</source>
          <target state="new">通过将代码拆分成不同的部分并生成循环构造，代码将更好管理和维护。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>有关更多开发技巧，请参阅<bpt id="p1">[</bpt>开发概述<ept id="p1">][]</ept>。</source>
          <target state="new">有关更多开发技巧，请参阅<bpt id="p1">[</bpt>开发概述<ept id="p1">][]</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>