<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e31d848f426f588e01cb34842dd41e0fdbe60c6d</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>开始使用 blob 存储和 Visual Studio 连接服务 (ASP.NET) | Azure</source>
          <target state="new">开始使用 blob 存储和 Visual Studio 连接服务 (ASP.NET) | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>在使用 Visual Studio 连接服务连接到存储帐户后，如何开始在 Visual Studio 的 ASP.NET 项目中使用 Azure Blob 存储</source>
          <target state="new">在使用 Visual Studio 连接服务连接到存储帐户后，如何开始在 Visual Studio 的 ASP.NET 项目中使用 Azure Blob 存储</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>开始使用 blob 存储和 Visual Studio 连接服务 (ASP.NET)</source>
          <target state="new">开始使用 blob 存储和 Visual Studio 连接服务 (ASP.NET)</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本文介绍通过使用 Visual Studio 中的“添加连接服务”对话框在 ASP.NET 应用中创建或引用 Azure 存储帐户之后，如何开始使用 Azure Blob 存储。本文演示如何创建 blob 容器和执行其他常见任务（如上载、列出、下载和删除 blob）。示例是用 C# 编写的，并使用了 <bpt id="p1">[</bpt>Azure .NET 存储客户端库<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/azure/dn261237.aspx)</ept>。</source>
          <target state="new">本文介绍通过使用 Visual Studio 中的“添加连接服务”对话框在 ASP.NET 应用中创建或引用 Azure 存储帐户之后，如何开始使用 Azure Blob 存储。本文演示如何创建 blob 容器和执行其他常见任务（如上载、列出、下载和删除 blob）。示例是用 C# 编写的，并使用了 <bpt id="p1">[</bpt>Azure .NET 存储客户端库<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/azure/dn261237.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>有关使用 Azure Blob 存储的更多常规信息，请参阅<bpt id="p1">[</bpt>如何通过 .NET 使用 Blob 存储<ept id="p1">](/documentation/articles/storage-dotnet-how-to-use-blobs)</ept>。</source>
          <target state="new">有关使用 Azure Blob 存储的更多常规信息，请参阅<bpt id="p1">[</bpt>如何通过 .NET 使用 Blob 存储<ept id="p1">](/documentation/articles/storage-dotnet-how-to-use-blobs)</ept>。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>有关 ASP.NET 项目的详细信息，请参阅 <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](http://www.asp.net)</ept>。</source>
          <target state="new">有关 ASP.NET 项目的详细信息，请参阅 <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](http://www.asp.net)</ept>。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Azure Blob 存储是一项可存储大量非结构化数据的服务，用户可在世界任何地方通过 HTTP 或 HTTPS 访问这些数据。单个 Blob 可以是任意大小。Blob 可以是图像、音频和视频文件、原始数据以及文档文件等。</source>
          <target state="new">Azure Blob 存储是一项可存储大量非结构化数据的服务，用户可在世界任何地方通过 HTTP 或 HTTPS 访问这些数据。单个 Blob 可以是任意大小。Blob 可以是图像、音频和视频文件、原始数据以及文档文件等。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>正如文件位于文件夹中一样，存储 Blob 位于容器中。创建存储帐户后，可以在存储空间中创建一个或多个容器。例如，在名为“Scrapbook”的存储空间中，可以在名为“images”的存储空间中创建 blob 容器用于存储图片，还可以在名为“audio”的存储空间中创建另一个容器，用于存储音频文件。创建这些容器后，您可以向它们上载单独的 Blob 文件。</source>
          <target state="new">正如文件位于文件夹中一样，存储 Blob 位于容器中。创建存储帐户后，可以在存储空间中创建一个或多个容器。例如，在名为“Scrapbook”的存储空间中，可以在名为“images”的存储空间中创建 blob 容器用于存储图片，还可以在名为“audio”的存储空间中创建另一个容器，用于存储音频文件。创建这些容器后，您可以向它们上载单独的 Blob 文件。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>使用代码访问 blob 容器</source>
          <target state="new">使用代码访问 blob 容器</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>若要以编程方式访问 ASP.NET 项目中的 Blob，你需要添加以下项（如果尚未存在）。</source>
          <target state="new">若要以编程方式访问 ASP.NET 项目中的 Blob，你需要添加以下项（如果尚未存在）。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>在您希望以编程方式访问 Azure 存储的任何 C# 文件中，将以下代码命名空间声明添加到文件的顶部。</source>
          <target state="new">在您希望以编程方式访问 Azure 存储的任何 C# 文件中，将以下代码命名空间声明添加到文件的顶部。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>获取表示存储帐户信息的 <bpt id="p1">**</bpt>CloudStorageAccount<ept id="p1">**</ept> 对象。使用下面的代码获取存储连接字符串和 Azure 服务配置中的存储帐户信息。</source>
          <target state="new">获取表示存储帐户信息的 <bpt id="p1">**</bpt>CloudStorageAccount<ept id="p1">**</ept> 对象。使用下面的代码获取存储连接字符串和 Azure 服务配置中的存储帐户信息。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>在接下来的部分中，将在代码的前面使用先前的全部代码。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>在接下来的部分中，将在代码的前面使用先前的全部代码。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>获取 <bpt id="p1">**</bpt>CloudBlobClient<ept id="p1">**</ept> 对象，以引用存储帐户中的现有容器。</source>
          <target state="new">获取 <bpt id="p1">**</bpt>CloudBlobClient<ept id="p1">**</ept> 对象，以引用存储帐户中的现有容器。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>在 ASP.NET 5 中执行调出 Azure 存储的一些 API 是异步的。有关详细信息，请参阅<bpt id="p1">[</bpt>使用 Async 和 Await 进行异步编程<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/hh191443.aspx)</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>在 ASP.NET 5 中执行调出 Azure 存储的一些 API 是异步的。有关详细信息，请参阅<bpt id="p1">[</bpt>使用 Async 和 Await 进行异步编程<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/hh191443.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>使用代码创建 blob 容器</source>
          <target state="new">使用代码创建 blob 容器</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>你还可以使用 <bpt id="p1">**</bpt>CloudBlobClient<ept id="p1">**</ept> 对象在存储帐户中创建容器。你所需做的只是在上面的代码中添加对 <bpt id="p2">**</bpt>CreateIfNotExistsAsync<ept id="p2">**</ept> 的调用，如下面的示例所示。</source>
          <target state="new">你还可以使用 <bpt id="p1">**</bpt>CloudBlobClient<ept id="p1">**</ept> 对象在存储帐户中创建容器。你所需做的只是在上面的代码中添加对 <bpt id="p2">**</bpt>CreateIfNotExistsAsync<ept id="p2">**</ept> 的调用，如下面的示例所示。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>将 Blob 上载到容器中</source>
          <target state="new">将 Blob 上载到容器中</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Azure Blob 存储支持块 Blob 和页 Blob。大多数情况下，推荐使用块 Blob。</source>
          <target state="new">Azure Blob 存储支持块 Blob 和页 Blob。大多数情况下，推荐使用块 Blob。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>若要将文件上载到块 Blob，请获取容器引用，并使用它获取块 Blob 引用。获取 Blob 引用后，可以通过调用 <bpt id="p1">**</bpt>UploadFromStream<ept id="p1">**</ept> 方法，将任何数据流上载到该 Blob。如果之前不存在 Blob，此操作将创建一个；如果存在 Blob，此操作将覆盖它。下面的示例演示了如何将 Blob 上载到容器中，并假定已创建容器。</source>
          <target state="new">若要将文件上载到块 Blob，请获取容器引用，并使用它获取块 Blob 引用。获取 Blob 引用后，可以通过调用 <bpt id="p1">**</bpt>UploadFromStream<ept id="p1">**</ept> 方法，将任何数据流上载到该 Blob。如果之前不存在 Blob，此操作将创建一个；如果存在 Blob，此操作将覆盖它。下面的示例演示了如何将 Blob 上载到容器中，并假定已创建容器。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>列出容器中的 Blob</source>
          <target state="new">列出容器中的 Blob</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>若要列出容器中的 Blob，可以使用 <bpt id="p1">**</bpt>ListBlobs<ept id="p1">**</ept> 方法检索其中的 Blob 和/或目录。若要访问返回的 <bpt id="p2">**</bpt>IListBlobItem<ept id="p2">**</ept> 的丰富属性和方法，您必须将它转换到 <bpt id="p3">**</bpt>CloudBlockBlob<ept id="p3">**</ept>、<bpt id="p4">**</bpt>CloudPageBlob<ept id="p4">**</ept> 或 <bpt id="p5">**</bpt>CloudBlobDirectory<ept id="p5">**</ept> 对象。如果类型未知，你可以使用类型检查来确定要将其转换为哪种类型。以下代码演示了如何检索和输出 <bpt id="p6">**</bpt>photos<ept id="p6">**</ept> 容器中每项的 URI。</source>
          <target state="new">若要列出容器中的 Blob，可以使用 <bpt id="p1">**</bpt>ListBlobs<ept id="p1">**</ept> 方法检索其中的 Blob 和/或目录。若要访问返回的 <bpt id="p2">**</bpt>IListBlobItem<ept id="p2">**</ept> 的丰富属性和方法，您必须将它转换到 <bpt id="p3">**</bpt>CloudBlockBlob<ept id="p3">**</ept>、<bpt id="p4">**</bpt>CloudPageBlob<ept id="p4">**</ept> 或 <bpt id="p5">**</bpt>CloudBlobDirectory<ept id="p5">**</ept> 对象。如果类型未知，你可以使用类型检查来确定要将其转换为哪种类型。以下代码演示了如何检索和输出 <bpt id="p6">**</bpt>photos<ept id="p6">**</ept> 容器中每项的 URI。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>如上例所示，还可将 Blob 服务视为容器中的目录。这是为了让您能够以更类似于文件夹的结构来组织 Blob。例如，考虑名为 <bpt id="p1">**</bpt>photos<ept id="p1">**</ept> 的容器中包含的下面一组块 Blob。</source>
          <target state="new">如上例所示，还可将 Blob 服务视为容器中的目录。这是为了让您能够以更类似于文件夹的结构来组织 Blob。例如，考虑名为 <bpt id="p1">**</bpt>photos<ept id="p1">**</ept> 的容器中包含的下面一组块 Blob。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>当你对“photos”容器调用 <bpt id="p1">**</bpt>ListBlobs<ept id="p1">**</ept> 时（如前面的示例所示），返回的集合将包含 <bpt id="p2">**</bpt>CloudBlobDirectory<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>CloudBlockBlob<ept id="p3">**</ept> 对象，分别表示最高层中所含的目录和 Blob。以下示例显示生成的输出。</source>
          <target state="new">当你对“photos”容器调用 <bpt id="p1">**</bpt>ListBlobs<ept id="p1">**</ept> 时（如前面的示例所示），返回的集合将包含 <bpt id="p2">**</bpt>CloudBlobDirectory<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>CloudBlockBlob<ept id="p3">**</ept> 对象，分别表示最高层中所含的目录和 Blob。以下示例显示生成的输出。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>另外，也可以将 <bpt id="p1">**</bpt>ListBlobs<ept id="p1">**</ept> 方法的 <bpt id="p2">**</bpt>UseFlatBlobListing<ept id="p2">**</ept> 参数设置为 <bpt id="p3">**</bpt>true<ept id="p3">**</ept>。这将导致每个 Blob 将作为 <bpt id="p4">**</bpt>CloudBlockBlob<ept id="p4">**</ept> 返回，而无论目录如何。以下示例显示对 <bpt id="p5">**</bpt>ListBlobs<ept id="p5">**</ept> 的调用。</source>
          <target state="new">另外，也可以将 <bpt id="p1">**</bpt>ListBlobs<ept id="p1">**</ept> 方法的 <bpt id="p2">**</bpt>UseFlatBlobListing<ept id="p2">**</ept> 参数设置为 <bpt id="p3">**</bpt>true<ept id="p3">**</ept>。这将导致每个 Blob 将作为 <bpt id="p4">**</bpt>CloudBlockBlob<ept id="p4">**</ept> 返回，而无论目录如何。以下示例显示对 <bpt id="p5">**</bpt>ListBlobs<ept id="p5">**</ept> 的调用。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>下一个示例显示结果。</source>
          <target state="new">下一个示例显示结果。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>下载 Blob</source>
          <target state="new">下载 Blob</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>若要下载 blob，请使用 <bpt id="p1">**</bpt>DownloadToStream<ept id="p1">**</ept> 方法。以下示例使用 <bpt id="p2">**</bpt>DownloadToStream<ept id="p2">**</ept> 方法将 Blob 内容传输到一个流对象，然后您可以将该对象保存到本地文件。</source>
          <target state="new">若要下载 blob，请使用 <bpt id="p1">**</bpt>DownloadToStream<ept id="p1">**</ept> 方法。以下示例使用 <bpt id="p2">**</bpt>DownloadToStream<ept id="p2">**</ept> 方法将 Blob 内容传输到一个流对象，然后您可以将该对象保存到本地文件。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>也可以使用 <bpt id="p1">**</bpt>DownloadToStream<ept id="p1">**</ept> 方法以文本字符串形式下载 Blob 的内容。</source>
          <target state="new">也可以使用 <bpt id="p1">**</bpt>DownloadToStream<ept id="p1">**</ept> 方法以文本字符串形式下载 Blob 的内容。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>删除 Blob</source>
          <target state="new">删除 Blob</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>若要删除 Blob，请使用 <bpt id="p1">**</bpt>Delete<ept id="p1">**</ept> 方法。</source>
          <target state="new">若要删除 Blob，请使用 <bpt id="p1">**</bpt>Delete<ept id="p1">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>以异步方式列出页中的 Blob</source>
          <target state="new">以异步方式列出页中的 Blob</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>如果要列出大量 Blob，或需要控制一个列表操作中返回的结果数，则可以结果页的方式列出 Blob。以下示例显示如何以页面形式异步返回结果，这样就不会在等待返回大型结果集时阻止操作的执行。</source>
          <target state="new">如果要列出大量 Blob，或需要控制一个列表操作中返回的结果数，则可以结果页的方式列出 Blob。以下示例显示如何以页面形式异步返回结果，这样就不会在等待返回大型结果集时阻止操作的执行。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>此示例演示平面 Blob 列表，但你也可以执行分层列表，只需将 <bpt id="p1">**</bpt>ListBlobsSegmentedAsync<ept id="p1">**</ept> 方法的 <bpt id="p2">**</bpt>useFlatBlobListing<ept id="p2">**</ept> 参数设置为 <bpt id="p3">**</bpt>false<ept id="p3">**</ept> 即可。</source>
          <target state="new">此示例演示平面 Blob 列表，但你也可以执行分层列表，只需将 <bpt id="p1">**</bpt>ListBlobsSegmentedAsync<ept id="p1">**</ept> 方法的 <bpt id="p2">**</bpt>useFlatBlobListing<ept id="p2">**</ept> 参数设置为 <bpt id="p3">**</bpt>false<ept id="p3">**</ept> 即可。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>由于示例方法调用异步方法，因此必须以 <bpt id="p1">**</bpt>async<ept id="p1">**</ept> 关键字开头，且必须返回 <bpt id="p2">**</bpt>Task<ept id="p2">**</ept> 对象。为 <bpt id="p3">**</bpt>ListBlobsSegmentedAsync<ept id="p3">**</ept> 方法指定的 await 关键字将挂起示例方法的执行，直至列表任务完成。</source>
          <target state="new">由于示例方法调用异步方法，因此必须以 <bpt id="p1">**</bpt>async<ept id="p1">**</ept> 关键字开头，且必须返回 <bpt id="p2">**</bpt>Task<ept id="p2">**</ept> 对象。为 <bpt id="p3">**</bpt>ListBlobsSegmentedAsync<ept id="p3">**</ept> 方法指定的 await 关键字将挂起示例方法的执行，直至列表任务完成。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>