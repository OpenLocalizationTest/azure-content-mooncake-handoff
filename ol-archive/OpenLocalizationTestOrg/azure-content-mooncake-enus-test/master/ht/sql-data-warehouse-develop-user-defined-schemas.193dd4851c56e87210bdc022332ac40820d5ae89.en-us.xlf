<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c44bf0a09e2daf2db2957af2bed809fe32226611</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>SQL 数据仓库中用户定义的架构 | Azure</source>
          <target state="new">SQL 数据仓库中用户定义的架构 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>有关在开发解决方案时使用 Azure SQL 数据仓库中的 Transact-SQL 架构的技巧。</source>
          <target state="new">有关在开发解决方案时使用 Azure SQL 数据仓库中的 Transact-SQL 架构的技巧。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>SQL 数据仓库中用户定义的架构</source>
          <target state="new">SQL 数据仓库中用户定义的架构</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>传统数据仓库通常使用不同的数据库，根据工作负荷、域或安全性来创建应用程序边界。例如，传统 SQL Server 数据仓库可能包含过渡数据库、数据仓库数据库和某些数据集市数据库。在此拓扑中，每个数据库均作为体系结构中的工作负荷和安全边界来运行。</source>
          <target state="new">传统数据仓库通常使用不同的数据库，根据工作负荷、域或安全性来创建应用程序边界。例如，传统 SQL Server 数据仓库可能包含过渡数据库、数据仓库数据库和某些数据集市数据库。在此拓扑中，每个数据库均作为体系结构中的工作负荷和安全边界来运行。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>相比之下，SQL 数据仓库在一个数据库中运行整个数据仓库工作负荷。不允许跨数据库联接。因此，SQL 数据仓库预期仓库使用的所有表都存储在一个数据库中。</source>
          <target state="new">相比之下，SQL 数据仓库在一个数据库中运行整个数据仓库工作负荷。不允许跨数据库联接。因此，SQL 数据仓库预期仓库使用的所有表都存储在一个数据库中。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>SQL 数据仓库不支持任何种类的跨数据库查询。因此，需要修改利用此模式的数据仓库实现。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>SQL 数据仓库不支持任何种类的跨数据库查询。因此，需要修改利用此模式的数据仓库实现。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>建议</source>
          <target state="new">建议</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>以下是针对使用用户定义的架构合并工作负荷、安全性、域和功能边界的一些建议</source>
          <target state="new">以下是针对使用用户定义的架构合并工作负荷、安全性、域和功能边界的一些建议</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>使用一个 SQL 数据仓库数据库来运行整个数据仓库工作负荷</source>
          <target state="new">使用一个 SQL 数据仓库数据库来运行整个数据仓库工作负荷</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>合并现有的数据仓库环境，以使用一个 SQL 数据仓库数据库</source>
          <target state="new">合并现有的数据仓库环境，以使用一个 SQL 数据仓库数据库</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>利用<bpt id="p1">**</bpt>用户定义的架构<ept id="p1">**</ept>来提供以前使用数据库实现的边界。</source>
          <target state="new">利用<bpt id="p1">**</bpt>用户定义的架构<ept id="p1">**</ept>来提供以前使用数据库实现的边界。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>如果以前尚未使用用户定义的架构，则就不会存在任何记录。只需使用旧数据库名称作为 SQL 数据仓库数据库中用户定义架构的基础。</source>
          <target state="new">如果以前尚未使用用户定义的架构，则就不会存在任何记录。只需使用旧数据库名称作为 SQL 数据仓库数据库中用户定义架构的基础。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>如果已使用架构，则你可以采用以下几个选项：</source>
          <target state="new">如果已使用架构，则你可以采用以下几个选项：</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>删除旧架构名称并重新开始</source>
          <target state="new">删除旧架构名称并重新开始</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>在表名称前面附加旧架构名称，以保留旧架构名称。</source>
          <target state="new">在表名称前面附加旧架构名称，以保留旧架构名称。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>在额外架构中的表上实现视图来重建旧架构结构，以保留旧架构名称。</source>
          <target state="new">在额外架构中的表上实现视图来重建旧架构结构，以保留旧架构名称。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>在首次检查时，选项 3 似乎像是最吸引人的选项。但是，细节决定成败。SQL 数据仓库中的视图为只读状态。任何表修改或数据修改只能针对基础表执行。选项 3 还在系统中引入了一个视图层。如果已在体系结构中使用视图，你可以再三考虑一下此选项。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>在首次检查时，选项 3 似乎像是最吸引人的选项。但是，细节决定成败。SQL 数据仓库中的视图为只读状态。任何表修改或数据修改只能针对基础表执行。选项 3 还在系统中引入了一个视图层。如果已在体系结构中使用视图，你可以再三考虑一下此选项。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>示例:</source>
          <target state="new">示例:</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>基于数据库名称实现用户定义的架构</source>
          <target state="new">基于数据库名称实现用户定义的架构</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>在表名称前面附加旧架构名称，以保留旧架构名称。使用工作负荷边界的架构。</source>
          <target state="new">在表名称前面附加旧架构名称，以保留旧架构名称。使用工作负荷边界的架构。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>使用视图保留旧架构名称</source>
          <target state="new">使用视图保留旧架构名称</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>如果架构策略发生任何更改，则需要检查数据库的安全模型。在许多情况下，你可以在架构级别分配权限，以简化安全模型。如果需要更高粒度的权限，可以使用数据库角色。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>如果架构策略发生任何更改，则需要检查数据库的安全模型。在许多情况下，你可以在架构级别分配权限，以简化安全模型。如果需要更高粒度的权限，可以使用数据库角色。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>有关更多开发技巧，请参阅<bpt id="p1">[</bpt>开发概述<ept id="p1">][]</ept>。</source>
          <target state="new">有关更多开发技巧，请参阅<bpt id="p1">[</bpt>开发概述<ept id="p1">][]</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>