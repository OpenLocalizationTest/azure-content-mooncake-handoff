<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a9133c5f81a185c59f46e053e3922c3bfeed150f</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>开始使用队列存储和 Visual Studio 连接服务 (ASP.NET 5) | Azure</source>
          <target state="new">开始使用队列存储和 Visual Studio 连接服务 (ASP.NET 5) | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>如何开始在 Visual Studio 中的 ASP.NET 5 项目中使用 Azure 队列存储</source>
          <target state="new">如何开始在 Visual Studio 中的 ASP.NET 5 项目中使用 Azure 队列存储</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>开始使用队列存储和 Visual Studio 连接服务 (ASP.NET 5)</source>
          <target state="new">开始使用队列存储和 Visual Studio 连接服务 (ASP.NET 5)</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本文介绍通过使用 Visual Studio 中的“添加连接服务”对话框在 ASP.NET 5 项目中已创建或引用 Azure 存储帐户之后，如何开始在 Visual Studio 中使用 Azure 表存储。执行“添加连接服务”操作会安装相应的 NuGet 程序包，以访问项目中的 Azure 存储，并将存储帐户的连接字符串添加到项目配置文件中。</source>
          <target state="new">本文介绍通过使用 Visual Studio 中的“添加连接服务”对话框在 ASP.NET 5 项目中已创建或引用 Azure 存储帐户之后，如何开始在 Visual Studio 中使用 Azure 表存储。执行“添加连接服务”操作会安装相应的 NuGet 程序包，以访问项目中的 Azure 存储，并将存储帐户的连接字符串添加到项目配置文件中。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Azure 队列存储是一项可存储大量消息的服务，用户可以通过经验证的呼叫，使用 HTTP 或 HTTPS 从世界任何地方访问这些消息。一条队列消息的大小最多可为 64 千字节 (KB)，一个队列中可以包含数百万条消息，直至达到存储帐户的总容量限值。</source>
          <target state="new">Azure 队列存储是一项可存储大量消息的服务，用户可以通过经验证的呼叫，使用 HTTP 或 HTTPS 从世界任何地方访问这些消息。一条队列消息的大小最多可为 64 千字节 (KB)，一个队列中可以包含数百万条消息，直至达到存储帐户的总容量限值。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>若要开始，首先需要在存储帐户中创建 Azure 队列。我们将向你展示如何使用代码创建队列。此外，我们将展示如何执行基本的队列操作，例如添加、修改、读取和删除队列消息。示例是使用 C# 代码编写的，并使用了 .NET 的 Azure 存储客户端库。有关 ASP.NET 的详细信息，请参阅 <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](http://www.asp.net)</ept>。</source>
          <target state="new">若要开始，首先需要在存储帐户中创建 Azure 队列。我们将向你展示如何使用代码创建队列。此外，我们将展示如何执行基本的队列操作，例如添加、修改、读取和删除队列消息。示例是使用 C# 代码编写的，并使用了 .NET 的 Azure 存储客户端库。有关 ASP.NET 的详细信息，请参阅 <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](http://www.asp.net)</ept>。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>注意：<ept id="p1">**</ept>在 ASP.NET 5 中执行调用 Azure 存储的一些 API 是异步的。有关详细信息，请参阅<bpt id="p2">[</bpt>使用 Async 和 Await 进行异步编程<ept id="p2">](http://msdn.microsoft.com/zh-cn/library/hh191443.aspx)</ept>。下面的代码假定正在使用异步编程方法。</source>
          <target state="new"><bpt id="p1">**</bpt>注意：<ept id="p1">**</ept>在 ASP.NET 5 中执行调用 Azure 存储的一些 API 是异步的。有关详细信息，请参阅<bpt id="p2">[</bpt>使用 Async 和 Await 进行异步编程<ept id="p2">](http://msdn.microsoft.com/zh-cn/library/hh191443.aspx)</ept>。下面的代码假定正在使用异步编程方法。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>有关以编程方式操作队列的详细信息，请参阅<bpt id="p1">[</bpt>如何通过 .NET 使用队列存储<ept id="p1">](/documentation/articles/storage-dotnet-how-to-use-queues)</ept>。</source>
          <target state="new">有关以编程方式操作队列的详细信息，请参阅<bpt id="p1">[</bpt>如何通过 .NET 使用队列存储<ept id="p1">](/documentation/articles/storage-dotnet-how-to-use-queues)</ept>。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>有关 Azure 存储空间的常规信息，请参阅<bpt id="p1">[</bpt>存储空间文档<ept id="p1">](/documentation/services/storage/)</ept>。</source>
          <target state="new">有关 Azure 存储空间的常规信息，请参阅<bpt id="p1">[</bpt>存储空间文档<ept id="p1">](/documentation/services/storage/)</ept>。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>有关 Azure 云服务的常规信息，请参阅<bpt id="p1">[</bpt>云服务文档<ept id="p1">](/documentation/services/cloud-services/)</ept>。</source>
          <target state="new">有关 Azure 云服务的常规信息，请参阅<bpt id="p1">[</bpt>云服务文档<ept id="p1">](/documentation/services/cloud-services/)</ept>。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>有关对 ASP.NET 应用程序进行编程的详细信息，请参阅 <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](http://www.asp.net)</ept>。</source>
          <target state="new">有关对 ASP.NET 应用程序进行编程的详细信息，请参阅 <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](http://www.asp.net)</ept>。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>使用代码访问队列</source>
          <target state="new">使用代码访问队列</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>若要访问 ASP.NET 5 项目中的队列，需要将下列事项包含在访问 Azure 队列存储的任何 C# 源文件中。</source>
          <target state="new">若要访问 ASP.NET 5 项目中的队列，需要将下列事项包含在访问 Azure 队列存储的任何 C# 源文件中。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>请确保 C# 文件顶部的命名空间声明包括这些 <bpt id="p1">**</bpt>using<ept id="p1">**</ept> 语句。</source>
          <target state="new">请确保 C# 文件顶部的命名空间声明包括这些 <bpt id="p1">**</bpt>using<ept id="p1">**</ept> 语句。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>获取表示存储帐户信息的 <bpt id="p1">**</bpt>CloudStorageAccount<ept id="p1">**</ept> 对象。使用下面的代码获取存储连接字符串和 Azure 服务配置中的存储帐户信息。</source>
          <target state="new">获取表示存储帐户信息的 <bpt id="p1">**</bpt>CloudStorageAccount<ept id="p1">**</ept> 对象。使用下面的代码获取存储连接字符串和 Azure 服务配置中的存储帐户信息。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>获取 <bpt id="p1">**</bpt>CloudQueueClient<ept id="p1">**</ept> 对象，以引用存储帐户中的队列对象。</source>
          <target state="new">获取 <bpt id="p1">**</bpt>CloudQueueClient<ept id="p1">**</ept> 对象，以引用存储帐户中的队列对象。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>获取 <bpt id="p1">**</bpt>CloudQueue<ept id="p1">**</ept> 对象，以引用特定队列。</source>
          <target state="new">获取 <bpt id="p1">**</bpt>CloudQueue<ept id="p1">**</ept> 对象，以引用特定队列。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>注意：<ept id="p1">**</ept>在下列示例中，在代码的前面使用上述全部代码。</source>
          <target state="new"><bpt id="p1">**</bpt>注意：<ept id="p1">**</ept>在下列示例中，在代码的前面使用上述全部代码。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>使用代码创建队列</source>
          <target state="new">使用代码创建队列</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>若要在代码中创建 Azure 队列，只需添加对 <bpt id="p1">**</bpt>CreateIfNotExistsAsync<ept id="p1">**</ept> 的调用。</source>
          <target state="new">若要在代码中创建 Azure 队列，只需添加对 <bpt id="p1">**</bpt>CreateIfNotExistsAsync<ept id="p1">**</ept> 的调用。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>向队列添加消息</source>
          <target state="new">向队列添加消息</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>若要在现有队列中插入消息，请创建新的 <bpt id="p1">**</bpt>CloudQueueMessage<ept id="p1">**</ept> 对象，然后调用 <bpt id="p2">**</bpt>AddMessageAsync<ept id="p2">**</ept> 方法。</source>
          <target state="new">若要在现有队列中插入消息，请创建新的 <bpt id="p1">**</bpt>CloudQueueMessage<ept id="p1">**</ept> 对象，然后调用 <bpt id="p2">**</bpt>AddMessageAsync<ept id="p2">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>可从字符串（UTF-8 格式）或字节数组创建 <bpt id="p1">**</bpt>CloudQueueMessage<ept id="p1">**</ept> 对象。</source>
          <target state="new">可从字符串（UTF-8 格式）或字节数组创建 <bpt id="p1">**</bpt>CloudQueueMessage<ept id="p1">**</ept> 对象。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>以下示例插入了消息“Hello, World”。</source>
          <target state="new">以下示例插入了消息“Hello, World”。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>读取队列中的消息</source>
          <target state="new">读取队列中的消息</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>通过调用 <bpt id="p1">**</bpt>PeekMessageAsync<ept id="p1">**</ept> 方法，可以查看队列前面的消息，而不必从队列中将其删除。</source>
          <target state="new">通过调用 <bpt id="p1">**</bpt>PeekMessageAsync<ept id="p1">**</ept> 方法，可以查看队列前面的消息，而不必从队列中将其删除。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>读取和删除队列中的消息</source>
          <target state="new">读取和删除队列中的消息</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>你的代码分两步从队列中删除消息（取消对消息的排队）。1.调用 <bpt id="p1">**</bpt>GetMessageAsync<ept id="p1">**</ept>，以获得队列中的下一条消息。从 <bpt id="p2">**</bpt>GetMessageAsync<ept id="p2">**</ept> 返回的消息将变为对从此队列读取消息的任何其他代码不可见。默认情况下，此消息将持续 30 秒不可见。2.若要完成从队列中删除消息的操作，请调用 <bpt id="p3">**</bpt>DeleteMessageAsync<ept id="p3">**</ept>。</source>
          <target state="new">你的代码分两步从队列中删除消息（取消对消息的排队）。1.调用 <bpt id="p1">**</bpt>GetMessageAsync<ept id="p1">**</ept>，以获得队列中的下一条消息。从 <bpt id="p2">**</bpt>GetMessageAsync<ept id="p2">**</ept> 返回的消息将变为对从此队列读取消息的任何其他代码不可见。默认情况下，此消息将持续 30 秒不可见。2.若要完成从队列中删除消息的操作，请调用 <bpt id="p3">**</bpt>DeleteMessageAsync<ept id="p3">**</ept>。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>此删除消息的两步过程可确保，如果你的代码因硬件或软件故障而无法处理消息，则你的代码的其他实例可以获取相同消息并重试。以下代码将在处理消息后立即调用 <bpt id="p1">**</bpt>DeleteMessageAsync<ept id="p1">**</ept>。</source>
          <target state="new">此删除消息的两步过程可确保，如果你的代码因硬件或软件故障而无法处理消息，则你的代码的其他实例可以获取相同消息并重试。以下代码将在处理消息后立即调用 <bpt id="p1">**</bpt>DeleteMessageAsync<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>使用其他方法取消对消息的排队</source>
          <target state="new">使用其他方法取消对消息的排队</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>你可以通过两种方式自定义队列中的消息检索。首先，你可以获取一批消息（最多 32 个）。其次，你可以设置更长或更短的不可见超时时间，从而允许你的代码使用更多或更少时间来完全处理每个消息。以下代码示例使用 <bpt id="p1">**</bpt>GetMessages<ept id="p1">**</ept> 方法在一次调用中获取 20 条消息。然后，它使用 <bpt id="p2">**</bpt>foreach<ept id="p2">**</ept> 循环处理每条消息。它还将每条消息的不可见超时时间设置为 5 分钟。请注意，5 分钟超时时间对于所有消息都是同时开始的，因此在调用 <bpt id="p3">**</bpt>GetMessages<ept id="p3">**</ept> 5 分钟后，尚未删除的任何消息都将再次变得可见。</source>
          <target state="new">你可以通过两种方式自定义队列中的消息检索。首先，你可以获取一批消息（最多 32 个）。其次，你可以设置更长或更短的不可见超时时间，从而允许你的代码使用更多或更少时间来完全处理每个消息。以下代码示例使用 <bpt id="p1">**</bpt>GetMessages<ept id="p1">**</ept> 方法在一次调用中获取 20 条消息。然后，它使用 <bpt id="p2">**</bpt>foreach<ept id="p2">**</ept> 循环处理每条消息。它还将每条消息的不可见超时时间设置为 5 分钟。请注意，5 分钟超时时间对于所有消息都是同时开始的，因此在调用 <bpt id="p3">**</bpt>GetMessages<ept id="p3">**</ept> 5 分钟后，尚未删除的任何消息都将再次变得可见。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>获取队列长度</source>
          <target state="new">获取队列长度</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>你可以获取队列中消息的估计数。使用 <bpt id="p1">**</bpt>FetchAttributes<ept id="p1">**</ept> 方法可请求队列服务检索队列属性，包括消息计数。<bpt id="p2">**</bpt>ApproximateMethodCount<ept id="p2">**</ept> 属性返回 <bpt id="p3">**</bpt>FetchAttributes<ept id="p3">**</ept> 方法检索到的最后一个值，而不会调用队列服务。</source>
          <target state="new">你可以获取队列中消息的估计数。使用 <bpt id="p1">**</bpt>FetchAttributes<ept id="p1">**</ept> 方法可请求队列服务检索队列属性，包括消息计数。<bpt id="p2">**</bpt>ApproximateMethodCount<ept id="p2">**</ept> 属性返回 <bpt id="p3">**</bpt>FetchAttributes<ept id="p3">**</ept> 方法检索到的最后一个值，而不会调用队列服务。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>共同使用 Async Await 模式和公用队列 API</source>
          <target state="new">共同使用 Async Await 模式和公用队列 API</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>此示例演示如何共同使用 Async Await 模式和公用队列 API。示例代码会调用每个给定方法的异步版本，这可以通过每个方法的 Async 后修补程序体现。使用异步方法时，async-await 模式将暂停本地执行，直到调用完成。此行为允许当前的线程执行其他工作，这有助于避免性能瓶颈并提高应用程序的整体响应能力。有关在.NET 中使用 Async-Await 模式的详细信息，请参阅 <bpt id="p1">[</bpt>Async 和 Await（C# 和 Visual Basic）<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/hh191443.aspx)</ept></source>
          <target state="new">此示例演示如何共同使用 Async Await 模式和公用队列 API。示例代码会调用每个给定方法的异步版本，这可以通过每个方法的 Async 后修补程序体现。使用异步方法时，async-await 模式将暂停本地执行，直到调用完成。此行为允许当前的线程执行其他工作，这有助于避免性能瓶颈并提高应用程序的整体响应能力。有关在.NET 中使用 Async-Await 模式的详细信息，请参阅 <bpt id="p1">[</bpt>Async 和 Await（C# 和 Visual Basic）<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/hh191443.aspx)</ept></target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>删除队列</source>
          <target state="new">删除队列</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>若要删除队列及其包含的所有消息，请对队列对象调用 <bpt id="p1">**</bpt>Delete<ept id="p1">**</ept> 方法。</source>
          <target state="new">若要删除队列及其包含的所有消息，请对队列对象调用 <bpt id="p1">**</bpt>Delete<ept id="p1">**</ept> 方法。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>