<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6eb125377617d2eaaacfe814cf435f1d8a03d912</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>WebAPI 项目</source>
          <target state="new">WebAPI 项目</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>在 Visual Studio 中，打开您在<bpt id="p1">**</bpt>通知用户<ept id="p1">**</ept>教程中创建的 <bpt id="p2">**</bpt>AppBackend<ept id="p2">**</ept> 项目。</source>
          <target state="new">在 Visual Studio 中，打开您在<bpt id="p1">**</bpt>通知用户<ept id="p1">**</ept>教程中创建的 <bpt id="p2">**</bpt>AppBackend<ept id="p2">**</ept> 项目。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>在 Notifications.cs 中，将整个 <bpt id="p1">**</bpt>Notifications<ept id="p1">**</ept> 类替换为以下代码。请确保将占位符替换为通知中心的连接字符串（具有完全访问权限）和中心名称。可以从 <bpt id="p2">[</bpt>Azure 管理门户<ept id="p2">](http://manage.windowsazure.cn)</ept>中获取这些值。现在，该模块将表示要发送的其他安全通知。在完整的实现中，通知将存储在数据库中；为简单起见，在此示例中我们将它们存储在内存中。</source>
          <target state="new">在 Notifications.cs 中，将整个 <bpt id="p1">**</bpt>Notifications<ept id="p1">**</ept> 类替换为以下代码。请确保将占位符替换为通知中心的连接字符串（具有完全访问权限）和中心名称。可以从 <bpt id="p2">[</bpt>Azure 管理门户<ept id="p2">](http://manage.windowsazure.cn)</ept>中获取这些值。现在，该模块将表示要发送的其他安全通知。在完整的实现中，通知将存储在数据库中；为简单起见，在此示例中我们将它们存储在内存中。</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>在 NotificationsController.cs 中，将 <bpt id="p1">**</bpt>NotificationsController<ept id="p1">**</ept> 类定义中的代码替换为以下代码。该组件为设备实现了一种安全检索通知的方法，还提供了一种方法来触发到设备的安全推送（用于本教程的教学目的）。请注意，在向通知中心发送通知时，我们将只发送一个包含通知 ID（且没有实际的消息内容）的原始通知：</source>
          <target state="new">在 NotificationsController.cs 中，将 <bpt id="p1">**</bpt>NotificationsController<ept id="p1">**</ept> 类定义中的代码替换为以下代码。该组件为设备实现了一种安全检索通知的方法，还提供了一种方法来触发到设备的安全推送（用于本教程的教学目的）。请注意，在向通知中心发送通知时，我们将只发送一个包含通知 ID（且没有实际的消息内容）的原始通知：</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>请注意，<ph id="ph1">`Post`</ph> 方法现在不发送 toast 通知。它将发送只包含通知 ID 且没有任何敏感内容的原始通知。另外，请确保注释在通知中心上未配置其凭据的平台的发送操作，因为它们会导致错误。</source>
          <target state="new">请注意，<ph id="ph1">`Post`</ph> 方法现在不发送 toast 通知。它将发送只包含通知 ID 且没有任何敏感内容的原始通知。另外，请确保注释在通知中心上未配置其凭据的平台的发送操作，因为它们会导致错误。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>现在，我们将此应用重新部署到 Azure Web 应用，以便可以从所有设备对其进行访问。右键单击 <bpt id="p1">**</bpt>AppBackend<ept id="p1">**</ept> 项目，然后选择“发布”。</source>
          <target state="new">现在，我们将此应用重新部署到 Azure Web 应用，以便可以从所有设备对其进行访问。右键单击 <bpt id="p1">**</bpt>AppBackend<ept id="p1">**</ept> 项目，然后选择“发布”。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>选择 Azure Web 应用作为发布目标。使用您的 Azure 帐户登录，选择一个现有的或新的 Web 应用，并记下“连接”选项卡中的<bpt id="p1">**</bpt>目标 URL<ept id="p1">**</ept> 属性。在本教程后面的部分中，我们将此 URL 称为<bpt id="p2">*</bpt>后端终结点<ept id="p2">*</ept>。单击“发布”。</source>
          <target state="new">选择 Azure Web 应用作为发布目标。使用您的 Azure 帐户登录，选择一个现有的或新的 Web 应用，并记下“连接”选项卡中的<bpt id="p1">**</bpt>目标 URL<ept id="p1">**</ept> 属性。在本教程后面的部分中，我们将此 URL 称为<bpt id="p2">*</bpt>后端终结点<ept id="p2">*</ept>。单击“发布”。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>