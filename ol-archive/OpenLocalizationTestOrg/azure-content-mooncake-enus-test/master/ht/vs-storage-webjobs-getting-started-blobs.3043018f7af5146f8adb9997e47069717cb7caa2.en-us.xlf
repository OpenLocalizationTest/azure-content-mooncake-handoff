<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a33820e36ca8e19f7d42adbfe4efb992c0c105dc</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>开始使用 blob 存储和 Visual Studio 连接服务（WebJob 项目）| Azure</source>
          <target state="new">开始使用 blob 存储和 Visual Studio 连接服务（WebJob 项目）| Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>在使用 Visual Studio 连接服务连接到 Azure 存储后，如何开始使用 WebJob 项目中的 Blob 存储</source>
          <target state="new">在使用 Visual Studio 连接服务连接到 Azure 存储后，如何开始使用 WebJob 项目中的 Blob 存储</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>开始使用 Azure Blob 存储和 Visual Studio 连接服务（WebJob 项目）</source>
          <target state="new">开始使用 Azure Blob 存储和 Visual Studio 连接服务（WebJob 项目）</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本文章提供 C# 代码示例，用于演示如何在创建或更新 Azure blob 后触发进程。这些代码示例使用 <bpt id="p1">[</bpt>WebJobs SDK<ept id="p1">](/documentation/articles/websites-dotnet-webjobs-sdk)</ept> 版本 1.x。当你使用 Visual Studio“添加连接服务”对话框将存储帐户添加到 WebJob 项目中时，会安装相应的 Azure 存储 NuGet 包，相应的.NET 引用会添加到项目中，并会在 App.config 文件中更新存储帐户的连接字符串。</source>
          <target state="new">本文章提供 C# 代码示例，用于演示如何在创建或更新 Azure blob 后触发进程。这些代码示例使用 <bpt id="p1">[</bpt>WebJobs SDK<ept id="p1">](/documentation/articles/websites-dotnet-webjobs-sdk)</ept> 版本 1.x。当你使用 Visual Studio“添加连接服务”对话框将存储帐户添加到 WebJob 项目中时，会安装相应的 Azure 存储 NuGet 包，相应的.NET 引用会添加到项目中，并会在 App.config 文件中更新存储帐户的连接字符串。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>如何在创建或更新 Blob 后触发函数</source>
          <target state="new">如何在创建或更新 Blob 后触发函数</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>本部分说明如何使用 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 属性。</source>
          <target state="new">本部分说明如何使用 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 属性。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>注意：<ept id="p1">**</ept>WebJobs SDK 会扫描日志文件，以观察新的或更改的 blob。此过程非常缓慢；创建 blob 之后数分钟或更长时间内可能仍不会触发函数。如果你的应用程序需要立即处理 blob，推荐的方法是在创建该 blob 时创建队列消息，并在处理该 blob 的函数上使用 <bpt id="p2">[</bpt>QueueTrigger<ept id="p2">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-queues-how-to#trigger)</ept> 属性（而非 <bpt id="p3">**</bpt>BlobTrigger<ept id="p3">**</ept> 属性）。</source>
          <target state="new"><bpt id="p1">**</bpt>注意：<ept id="p1">**</ept>WebJobs SDK 会扫描日志文件，以观察新的或更改的 blob。此过程非常缓慢；创建 blob 之后数分钟或更长时间内可能仍不会触发函数。如果你的应用程序需要立即处理 blob，推荐的方法是在创建该 blob 时创建队列消息，并在处理该 blob 的函数上使用 <bpt id="p2">[</bpt>QueueTrigger<ept id="p2">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-queues-how-to#trigger)</ept> 属性（而非 <bpt id="p3">**</bpt>BlobTrigger<ept id="p3">**</ept> 属性）。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Blob 名称和扩展名的单个占位符</source>
          <target state="new">Blob 名称和扩展名的单个占位符</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>以下代码示例将<bpt id="p1">*</bpt>输入<ept id="p1">*</ept>容器中显示的文本 blob 复制到<bpt id="p2">*</bpt>输出<ept id="p2">*</ept>容器中：</source>
          <target state="new">以下代码示例将<bpt id="p1">*</bpt>输入<ept id="p1">*</ept>容器中显示的文本 blob 复制到<bpt id="p2">*</bpt>输出<ept id="p2">*</ept>容器中：</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>属性构造函数采用指定容器名称的字符串参数和 Blob 名称的占位符。在此示例中，如果在<bpt id="p1">*</bpt>输入<ept id="p1">*</ept>容器中创建了名为 <bpt id="p2">*</bpt>Blob1.txt<ept id="p2">*</ept> 的 blob，则该函数将在<bpt id="p3">*</bpt>输出<ept id="p3">*</ept>容器中创建名为 <bpt id="p4">*</bpt>Blob1.txt<ept id="p4">*</ept> 的 blob。</source>
          <target state="new">属性构造函数采用指定容器名称的字符串参数和 Blob 名称的占位符。在此示例中，如果在<bpt id="p1">*</bpt>输入<ept id="p1">*</ept>容器中创建了名为 <bpt id="p2">*</bpt>Blob1.txt<ept id="p2">*</ept> 的 blob，则该函数将在<bpt id="p3">*</bpt>输出<ept id="p3">*</ept>容器中创建名为 <bpt id="p4">*</bpt>Blob1.txt<ept id="p4">*</ept> 的 blob。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>你可以指定包含 Blob 名称占位符的名称模式，如以下代码示例中所示：</source>
          <target state="new">你可以指定包含 Blob 名称占位符的名称模式，如以下代码示例中所示：</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>此代码只会复制名称以“original-”开头的 Blob。例如，将<bpt id="p1">*</bpt>输入<ept id="p1">*</ept>容器中的 <bpt id="p2">*</bpt>original-Blob1.txt<ept id="p2">*</ept> 复制到<bpt id="p3">*</bpt>输出<ept id="p3">*</ept>容器中的 <bpt id="p4">*</bpt>copy-Blob1.txt<ept id="p4">*</ept>。</source>
          <target state="new">此代码只会复制名称以“original-”开头的 Blob。例如，将<bpt id="p1">*</bpt>输入<ept id="p1">*</ept>容器中的 <bpt id="p2">*</bpt>original-Blob1.txt<ept id="p2">*</ept> 复制到<bpt id="p3">*</bpt>输出<ept id="p3">*</ept>容器中的 <bpt id="p4">*</bpt>copy-Blob1.txt<ept id="p4">*</ept>。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>如果你需要指定的名称中包含大括号的 Blob 名称的名称模式，增加大括号。例如，如果你想要在<bpt id="p1">*</bpt>映像<ept id="p1">*</ept>容器中查找具有以下类似名称的 blob：</source>
          <target state="new">如果你需要指定的名称中包含大括号的 Blob 名称的名称模式，增加大括号。例如，如果你想要在<bpt id="p1">*</bpt>映像<ept id="p1">*</ept>容器中查找具有以下类似名称的 blob：</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>为模式使用以下代码：</source>
          <target state="new">为模式使用以下代码：</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>在示例中，<bpt id="p1">*</bpt>名称<ept id="p1">*</ept>占位符值将为 <bpt id="p2">*</bpt>soundfile.mp3<ept id="p2">*</ept>。</source>
          <target state="new">在示例中，<bpt id="p1">*</bpt>名称<ept id="p1">*</ept>占位符值将为 <bpt id="p2">*</bpt>soundfile.mp3<ept id="p2">*</ept>。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>单独的 Blob 名称和扩展名占位符</source>
          <target state="new">单独的 Blob 名称和扩展名占位符</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>以下代码示例在将<bpt id="p1">*</bpt>输入<ept id="p1">*</ept>容器中显示的 blob 复制到<bpt id="p2">*</bpt>输出<ept id="p2">*</ept>容器中时更改文件扩展名。该代码将记录<bpt id="p3">*</bpt>输入<ept id="p3">*</ept> blob 的扩展名，并将<bpt id="p4">*</bpt>输出<ept id="p4">*</ept> blob 的扩展名设置为 <bpt id="p5">*</bpt>.txt<ept id="p5">*</ept>。</source>
          <target state="new">以下代码示例在将<bpt id="p1">*</bpt>输入<ept id="p1">*</ept>容器中显示的 blob 复制到<bpt id="p2">*</bpt>输出<ept id="p2">*</ept>容器中时更改文件扩展名。该代码将记录<bpt id="p3">*</bpt>输入<ept id="p3">*</ept> blob 的扩展名，并将<bpt id="p4">*</bpt>输出<ept id="p4">*</ept> blob 的扩展名设置为 <bpt id="p5">*</bpt>.txt<ept id="p5">*</ept>。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="types"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 可绑定到 blob 的类型</source>
          <target state="new"><ph id="ph1">&lt;a id="types"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 可绑定到 blob 的类型</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>可对以下类型使用 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 属性：</source>
          <target state="new">可对以下类型使用 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 属性：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="new">string</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>TextReader</source>
          <target state="new">TextReader</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="new">Stream</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>ICloudBlob</source>
          <target state="new">ICloudBlob</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>CloudBlockBlob</source>
          <target state="new">CloudBlockBlob</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>CloudPageBlob</source>
          <target state="new">CloudPageBlob</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ICloudBlobStreamBinder<ept id="p1">](#icbsb)</ept> 反序列化的其他类型</source>
          <target state="new"><bpt id="p1">[</bpt>ICloudBlobStreamBinder<ept id="p1">](#icbsb)</ept> 反序列化的其他类型</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>如果你想要直接使用 Azure 存储帐户，则还可以向方法签名添加 <bpt id="p1">**</bpt>CloudStorageAccount<ept id="p1">**</ept> 参数。</source>
          <target state="new">如果你想要直接使用 Azure 存储帐户，则还可以向方法签名添加 <bpt id="p1">**</bpt>CloudStorageAccount<ept id="p1">**</ept> 参数。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="string"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 通过绑定到字符串获取文本 blob 内容</source>
          <target state="new"><ph id="ph1">&lt;a id="string"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 通过绑定到字符串获取文本 blob 内容</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>如果需要文本 blob，可将 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 应用到 <bpt id="p2">**</bpt>string<ept id="p2">**</ept> 参数。以下代码示例将文本 blob 绑定到名为 <bpt id="p3">**</bpt>logMessage<ept id="p3">**</ept> 的 <bpt id="p4">**</bpt>string<ept id="p4">**</ept> 参数。函数使用该参数将 Blob 的内容写入 WebJobs SDK 仪表板。</source>
          <target state="new">如果需要文本 blob，可将 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 应用到 <bpt id="p2">**</bpt>string<ept id="p2">**</ept> 参数。以下代码示例将文本 blob 绑定到名为 <bpt id="p3">**</bpt>logMessage<ept id="p3">**</ept> 的 <bpt id="p4">**</bpt>string<ept id="p4">**</ept> 参数。函数使用该参数将 Blob 的内容写入 WebJobs SDK 仪表板。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="icbsb"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 使用 ICloudBlobStreamBinder 获取序列化 blob 内容</source>
          <target state="new"><ph id="ph1">&lt;a id="icbsb"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 使用 ICloudBlobStreamBinder 获取序列化 blob 内容</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>以下代码示例使用实现 <bpt id="p1">**</bpt>ICloudBlobStreamBinder<ept id="p1">**</ept> 的类来启用 <bpt id="p2">**</bpt>BlobTrigger<ept id="p2">**</ept> 属性，将 blob 绑定到 <bpt id="p3">**</bpt>WebImage<ept id="p3">**</ept> 类型。</source>
          <target state="new">以下代码示例使用实现 <bpt id="p1">**</bpt>ICloudBlobStreamBinder<ept id="p1">**</ept> 的类来启用 <bpt id="p2">**</bpt>BlobTrigger<ept id="p2">**</ept> 属性，将 blob 绑定到 <bpt id="p3">**</bpt>WebImage<ept id="p3">**</ept> 类型。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WebImage<ept id="p1">**</ept> 绑定代码在 <bpt id="p2">**</bpt>WebImageBinder<ept id="p2">**</ept> 类中提供，该类派生自 <bpt id="p3">**</bpt>ICloudBlobStreamBinder<ept id="p3">**</ept>。</source>
          <target state="new"><bpt id="p1">**</bpt>WebImage<ept id="p1">**</ept> 绑定代码在 <bpt id="p2">**</bpt>WebImageBinder<ept id="p2">**</ept> 类中提供，该类派生自 <bpt id="p3">**</bpt>ICloudBlobStreamBinder<ept id="p3">**</ept>。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="poison"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 如何处理有害 blob</source>
          <target state="new"><ph id="ph1">&lt;a id="poison"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 如何处理有害 blob</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>当 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 函数失败时，如果失败是暂时性错误导致的，则 SDK 会再次调用该函数。如果失败是由 Blob 的内容导致的，则该函数每次尝试处理 Blob 时都会失败。默认情况下，对于给定的 Blob，SDK 调用一个函数最多 5 次。如果第五次尝试失败，SDK 会将消息添加到名为 <bpt id="p2">*</bpt>webjobs-blobtrigger-poison<ept id="p2">*</ept> 的队列中。</source>
          <target state="new">当 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 函数失败时，如果失败是暂时性错误导致的，则 SDK 会再次调用该函数。如果失败是由 Blob 的内容导致的，则该函数每次尝试处理 Blob 时都会失败。默认情况下，对于给定的 Blob，SDK 调用一个函数最多 5 次。如果第五次尝试失败，SDK 会将消息添加到名为 <bpt id="p2">*</bpt>webjobs-blobtrigger-poison<ept id="p2">*</ept> 的队列中。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>最大尝试次数可配置。将使用相同的 <bpt id="p1">[</bpt>MaxDequeueCount<ept id="p1">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-queues-how-to#configqueue)</ept> 设置处理有害 blob 和有害队列消息。</source>
          <target state="new">最大尝试次数可配置。将使用相同的 <bpt id="p1">[</bpt>MaxDequeueCount<ept id="p1">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-queues-how-to#configqueue)</ept> 设置处理有害 blob 和有害队列消息。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>有害 Blob 的队列消息是包含以下属性的 JSON 对象：</source>
          <target state="new">有害 Blob 的队列消息是包含以下属性的 JSON 对象：</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>FunctionId（格式为 <bpt id="p1">*</bpt>{WebJob name}<ept id="p1">*</ept>.Functions.<bpt id="p2">*</bpt>{Function name}<ept id="p2">*</ept>，例如 WebJob1.Functions.CopyBlob）</source>
          <target state="new">FunctionId（格式为 <bpt id="p1">*</bpt>{WebJob name}<ept id="p1">*</ept>.Functions.<bpt id="p2">*</bpt>{Function name}<ept id="p2">*</ept>，例如 WebJob1.Functions.CopyBlob）</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>BlobType（"BlockBlob" 或 "PageBlob"）</source>
          <target state="new">BlobType（"BlockBlob" 或 "PageBlob"）</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>ContainerName</source>
          <target state="new">ContainerName</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>BlobName</source>
          <target state="new">BlobName</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>ETag（blob 版本标识符，例如："0x8D1DC6E70A277EF"）</source>
          <target state="new">ETag（blob 版本标识符，例如："0x8D1DC6E70A277EF"）</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>在下面的代码示例中，<bpt id="p1">**</bpt>CopyBlob<ept id="p1">**</ept> 函数的代码导致它每次调用时都失败。SDK 进行最大重试次数的调用之后，有害 blob 队列中会创建消息，该消息通过 <bpt id="p2">**</bpt>LogPoisonBlob<ept id="p2">**</ept> 函数进行处理。</source>
          <target state="new">在下面的代码示例中，<bpt id="p1">**</bpt>CopyBlob<ept id="p1">**</ept> 函数的代码导致它每次调用时都失败。SDK 进行最大重试次数的调用之后，有害 blob 队列中会创建消息，该消息通过 <bpt id="p2">**</bpt>LogPoisonBlob<ept id="p2">**</ept> 函数进行处理。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>SDK 自动反序列化 JSON 消息。下面是 <bpt id="p1">**</bpt>PoisonBlobMessage<ept id="p1">**</ept> 类：</source>
          <target state="new">SDK 自动反序列化 JSON 消息。下面是 <bpt id="p1">**</bpt>PoisonBlobMessage<ept id="p1">**</ept> 类：</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="polling"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> Blob 轮询算法</source>
          <target state="new"><ph id="ph1">&lt;a id="polling"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> Blob 轮询算法</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>启动应用程序时，WebJobs SDK 将扫描 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 属性指定的所有容器。在大型存储帐户中，此扫描可能需要一些时间，因此在查找新 blob 和执行 <bpt id="p2">**</bpt>BlobTrigger<ept id="p2">**</ept> 函数之前，可能需要一段时间。</source>
          <target state="new">启动应用程序时，WebJobs SDK 将扫描 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 属性指定的所有容器。在大型存储帐户中，此扫描可能需要一些时间，因此在查找新 blob 和执行 <bpt id="p2">**</bpt>BlobTrigger<ept id="p2">**</ept> 函数之前，可能需要一段时间。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>若要在应用程序启动后检测新的或已更改的 Blob，SDK 会定期读取从 Blob 存储日志。blob 日志将进行缓冲，仅每隔 10 分钟左右获取物理写入，因此创建或更新 blob 后可能存在很长的延迟，然后才会执行对应的 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 函数。</source>
          <target state="new">若要在应用程序启动后检测新的或已更改的 Blob，SDK 会定期读取从 Blob 存储日志。blob 日志将进行缓冲，仅每隔 10 分钟左右获取物理写入，因此创建或更新 blob 后可能存在很长的延迟，然后才会执行对应的 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 函数。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>Blob<ept id="p1">**</ept> 属性创建的 blob 出现异常。当 WebJobs SDK 创建新 blob 时，会立即将新的 blob 传递给任何匹配的 <bpt id="p2">**</bpt>BlobTrigger<ept id="p2">**</ept> 函数。因此，如果建立了 Blob 输入和输出的链接，则 SDK 可以高效地处理它们。但是，如果你想要对通过其他方式创建或更新的 blob 降低运行 blob 处理功能的延迟时间，我们建议使用 <bpt id="p3">**</bpt>QueueTrigger<ept id="p3">**</ept>（而不是 <bpt id="p4">**</bpt>BlobTrigger<ept id="p4">**</ept>）。</source>
          <target state="new">使用 <bpt id="p1">**</bpt>Blob<ept id="p1">**</ept> 属性创建的 blob 出现异常。当 WebJobs SDK 创建新 blob 时，会立即将新的 blob 传递给任何匹配的 <bpt id="p2">**</bpt>BlobTrigger<ept id="p2">**</ept> 函数。因此，如果建立了 Blob 输入和输出的链接，则 SDK 可以高效地处理它们。但是，如果你想要对通过其他方式创建或更新的 blob 降低运行 blob 处理功能的延迟时间，我们建议使用 <bpt id="p3">**</bpt>QueueTrigger<ept id="p3">**</ept>（而不是 <bpt id="p4">**</bpt>BlobTrigger<ept id="p4">**</ept>）。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="receipts"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> Blob 回执</source>
          <target state="new"><ph id="ph1">&lt;a id="receipts"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> Blob 回执</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>WebJobs SDK 确保没有为相同的新 blob 或更新 blob 多次调用 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 函数。为此，它会维护 <bpt id="p2">*</bpt>blob 回执<ept id="p2">*</ept>，以确定是否已处理给定的 blob 版本。</source>
          <target state="new">WebJobs SDK 确保没有为相同的新 blob 或更新 blob 多次调用 <bpt id="p1">**</bpt>BlobTrigger<ept id="p1">**</ept> 函数。为此，它会维护 <bpt id="p2">*</bpt>blob 回执<ept id="p2">*</ept>，以确定是否已处理给定的 blob 版本。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Blob 回执在 AzureWebJobsStorage 连接字符串指定的 Azure 存储帐户中名为 <bpt id="p1">*</bpt>azure-webjobs-hosts<ept id="p1">*</ept> 的容器内存储。Blob 回执包含以下信息：</source>
          <target state="new">Blob 回执在 AzureWebJobsStorage 连接字符串指定的 Azure 存储帐户中名为 <bpt id="p1">*</bpt>azure-webjobs-hosts<ept id="p1">*</ept> 的容器内存储。Blob 回执包含以下信息：</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>为 blob 调用的函数（"<bpt id="p1">*</bpt>{WebJob name}<ept id="p1">*</ept>.Functions.<bpt id="p2">*</bpt>{Function name}<ept id="p2">*</ept>"，例如 "WebJob1.Functions.CopyBlob"）</source>
          <target state="new">为 blob 调用的函数（"<bpt id="p1">*</bpt>{WebJob name}<ept id="p1">*</ept>.Functions.<bpt id="p2">*</bpt>{Function name}<ept id="p2">*</ept>"，例如 "WebJob1.Functions.CopyBlob"）</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>容器名称</source>
          <target state="new">容器名称</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Blob 类型（"BlockBlob" 或 "PageBlob"）</source>
          <target state="new">Blob 类型（"BlockBlob" 或 "PageBlob"）</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Blob 名称</source>
          <target state="new">Blob 名称</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>ETag（blob 版本标识符，例如："0x8D1DC6E70A277EF"）</source>
          <target state="new">ETag（blob 版本标识符，例如："0x8D1DC6E70A277EF"）</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>如果您想要强制重新处理某个 blob，则可以从 <bpt id="p1">*</bpt>azure-webjobs-hosts<ept id="p1">*</ept> 容器中手动删除该 blob 的 blob 回执。</source>
          <target state="new">如果您想要强制重新处理某个 blob，则可以从 <bpt id="p1">*</bpt>azure-webjobs-hosts<ept id="p1">*</ept> 容器中手动删除该 blob 的 blob 回执。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="queues"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 队列文章涵盖的相关主题</source>
          <target state="new"><ph id="ph1">&lt;a id="queues"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 队列文章涵盖的相关主题</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>有关如何处理队列消息触发的 blob 处理，或者不特定于 blob 处理的 WebJobs SDK 方案的信息，请参阅<bpt id="p1">[</bpt>如何通过 WebJobs SDK 使用 Azure 队列存储<ept id="p1">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-queues-how-to)</ept>。</source>
          <target state="new">有关如何处理队列消息触发的 blob 处理，或者不特定于 blob 处理的 WebJobs SDK 方案的信息，请参阅<bpt id="p1">[</bpt>如何通过 WebJobs SDK 使用 Azure 队列存储<ept id="p1">](/documentation/articles/websites-dotnet-webjobs-sdk-storage-queues-how-to)</ept>。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>该文章涵盖的相关主题包括：</source>
          <target state="new">该文章涵盖的相关主题包括：</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>异步函数</source>
          <target state="new">异步函数</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>多个实例</source>
          <target state="new">多个实例</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>正常关闭</source>
          <target state="new">正常关闭</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>在函数正文中使用 WebJobs SDK 属性</source>
          <target state="new">在函数正文中使用 WebJobs SDK 属性</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>在代码中设置 SDK 连接字符串。</source>
          <target state="new">在代码中设置 SDK 连接字符串。</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>在代码中设置 WebJobs SDK 构造函数参数的值</source>
          <target state="new">在代码中设置 WebJobs SDK 构造函数参数的值</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>配置 <bpt id="p1">**</bpt>MaxDequeueCount<ept id="p1">**</ept>，以便进行有害 blob 的处理。</source>
          <target state="new">配置 <bpt id="p1">**</bpt>MaxDequeueCount<ept id="p1">**</ept>，以便进行有害 blob 的处理。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>手动触发函数</source>
          <target state="new">手动触发函数</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>写入日志</source>
          <target state="new">写入日志</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a id="nextsteps"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>后续步骤</source>
          <target state="new"><ph id="ph1">&lt;a id="nextsteps"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>后续步骤</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>本文提供了代码示例，演示如何处理用于操作 Azure blob 的常见方案。有关如何使用 Azure WebJobs 和 WebJobs SDK 的详细信息，请参阅 <bpt id="p1">[</bpt>Azure WebJobs 推荐资源<ept id="p1">](/documentation/articles/websites-webjobs-resources)</ept>。</source>
          <target state="new">本文提供了代码示例，演示如何处理用于操作 Azure blob 的常见方案。有关如何使用 Azure WebJobs 和 WebJobs SDK 的详细信息，请参阅 <bpt id="p1">[</bpt>Azure WebJobs 推荐资源<ept id="p1">](/documentation/articles/websites-webjobs-resources)</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>