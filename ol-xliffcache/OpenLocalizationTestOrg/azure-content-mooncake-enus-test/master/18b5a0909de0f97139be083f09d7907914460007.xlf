<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">18b5a0909de0f97139be083f09d7907914460007</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>自定义身份验证入门 | Azure</source>
          <target state="new">自定义身份验证入门 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何使用用户名和密码对用户进行身份验证。</source>
          <target state="new">了解如何使用用户名和密码对用户进行身份验证。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>自定义身份验证入门</source>
          <target state="new">自定义身份验证入门</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;</source>
          <target state="new">&amp;nbsp;</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>本主题说明如何通过颁发自己的移动服务身份验证令牌，对 Azure 移动服务 .NET 后端中的用户进行身份验证。在本教程中，你将使用应用程序的自定义用户名和密码向快速入门项目添加身份验证。</source>
          <target state="new">本主题说明如何通过颁发自己的移动服务身份验证令牌，对 Azure 移动服务 .NET 后端中的用户进行身份验证。在本教程中，你将使用应用程序的自定义用户名和密码向快速入门项目添加身份验证。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>本教程演示了使用自定义凭据对移动服务进行身份验证的高级方法。许多应用程序最好是改用内置的社交标识提供程序，以便让用户通过 Microsoft 帐户和 Azure Active Directory 登录。如果你这是第一次体验移动服务中的身份验证，请参阅<bpt id="p1">[</bpt><ept id="p1">向应用程序添加身份验证]</ept>教程。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>本教程演示了使用自定义凭据对移动服务进行身份验证的高级方法。许多应用程序最好是改用内置的社交标识提供程序，以便让用户通过 Microsoft 帐户和 Azure Active Directory 登录。如果你这是第一次体验移动服务中的身份验证，请参阅<bpt id="p1">[</bpt><ept id="p1">向应用程序添加身份验证]</ept>教程。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>本教程基于移动服务快速入门。此外，还必须先完成<bpt id="p1">[</bpt><ept id="p1">移动服务入门]</ept>教程。</source>
          <target state="new">本教程基于移动服务快速入门。此外，还必须先完成<bpt id="p1">[</bpt><ept id="p1">移动服务入门]</ept>教程。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>本教程旨在说明如何颁发移动服务的身份验证令牌。请不要将其视为安全指导原则。在开发应用程序时，你必须留意密码存储的安全问题，并且需要制定暴力破解攻击的管理策略。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>本教程旨在说明如何颁发移动服务的身份验证令牌。请不要将其视为安全指导原则。在开发应用程序时，你必须留意密码存储的安全问题，并且需要制定暴力破解攻击的管理策略。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>设置帐户表</source>
          <target state="new">设置帐户表</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>由于你使用自定义身份验证，且未依赖其他标识提供程序，因此需要存储用户的登录信息。在本部分中，你将为帐户创建一个表，并设置基本的安全性机制。帐户表包含用户名和加盐哈希密码，你也可以视需要加入其他用户信息。</source>
          <target state="new">由于你使用自定义身份验证，且未依赖其他标识提供程序，因此需要存储用户的登录信息。在本部分中，你将为帐户创建一个表，并设置基本的安全性机制。帐户表包含用户名和加盐哈希密码，你也可以视需要加入其他用户信息。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>在后端项目的 <bpt id="p1">**</bpt>DataObjects<ept id="p1">**</ept> 数据夹中，创建名为 <ph id="ph1">`Account`</ph> 的新实体。</source>
          <target state="new">在后端项目的 <bpt id="p1">**</bpt>DataObjects<ept id="p1">**</ept> 数据夹中，创建名为 <ph id="ph1">`Account`</ph> 的新实体。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>添加以下 <ph id="ph1">`using`</ph> 语句：</source>
          <target state="new">添加以下 <ph id="ph1">`using`</ph> 语句：</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>将类定义替换为以下代码：</source>
          <target state="new">将类定义替换为以下代码：</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>这样，我们的新帐户表中将会显示一行，其中包含用户名、该用户的盐以及安全存储的密码。</source>
          <target state="new">这样，我们的新帐户表中将会显示一行，其中包含用户名、该用户的盐以及安全存储的密码。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>Models<ept id="p1">**</ept> 文件夹下，你将会看到与移动服务同名的 <bpt id="p2">**</bpt>DbContext<ept id="p2">**</ept> 派生类。请打开你的内容并添加以下代码，将帐户表添加到数据模型：</source>
          <target state="new">在 <bpt id="p1">**</bpt>Models<ept id="p1">**</ept> 文件夹下，你将会看到与移动服务同名的 <bpt id="p2">**</bpt>DbContext<ept id="p2">**</ept> 派生类。请打开你的内容并添加以下代码，将帐户表添加到数据模型：</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>本教程中的代码段使用 <ph id="ph2">`todoContext`</ph> 作为上下文名称。你必须更新项目上下文的代码段。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>本教程中的代码段使用 <ph id="ph2">`todoContext`</ph> 作为上下文名称。你必须更新项目上下文的代码段。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;</source>
          <target state="new">&amp;nbsp;</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>接下来，请设置安全功能以处理此数据。</source>
          <target state="new">接下来，请设置安全功能以处理此数据。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>创建名为 <ph id="ph1">`CustomLoginProviderUtils`</ph> 的类，然后添加以下 <ph id="ph2">`using`</ph> 语句：</source>
          <target state="new">创建名为 <ph id="ph1">`CustomLoginProviderUtils`</ph> 的类，然后添加以下 <ph id="ph2">`using`</ph> 语句：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>将以下代码方法添加到新类：</source>
          <target state="new">将以下代码方法添加到新类：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>创建注册终结点</source>
          <target state="new">创建注册终结点</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>此时，创建用户帐户的各项准备都已完成。在本部分中，你将设置注册终结点以处理新的注册请求。你将在此处强制实施新的用户名和密码策略，并确保用户名不会盗用。然后，你要将用户信息安全存储在数据库中。</source>
          <target state="new">此时，创建用户帐户的各项准备都已完成。在本部分中，你将设置注册终结点以处理新的注册请求。你将在此处强制实施新的用户名和密码策略，并确保用户名不会盗用。然后，你要将用户信息安全存储在数据库中。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>创建以下新类用于表示传入的注册尝试：</source>
          <target state="new">创建以下新类用于表示传入的注册尝试：</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>如果你要在注册期间收集和存储其他信息，应该在此处执行相应的操作。</source>
          <target state="new">如果你要在注册期间收集和存储其他信息，应该在此处执行相应的操作。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>在移动服务后端项目中，右键单击“控制器”，单击“添加”和“控制器”，创建名为 <ph id="ph1">`CustomRegistrationController`</ph> 的新“Azure 移动服务自定义控制器”，然后添加以下 <ph id="ph2">`using`</ph> 语句：</source>
          <target state="new">在移动服务后端项目中，右键单击“控制器”，单击“添加”和“控制器”，创建名为 <ph id="ph1">`CustomRegistrationController`</ph> 的新“Azure 移动服务自定义控制器”，然后添加以下 <ph id="ph2">`using`</ph> 语句：</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>在以上代码中，将占位符替换为项目的命名空间。</source>
          <target state="new">在以上代码中，将占位符替换为项目的命名空间。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>将类定义替换为以下代码：</source>
          <target state="new">将类定义替换为以下代码：</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>请记得将 <bpt id="p1">*</bpt>todoContext<ept id="p1">*</ept> 变量替换为项目的 <bpt id="p2">**</bpt>DbContext<ept id="p2">**</ept> 的名称。请注意，此控制器使用以下属性来允许发往此终结点的所有流量：</source>
          <target state="new">请记得将 <bpt id="p1">*</bpt>todoContext<ept id="p1">*</ept> 变量替换为项目的 <bpt id="p2">**</bpt>DbContext<ept id="p2">**</ept> 的名称。请注意，此控制器使用以下属性来允许发往此终结点的所有流量：</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>任何客户端均可通过 HTTP 访问此注册终结点。将此服务发布到生产环境之前，应实现某种形式的方案来验证注册，例如 SMS 或基于电子邮件的验证。这有助于防止恶意用户创建欺骗性的注册。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>任何客户端均可通过 HTTP 访问此注册终结点。将此服务发布到生产环境之前，应实现某种形式的方案来验证注册，例如 SMS 或基于电子邮件的验证。这有助于防止恶意用户创建欺骗性的注册。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>创建 LoginProvider</source>
          <target state="new">创建 LoginProvider</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>LoginProvider<ept id="p1">**</ept> 是移动服务身份验证管道中的基础构造之一。在本部分中，你将创建自己的 <ph id="ph1">`CustomLoginProvider`</ph>。它并不会像内置提供程序一样插入管道中，但会为你提供方便的功能。</source>
          <target state="new"><bpt id="p1">**</bpt>LoginProvider<ept id="p1">**</ept> 是移动服务身份验证管道中的基础构造之一。在本部分中，你将创建自己的 <ph id="ph1">`CustomLoginProvider`</ph>。它并不会像内置提供程序一样插入管道中，但会为你提供方便的功能。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>如果你使用 Visual Studio 2013，则可能需要安装 <ph id="ph1">`WindowsAzure.MobileServices.Backend.Security`</ph> Nuget 包才能添加对 <ph id="ph2">`LoginProvider`</ph> 类的引用。</source>
          <target state="new">如果你使用 Visual Studio 2013，则可能需要安装 <ph id="ph1">`WindowsAzure.MobileServices.Backend.Security`</ph> Nuget 包才能添加对 <ph id="ph2">`LoginProvider`</ph> 类的引用。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>创建派生自 <bpt id="p1">**</bpt>LoginProvider<ept id="p1">**</ept> 的新类 <ph id="ph1">`CustomLoginProvider`</ph>，然后添加以下 <ph id="ph2">`using`</ph> 语句：</source>
          <target state="new">创建派生自 <bpt id="p1">**</bpt>LoginProvider<ept id="p1">**</ept> 的新类 <ph id="ph1">`CustomLoginProvider`</ph>，然后添加以下 <ph id="ph2">`using`</ph> 语句：</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>将 <bpt id="p1">**</bpt>CustomLoginProvider<ept id="p1">**</ept> 类定义替换为以下代码：</source>
          <target state="new">将 <bpt id="p1">**</bpt>CustomLoginProvider<ept id="p1">**</ept> 类定义替换为以下代码：</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>在同一个代码文件中创建名为 <ph id="ph1">`CustomLoginProviderCredentials`</ph> 的新类。</source>
          <target state="new">在同一个代码文件中创建名为 <ph id="ph1">`CustomLoginProviderCredentials`</ph> 的新类。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>此类表示有关用户的信息，将通过 <bpt id="p1">[</bpt>GetIdentitiesAsync<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/azure/microsoft.windowsazure.mobile.service.security.serviceuser.getidentitiesasync.aspx)</ept> 在后端上供你使用。如果你要添加自定义声明，请确保可在此对象中捕获这些声明。</source>
          <target state="new">此类表示有关用户的信息，将通过 <bpt id="p1">[</bpt>GetIdentitiesAsync<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/azure/microsoft.windowsazure.mobile.service.security.serviceuser.getidentitiesasync.aspx)</ept> 在后端上供你使用。如果你要添加自定义声明，请确保可在此对象中捕获这些声明。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>将抽象方法 <ph id="ph1">`ConfigureMiddleware`</ph> 的以下实现添加到 <bpt id="p1">**</bpt>CustomLoginProvider<ept id="p1">**</ept>。</source>
          <target state="new">将抽象方法 <ph id="ph1">`ConfigureMiddleware`</ph> 的以下实现添加到 <bpt id="p1">**</bpt>CustomLoginProvider<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>此方法尚未实现，因为 <bpt id="p1">**</bpt>CustomLoginProvider<ept id="p1">**</ept> 不会与身份验证管道集成。</source>
          <target state="new">此方法尚未实现，因为 <bpt id="p1">**</bpt>CustomLoginProvider<ept id="p1">**</ept> 不会与身份验证管道集成。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>将抽象方法 <ph id="ph1">`ParseCredentials`</ph> 的以下实现添加到 <bpt id="p1">**</bpt>CustomLoginProvider<ept id="p1">**</ept>。</source>
          <target state="new">将抽象方法 <ph id="ph1">`ParseCredentials`</ph> 的以下实现添加到 <bpt id="p1">**</bpt>CustomLoginProvider<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>此方法将使后端能够从传入的身份验证令牌反序列化用户信息。</source>
          <target state="new">此方法将使后端能够从传入的身份验证令牌反序列化用户信息。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>将抽象方法 <ph id="ph1">`CreateCredentials`</ph> 的以下实现添加到 <bpt id="p1">**</bpt>CustomLoginProvider<ept id="p1">**</ept>。</source>
          <target state="new">将抽象方法 <ph id="ph1">`CreateCredentials`</ph> 的以下实现添加到 <bpt id="p1">**</bpt>CustomLoginProvider<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>此方法将 <bpt id="p1">[</bpt><ept id="p1">ClaimsIdentity]</ept> 转换成在身份验证令牌颁发阶段使用的 <bpt id="p2">[</bpt><ept id="p2">ProviderCredentials]</ept> 对象。在此方法中，你可以再次捕获任何其他声明。</source>
          <target state="new">此方法将 <bpt id="p1">[</bpt><ept id="p1">ClaimsIdentity]</ept> 转换成在身份验证令牌颁发阶段使用的 <bpt id="p2">[</bpt><ept id="p2">ProviderCredentials]</ept> 对象。在此方法中，你可以再次捕获任何其他声明。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>创建 <bpt id="p1">**</bpt>ConfigOptions<ept id="p1">**</ept> 后，打开 App\_Start 文件夹中的 WebApiConfig.cs 项目文件并添加以下代码行:</source>
          <target state="new">创建 <bpt id="p1">**</bpt>ConfigOptions<ept id="p1">**</ept> 后，打开 App\_Start 文件夹中的 WebApiConfig.cs 项目文件并添加以下代码行:</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>创建登录终结点</source>
          <target state="new">创建登录终结点</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>接下来，需要创建一个终结点，使你的用户能够登录。系统会根据数据库检查你所收到的用户名和密码，方法是应用用户的盐，哈希处理密码，然后确保传入值与数据库的值匹配。如果匹配，则你可以创建 <bpt id="p1">[</bpt><ept id="p1">ClaimsIdentity]</ept> 并将其传递给 <bpt id="p2">**</bpt>CustomLoginProvider<ept id="p2">**</ept>。客户端应用程序将接收用户 ID 和身份验证令牌，以进一步访问你的移动服务。</source>
          <target state="new">接下来，需要创建一个终结点，使你的用户能够登录。系统会根据数据库检查你所收到的用户名和密码，方法是应用用户的盐，哈希处理密码，然后确保传入值与数据库的值匹配。如果匹配，则你可以创建 <bpt id="p1">[</bpt><ept id="p1">ClaimsIdentity]</ept> 并将其传递给 <bpt id="p2">**</bpt>CustomLoginProvider<ept id="p2">**</ept>。客户端应用程序将接收用户 ID 和身份验证令牌，以进一步访问你的移动服务。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>在移动服务后端项目中创建以下新的 <ph id="ph1">`LoginRequest`</ph> 类：</source>
          <target state="new">在移动服务后端项目中创建以下新的 <ph id="ph1">`LoginRequest`</ph> 类：</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>此类表示传入的登录尝试。</source>
          <target state="new">此类表示传入的登录尝试。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>创建以下新的 <ph id="ph1">`CustomLoginResult`</ph> 类：</source>
          <target state="new">创建以下新的 <ph id="ph1">`CustomLoginResult`</ph> 类：</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>此类表示使用用户 ID 和身份验证令牌成功完成的登录。请注意，此类和客户端的 MobileServiceUser 类具有相同形式，因此，使用此类可以轻松地将登录响应传递给强类型化客户端。</source>
          <target state="new">此类表示使用用户 ID 和身份验证令牌成功完成的登录。请注意，此类和客户端的 MobileServiceUser 类具有相同形式，因此，使用此类可以轻松地将登录响应传递给强类型化客户端。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>右键单击“控制器”，单击“添加”和“控制器”，创建名为 <ph id="ph1">`CustomLoginController`</ph> 的新“Azure 移动服务自定义控制器”，然后添加以下 <ph id="ph2">`using`</ph> 语句：</source>
          <target state="new">右键单击“控制器”，单击“添加”和“控制器”，创建名为 <ph id="ph1">`CustomLoginController`</ph> 的新“Azure 移动服务自定义控制器”，然后添加以下 <ph id="ph2">`using`</ph> 语句：</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>将 <bpt id="p1">**</bpt>CustomLoginController<ept id="p1">**</ept> 类定义替换为以下代码：</source>
          <target state="new">将 <bpt id="p1">**</bpt>CustomLoginController<ept id="p1">**</ept> 类定义替换为以下代码：</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>用于生产环境的 <ph id="ph2">`CustomLoginController`</ph> 也应包含暴力破解攻击检测策略。否则，你的登录解决方案可能容易受到攻击。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>用于生产环境的 <ph id="ph2">`CustomLoginController`</ph> 也应包含暴力破解攻击检测策略。否则，你的登录解决方案可能容易受到攻击。</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>将移动服务配置为要求身份验证</source>
          <target state="new">将移动服务配置为要求身份验证</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>使用测试客户端测试登录流</source>
          <target state="new">使用测试客户端测试登录流</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>在客户端应用程序中，必须开发一个自定义登录屏幕，以捕获用户名和密码，并将其以 JSON 负载形式发送到你的注册和登录终结点。要完成本教程，你只需使用移动服务 .NET 后端的内置测试客户端。</source>
          <target state="new">在客户端应用程序中，必须开发一个自定义登录屏幕，以捕获用户名和密码，并将其以 JSON 负载形式发送到你的注册和登录终结点。要完成本教程，你只需使用移动服务 .NET 后端的内置测试客户端。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>在 Visual Studio 中，右键单击移动服务项目，然后单击“调试”和“启动新实例”。</source>
          <target state="new">在 Visual Studio 中，右键单击移动服务项目，然后单击“调试”和“启动新实例”。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>随后会启动移动服务后端项目的新调试实例。成功启动服务之后，你会看到显示“此移动服务在正常运行”的启动页。</source>
          <target state="new">随后会启动移动服务后端项目的新调试实例。成功启动服务之后，你会看到显示“此移动服务在正常运行”的启动页。</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>在服务启动页中，单击“试用”，然后在身份验证对话框中，键入你在 web.config 文件的 <bpt id="p1">**</bpt>MS\_ApplicationKey<ept id="p1">**</ept> 应用程序设置中设置的密码，并将用户名保留空白。</source>
          <target state="new">在服务启动页中，单击“试用”，然后在身份验证对话框中，键入你在 web.config 文件的 <bpt id="p1">**</bpt>MS\_ApplicationKey<ept id="p1">**</ept> 应用程序设置中设置的密码，并将用户名保留空白。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>在帮助页中，单击“CustomRegistration”终结点，然后单击“试用”。</source>
          <target state="new">在帮助页中，单击“CustomRegistration”终结点，然后单击“试用”。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>在正文中，将示例字符串替换为符合前面所指定条件的用户名和密码，然后单击“发送”。</source>
          <target state="new">在正文中，将示例字符串替换为符合前面所指定条件的用户名和密码，然后单击“发送”。</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>响应应为“201/已创建”。</source>
          <target state="new">响应应为“201/已创建”。</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>单击浏览器中的后退按钮，并使用前一步骤中注册的同一用户名和密码，对 <bpt id="p1">**</bpt>CustomLogin<ept id="p1">**</ept> 终结点重复步骤 2 和 3。</source>
          <target state="new">单击浏览器中的后退按钮，并使用前一步骤中注册的同一用户名和密码，对 <bpt id="p1">**</bpt>CustomLogin<ept id="p1">**</ept> 终结点重复步骤 2 和 3。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>你应会收到响应消息，其正文包含一个具有 <bpt id="p1">*</bpt>userId<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>authenticationToken<ept id="p2">*</ept> 的 <bpt id="p3">**</bpt>user<ept id="p3">**</ept> JSON 对象，此对象是自定义身份验证生成的移动服务身份验证令牌。此令牌足以授予客户端应用程序访问 TodoItem 终结点的权限。</source>
          <target state="new">你应会收到响应消息，其正文包含一个具有 <bpt id="p1">*</bpt>userId<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>authenticationToken<ept id="p2">*</ept> 的 <bpt id="p3">**</bpt>user<ept id="p3">**</ept> JSON 对象，此对象是自定义身份验证生成的移动服务身份验证令牌。此令牌足以授予客户端应用程序访问 TodoItem 终结点的权限。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>复制 <bpt id="p1">*</bpt>authenticationToken<ept id="p1">*</ept> 的值。稍后你将使用此值来访问受限制的 TodoItem 终结点。</source>
          <target state="new">复制 <bpt id="p1">*</bpt>authenticationToken<ept id="p1">*</ept> 的值。稍后你将使用此值来访问受限制的 TodoItem 终结点。</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>单击浏览器中的后退按钮，然后在 API 文档页中，依次单击“GetTables”、“试用”。</source>
          <target state="new">单击浏览器中的后退按钮，然后在 API 文档页中，依次单击“GetTables”、“试用”。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>在 GET 请求对话框中，单击“标头”旁边的加号，在左侧框中键入 <ph id="ph1">`X-ZUMO-AUTH`</ph> 值，在右侧框中粘贴复制的 <bpt id="p1">*</bpt>authenticationToken<ept id="p1">*</ept> 值，然后单击“发送”。</source>
          <target state="new">在 GET 请求对话框中，单击“标头”旁边的加号，在左侧框中键入 <ph id="ph1">`X-ZUMO-AUTH`</ph> 值，在右侧框中粘贴复制的 <bpt id="p1">*</bpt>authenticationToken<ept id="p1">*</ept> 值，然后单击“发送”。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>移动服务应会授予访问终结点的权限，并返回“200/正常”状态，以及表中的 TodoItems 列表。</source>
          <target state="new">移动服务应会授予访问终结点的权限，并返回“200/正常”状态，以及表中的 TodoItems 列表。</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>如果你选择还要将此移动服务项目发布到 Azure 以供测试，请记住，登录和身份验证提供程序将很容易受到攻击。确保这些提供程序已经过适当的增强，或者受保护的测试数据对你而言并不重要。使用自定义身份验证方案之前请保持谨慎，以确保生产环境服务的安全。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>如果你选择还要将此移动服务项目发布到 Azure 以供测试，请记住，登录和身份验证提供程序将很容易受到攻击。确保这些提供程序已经过适当的增强，或者受保护的测试数据对你而言并不重要。使用自定义身份验证方案之前请保持谨慎，以确保生产环境服务的安全。</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>使用自定义身份验证从客户端登录</source>
          <target state="new">使用自定义身份验证从客户端登录</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>本部分介绍在从客户端访问自定义身份验证终结点，以获取访问移动服务所需的身份验证令牌时需要执行的步骤。由于所需的特定客户端代码取决于客户端，因此，此处提供的指引与平台无关。</source>
          <target state="new">本部分介绍在从客户端访问自定义身份验证终结点，以获取访问移动服务所需的身份验证令牌时需要执行的步骤。由于所需的特定客户端代码取决于客户端，因此，此处提供的指引与平台无关。</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>移动服务客户端库通过 HTTPS 与服务通信。由于此解决方案需要你以纯文本发送密码，因此请务必在使用直接 REST 请求调用这些终结点时，使用 HTTPS。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>移动服务客户端库通过 HTTPS 与服务通信。由于此解决方案需要你以纯文本发送密码，因此请务必在使用直接 REST 请求调用这些终结点时，使用 HTTPS。</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>在客户端应用程序中创建所需的 UI 元素，以允许用户输入用户名和密码。</source>
          <target state="new">在客户端应用程序中创建所需的 UI 元素，以允许用户输入用户名和密码。</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>在客户端库的 <bpt id="p1">**</bpt>MobileServiceClient<ept id="p1">**</ept> 上使用适当的 <bpt id="p2">**</bpt>invokeApi<ept id="p2">**</ept> 方法调用 <bpt id="p3">**</bpt>CustomRegistration<ept id="p3">**</ept> 终结点，以在消息正文中传递运行时提供的用户名和密码。</source>
          <target state="new">在客户端库的 <bpt id="p1">**</bpt>MobileServiceClient<ept id="p1">**</ept> 上使用适当的 <bpt id="p2">**</bpt>invokeApi<ept id="p2">**</ept> 方法调用 <bpt id="p3">**</bpt>CustomRegistration<ept id="p3">**</ept> 终结点，以在消息正文中传递运行时提供的用户名和密码。</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>如果你在“帐户”表中保留了用户登录信息，则你只需调用 <bpt id="p1">**</bpt>CustomRegistration<ept id="p1">**</ept> 终结点一次，即可为给定的用户创建帐户。有关如何在支持的各种客户端平台上调用自定义 API 的示例，请参阅文章 <bpt id="p2">[</bpt>Azure 移动服务中的自定义 API – 客户端 SDK<ept id="p2">](http://blogs.msdn.com/b/carlosfigueira/archive/2013/06/19/custom-api-in-azure-mobile-services-client-sdks.aspx)</ept>。</source>
          <target state="new">如果你在“帐户”表中保留了用户登录信息，则你只需调用 <bpt id="p1">**</bpt>CustomRegistration<ept id="p1">**</ept> 终结点一次，即可为给定的用户创建帐户。有关如何在支持的各种客户端平台上调用自定义 API 的示例，请参阅文章 <bpt id="p2">[</bpt>Azure 移动服务中的自定义 API – 客户端 SDK<ept id="p2">](http://blogs.msdn.com/b/carlosfigueira/archive/2013/06/19/custom-api-in-azure-mobile-services-client-sdks.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>由于此用户设置步骤只会发生一次，因此你可以考虑以某种带外方式创建用户帐户。对于公共注册终结点，还应该考虑实施基于短信或电子邮件的验证过程或者其他防护机制，以避免生成欺骗性的帐户。你可以使用 Twilio 从移动服务发送短信。也可以使用 SendGrid 从移动服务发送电子邮件。有关使用 SendGrid 的详细信息，请参阅<bpt id="p1">[</bpt>使用 SendGrid 从移动服务发送电子邮件<ept id="p1">](/documentation/articles/store-sendgrid-mobile-services-send-email-scripts)</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>由于此用户设置步骤只会发生一次，因此你可以考虑以某种带外方式创建用户帐户。对于公共注册终结点，还应该考虑实施基于短信或电子邮件的验证过程或者其他防护机制，以避免生成欺骗性的帐户。你可以使用 Twilio 从移动服务发送短信。也可以使用 SendGrid 从移动服务发送电子邮件。有关使用 SendGrid 的详细信息，请参阅<bpt id="p1">[</bpt>使用 SendGrid 从移动服务发送电子邮件<ept id="p1">](/documentation/articles/store-sendgrid-mobile-services-send-email-scripts)</ept>。</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>再次使用适当的 <bpt id="p1">**</bpt>invokeApi<ept id="p1">**</ept> 方法，但这次改为调用 <bpt id="p2">**</bpt>CustomLogin<ept id="p2">**</ept> 终结点，以在消息正文中传递运行时提供的用户名和密码。</source>
          <target state="new">再次使用适当的 <bpt id="p1">**</bpt>invokeApi<ept id="p1">**</ept> 方法，但这次改为调用 <bpt id="p2">**</bpt>CustomLogin<ept id="p2">**</ept> 终结点，以在消息正文中传递运行时提供的用户名和密码。</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>这次你必须在成功登录后，捕获响应对象中返回的 <bpt id="p1">*</bpt>userId<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>authenticationToken<ept id="p2">*</ept> 值。</source>
          <target state="new">这次你必须在成功登录后，捕获响应对象中返回的 <bpt id="p1">*</bpt>userId<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>authenticationToken<ept id="p2">*</ept> 值。</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>使用返回的 <bpt id="p1">*</bpt>userId<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>authenticationToken<ept id="p2">*</ept> 值创建新的 <bpt id="p3">**</bpt>MobileServiceUser<ept id="p3">**</ept> 对象，并将该对象设为 <bpt id="p4">**</bpt>MobileServiceClient<ept id="p4">**</ept> 实例的当前用户，如<bpt id="p5">[</bpt>向现有应用程序添加身份验证<ept id="p5">](/documentation/articles/mobile-services-dotnet-backend-ios-get-started-users)</ept>主题中所述。由于 CustomLogin 的结果与 <bpt id="p6">**</bpt>MobileServiceUser<ept id="p6">**</ept> 对象具有相同形式，因此你应该能够直接转换结果。</source>
          <target state="new">使用返回的 <bpt id="p1">*</bpt>userId<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>authenticationToken<ept id="p2">*</ept> 值创建新的 <bpt id="p3">**</bpt>MobileServiceUser<ept id="p3">**</ept> 对象，并将该对象设为 <bpt id="p4">**</bpt>MobileServiceClient<ept id="p4">**</ept> 实例的当前用户，如<bpt id="p5">[</bpt>向现有应用程序添加身份验证<ept id="p5">](/documentation/articles/mobile-services-dotnet-backend-ios-get-started-users)</ept>主题中所述。由于 CustomLogin 的结果与 <bpt id="p6">**</bpt>MobileServiceUser<ept id="p6">**</ept> 对象具有相同形式，因此你应该能够直接转换结果。</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>本教程到此结束。</source>
          <target state="new">本教程到此结束。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>