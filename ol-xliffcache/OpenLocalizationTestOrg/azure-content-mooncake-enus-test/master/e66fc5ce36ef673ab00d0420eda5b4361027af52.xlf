<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e66fc5ce36ef673ab00d0420eda5b4361027af52</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>在 Ubuntu 上使用资源管理器模板创建 MongoDB 群集</source>
          <target state="new">在 Ubuntu 上使用资源管理器模板创建 MongoDB 群集</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>通过 PowerShell 或 Azure CLI 使用资源管理器模板在 Ubuntu 上创建 MongoDB 群集</source>
          <target state="new">通过 PowerShell 或 Azure CLI 使用资源管理器模板在 Ubuntu 上创建 MongoDB 群集</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>在 Ubuntu 上使用资源管理器模板创建 MongoDB 群集</source>
          <target state="new">在 Ubuntu 上使用资源管理器模板创建 MongoDB 群集</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>MongoDB 是一种可提供高性能、高可用性和自动缩放的开源文档数据库。MongoDB 可独立安装或利用内置的复制功能在群集内安装。在某些情况下，你可使用复制来提高读取容量。客户端能够将读取和写入操作发送到不同的服务器。你还可以在不同数据中心中维护副本，以增加分布式应用程序的的数据位置和可用性。使用 MongoDB，复制还提供了冗余，并提高数据可用性。通过将数据的多个副本保存在不同数据库服务器上，复制还可保护数据库免遭丢失一个服务器的危害。复制还可以让你从硬件故障和服务中断中恢复。有了附加数据副本，你可以将其中一个副本专用于灾难恢复、报告或备份。</source>
          <target state="new">MongoDB 是一种可提供高性能、高可用性和自动缩放的开源文档数据库。MongoDB 可独立安装或利用内置的复制功能在群集内安装。在某些情况下，你可使用复制来提高读取容量。客户端能够将读取和写入操作发送到不同的服务器。你还可以在不同数据中心中维护副本，以增加分布式应用程序的的数据位置和可用性。使用 MongoDB，复制还提供了冗余，并提高数据可用性。通过将数据的多个副本保存在不同数据库服务器上，复制还可保护数据库免遭丢失一个服务器的危害。复制还可以让你从硬件故障和服务中断中恢复。有了附加数据副本，你可以将其中一个副本专用于灾难恢复、报告或备份。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>除了提供 Azure 应用商店中已可供使用的各种功能之外，现在你还可以使用通过 <bpt id="p1">[</bpt>Azure PowerShell<ept id="p1">](/documentation/articles/powershell-install-configure)</ept> 或 <bpt id="p2">[</bpt>Azure CLI<ept id="p2">](/documentation/articles/xplat-cli)</ept> 部署的资源管理器模板，在 Ubuntu VM 上轻松部署新的 MongoDB 群集。</source>
          <target state="new">除了提供 Azure 应用商店中已可供使用的各种功能之外，现在你还可以使用通过 <bpt id="p1">[</bpt>Azure PowerShell<ept id="p1">](/documentation/articles/powershell-install-configure)</ept> 或 <bpt id="p2">[</bpt>Azure CLI<ept id="p2">](/documentation/articles/xplat-cli)</ept> 部署的资源管理器模板，在 Ubuntu VM 上轻松部署新的 MongoDB 群集。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>根据此模板新部署的群集采用下图中所述的拓扑，不过，你可以通过自定义本文中所述的模板，轻松实现其他拓扑：</source>
          <target state="new">根据此模板新部署的群集采用下图中所述的拓扑，不过，你可以通过自定义本文中所述的模板，轻松实现其他拓扑：</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>cluster-architecture</source>
          <target state="new">cluster-architecture</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>通过一个参数你可以定义要在新的 MongoDB 群集中部署的节点数，而基于另一个参数，也可以将一个具有公共 IP 地址的 VM 实例 (Jumpbox) 部署在同一个虚拟网络内，从而使你能够从公共 Internet 连接到该群集并执行任何种类的与该群集相关的管理任务。使用作为参数提供的另一个选项可以向副本集添加一个仲裁节点，当副本集具有偶数个成员时通常会建议这样做。有关 MongoDB 复制拓扑和细节的详细信息，应参阅正式的 <bpt id="p1">[</bpt>MongoDB 文档<ept id="p1">](http://docs.mongodb.org/manual/core/replication-introduction/)</ept>。</source>
          <target state="new">通过一个参数你可以定义要在新的 MongoDB 群集中部署的节点数，而基于另一个参数，也可以将一个具有公共 IP 地址的 VM 实例 (Jumpbox) 部署在同一个虚拟网络内，从而使你能够从公共 Internet 连接到该群集并执行任何种类的与该群集相关的管理任务。使用作为参数提供的另一个选项可以向副本集添加一个仲裁节点，当副本集具有偶数个成员时通常会建议这样做。有关 MongoDB 复制拓扑和细节的详细信息，应参阅正式的 <bpt id="p1">[</bpt>MongoDB 文档<ept id="p1">](http://docs.mongodb.org/manual/core/replication-introduction/)</ept>。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>部署完成之后，你可以使用 SSH 端口 22 上配置的 DNS 地址来访问 Jumpbox。</source>
          <target state="new">部署完成之后，你可以使用 SSH 端口 22 上配置的 DNS 地址来访问 Jumpbox。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>在深入了解与 Azure 资源管理器和你将用于此部署的模板相关的详细信息之前，请确保你已正确配置 Azure PowerShell 或 Azure CLI。</source>
          <target state="new">在深入了解与 Azure 资源管理器和你将用于此部署的模板相关的详细信息之前，请确保你已正确配置 Azure PowerShell 或 Azure CLI。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>使用资源管理器模板创建 MongoDB 群集</source>
          <target state="new">使用资源管理器模板创建 MongoDB 群集</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>按照以下步骤，使用 Github 模板存储库中的资源管理器模板创建 MongoDB 群集。每个步骤将同时提供 Azure PowerShell 和 Azure CLI 指令。</source>
          <target state="new">按照以下步骤，使用 Github 模板存储库中的资源管理器模板创建 MongoDB 群集。每个步骤将同时提供 Azure PowerShell 和 Azure CLI 指令。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>步骤 1-a：使用 PowerShell 下载模板文件</source>
          <target state="new">步骤 1-a：使用 PowerShell 下载模板文件</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>为 JSON 模板和其他关联的文件创建本地文件夹（例如，C:\Azure\\Templates\\MongoDB）。</source>
          <target state="new">为 JSON 模板和其他关联的文件创建本地文件夹（例如，C:\Azure\\Templates\\MongoDB）。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>替换为你的本地文件夹的文件夹名称，并运行以下命令：</source>
          <target state="new">替换为你的本地文件夹的文件夹名称，并运行以下命令：</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>步骤 1-b：使用 Azure CLI 下载模板文件</source>
          <target state="new">步骤 1-b：使用 Azure CLI 下载模板文件</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>使用所选的 git 客户端克隆整个模板存储库，例如：</source>
          <target state="new">使用所选的 git 客户端克隆整个模板存储库，例如：</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>完成后，在 C:\Azure\\Templates 目录中查找 <bpt id="p1">**</bpt>mongodb-high-availability<ept id="p1">**</ept> 文件夹。</source>
          <target state="new">完成后，在 C:\Azure\\Templates 目录中查找 <bpt id="p1">**</bpt>mongodb-high-availability<ept id="p1">**</ept> 文件夹。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>步骤 2：（可选）了解模板参数</source>
          <target state="new">步骤 2：（可选）了解模板参数</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>部署非简单的解决方案（例如，MongoDB 群集）时，必须指定一组配置参数来处理一些所需的设置。通过在模板定义中声明这些参数，就能在部署期间通过外部文件或命令行指定值。</source>
          <target state="new">部署非简单的解决方案（例如，MongoDB 群集）时，必须指定一组配置参数来处理一些所需的设置。通过在模板定义中声明这些参数，就能在部署期间通过外部文件或命令行指定值。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>azuredeploy.json<ept id="p1">**</ept> 文件顶部的“parameters”节中，你会发现模板需要用来配置 MongoDB 群集的参数集。以下示例来自此模板的 azuredeploy.json 文件的 parameters 节：</source>
          <target state="new">在 <bpt id="p1">**</bpt>azuredeploy.json<ept id="p1">**</ept> 文件顶部的“parameters”节中，你会发现模板需要用来配置 MongoDB 群集的参数集。以下示例来自此模板的 azuredeploy.json 文件的 parameters 节：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>每个参数都具有数据类型和允许值之类的详细信息。这样，便可以验证在交互模式（例如 PowerShell 或 Azure CLI）下，以及在自我发现 UI（通过分析所需参数列表及其说明动态生成的 UI）中执行模板期间所传递的参数。</source>
          <target state="new">每个参数都具有数据类型和允许值之类的详细信息。这样，便可以验证在交互模式（例如 PowerShell 或 Azure CLI）下，以及在自我发现 UI（通过分析所需参数列表及其说明动态生成的 UI）中执行模板期间所传递的参数。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>步骤 3-a：使用 PowerShell 基于模板部署 MongoDB 群集</source>
          <target state="new">步骤 3-a：使用 PowerShell 基于模板部署 MongoDB 群集</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>通过创建包含所有参数的运行时值的 JSON 文件，为部署准备参数文件。然后，将此文件作为单个实体传递给部署命令。如果未包含参数文件，PowerShell 将使用模板中指定的任何默认值，然后提示你填写剩余的值。</source>
          <target state="new">通过创建包含所有参数的运行时值的 JSON 文件，为部署准备参数文件。然后，将此文件作为单个实体传递给部署命令。如果未包含参数文件，PowerShell 将使用模板中指定的任何默认值，然后提示你填写剩余的值。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>下面是 <bpt id="p1">**</bpt>azuredeploy-parameters.json<ept id="p1">**</ept> 文件中的一组示例参数：</source>
          <target state="new">下面是 <bpt id="p1">**</bpt>azuredeploy-parameters.json<ept id="p1">**</ept> 文件中的一组示例参数：</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>填写 Azure 部署名称、资源组名称、Azure 位置，以及存储 JSON 部署文件的文件夹。然后运行以下命令：</source>
          <target state="new">填写 Azure 部署名称、资源组名称、Azure 位置，以及存储 JSON 部署文件的文件夹。然后运行以下命令：</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>运行 <bpt id="p1">**</bpt>New-AzureResourceGroupDeployment<ept id="p1">**</ept> 命令时，会从 JSON 参数文件中提取参数值，然后相应地开始执行模板。在不同的环境（例如测试、生产等）中定义和使用多个参数文件有利于重复使用模板，并简化复杂的多环境解决方案。</source>
          <target state="new">运行 <bpt id="p1">**</bpt>New-AzureResourceGroupDeployment<ept id="p1">**</ept> 命令时，会从 JSON 参数文件中提取参数值，然后相应地开始执行模板。在不同的环境（例如测试、生产等）中定义和使用多个参数文件有利于重复使用模板，并简化复杂的多环境解决方案。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>部署时，请记得需要创建新的 Azure 存储帐户，因此，提供用作存储帐户参数的名称必须唯一且符合 Azure 存储帐户的所有要求（仅限小写字母和数字）。</source>
          <target state="new">部署时，请记得需要创建新的 Azure 存储帐户，因此，提供用作存储帐户参数的名称必须唯一且符合 Azure 存储帐户的所有要求（仅限小写字母和数字）。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>部署期间以及部署之后，你可以检查设置期间发出的所有要求，包括发生的任何错误。</source>
          <target state="new">部署期间以及部署之后，你可以检查设置期间发出的所有要求，包括发生的任何错误。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>为此，请转到 <bpt id="p1">[</bpt>Azure 门户<ept id="p1">](https://manage.windowsazure.cn)</ept>并执行以下操作：</source>
          <target state="new">为此，请转到 <bpt id="p1">[</bpt>Azure 门户<ept id="p1">](https://manage.windowsazure.cn)</ept>并执行以下操作：</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>单击左侧导航栏上的“浏览”，向下滚动，然后单击“资源组”。</source>
          <target state="new">单击左侧导航栏上的“浏览”，向下滚动，然后单击“资源组”。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>单击刚创建的资源组之后，系统会显示“资源组”边栏选项卡。</source>
          <target state="new">单击刚创建的资源组之后，系统会显示“资源组”边栏选项卡。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>在“资源组”边栏选项卡的“监视”部分中单击“事件”条形图可以查看部署的事件：</source>
          <target state="new">在“资源组”边栏选项卡的“监视”部分中单击“事件”条形图可以查看部署的事件：</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>单击各个事件可以进一步细化到系统代表模板执行的各项操作的详细信息中。</source>
          <target state="new">单击各个事件可以进一步细化到系统代表模板执行的各项操作的详细信息中。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>测试之后，如果需要删除此资源组及其所有资源（存储帐户、虚拟机和虚拟网络），请使用这一命令：</source>
          <target state="new">测试之后，如果需要删除此资源组及其所有资源（存储帐户、虚拟机和虚拟网络），请使用这一命令：</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>步骤 3-b：使用 Azure CLI 基于模板部署 MongoDB 群集</source>
          <target state="new">步骤 3-b：使用 Azure CLI 基于模板部署 MongoDB 群集</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>若要通过 Azure CLI 部署 MongoDB 群集，请先通过指定名称和位置来创建资源组：</source>
          <target state="new">若要通过 Azure CLI 部署 MongoDB 群集，请先通过指定名称和位置来创建资源组：</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>将此资源组名称、JSON 模板文件的位置，以及参数文件的位置（有关详细信息，请参阅上面的 PowerShell 部分）传入以下命令：</source>
          <target state="new">将此资源组名称、JSON 模板文件的位置，以及参数文件的位置（有关详细信息，请参阅上面的 PowerShell 部分）传入以下命令：</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>你可以使用以下命令来检查单个资源部署的状态：</source>
          <target state="new">你可以使用以下命令来检查单个资源部署的状态：</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>MongoDB 模板结构和文件组织概览</source>
          <target state="new">MongoDB 模板结构和文件组织概览</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>为了让资源管理器模板的设计更加完善且可重复使用，你必须在部署 MongoDB 之类的复杂解决方案期间，考虑清楚如何安排一连串复杂但又彼此相关的任务。除了通过相关扩展执行脚本之外，还可以利用 ARM <bpt id="p1">**</bpt>模板链接<ept id="p1">**</ept>和<bpt id="p2">**</bpt>资源循环<ept id="p2">**</ept>，这样就能实现模块化方法，而所有基于模板的复杂部署基本上都能重复使用此方法。</source>
          <target state="new">为了让资源管理器模板的设计更加完善且可重复使用，你必须在部署 MongoDB 之类的复杂解决方案期间，考虑清楚如何安排一连串复杂但又彼此相关的任务。除了通过相关扩展执行脚本之外，还可以利用 ARM <bpt id="p1">**</bpt>模板链接<ept id="p1">**</ept>和<bpt id="p2">**</bpt>资源循环<ept id="p2">**</ept>，这样就能实现模块化方法，而所有基于模板的复杂部署基本上都能重复使用此方法。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>下图描述了从 GitHub 中为此部署下载的所有文件彼此间的关系：</source>
          <target state="new">下图描述了从 GitHub 中为此部署下载的所有文件彼此间的关系：</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>mongodb-files</source>
          <target state="new">mongodb-files</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>本部分将指导你逐步了解 MongoDB 群集的 <bpt id="p1">**</bpt>azuredeploy.json<ept id="p1">**</ept> 文件结构。</source>
          <target state="new">本部分将指导你逐步了解 MongoDB 群集的 <bpt id="p1">**</bpt>azuredeploy.json<ept id="p1">**</ept> 文件结构。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>“parameters”节</source>
          <target state="new">“parameters”节</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>azuredeploy.json<ept id="p1">**</ept> 的“parameters”节指定此模板中使用的可修改参数。本文前面所述的 <bpt id="p2">**</bpt>azuredeploy-parameters.json<ept id="p2">**</ept> 文件用于在模板执行期间将值传入 azuredeploy.json 的“parameters”节。</source>
          <target state="new"><bpt id="p1">**</bpt>azuredeploy.json<ept id="p1">**</ept> 的“parameters”节指定此模板中使用的可修改参数。本文前面所述的 <bpt id="p2">**</bpt>azuredeploy-parameters.json<ept id="p2">**</ept> 文件用于在模板执行期间将值传入 azuredeploy.json 的“parameters”节。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>“variables”节</source>
          <target state="new">“variables”节</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>“variables”节指定可在这整个模板中使用的变量。这包含多个字段（JSON 数据类型或片段），在执行时，这些字段将设置为常量或计算值。下面是此 MongoDB 模板的“variables”节：</source>
          <target state="new">“variables”节指定可在这整个模板中使用的变量。这包含多个字段（JSON 数据类型或片段），在执行时，这些字段将设置为常量或计算值。下面是此 MongoDB 模板的“variables”节：</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>深入分析此示例之后，你可以看到两种不同的方法。在这第一个片段中，“osFamilyUbuntu”变量将设为 JSON 元素，其中包含 6 个键/值对：</source>
          <target state="new">深入分析此示例之后，你可以看到两种不同的方法。在这第一个片段中，“osFamilyUbuntu”变量将设为 JSON 元素，其中包含 6 个键/值对：</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>在这第二个片段中，将“vmScripts”变量分配给 JSON 数组，其中的单个元素将在运行时使用模板语言函数 (concat)、另一个变量的值以及字符串常量来计算：</source>
          <target state="new">在这第二个片段中，将“vmScripts”变量分配给 JSON 数组，其中的单个元素将在运行时使用模板语言函数 (concat)、另一个变量的值以及字符串常量来计算：</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>此模板中的一个重要概念是针对 MongoDB 群集定义不同“T 恤大小”的方式。看一下这些“tshirtSizeXXXX”变量中的一个，可以注意到它描述了群集的部署方式的重要特征。让我们以“中等”大小为例：</source>
          <target state="new">此模板中的一个重要概念是针对 MongoDB 群集定义不同“T 恤大小”的方式。看一下这些“tshirtSizeXXXX”变量中的一个，可以注意到它描述了群集的部署方式的重要特征。让我们以“中等”大小为例：</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>“中等”MongoDB 群集将使用 D2 作为托管数据的 3 个 MongoDB 节点，以及将出于复制目的用作仲裁器的第四个 A1 VM 的 VM 大小。调用以部署数据节点的相应子模板将是 <bpt id="p1">**</bpt>member-resources-D2.json<ept id="p1">**</ept>，并且数据文件（每个 250 GB）将存储在 2 个存储帐户中。在“resources”节中将使用此变量来安排节点部署和其他任务。</source>
          <target state="new">“中等”MongoDB 群集将使用 D2 作为托管数据的 3 个 MongoDB 节点，以及将出于复制目的用作仲裁器的第四个 A1 VM 的 VM 大小。调用以部署数据节点的相应子模板将是 <bpt id="p1">**</bpt>member-resources-D2.json<ept id="p1">**</ept>，并且数据文件（每个 250 GB）将存储在 2 个存储帐户中。在“resources”节中将使用此变量来安排节点部署和其他任务。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>“resources”节</source>
          <target state="new">“resources”节</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>大多数操作是在<bpt id="p1">**</bpt>“resources”<ept id="p1">**</ept>节中发生的。仔细查看此节，你会立即找到两个不同的案例：第一个案例是定义为 <ph id="ph1">`Microsoft.Resources/deployments`</ph> 类型的元素，它基本上表示调用主部署中的嵌套部署。通过“templateLink”元素（和相关的版本属性），可以指定链接的模板文件，并在调用此文件时传递一组参数作为输入，如同你在此片段中所看到的那样：</source>
          <target state="new">大多数操作是在<bpt id="p1">**</bpt>“resources”<ept id="p1">**</ept>节中发生的。仔细查看此节，你会立即找到两个不同的案例：第一个案例是定义为 <ph id="ph1">`Microsoft.Resources/deployments`</ph> 类型的元素，它基本上表示调用主部署中的嵌套部署。通过“templateLink”元素（和相关的版本属性），可以指定链接的模板文件，并在调用此文件时传递一组参数作为输入，如同你在此片段中所看到的那样：</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>从第一个示例我们清楚地了解此方案中的 <bpt id="p1">**</bpt>azuredeploy.json<ept id="p1">**</ept> 如何作为一种协调机制进行组织，并调用其他一些模板文件，其中每个文件都负责所需部署活动的一部分。</source>
          <target state="new">从第一个示例我们清楚地了解此方案中的 <bpt id="p1">**</bpt>azuredeploy.json<ept id="p1">**</ept> 如何作为一种协调机制进行组织，并调用其他一些模板文件，其中每个文件都负责所需部署活动的一部分。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>具体而言，以下链接模板将用于此部署：</source>
          <target state="new">具体而言，以下链接模板将用于此部署：</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>shared-resource.json<ept id="p1">**</ept>：包含要在整个部署中共享的所有资源的定义。例如，用来存储 VM 的操作系统磁盘和虚拟网络的存储帐户。</source>
          <target state="new"><bpt id="p1">**</bpt>shared-resource.json<ept id="p1">**</ept>：包含要在整个部署中共享的所有资源的定义。例如，用来存储 VM 的操作系统磁盘和虚拟网络的存储帐户。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>jumpbox-resources.json<ept id="p1">**</ept>：如果启用，将负责部署与 Jumpbox VM 相关的所有资源，该 VM 具有公共 IP 地址可用于从公共网络访问 MongoDB 群集。</source>
          <target state="new"><bpt id="p1">**</bpt>jumpbox-resources.json<ept id="p1">**</ept>：如果启用，将负责部署与 Jumpbox VM 相关的所有资源，该 VM 具有公共 IP 地址可用于从公共网络访问 MongoDB 群集。</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>arbiter-resources.json<ept id="p1">**</ept>：如果启用，此模板会在 MongoDB 群集中部署仲裁器成员。仲裁器不包含数据，但在副本集包含偶数个用于管理主选举的节点时使用。</source>
          <target state="new"><bpt id="p1">**</bpt>arbiter-resources.json<ept id="p1">**</ept>：如果启用，此模板会在 MongoDB 群集中部署仲裁器成员。仲裁器不包含数据，但在副本集包含偶数个用于管理主选举的节点时使用。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>member-resources-Dx.json<ept id="p1">**</ept>：这些资源模板有效地部署 MongoDB 节点。将根据所选的 T 恤大小定义使用特定文件，其中每个文件将因每个节点的附加磁盘数而异。</source>
          <target state="new"><bpt id="p1">**</bpt>member-resources-Dx.json<ept id="p1">**</ept>：这些资源模板有效地部署 MongoDB 节点。将根据所选的 T 恤大小定义使用特定文件，其中每个文件将因每个节点的附加磁盘数而异。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>mongodb-ubuntu-install.sh<ept id="p1">**</ept>：CustomScriptForLinux 扩展对群集中每个节点调用的 bash 脚本文件。负责装载并格式化数据磁盘，以及在节点上安装 MongoDB 各部分。</source>
          <target state="new"><bpt id="p1">**</bpt>mongodb-ubuntu-install.sh<ept id="p1">**</ept>：CustomScriptForLinux 扩展对群集中每个节点调用的 bash 脚本文件。负责装载并格式化数据磁盘，以及在节点上安装 MongoDB 各部分。</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>若要部署 MongoDB 群集，需要特定逻辑才能正确设置副本集。在部署过程中必须按照的特定顺序如下：</source>
          <target state="new">若要部署 MongoDB 群集，需要特定逻辑才能正确设置副本集。在部署过程中必须按照的特定顺序如下：</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>部署数据成员（以并行方式）= &gt; 部署最后一个数据成员 = &gt;（可选）部署仲裁器</source>
          <target state="new">部署数据成员（以并行方式）= &gt; 部署最后一个数据成员 = &gt;（可选）部署仲裁器</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>在此顺序中，部署多个数据节点以并行方式进行，但最后一个节点除外。这是将形成群集和新副本集将部署到的位置，因此以前的所有节点需要在该时刻之前已启动并在运行。最后一步将部署可选的仲裁节点（仅适用于需要此节点的 T 恤大小）。</source>
          <target state="new">在此顺序中，部署多个数据节点以并行方式进行，但最后一个节点除外。这是将形成群集和新副本集将部署到的位置，因此以前的所有节点需要在该时刻之前已启动并在运行。最后一步将部署可选的仲裁节点（仅适用于需要此节点的 T 恤大小）。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>在我们的主模板 (azuredeploy.json) 内再看一下，让我们看一下如何实现此逻辑，从所有数据成员开始：</source>
          <target state="new">在我们的主模板 (azuredeploy.json) 内再看一下，让我们看一下如何实现此逻辑，从所有数据成员开始：</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>在此要强调一个重要的概念，那就是如何可以部署单个资源类型的多个副本，而且可以为每一个实例指定所需设置的唯一值。此概念称为<bpt id="p1">**</bpt>资源循环<ept id="p1">**</ept>。</source>
          <target state="new">在此要强调一个重要的概念，那就是如何可以部署单个资源类型的多个副本，而且可以为每一个实例指定所需设置的唯一值。此概念称为<bpt id="p1">**</bpt>资源循环<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>在上一片段中，参数（要在群集中部署的节点数）将用于设置变量 (“numberOfMembers”)，然后将该变量传递给 <bpt id="p1">**</bpt>“copy”<ept id="p1">**</ept>元素以触发多个子部署（环），每个子部署将导致群集中的每个成员的模板实例化。若要能够设置在实例之间需要唯一值的所有设置，可使用 <bpt id="p2">**</bpt>copyindex()<ept id="p2">**</ept> 函数获取数字值，以指示该特定资源循环创建中的当前索引。</source>
          <target state="new">在上一片段中，参数（要在群集中部署的节点数）将用于设置变量 (“numberOfMembers”)，然后将该变量传递给 <bpt id="p1">**</bpt>“copy”<ept id="p1">**</ept>元素以触发多个子部署（环），每个子部署将导致群集中的每个成员的模板实例化。若要能够设置在实例之间需要唯一值的所有设置，可使用 <bpt id="p2">**</bpt>copyindex()<ept id="p2">**</ept> 函数获取数字值，以指示该特定资源循环创建中的当前索引。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>资源创建中的另一个重要概念是能够指定资源间的依赖关系和优先级，如你在 <bpt id="p1">**</bpt>dependsOn<ept id="p1">**</ept> JSON 数组中所注意到的。在此特定模板中，部署每个节点取决于<bpt id="p2">**</bpt>共享资源<ept id="p2">**</ept>的前次成功部署。</source>
          <target state="new">资源创建中的另一个重要概念是能够指定资源间的依赖关系和优先级，如你在 <bpt id="p1">**</bpt>dependsOn<ept id="p1">**</ept> JSON 数组中所注意到的。在此特定模板中，部署每个节点取决于<bpt id="p2">**</bpt>共享资源<ept id="p2">**</ept>的前次成功部署。</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>在通过执行 <bpt id="p1">**</bpt>mongodb-ubuntu-install.sh<ept id="p1">**</ept> 脚本文件触发的节点准备活动中，将格式化附加的磁盘。在该文件中，实际上你可以找到此调用的实例：</source>
          <target state="new">在通过执行 <bpt id="p1">**</bpt>mongodb-ubuntu-install.sh<ept id="p1">**</ept> 脚本文件触发的节点准备活动中，将格式化附加的磁盘。在该文件中，实际上你可以找到此调用的实例：</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>vm-disk-utils-0.1.sh<ept id="p1">**</ept> 是 azure-quickstart-tempates github 存储库中 <bpt id="p2">**</bpt>shared_scripts\\ubuntu<ept id="p2">**</ept> 文件夹的一部分，其中包含用于磁盘装入、格式化和条带化的非常有用的函数，每次需要在模板创建过程中执行类似任务时都可以使用。</source>
          <target state="new"><bpt id="p1">**</bpt>vm-disk-utils-0.1.sh<ept id="p1">**</ept> 是 azure-quickstart-tempates github 存储库中 <bpt id="p2">**</bpt>shared_scripts\\ubuntu<ept id="p2">**</ept> 文件夹的一部分，其中包含用于磁盘装入、格式化和条带化的非常有用的函数，每次需要在模板创建过程中执行类似任务时都可以使用。</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>另一个要探讨的有趣片段是与 CustomScriptForLinux VM 扩展相关的片段。这些扩展作为单独的资源类型安装，并依赖于每个群集节点部署模板，请在每个 <bpt id="p1">**</bpt>member-resources-Dx.json<ept id="p1">**</ept> 文件末尾查看此片段：</source>
          <target state="new">另一个要探讨的有趣片段是与 CustomScriptForLinux VM 扩展相关的片段。这些扩展作为单独的资源类型安装，并依赖于每个群集节点部署模板，请在每个 <bpt id="p1">**</bpt>member-resources-Dx.json<ept id="p1">**</ept> 文件末尾查看此片段：</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>熟悉此部署包含的其他文件后，你将能够了解有关如何利用 Azure 资源管理器模板基于任何技术来组织和协调多节点解决方案的复杂部署策略所需的所有详细信息和最佳实践。在此建议一种构造模板文件的方法，请自行决定是否采用，如下图突出显示的部分所示：</source>
          <target state="new">熟悉此部署包含的其他文件后，你将能够了解有关如何利用 Azure 资源管理器模板基于任何技术来组织和协调多节点解决方案的复杂部署策略所需的所有详细信息和最佳实践。在此建议一种构造模板文件的方法，请自行决定是否采用，如下图突出显示的部分所示：</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>mongodb-template-structure</source>
          <target state="new">mongodb-template-structure</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>本质上，这种方法会建议：</source>
          <target state="new">本质上，这种方法会建议：</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>将你的核心模板文件定义成所有特定部署活动的中心协调点，并利用模板链接来调用子模板执行</source>
          <target state="new">将你的核心模板文件定义成所有特定部署活动的中心协调点，并利用模板链接来调用子模板执行</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>创建特定的模板文件，用于部署所有其他特定部署任务会共享的所有资源（例如存储帐户、虚拟网络配置，等等）。如果不同的部署在公用基础结构方面具有类似的要求，你就可以对其频繁重复使用此方法。</source>
          <target state="new">创建特定的模板文件，用于部署所有其他特定部署任务会共享的所有资源（例如存储帐户、虚拟网络配置，等等）。如果不同的部署在公用基础结构方面具有类似的要求，你就可以对其频繁重复使用此方法。</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>针对特定于给定资源的场地要求提供可选资源模板</source>
          <target state="new">针对特定于给定资源的场地要求提供可选资源模板</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>针对资源组的相同成员（群集中的节点，等等）创建利用资源循环的特定模板，以便部署多个具有特有属性的实例。</source>
          <target state="new">针对资源组的相同成员（群集中的节点，等等）创建利用资源循环的特定模板，以便部署多个具有特有属性的实例。</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>对于所有部署后任务（例如产品安装、配置，等等），利用脚本部署扩展并创建特定于每种技术的脚本</source>
          <target state="new">对于所有部署后任务（例如产品安装、配置，等等），利用脚本部署扩展并创建特定于每种技术的脚本</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>有关详细信息，请参阅 <bpt id="p1">[</bpt>Azure 资源管理器模板语言<ept id="p1">](https://msdn.microsoft.com/zh-CN/library/azure/dn835138.aspx)</ept>。</source>
          <target state="new">有关详细信息，请参阅 <bpt id="p1">[</bpt>Azure 资源管理器模板语言<ept id="p1">](https://msdn.microsoft.com/zh-CN/library/azure/dn835138.aspx)</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>