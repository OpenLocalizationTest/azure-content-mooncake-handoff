<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2fcf528d86e5783245150903376d7efa32dbb42e</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>创建 WebAPI 项目</source>
          <target state="new">创建 WebAPI 项目</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>新的 ASP.NET WebAPI 后端将会在后续部分中创建，该后端有三个主要用途：</source>
          <target state="new">新的 ASP.NET WebAPI 后端将会在后续部分中创建，该后端有三个主要用途：</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>对客户端进行身份验证<ept id="p1">**</ept>：稍后将会添加消息处理程序，以便对客户端请求进行身份验证，并将用户与请求相关联。</source>
          <target state="new"><bpt id="p1">**</bpt>对客户端进行身份验证<ept id="p1">**</ept>：稍后将会添加消息处理程序，以便对客户端请求进行身份验证，并将用户与请求相关联。</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>客户端通知注册<ept id="p1">**</ept>：稍后，你将要添加一个控制器来处理新的注册，使客户端设备能够接收通知。经过身份验证的用户名将作为<bpt id="p2">[</bpt>标记<ept id="p2">](https://msdn.microsoft.com/library/azure/dn530749.aspx)</ept>自动添加到注册。</source>
          <target state="new"><bpt id="p1">**</bpt>客户端通知注册<ept id="p1">**</ept>：稍后，你将要添加一个控制器来处理新的注册，使客户端设备能够接收通知。经过身份验证的用户名将作为<bpt id="p2">[</bpt>标记<ept id="p2">](https://msdn.microsoft.com/library/azure/dn530749.aspx)</ept>自动添加到注册。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>将通知发送到客户端<ept id="p1">**</ept>：稍后，你还要添加一个控制器，以便用户对与标记关联的设备和客户端触发安全推送。</source>
          <target state="new"><bpt id="p1">**</bpt>将通知发送到客户端<ept id="p1">**</ept>：稍后，你还要添加一个控制器，以便用户对与标记关联的设备和客户端触发安全推送。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>以下步骤说明了如何创建新的 ASP.NET WebAPI 后端：</source>
          <target state="new">以下步骤说明了如何创建新的 ASP.NET WebAPI 后端：</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph><bpt id="p1">**</bpt>重要提示<ept id="p1">**</ept>：在开始本教程之前，请确保已安装最新版本的 NuGet 程序包管理器。若要进行检查，请启动 Visual Studio。从“工具”菜单，单击“扩展和更新”。搜索“适用于 Visual Studio 2013 的 NuGet 程序包管理器”，并且确保具有版本 2.8.50313.46 或更高版本。否则，请卸载并重新安装 NuGet 程序包管理器。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph><bpt id="p1">**</bpt>重要提示<ept id="p1">**</ept>：在开始本教程之前，请确保已安装最新版本的 NuGet 程序包管理器。若要进行检查，请启动 Visual Studio。从“工具”菜单，单击“扩展和更新”。搜索“适用于 Visual Studio 2013 的 NuGet 程序包管理器”，并且确保具有版本 2.8.50313.46 或更高版本。否则，请卸载并重新安装 NuGet 程序包管理器。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>请确保已安装 Visual Studio <bpt id="p1">[</bpt>Azure SDK<ept id="p1">](/zh-cn/downloads/)</ept> 以便进行 Web 应用部署。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>请确保已安装 Visual Studio <bpt id="p1">[</bpt>Azure SDK<ept id="p1">](/zh-cn/downloads/)</ept> 以便进行 Web 应用部署。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>启动 Visual Studio 或 Visual Studio Express。单击“服务器资源管理器”并登录到你的 Azure 帐户。Visual Studio 需要你登录才能在你的帐户中创建 Web 应用资源。</source>
          <target state="new">启动 Visual Studio 或 Visual Studio Express。单击“服务器资源管理器”并登录到你的 Azure 帐户。Visual Studio 需要你登录才能在你的帐户中创建 Web 应用资源。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>在 Visual Studio 中，依次单击“文件”、“新建”和“项目”，依次展开“模板”和“Visual C#”，然后依次单击“Web”和“ASP.NET Web 应用程序”，键入名称 <bpt id="p1">**</bpt>AppBackend<ept id="p1">**</ept>，然后单击“确定”。</source>
          <target state="new">在 Visual Studio 中，依次单击“文件”、“新建”和“项目”，依次展开“模板”和“Visual C#”，然后依次单击“Web”和“ASP.NET Web 应用程序”，键入名称 <bpt id="p1">**</bpt>AppBackend<ept id="p1">**</ept>，然后单击“确定”。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>在“新建 ASP.NET 项目”对话框中，单击“Web API”，然后单击“确定”。</source>
          <target state="new">在“新建 ASP.NET 项目”对话框中，单击“Web API”，然后单击“确定”。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>在“配置 Azure Web 应用”对话框中，选择订阅和你已创建的 <bpt id="p1">**</bpt>App Service 计划<ept id="p1">**</ept>。你也可以选择“创建新的 App Service 计划”，并通过对话框创建一个计划。在本教程中，你不需要使用数据库。选择 App Service 计划后，单击“确定”以创建项目。</source>
          <target state="new">在“配置 Azure Web 应用”对话框中，选择订阅和你已创建的 <bpt id="p1">**</bpt>App Service 计划<ept id="p1">**</ept>。你也可以选择“创建新的 App Service 计划”，并通过对话框创建一个计划。在本教程中，你不需要使用数据库。选择 App Service 计划后，单击“确定”以创建项目。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>在 WebAPI 后端上对客户端进行身份验证</source>
          <target state="new">在 WebAPI 后端上对客户端进行身份验证</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>在本部分，你将为新的后端创建名为 <bpt id="p1">**</bpt>AuthenticationTestHandler<ept id="p1">**</ept> 的新消息处理程序类。此类衍生自 <bpt id="p2">[</bpt>DelegatingHandler<ept id="p2">](https://msdn.microsoft.com/library/system.net.http.delegatinghandler.aspx)</ept> 并已添加为消息处理程序，以便处理传入后端的所有请求。</source>
          <target state="new">在本部分，你将为新的后端创建名为 <bpt id="p1">**</bpt>AuthenticationTestHandler<ept id="p1">**</ept> 的新消息处理程序类。此类衍生自 <bpt id="p2">[</bpt>DelegatingHandler<ept id="p2">](https://msdn.microsoft.com/library/system.net.http.delegatinghandler.aspx)</ept> 并已添加为消息处理程序，以便处理传入后端的所有请求。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中，右键单击“AppBackend”项目，单击“添加”，然后单击“类”。将新类命名为 <bpt id="p1">**</bpt>AuthenticationTestHandler.cs<ept id="p1">**</ept>，然后单击“添加”以生成该类。通过此类可简单地使用<bpt id="p2">*</bpt>基本身份验证<ept id="p2">*</ept> 对用户进行身份验证。请注意，您的应用可以使用所有身份验证方案。</source>
          <target state="new">在“解决方案资源管理器”中，右键单击“AppBackend”项目，单击“添加”，然后单击“类”。将新类命名为 <bpt id="p1">**</bpt>AuthenticationTestHandler.cs<ept id="p1">**</ept>，然后单击“添加”以生成该类。通过此类可简单地使用<bpt id="p2">*</bpt>基本身份验证<ept id="p2">*</ept> 对用户进行身份验证。请注意，您的应用可以使用所有身份验证方案。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>在 AuthenticationTestHandler.cs 中，添加以下 <ph id="ph1">`using`</ph> 语句：</source>
          <target state="new">在 AuthenticationTestHandler.cs 中，添加以下 <ph id="ph1">`using`</ph> 语句：</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>在 AuthenticationTestHandler.cs 中，将 <ph id="ph1">`AuthenticationTestHandler`</ph> 类定义替换为以下代码。</source>
          <target state="new">在 AuthenticationTestHandler.cs 中，将 <ph id="ph1">`AuthenticationTestHandler`</ph> 类定义替换为以下代码。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>当以下三个条件都成立时，此处理程序将授权给请求：</source>
          <target state="new">当以下三个条件都成立时，此处理程序将授权给请求：</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>请求包含 <bpt id="p1">*</bpt>Authorization<ept id="p1">*</ept> 标头。</source>
          <target state="new">请求包含 <bpt id="p1">*</bpt>Authorization<ept id="p1">*</ept> 标头。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>请求使用<bpt id="p1">*</bpt>基本<ept id="p1">*</ept> 身份验证。</source>
          <target state="new">请求使用<bpt id="p1">*</bpt>基本<ept id="p1">*</ept> 身份验证。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>用户名字符串和密码字符串是相同的字符串。</source>
          <target state="new">用户名字符串和密码字符串是相同的字符串。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>否则，将会拒绝该请求。这不是真正的身份验证和授权方法。它只是本教程中一个非常简单的示例。</source>
          <target state="new">否则，将会拒绝该请求。这不是真正的身份验证和授权方法。它只是本教程中一个非常简单的示例。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>如果请求消息已经过 <ph id="ph1">`AuthenticationTestHandler`</ph> 的身份验证和授权，则基本身份验证用户将附加到 <bpt id="p1">[</bpt>HttpContext<ept id="p1">](https://msdn.microsoft.com/library/system.web.httpcontext.current.aspx)</ept> 上的当前请求。然后，另一个控制器 (RegisterController) 会使用 HttpContext 中的用户信息，将<bpt id="p2">[</bpt>标记<ept id="p2">](https://msdn.microsoft.com/library/azure/dn530749.aspx)</ept>添加到通知注册请求。</source>
          <target state="new">如果请求消息已经过 <ph id="ph1">`AuthenticationTestHandler`</ph> 的身份验证和授权，则基本身份验证用户将附加到 <bpt id="p1">[</bpt>HttpContext<ept id="p1">](https://msdn.microsoft.com/library/system.web.httpcontext.current.aspx)</ept> 上的当前请求。然后，另一个控制器 (RegisterController) 会使用 HttpContext 中的用户信息，将<bpt id="p2">[</bpt>标记<ept id="p2">](https://msdn.microsoft.com/library/azure/dn530749.aspx)</ept>添加到通知注册请求。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph><bpt id="p1">**</bpt>安全说明<ept id="p1">**</ept>：<ph id="ph2">`AuthenticationTestHandler`</ph> 类不提供真正的身份验证。它仅用于模拟基本身份验证并且是不安全的。您必须在生产应用程序和服务中实现安全的身份验证机制。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph><bpt id="p1">**</bpt>安全说明<ept id="p1">**</ept>：<ph id="ph2">`AuthenticationTestHandler`</ph> 类不提供真正的身份验证。它仅用于模拟基本身份验证并且是不安全的。您必须在生产应用程序和服务中实现安全的身份验证机制。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>App\_Start/WebApiConfig.cs<ept id="p1">**</ept> 类中 <ph id="ph1">`Register`</ph> 方法的末尾添加以下代码，以注册消息处理程序：</source>
          <target state="new">在 <bpt id="p1">**</bpt>App\_Start/WebApiConfig.cs<ept id="p1">**</ept> 类中 <ph id="ph1">`Register`</ph> 方法的末尾添加以下代码，以注册消息处理程序：</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>保存所做更改。</source>
          <target state="new">保存所做更改。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>使用 WebAPI 后端注册通知</source>
          <target state="new">使用 WebAPI 后端注册通知</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>在本部分，我们要将新的控制器添加到 WebAPI 后端来处理请求，以使用通知中心的客户端库为用户和设备注册通知。控制器将为已由 <ph id="ph1">`AuthenticationTestHandler`</ph> 验证并已附加到 HttpContext 的用户添加用户标记。该标记采用以下字符串格式：<ph id="ph2">`"username:&lt;actual username&gt;"`</ph>。</source>
          <target state="new">在本部分，我们要将新的控制器添加到 WebAPI 后端来处理请求，以使用通知中心的客户端库为用户和设备注册通知。控制器将为已由 <ph id="ph1">`AuthenticationTestHandler`</ph> 验证并已附加到 HttpContext 的用户添加用户标记。该标记采用以下字符串格式：<ph id="ph2">`"username:&lt;actual username&gt;"`</ph>。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中，右键单击“AppBackend”项目，然后单击“管理 NuGet 程序包”。</source>
          <target state="new">在“解决方案资源管理器”中，右键单击“AppBackend”项目，然后单击“管理 NuGet 程序包”。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>在左侧，单击“联机”，然后在“搜索”框中搜索 <bpt id="p1">**</bpt>Microsoft.Azure.NotificationHubs<ept id="p1">**</ept>。</source>
          <target state="new">在左侧，单击“联机”，然后在“搜索”框中搜索 <bpt id="p1">**</bpt>Microsoft.Azure.NotificationHubs<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>在结果列表中，单击“Azure 通知中心”，然后单击“安装”。完成安装后，关闭“NuGet 程序包管理器”窗口。</source>
          <target state="new">在结果列表中，单击“Azure 通知中心”，然后单击“安装”。完成安装后，关闭“NuGet 程序包管理器”窗口。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>这将使用 <ph id="ph1">&lt;a href="http://www.nuget.org/packages/Microsoft.Azure.NotificationHubs/"&gt;</ph>Microsoft.Azure.Notification Hubs NuGet 程序包<ph id="ph2">&lt;/a&gt;</ph>添加对 Azure 通知中心 SDK 的引用。</source>
          <target state="new">这将使用 <ph id="ph1">&lt;a href="http://www.nuget.org/packages/Microsoft.Azure.NotificationHubs/"&gt;</ph>Microsoft.Azure.Notification Hubs NuGet 程序包<ph id="ph2">&lt;/a&gt;</ph>添加对 Azure 通知中心 SDK 的引用。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>现在，我们要创建新的类文件，用于表示所要发送的不同安全通知。在完整的实现中，这些通知存储在某个数据库中。为简单起见，本教程将这些通知存储在内存中。在“解决方案资源管理器”中，右键单击“Models”文件夹，单击“添加”，然后单击“类”。将新类命名为 <bpt id="p1">**</bpt>Notifications.cs<ept id="p1">**</ept>，然后单击“添加”以生成该类。</source>
          <target state="new">现在，我们要创建新的类文件，用于表示所要发送的不同安全通知。在完整的实现中，这些通知存储在某个数据库中。为简单起见，本教程将这些通知存储在内存中。在“解决方案资源管理器”中，右键单击“Models”文件夹，单击“添加”，然后单击“类”。将新类命名为 <bpt id="p1">**</bpt>Notifications.cs<ept id="p1">**</ept>，然后单击“添加”以生成该类。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>在 Notifications.cs 中，在文件顶部添加以下 <ph id="ph1">`using`</ph> 语句：</source>
          <target state="new">在 Notifications.cs 中，在文件顶部添加以下 <ph id="ph1">`using`</ph> 语句：</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>将 <ph id="ph1">`Notifications`</ph> 类定义替换为以下内容并确保将两个占位符替换为通知中心的连接字符串（具有完全访问权限）和中心名称（可在 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](http://manage.windowsazure.cn)</ept>中找到）：</source>
          <target state="new">将 <ph id="ph1">`Notifications`</ph> 类定义替换为以下内容并确保将两个占位符替换为通知中心的连接字符串（具有完全访问权限）和中心名称（可在 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](http://manage.windowsazure.cn)</ept>中找到）：</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>接下来，我们将创建一个名为 <bpt id="p1">**</bpt>RegisterController<ept id="p1">**</ept> 的新控制器。在“解决方案资源管理器”中，右键单击“Controllers”文件夹，然后依次单击“添加”和“控制器”。单击“Web API 2 Controller -- Empty”项目，然后单击“添加”。将新类命名为 <bpt id="p2">**</bpt>RegisterController<ept id="p2">**</ept>，然后再次单击“添加”以生成该控制器。</source>
          <target state="new">接下来，我们将创建一个名为 <bpt id="p1">**</bpt>RegisterController<ept id="p1">**</ept> 的新控制器。在“解决方案资源管理器”中，右键单击“Controllers”文件夹，然后依次单击“添加”和“控制器”。单击“Web API 2 Controller -- Empty”项目，然后单击“添加”。将新类命名为 <bpt id="p2">**</bpt>RegisterController<ept id="p2">**</ept>，然后再次单击“添加”以生成该控制器。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>在 RegisterController.cs 中，添加以下 <ph id="ph1">`using`</ph> 语句：</source>
          <target state="new">在 RegisterController.cs 中，添加以下 <ph id="ph1">`using`</ph> 语句：</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>在 <ph id="ph1">`RegisterController`</ph> 类定义中添加以下代码：请注意，在此代码中，我们将为已附加到 HttpContext 的用户添加用户标记。添加的消息筛选器 <ph id="ph2">`AuthenticationTestHandler`</ph> 将对该用户进行身份验证并将其附加到 HttpContext。还可以通过添加可选复选框来验证用户是否有权注册以获取请求标记。</source>
          <target state="new">在 <ph id="ph1">`RegisterController`</ph> 类定义中添加以下代码：请注意，在此代码中，我们将为已附加到 HttpContext 的用户添加用户标记。添加的消息筛选器 <ph id="ph2">`AuthenticationTestHandler`</ph> 将对该用户进行身份验证并将其附加到 HttpContext。还可以通过添加可选复选框来验证用户是否有权注册以获取请求标记。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>保存所做更改。</source>
          <target state="new">保存所做更改。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>从 WebAPI 后端发送通知</source>
          <target state="new">从 WebAPI 后端发送通知</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>在本部分，你将添加新的控制器，以便客户端设备使用 ASP.NET WebAPI 后端中的 Azure 通知中心服务管理库根据用户名标记发送通知。</source>
          <target state="new">在本部分，你将添加新的控制器，以便客户端设备使用 ASP.NET WebAPI 后端中的 Azure 通知中心服务管理库根据用户名标记发送通知。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>创建另一个名为 <bpt id="p1">**</bpt>NotificationsController<ept id="p1">**</ept> 的新控制器。以你在上一节中创建 <bpt id="p2">**</bpt>RegisterController<ept id="p2">**</ept> 的相同方式来创建新控制器。</source>
          <target state="new">创建另一个名为 <bpt id="p1">**</bpt>NotificationsController<ept id="p1">**</ept> 的新控制器。以你在上一节中创建 <bpt id="p2">**</bpt>RegisterController<ept id="p2">**</ept> 的相同方式来创建新控制器。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>在 NotificationsController.cs 中，添加以下 <ph id="ph1">`using`</ph> 语句：</source>
          <target state="new">在 NotificationsController.cs 中，添加以下 <ph id="ph1">`using`</ph> 语句：</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">**</bpt>NotificationsController<ept id="p1">**</ept> 类中添加以下方法。</source>
          <target state="new">在 <bpt id="p1">**</bpt>NotificationsController<ept id="p1">**</ept> 类中添加以下方法。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>此代码将会根据平台通知服务 (PNS) <ph id="ph1">`pns`</ph> 参数发送相应类型的通知。<ph id="ph2">`to_tag`</ph> 的值用于设置消息中的 <bpt id="p1">*</bpt>username<ept id="p1">*</ept> 标记。此标记必须与活动的通知中心注册的用户名标记相匹配。将从 POST 请求正文提取通知消息，并根据目标 PNS 将其格式化。</source>
          <target state="new">此代码将会根据平台通知服务 (PNS) <ph id="ph1">`pns`</ph> 参数发送相应类型的通知。<ph id="ph2">`to_tag`</ph> 的值用于设置消息中的 <bpt id="p1">*</bpt>username<ept id="p1">*</ept> 标记。此标记必须与活动的通知中心注册的用户名标记相匹配。将从 POST 请求正文提取通知消息，并根据目标 PNS 将其格式化。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>根据受支持设备用来接收通知的平台通知服务 (PNS)，支持使用不同的格式接收不同的通知。例如，在 Windows 设备上，可以使用其他 PNS 不能直接支持的 <bpt id="p1">[</bpt>toast 通知和 WNS<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br230849.aspx)</ept>。因此，后端需要将通知格式化为你打算使用的设备 PNS 所支持的通知。然后，对 <bpt id="p2">[</bpt>NotificationHubClient 类<ept id="p2">](https://msdn.microsoft.com/library/azure/microsoft.azure.notificationhubs.notificationhubclient_methods.aspx)</ept>使用相应的 send API</source>
          <target state="new">根据受支持设备用来接收通知的平台通知服务 (PNS)，支持使用不同的格式接收不同的通知。例如，在 Windows 设备上，可以使用其他 PNS 不能直接支持的 <bpt id="p1">[</bpt>toast 通知和 WNS<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br230849.aspx)</ept>。因此，后端需要将通知格式化为你打算使用的设备 PNS 所支持的通知。然后，对 <bpt id="p2">[</bpt>NotificationHubClient 类<ept id="p2">](https://msdn.microsoft.com/library/azure/microsoft.azure.notificationhubs.notificationhubclient_methods.aspx)</ept>使用相应的 send API</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>按 <bpt id="p1">**</bpt>F5<ept id="p1">**</ept> 运行应用程序并确保到目前为止操作的准确性。该应用应启动 Web 浏览器，然后显示 ASP.NET 主页。</source>
          <target state="new">按 <bpt id="p1">**</bpt>F5<ept id="p1">**</ept> 运行应用程序并确保到目前为止操作的准确性。该应用应启动 Web 浏览器，然后显示 ASP.NET 主页。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>发布新的 WebAPI 后端</source>
          <target state="new">发布新的 WebAPI 后端</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>现在，我们将此应用部署到 Azure Web 应用，以便可以从任意设备访问它。右键单击 <bpt id="p1">**</bpt>AppBackend<ept id="p1">**</ept> 项目，然后选择“发布”。</source>
          <target state="new">现在，我们将此应用部署到 Azure Web 应用，以便可以从任意设备访问它。右键单击 <bpt id="p1">**</bpt>AppBackend<ept id="p1">**</ept> 项目，然后选择“发布”。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>选择“Azure Web Apps”作为发布目标。</source>
          <target state="new">选择“Azure Web Apps”作为发布目标。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>使用你的 Azure 帐户登录，然后选择一个现有的或新的 Web 应用。</source>
          <target state="new">使用你的 Azure 帐户登录，然后选择一个现有的或新的 Web 应用。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>记下“连接”选项卡中的“目标 URL”属性。在本教程后面的部分中，我们将此 URL 称为<bpt id="p1">*</bpt>后端终结点<ept id="p1">*</ept>。单击“发布”。</source>
          <target state="new">记下“连接”选项卡中的“目标 URL”属性。在本教程后面的部分中，我们将此 URL 称为<bpt id="p1">*</bpt>后端终结点<ept id="p1">*</ept>。单击“发布”。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>