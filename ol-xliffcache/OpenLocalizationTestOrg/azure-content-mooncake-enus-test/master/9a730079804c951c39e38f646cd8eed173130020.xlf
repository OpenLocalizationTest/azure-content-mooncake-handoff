<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9a730079804c951c39e38f646cd8eed173130020</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>使用 Microsoft Avro Library 序列化数据 | Azure</source>
          <target state="new">使用 Microsoft Avro Library 序列化数据 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解 Azure HDInsight 如何使用 Avro 来序列化大数据。</source>
          <target state="new">了解 Azure HDInsight 如何使用 Avro 来序列化大数据。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>使用 Microsoft Avro Library 序列化 Hadoop 中的数据</source>
          <target state="new">使用 Microsoft Avro Library 序列化 Hadoop 中的数据</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>本主题演示如何使用 <ph id="ph1">&lt;a href="https://hadoopsdk.codeplex.com/wikipage?title=Avro%20Library" target="_blank"&gt;</ph>Microsoft Avro Library<ph id="ph2">&lt;/a&gt;</ph> 将对象及其他数据结构序列化为流，以便将它们持久保存到内存、数据库或文件中，同时还演示如何对这些流进行反序列化以恢复原始对象。</source>
          <target state="new">本主题演示如何使用 <ph id="ph1">&lt;a href="https://hadoopsdk.codeplex.com/wikipage?title=Avro%20Library" target="_blank"&gt;</ph>Microsoft Avro Library<ph id="ph2">&lt;/a&gt;</ph> 将对象及其他数据结构序列化为流，以便将它们持久保存到内存、数据库或文件中，同时还演示如何对这些流进行反序列化以恢复原始对象。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>[AZURE.INCLUDE <bpt id="p1">[</bpt>仅适用于 Windows<ept id="p1">](../includes/hdinsight-windows-only.md)</ept>]</source>
          <target state="new">[AZURE.INCLUDE <bpt id="p1">[</bpt>仅适用于 Windows<ept id="p1">](../includes/hdinsight-windows-only.md)</ept>]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="apacheAvro"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Apache Avro</source>
          <target state="new"><ph id="ph1">&lt;a name="apacheAvro"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Apache Avro</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a href="https://hadoopsdk.codeplex.com/wikipage?title=Avro%20Library" target="_blank"&gt;</ph>Microsoft Avro Library<ph id="ph2">&lt;/a&gt;</ph> 针对 Microsoft.NET 环境实现了 Apache Avro 数据序列化系统。Apache Avro 为序列化提供了一种紧凑的二进制数据交换格式。它使用 <ph id="ph3">&lt;a href="http://www.json.org" target="_blank"&gt;</ph>JSON<ph id="ph4">&lt;/a&gt;</ph> 定义与语言无关的架构，以支持语言互操作性。以一种语言序列化的数据可以用另一种语言读取。目前支持 C、C++、C#、Java、PHP、Python 和 Ruby。有关格式的详细信息可以在 <ph id="ph5">&lt;a href="http://avro.apache.org/docs/current/spec.html" target="_blank"&gt;</ph>Apache Avro 规范<ph id="ph6">&lt;/a&gt;</ph>中找到。请注意，Microsoft Avro Library 的当前版本不支持此规范的远程过程调用 (RPC) 部分。</source>
          <target state="new"><ph id="ph1">&lt;a href="https://hadoopsdk.codeplex.com/wikipage?title=Avro%20Library" target="_blank"&gt;</ph>Microsoft Avro Library<ph id="ph2">&lt;/a&gt;</ph> 针对 Microsoft.NET 环境实现了 Apache Avro 数据序列化系统。Apache Avro 为序列化提供了一种紧凑的二进制数据交换格式。它使用 <ph id="ph3">&lt;a href="http://www.json.org" target="_blank"&gt;</ph>JSON<ph id="ph4">&lt;/a&gt;</ph> 定义与语言无关的架构，以支持语言互操作性。以一种语言序列化的数据可以用另一种语言读取。目前支持 C、C++、C#、Java、PHP、Python 和 Ruby。有关格式的详细信息可以在 <ph id="ph5">&lt;a href="http://avro.apache.org/docs/current/spec.html" target="_blank"&gt;</ph>Apache Avro 规范<ph id="ph6">&lt;/a&gt;</ph>中找到。请注意，Microsoft Avro Library 的当前版本不支持此规范的远程过程调用 (RPC) 部分。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Avro 系统中的对象的序列化表示形式由两部分组成：架构和实际值。Avro 架构使用 JSON 描述已序列化数据的与语言无关的数据模型。它与数据的二进制表示形式并排显示。将架构与二进制表示形式分离，使写入每个对象时没有针对值的开销，从而实现快速序列化和较小的表示形式。</source>
          <target state="new">Avro 系统中的对象的序列化表示形式由两部分组成：架构和实际值。Avro 架构使用 JSON 描述已序列化数据的与语言无关的数据模型。它与数据的二进制表示形式并排显示。将架构与二进制表示形式分离，使写入每个对象时没有针对值的开销，从而实现快速序列化和较小的表示形式。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="hadoopScenario"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Hadoop 应用场景</source>
          <target state="new"><ph id="ph1">&lt;a name="hadoopScenario"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Hadoop 应用场景</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Apache Avro 序列化格式广泛应用于 Azure HDInsight 及其他 Apache Hadoop 环境中。Avro 提供了简便的方法来表示 Hadoop MapReduce 作业内的复杂数据结构。Avro 文件（Avro 对象容器文件）格式已设计为支持分布式 MapReduce 编程模型。实现分布的关键功能是文件是“可拆分的”，也就是说，用户可以在文件中搜寻任一点，然后即可从某一特定块开始读取。</source>
          <target state="new">Apache Avro 序列化格式广泛应用于 Azure HDInsight 及其他 Apache Hadoop 环境中。Avro 提供了简便的方法来表示 Hadoop MapReduce 作业内的复杂数据结构。Avro 文件（Avro 对象容器文件）格式已设计为支持分布式 MapReduce 编程模型。实现分布的关键功能是文件是“可拆分的”，也就是说，用户可以在文件中搜寻任一点，然后即可从某一特定块开始读取。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="serializationMAL"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Microsoft Avro Library 中的序列化</source>
          <target state="new"><ph id="ph1">&lt;a name="serializationMAL"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>Microsoft Avro Library 中的序列化</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>.NET Library for Avro 支持通过两种方式序列化对象：</source>
          <target state="new">.NET Library for Avro 支持通过两种方式序列化对象：</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>反射<ept id="p1">**</ept> - 自动从要序列化的 .NET 类型的数据协定特性生成这些类型的 JSON 架构。</source>
          <target state="new"><bpt id="p1">**</bpt>反射<ept id="p1">**</ept> - 自动从要序列化的 .NET 类型的数据协定特性生成这些类型的 JSON 架构。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>通用记录<ept id="p1">**</ept> - 当没有 .NET 类型可以用来描述要序列化的数据的架构时，系统会在以 <bpt id="p2">[</bpt><bpt id="p3">**</bpt>AvroRecord<ept id="p3">**</ept><ept id="p2">](http://msdn.microsoft.com/zh-cn/library/microsoft.hadoop.avro.avrorecord.aspx)</ept> 类表示的记录中显式指定 JSON 架构。</source>
          <target state="new"><bpt id="p1">**</bpt>通用记录<ept id="p1">**</ept> - 当没有 .NET 类型可以用来描述要序列化的数据的架构时，系统会在以 <bpt id="p2">[</bpt><bpt id="p3">**</bpt>AvroRecord<ept id="p3">**</ept><ept id="p2">](http://msdn.microsoft.com/zh-cn/library/microsoft.hadoop.avro.avrorecord.aspx)</ept> 类表示的记录中显式指定 JSON 架构。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>当流的写入器和读取器都知道数据架构时，可以发送没有架构的数据。在未使用 Avro 对象容器文件的情况下，架构将存储在文件中。可以指定其他参数，例如用于数据压缩的编解码器。这些情况将在下面的代码示例中进一步详述和说明。</source>
          <target state="new">当流的写入器和读取器都知道数据架构时，可以发送没有架构的数据。在未使用 Avro 对象容器文件的情况下，架构将存储在文件中。可以指定其他参数，例如用于数据压缩的编解码器。这些情况将在下面的代码示例中进一步详述和说明。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="prerequisites"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 安装 Avro Library</source>
          <target state="new"><ph id="ph1">&lt;a name="prerequisites"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 安装 Avro Library</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>以下是安装此库之前所需具备的先决条件：</source>
          <target state="new">以下是安装此库之前所需具备的先决条件：</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a href="http://www.microsoft.com/download/details.aspx?id=17851" target="_blank"&gt;</ph>Microsoft .NET Framework 4<ph id="ph2">&lt;/a&gt;</ph></source>
          <target state="new"><ph id="ph1">&lt;a href="http://www.microsoft.com/download/details.aspx?id=17851" target="_blank"&gt;</ph>Microsoft .NET Framework 4<ph id="ph2">&lt;/a&gt;</ph></target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a href="http://james.newtonking.com/json" target="_blank"&gt;</ph>Newtonsoft Json.NET<ph id="ph2">&lt;/a&gt;</ph>（6.0.4 或更高版本）</source>
          <target state="new"><ph id="ph1">&lt;a href="http://james.newtonking.com/json" target="_blank"&gt;</ph>Newtonsoft Json.NET<ph id="ph2">&lt;/a&gt;</ph>（6.0.4 或更高版本）</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>请注意，Newtonsoft.Json.dll 依赖项已随着 Microsoft Avro Library 的安装自动下载。下一部分将提供此操作的相关过程。</source>
          <target state="new">请注意，Newtonsoft.Json.dll 依赖项已随着 Microsoft Avro Library 的安装自动下载。下一部分将提供此操作的相关过程。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Microsoft Avro Library 以 NuGet 包发行，你可以使用以下过程在 Visual Studio 中安装 NuGet 程序包：</source>
          <target state="new">Microsoft Avro Library 以 NuGet 包发行，你可以使用以下过程在 Visual Studio 中安装 NuGet 程序包：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>选择“项目”选项卡-&gt;“管理 NuGet 包...”</source>
          <target state="new">选择“项目”选项卡-&gt;“管理 NuGet 包...”</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>在“联机搜索”框中，搜索“Microsoft.Hadoop.Avro”。</source>
          <target state="new">在“联机搜索”框中，搜索“Microsoft.Hadoop.Avro”。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>单击“Azure HDInsight Avro Library”旁边的“安装”按钮。</source>
          <target state="new">单击“Azure HDInsight Avro Library”旁边的“安装”按钮。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>请注意，Newtonsoft.Json.dll (&gt;= 6.0.4) 依赖项也将随 Microsoft Avro Library 一起自动下载。</source>
          <target state="new">请注意，Newtonsoft.Json.dll (&gt;= 6.0.4) 依赖项也将随 Microsoft Avro Library 一起自动下载。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>你可能需要浏览 <ph id="ph1">&lt;a href="https://hadoopsdk.codeplex.com/wikipage?title=Avro%20Library" target="_blank"&gt;</ph>Microsoft Avro Library 主页<ph id="ph2">&lt;/a&gt;</ph>以阅读最新的发行说明。</source>
          <target state="new">你可能需要浏览 <ph id="ph1">&lt;a href="https://hadoopsdk.codeplex.com/wikipage?title=Avro%20Library" target="_blank"&gt;</ph>Microsoft Avro Library 主页<ph id="ph2">&lt;/a&gt;</ph>以阅读最新的发行说明。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a href="https://hadoopsdk.codeplex.com/wikipage?title=Avro%20Library" target="_blank"&gt;</ph>Microsoft Avro Library 主页<ph id="ph2">&lt;/a&gt;</ph>中提供了 Microsoft Avro Library 源代码。</source>
          <target state="new"><ph id="ph1">&lt;a href="https://hadoopsdk.codeplex.com/wikipage?title=Avro%20Library" target="_blank"&gt;</ph>Microsoft Avro Library 主页<ph id="ph2">&lt;/a&gt;</ph>中提供了 Microsoft Avro Library 源代码。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="compiling"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>使用 Avro Library 编译架构</source>
          <target state="new"><ph id="ph1">&lt;a name="compiling"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>使用 Avro Library 编译架构</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Microsoft Avro Library 包含代码生成实用工具，可让你自动根据先前定义的 JSON 架构来创建 C# 类型。代码生成实用工具不是以二进制可执行文件的形式分发的，但你可使用以下过程轻松生成：</source>
          <target state="new">Microsoft Avro Library 包含代码生成实用工具，可让你自动根据先前定义的 JSON 架构来创建 C# 类型。代码生成实用工具不是以二进制可执行文件的形式分发的，但你可使用以下过程轻松生成：</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>从 <ph id="ph1">&lt;a href="http://hadoopsdk.codeplex.com/SourceControl/latest" target="_blank"&gt;</ph>Microsoft .NET SDK For Hadoop<ph id="ph2">&lt;/a&gt;</ph> 下载包含最新版 HDInsight SDK 源代码的 ZIP 文件。（单击“下载”图标。）</source>
          <target state="new">从 <ph id="ph1">&lt;a href="http://hadoopsdk.codeplex.com/SourceControl/latest" target="_blank"&gt;</ph>Microsoft .NET SDK For Hadoop<ph id="ph2">&lt;/a&gt;</ph> 下载包含最新版 HDInsight SDK 源代码的 ZIP 文件。（单击“下载”图标。）</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>将 HDInsight SDK 解压缩到已安装 .NET Framework 4.0 并连接到 Internet 的计算机上的目录，以下载必要的依赖项 NuGet 包。下面我们假设源代码已解压缩到 C:\\SDK。</source>
          <target state="new">将 HDInsight SDK 解压缩到已安装 .NET Framework 4.0 并连接到 Internet 的计算机上的目录，以下载必要的依赖项 NuGet 包。下面我们假设源代码已解压缩到 C:\\SDK。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>转到文件夹 C:\\SDK\\src\\Microsoft.Hadoop.Avro.Tools 并运行 build.bat。（此文件将从 .NET Framework 的 32 位分发版调用 MSBuild。如果你想要使用 64 位版本，请编辑 build.bat 文件注释后的列。） 确保生成成功。（在某些系统上，MSBuild 可能生成警告。只要没有生成错误，这些警告就不影响实用工具。）</source>
          <target state="new">转到文件夹 C:\\SDK\\src\\Microsoft.Hadoop.Avro.Tools 并运行 build.bat。（此文件将从 .NET Framework 的 32 位分发版调用 MSBuild。如果你想要使用 64 位版本，请编辑 build.bat 文件注释后的列。） 确保生成成功。（在某些系统上，MSBuild 可能生成警告。只要没有生成错误，这些警告就不影响实用工具。）</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>编译的实用工具位于 C:\\SDK\\Bin\\Unsigned\\Release\\Microsoft.Hadoop.Avro.Tools 中。</source>
          <target state="new">编译的实用工具位于 C:\\SDK\\Bin\\Unsigned\\Release\\Microsoft.Hadoop.Avro.Tools 中。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>若要熟悉命令行语法，请从代码生成实用工具所在的文件夹运行以下命令：<ph id="ph1">`Microsoft.Hadoop.Avro.Tools help /c:codegen`</ph></source>
          <target state="new">若要熟悉命令行语法，请从代码生成实用工具所在的文件夹运行以下命令：<ph id="ph1">`Microsoft.Hadoop.Avro.Tools help /c:codegen`</ph></target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>若要测试实用工具，你可以从随着源代码提供的示例 JSON 架构文件生成 C# 类。运行以下命令：</source>
          <target state="new">若要测试实用工具，你可以从随着源代码提供的示例 JSON 架构文件生成 C# 类。运行以下命令：</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>这应该在当前目录中生成两个 C# 文件：SensorData.cs 和 Location.cs。</source>
          <target state="new">这应该在当前目录中生成两个 C# 文件：SensorData.cs 和 Location.cs。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>若要了解代码生成实用工具在转换 JSON 架构为 C# 类型时使用的逻辑，请参阅 C:\\SDK\\src\\Microsoft.Hadoop.Avro.Tools\\Doc 中的 GenerationVerification.feature 文件。</source>
          <target state="new">若要了解代码生成实用工具在转换 JSON 架构为 C# 类型时使用的逻辑，请参阅 C:\\SDK\\src\\Microsoft.Hadoop.Avro.Tools\\Doc 中的 GenerationVerification.feature 文件。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>请注意，该命名空间是使用上一个段落中提及的文件中所描述的逻辑，从 JSON 架构中提取。从架构提取的命名空间，将比实用工具命令行中使用 /n 参数提供的设置具有优先权。如果你想要重写架构中包含的命名空间，请确保使用 /nf 参数。例如，若要将所有命名空间从 SampleJSONSchema.avsc 更改为 my.own.nspace，请运行以下命令：</source>
          <target state="new">请注意，该命名空间是使用上一个段落中提及的文件中所描述的逻辑，从 JSON 架构中提取。从架构提取的命名空间，将比实用工具命令行中使用 /n 参数提供的设置具有优先权。如果你想要重写架构中包含的命名空间，请确保使用 /nf 参数。例如，若要将所有命名空间从 SampleJSONSchema.avsc 更改为 my.own.nspace，请运行以下命令：</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="samples"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 示例</source>
          <target state="new"><ph id="ph1">&lt;a name="samples"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 示例</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>本主题中提供的六个示例演示了 Microsoft Avro Library 所支持的不同方案。Microsoft Avro Library 设计为可处理任何流。在这些示例中，为保持简单性和一致性，是使用内存流（而不是文件流或数据库）来操作数据的。在生产环境中所采取的方法将取决于实际的方案要求、数据源和卷、性能限制及其他因素。</source>
          <target state="new">本主题中提供的六个示例演示了 Microsoft Avro Library 所支持的不同方案。Microsoft Avro Library 设计为可处理任何流。在这些示例中，为保持简单性和一致性，是使用内存流（而不是文件流或数据库）来操作数据的。在生产环境中所采取的方法将取决于实际的方案要求、数据源和卷、性能限制及其他因素。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>前两个示例显示如何使用反射和通用记录将数据序列化到内存流缓冲区，以及如何进行反序列化。这两个方案假设在读取器和写入器之间共享架构。</source>
          <target state="new">前两个示例显示如何使用反射和通用记录将数据序列化到内存流缓冲区，以及如何进行反序列化。这两个方案假设在读取器和写入器之间共享架构。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>第三和第四个示例说明如何使用 Avro 对象容器文件，将数据序列化与反序列化。当数据存储在 Avro 容器文件中时，其架构始终随之一起存储，因为必须共享架构才能进行反序列化。</source>
          <target state="new">第三和第四个示例说明如何使用 Avro 对象容器文件，将数据序列化与反序列化。当数据存储在 Avro 容器文件中时，其架构始终随之一起存储，因为必须共享架构才能进行反序列化。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>包含前四个示例的样例可以从 <ph id="ph1">&lt;a href="https://github.com/Azure-Samples" target="_blank"&gt;</ph>Azure 代码示例<ph id="ph2">&lt;/a&gt;</ph>站点下载。</source>
          <target state="new">包含前四个示例的样例可以从 <ph id="ph1">&lt;a href="https://github.com/Azure-Samples" target="_blank"&gt;</ph>Azure 代码示例<ph id="ph2">&lt;/a&gt;</ph>站点下载。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>第五个示例演示如何将自定义压缩编解码器用于 Avro 对象容器文件。包含此示例代码的样例可以从 <ph id="ph1">&lt;a href="https://github.com/Azure-Samples" target="_blank"&gt;</ph>Azure 代码示例<ph id="ph2">&lt;/a&gt;</ph>站点下载。</source>
          <target state="new">第五个示例演示如何将自定义压缩编解码器用于 Avro 对象容器文件。包含此示例代码的样例可以从 <ph id="ph1">&lt;a href="https://github.com/Azure-Samples" target="_blank"&gt;</ph>Azure 代码示例<ph id="ph2">&lt;/a&gt;</ph>站点下载。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>第六个示例显示如何使用 Avro 序列化来上载数据到 Azure Blob 存储，然后使用具有 HDInsight (Hadoop) 群集的 Hive 加以分析。可以从 <ph id="ph1">&lt;a href="https://github.com/Azure-Samples" target="_blank"&gt;</ph>Azure 代码示例<ph id="ph2">&lt;/a&gt;</ph>站点下载该示例。</source>
          <target state="new">第六个示例显示如何使用 Avro 序列化来上载数据到 Azure Blob 存储，然后使用具有 HDInsight (Hadoop) 群集的 Hive 加以分析。可以从 <ph id="ph1">&lt;a href="https://github.com/Azure-Samples" target="_blank"&gt;</ph>Azure 代码示例<ph id="ph2">&lt;/a&gt;</ph>站点下载该示例。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>以下是本主题所讨论的六个示例的链接：</source>
          <target state="new">以下是本主题所讨论的六个示例的链接：</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a href="#Scenario1"&gt;</ph><bpt id="p1">**</bpt>通过反射进行序列化<ept id="p1">**</ept><ph id="ph2">&lt;/a&gt;</ph> - 自动从数据协定特性生成要序列化的类型的 JSON 架构。</source>
          <target state="new"><ph id="ph1">&lt;a href="#Scenario1"&gt;</ph><bpt id="p1">**</bpt>通过反射进行序列化<ept id="p1">**</ept><ph id="ph2">&lt;/a&gt;</ph> - 自动从数据协定特性生成要序列化的类型的 JSON 架构。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a href="#Scenario2"&gt;</ph><bpt id="p1">**</bpt>通过通用记录进行序列化<ept id="p1">**</ept><ph id="ph2">&lt;/a&gt;</ph> - 当没有可用于反射的 .NET 类型时，在记录中显式指定 JSON 架构。</source>
          <target state="new"><ph id="ph1">&lt;a href="#Scenario2"&gt;</ph><bpt id="p1">**</bpt>通过通用记录进行序列化<ept id="p1">**</ept><ph id="ph2">&lt;/a&gt;</ph> - 当没有可用于反射的 .NET 类型时，在记录中显式指定 JSON 架构。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a href="#Scenario3"&gt;</ph><bpt id="p1">**</bpt>使用对象容器文件与反射进行序列化<ept id="p1">**</ept><ph id="ph2">&lt;/a&gt;</ph> - JSON 架构自动生成并使用 Avro 对象容器文件随着序列化的数据共享。</source>
          <target state="new"><ph id="ph1">&lt;a href="#Scenario3"&gt;</ph><bpt id="p1">**</bpt>使用对象容器文件与反射进行序列化<ept id="p1">**</ept><ph id="ph2">&lt;/a&gt;</ph> - JSON 架构自动生成并使用 Avro 对象容器文件随着序列化的数据共享。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a href="#Scenario4"&gt;</ph><bpt id="p1">**</bpt>使用对象容器文件与通用记录进行序列化<ept id="p1">**</ept><ph id="ph2">&lt;/a&gt;</ph> - JSON 架构是在序列化前显式指定的，并使用 Avro 对象容器文件随着序列化的数据共享。</source>
          <target state="new"><ph id="ph1">&lt;a href="#Scenario4"&gt;</ph><bpt id="p1">**</bpt>使用对象容器文件与通用记录进行序列化<ept id="p1">**</ept><ph id="ph2">&lt;/a&gt;</ph> - JSON 架构是在序列化前显式指定的，并使用 Avro 对象容器文件随着序列化的数据共享。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a href="#Scenario5"&gt;</ph><bpt id="p1">**</bpt>使用对象容器文件和自定义压缩编解码器进行序列化<ept id="p1">**</ept><ph id="ph2">&lt;/a&gt;</ph> - 该示例演示如何使用 Deflate 数据压缩编解码器的自定义 .NET 实现，来创建 Avro 对象容器文件。</source>
          <target state="new"><ph id="ph1">&lt;a href="#Scenario5"&gt;</ph><bpt id="p1">**</bpt>使用对象容器文件和自定义压缩编解码器进行序列化<ept id="p1">**</ept><ph id="ph2">&lt;/a&gt;</ph> - 该示例演示如何使用 Deflate 数据压缩编解码器的自定义 .NET 实现，来创建 Avro 对象容器文件。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a href="#Scenario6"&gt;</ph><bpt id="p1">**</bpt>使用 Avro 来上载 Azure HDInsight 服务的数据<ept id="p1">**</ept><ph id="ph2">&lt;/a&gt;</ph> - 该示例演示 Avro 序列化如何与 HDInsight 服务交互。要运行此示例，你必须具备有效的 Azure 订阅并且可以访问 Azure HDInsight 群集。</source>
          <target state="new"><ph id="ph1">&lt;a href="#Scenario6"&gt;</ph><bpt id="p1">**</bpt>使用 Avro 来上载 Azure HDInsight 服务的数据<ept id="p1">**</ept><ph id="ph2">&lt;/a&gt;</ph> - 该示例演示 Avro 序列化如何与 HDInsight 服务交互。要运行此示例，你必须具备有效的 Azure 订阅并且可以访问 Azure HDInsight 群集。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="Scenario1"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例 1：通过反射进行序列化</source>
          <target state="new"><ph id="ph1">&lt;a name="Scenario1"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例 1：通过反射进行序列化</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Microsoft Avro Library 可以使用反射从要序列化的 C# 对象的数据协定特性自动生成类型的 JSON 架构。Microsoft Avro Library 将创建一个 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IAvroSeralizer<ph id="ph1">&lt;T&gt;</ph><ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/zh-cn/library/dn627341.aspx)</ept> 以标识要序列化的字段。</source>
          <target state="new">Microsoft Avro Library 可以使用反射从要序列化的 C# 对象的数据协定特性自动生成类型的 JSON 架构。Microsoft Avro Library 将创建一个 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IAvroSeralizer<ph id="ph1">&lt;T&gt;</ph><ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/zh-cn/library/dn627341.aspx)</ept> 以标识要序列化的字段。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>在此示例中，将对象（具有成员 <bpt id="p1">**</bpt>Location<ept id="p1">**</ept> 结构的 <bpt id="p2">**</bpt>SensorData<ept id="p2">**</ept> 类）序列化到内存流，继而又将此流反序列化。然后，将结果与初始实例进行比较，以确认恢复的 <bpt id="p3">**</bpt>SensorData<ept id="p3">**</ept> 对象与原始对象相同。</source>
          <target state="new">在此示例中，将对象（具有成员 <bpt id="p1">**</bpt>Location<ept id="p1">**</ept> 结构的 <bpt id="p2">**</bpt>SensorData<ept id="p2">**</ept> 类）序列化到内存流，继而又将此流反序列化。然后，将结果与初始实例进行比较，以确认恢复的 <bpt id="p3">**</bpt>SensorData<ept id="p3">**</ept> 对象与原始对象相同。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>此示例中的架构假定在读取器与写入器之间共享，因此无需采用 Avro 对象容器格式。有关在架构必须与数据一起共享时，如何使用反射和对象容器格式将数据序列化到内存缓冲区，以及如何对内存缓冲区中的数据进行反序列化的示例，请参阅<ph id="ph1">&lt;a href="#Scenario3"&gt;</ph>使用对象容器文件通过反射进行序列化<ph id="ph2">&lt;/a&gt;</ph>。</source>
          <target state="new">此示例中的架构假定在读取器与写入器之间共享，因此无需采用 Avro 对象容器格式。有关在架构必须与数据一起共享时，如何使用反射和对象容器格式将数据序列化到内存缓冲区，以及如何对内存缓冲区中的数据进行反序列化的示例，请参阅<ph id="ph1">&lt;a href="#Scenario3"&gt;</ph>使用对象容器文件通过反射进行序列化<ph id="ph2">&lt;/a&gt;</ph>。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="Scenario2"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例 2：通过通用记录进行序列化</source>
          <target state="new"><ph id="ph1">&lt;a name="Scenario2"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例 2：通过通用记录进行序列化</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>当数据无法使用具有数据协定的 .NET 类表示而导致不能使用反射时，可以在通用记录中显式指定 JSON 架构。此方法通常比使用反射要慢。在这种情况下，数据架构也可能是动态的，因为在编译之前它是未知的。以逗号分隔值 (CSV) 文件表示的数据（在运行时转换为 Avro 格式之前，其架构一直是未知的）是这种动态方案的一个示例。</source>
          <target state="new">当数据无法使用具有数据协定的 .NET 类表示而导致不能使用反射时，可以在通用记录中显式指定 JSON 架构。此方法通常比使用反射要慢。在这种情况下，数据架构也可能是动态的，因为在编译之前它是未知的。以逗号分隔值 (CSV) 文件表示的数据（在运行时转换为 Avro 格式之前，其架构一直是未知的）是这种动态方案的一个示例。</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>此示例演示如何创建 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AvroRecord<ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/zh-cn/library/microsoft.hadoop.avro.avrorecord.aspx)</ept> 并使用它显式指定 JSON 架构，如何为其填充数据，然后对其进行序列化和反序列化。然后，将结果与初始实例进行比较，以确认恢复的记录与原始记录相同。</source>
          <target state="new">此示例演示如何创建 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AvroRecord<ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/zh-cn/library/microsoft.hadoop.avro.avrorecord.aspx)</ept> 并使用它显式指定 JSON 架构，如何为其填充数据，然后对其进行序列化和反序列化。然后，将结果与初始实例进行比较，以确认恢复的记录与原始记录相同。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>此示例中的架构假定在读取器与写入器之间共享，因此无需采用 Avro 对象容器格式。有关在架构必须包含在已序列化的数据中时，如何使用通用记录和对象容器格式将数据序列化到内存缓冲区，以及对内存缓冲区中的数据进行反序列化的示例，请参阅<ph id="ph1">&lt;a href="#Scenario4"&gt;</ph>使用对象容器文件通过通用记录进行序列化<ph id="ph2">&lt;/a&gt;</ph>示例。</source>
          <target state="new">此示例中的架构假定在读取器与写入器之间共享，因此无需采用 Avro 对象容器格式。有关在架构必须包含在已序列化的数据中时，如何使用通用记录和对象容器格式将数据序列化到内存缓冲区，以及对内存缓冲区中的数据进行反序列化的示例，请参阅<ph id="ph1">&lt;a href="#Scenario4"&gt;</ph>使用对象容器文件通过通用记录进行序列化<ph id="ph2">&lt;/a&gt;</ph>示例。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="Scenario3"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例 3：使用对象容器文件进行序列化与使用反射进行序列化</source>
          <target state="new"><ph id="ph1">&lt;a name="Scenario3"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例 3：使用对象容器文件进行序列化与使用反射进行序列化</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>此示例与<ph id="ph1">&lt;a href="#Scenario1"&gt;</ph>第一个示例<ph id="ph2">&lt;/a&gt;</ph>中使用反射隐式指定架构的方案类似。除了本示例假设要将架构反序列化的读取器不知道架构以外。要序列化的 <bpt id="p1">**</bpt>SensorData<ept id="p1">**</ept> 对象及其隐式指定的架构存储在由 <bpt id="p2">[</bpt><bpt id="p3">**</bpt>AvroContainer<ept id="p3">**</ept><ept id="p2">](http://msdn.microsoft.com/zh-cn/library/microsoft.hadoop.avro.container.avrocontainer.aspx)</ept> 类表示的 Avro 对象容器文件中。</source>
          <target state="new">此示例与<ph id="ph1">&lt;a href="#Scenario1"&gt;</ph>第一个示例<ph id="ph2">&lt;/a&gt;</ph>中使用反射隐式指定架构的方案类似。除了本示例假设要将架构反序列化的读取器不知道架构以外。要序列化的 <bpt id="p1">**</bpt>SensorData<ept id="p1">**</ept> 对象及其隐式指定的架构存储在由 <bpt id="p2">[</bpt><bpt id="p3">**</bpt>AvroContainer<ept id="p3">**</ept><ept id="p2">](http://msdn.microsoft.com/zh-cn/library/microsoft.hadoop.avro.container.avrocontainer.aspx)</ept> 类表示的 Avro 对象容器文件中。</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>在此示例中，数据使用 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>SequentialWriter<ph id="ph1">&lt;SensorData&gt;</ph><ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/zh-cn/library/dn627340.aspx)</ept> 进行序列化，使用 <bpt id="p3">[</bpt><bpt id="p4">**</bpt>SequentialReader<ph id="ph2">&lt;SensorData&gt;</ph><ept id="p4">**</ept><ept id="p3">](http://msdn.microsoft.com/zh-cn/library/dn627340.aspx)</ept> 进行反序列化。然后，将结果与初始实例比较，以确保相同。</source>
          <target state="new">在此示例中，数据使用 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>SequentialWriter<ph id="ph1">&lt;SensorData&gt;</ph><ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/zh-cn/library/dn627340.aspx)</ept> 进行序列化，使用 <bpt id="p3">[</bpt><bpt id="p4">**</bpt>SequentialReader<ph id="ph2">&lt;SensorData&gt;</ph><ept id="p4">**</ept><ept id="p3">](http://msdn.microsoft.com/zh-cn/library/dn627340.aspx)</ept> 进行反序列化。然后，将结果与初始实例比较，以确保相同。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>对象容器文件中的数据是通过 .NET Framework 4 中的默认 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Deflate<ept id="p2">**</ept><ept id="p1">][deflate-100]</ept> 压缩编解码器压缩的。请参阅本主题中的<ph id="ph1">&lt;a href="#Scenario5"&gt;</ph>第五个示例<ph id="ph2">&lt;/a&gt;</ph>，了解如何使用 .NET Framework 4.5 中提供的更新的 <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Deflate<ept id="p4">**</ept><ept id="p3">][deflate-110]</ept> 压缩编解码器高级版。</source>
          <target state="new">对象容器文件中的数据是通过 .NET Framework 4 中的默认 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Deflate<ept id="p2">**</ept><ept id="p1">][deflate-100]</ept> 压缩编解码器压缩的。请参阅本主题中的<ph id="ph1">&lt;a href="#Scenario5"&gt;</ph>第五个示例<ph id="ph2">&lt;/a&gt;</ph>，了解如何使用 .NET Framework 4.5 中提供的更新的 <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Deflate<ept id="p4">**</ept><ept id="p3">][deflate-110]</ept> 压缩编解码器高级版。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="Scenario4"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例 4：使用对象容器文件进行序列化与使用通用记录进行序列化</source>
          <target state="new"><ph id="ph1">&lt;a name="Scenario4"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例 4：使用对象容器文件进行序列化与使用通用记录进行序列化</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>此示例与<ph id="ph1">&lt;a href="#Scenario2"&gt;</ph>第二个示例<ph id="ph2">&lt;/a&gt;</ph>中使用 JSON 显式指定架构的方案类似。除了本示例假设要将架构反序列化的读取器不知道架构以外。</source>
          <target state="new">此示例与<ph id="ph1">&lt;a href="#Scenario2"&gt;</ph>第二个示例<ph id="ph2">&lt;/a&gt;</ph>中使用 JSON 显式指定架构的方案类似。除了本示例假设要将架构反序列化的读取器不知道架构以外。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>测试数据集将通过显式定义的 JSON 架构收集到 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AvroRecord<ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/zh-cn/library/microsoft.hadoop.avro.avrorecord.aspx)</ept> 对象列表中，然后存储在由 <bpt id="p3">[</bpt><bpt id="p4">**</bpt>AvroContainer<ept id="p4">**</ept><ept id="p3">](http://msdn.microsoft.com/zh-cn/library/microsoft.hadoop.avro.container.avrocontainer.aspx)</ept> 类表示的对象容器文件中。此容器文件将创建一个写入器，该写入器用于将未压缩的数据序列化到内存流，然后将该内存流保存到文件中。指定不要压缩此数据的是创建读取器时所用的 <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Codex.Null<ept id="p6">**</ept><ept id="p5">](http://msdn.microsoft.com/zh-cn/library/microsoft.hadoop.avro.container.codec.null.aspx)</ept> 参数。</source>
          <target state="new">测试数据集将通过显式定义的 JSON 架构收集到 <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AvroRecord<ept id="p2">**</ept><ept id="p1">](http://msdn.microsoft.com/zh-cn/library/microsoft.hadoop.avro.avrorecord.aspx)</ept> 对象列表中，然后存储在由 <bpt id="p3">[</bpt><bpt id="p4">**</bpt>AvroContainer<ept id="p4">**</ept><ept id="p3">](http://msdn.microsoft.com/zh-cn/library/microsoft.hadoop.avro.container.avrocontainer.aspx)</ept> 类表示的对象容器文件中。此容器文件将创建一个写入器，该写入器用于将未压缩的数据序列化到内存流，然后将该内存流保存到文件中。指定不要压缩此数据的是创建读取器时所用的 <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Codex.Null<ept id="p6">**</ept><ept id="p5">](http://msdn.microsoft.com/zh-cn/library/microsoft.hadoop.avro.container.codec.null.aspx)</ept> 参数。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>然后，从文件中读取数据，并将数据反序列化为对象的集合。将此集合与 Avro 记录的初始列表进行比较，以确认它们相同。</source>
          <target state="new">然后，从文件中读取数据，并将数据反序列化为对象的集合。将此集合与 Avro 记录的初始列表进行比较，以确认它们相同。</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="Scenario5"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例 5：使用对象容器文件通过自定义压缩编解码器进行序列化</source>
          <target state="new"><ph id="ph1">&lt;a name="Scenario5"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例 5：使用对象容器文件通过自定义压缩编解码器进行序列化</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>第五个示例演示如何将自定义压缩编解码器用于 Avro 对象容器文件。包含此示例代码的样例可以从 <bpt id="p1">[</bpt>Azure 代码示例<ept id="p1">](https://github.com/Azure-Samples)</ept>站点下载。</source>
          <target state="new">第五个示例演示如何将自定义压缩编解码器用于 Avro 对象容器文件。包含此示例代码的样例可以从 <bpt id="p1">[</bpt>Azure 代码示例<ept id="p1">](https://github.com/Azure-Samples)</ept>站点下载。</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Avro 规范<ept id="p1">](http://avro.apache.org/docs/current/spec.html#Required+Codecs)</ept>允许使用可选的压缩编解码器（除了 <bpt id="p2">**</bpt>Null<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>Deflate<ept id="p3">**</ept> 默认压缩编解码器外）。此示例未完全实现类似 Snappy（在 <bpt id="p4">[</bpt>Avro 规范<ept id="p4">](http://avro.apache.org/docs/current/spec.html#snappy)</ept>中作为支持的可选编解码器提及）的新编解码器。它演示如何使用 <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Deflate<ept id="p6">**</ept><ept id="p5">][deflate-110]</ept> 编解码器的 .NET Framework 4.5 实现，后者基于 <bpt id="p7">[</bpt>zlib<ept id="p7">](http://zlib.net/)</ept> 压缩库提供比默认的 .NET Framework 4.0 版本更好的压缩算法。</source>
          <target state="new"><bpt id="p1">[</bpt>Avro 规范<ept id="p1">](http://avro.apache.org/docs/current/spec.html#Required+Codecs)</ept>允许使用可选的压缩编解码器（除了 <bpt id="p2">**</bpt>Null<ept id="p2">**</ept> 和 <bpt id="p3">**</bpt>Deflate<ept id="p3">**</ept> 默认压缩编解码器外）。此示例未完全实现类似 Snappy（在 <bpt id="p4">[</bpt>Avro 规范<ept id="p4">](http://avro.apache.org/docs/current/spec.html#snappy)</ept>中作为支持的可选编解码器提及）的新编解码器。它演示如何使用 <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Deflate<ept id="p6">**</ept><ept id="p5">][deflate-110]</ept> 编解码器的 .NET Framework 4.5 实现，后者基于 <bpt id="p7">[</bpt>zlib<ept id="p7">](http://zlib.net/)</ept> 压缩库提供比默认的 .NET Framework 4.0 版本更好的压缩算法。</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="Scenario6"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例 6：使用 Avro 上载 Azure HDInsight 服务的数据</source>
          <target state="new"><ph id="ph1">&lt;a name="Scenario6"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>示例 6：使用 Avro 上载 Azure HDInsight 服务的数据</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>第六个示例演示与 Azure HDInsight 服务交互相关的一些编程技巧。包含此示例代码的样例可以从 <bpt id="p1">[</bpt>Azure 代码示例<ept id="p1">](https://github.com/Azure-Samples)</ept>站点下载。</source>
          <target state="new">第六个示例演示与 Azure HDInsight 服务交互相关的一些编程技巧。包含此示例代码的样例可以从 <bpt id="p1">[</bpt>Azure 代码示例<ept id="p1">](https://github.com/Azure-Samples)</ept>站点下载。</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>该示例将执行以下操作：</source>
          <target state="new">该示例将执行以下操作：</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>连接到现有的 HDInsight 服务群集。</source>
          <target state="new">连接到现有的 HDInsight 服务群集。</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>序列化多个 CSV 文件并将结果上载到 Azure Blob 存储。（CSV 文件随着示例一起分发，而且代表 <bpt id="p1">[</bpt>Infochimps<ept id="p1">](http://www.infochimps.com/)</ept> 在 1970 年到 2010 年期间提取自 AMEX 股票的历史记录数据。该示例将读取 CSV 文件数据、将记录转换为 <bpt id="p2">**</bpt>Stock<ept id="p2">**</ept> 类的实例，然后使用反射序列化这些实例。Stock 类型定义是使用 Microsoft Avro Library 代码生成实用工具从 JSON 架构创建的。</source>
          <target state="new">序列化多个 CSV 文件并将结果上载到 Azure Blob 存储。（CSV 文件随着示例一起分发，而且代表 <bpt id="p1">[</bpt>Infochimps<ept id="p1">](http://www.infochimps.com/)</ept> 在 1970 年到 2010 年期间提取自 AMEX 股票的历史记录数据。该示例将读取 CSV 文件数据、将记录转换为 <bpt id="p2">**</bpt>Stock<ept id="p2">**</ept> 类的实例，然后使用反射序列化这些实例。Stock 类型定义是使用 Microsoft Avro Library 代码生成实用工具从 JSON 架构创建的。</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>在 Hive 中创建名为 <bpt id="p1">**</bpt>Stocks<ept id="p1">**</ept> 的新外部表，并将它链接到前一个步骤中上载的数据。</source>
          <target state="new">在 Hive 中创建名为 <bpt id="p1">**</bpt>Stocks<ept id="p1">**</ept> 的新外部表，并将它链接到前一个步骤中上载的数据。</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>使用 Hive 对 <bpt id="p1">**</bpt>Stocks<ept id="p1">**</ept> 表执行查询。</source>
          <target state="new">使用 Hive 对 <bpt id="p1">**</bpt>Stocks<ept id="p1">**</ept> 表执行查询。</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>此外，该示例将在执行主要操作之前和之后执行清理过程。在清理期间，将删除所有相关的 Azure Blob 数据和文件夹，并删除 Hive 表。你也可以从示例命令行调用清理过程。</source>
          <target state="new">此外，该示例将在执行主要操作之前和之后执行清理过程。在清理期间，将删除所有相关的 Azure Blob 数据和文件夹，并删除 Hive 表。你也可以从示例命令行调用清理过程。</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>该示例要求满足以下先决条件：</source>
          <target state="new">该示例要求满足以下先决条件：</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>有效的 Azure 订阅及其订阅 ID。</source>
          <target state="new">有效的 Azure 订阅及其订阅 ID。</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>包含相应私钥的订阅管理证书。该证书应安装在用于运行示例的计算机上的当前用户私用存储中。</source>
          <target state="new">包含相应私钥的订阅管理证书。该证书应安装在用于运行示例的计算机上的当前用户私用存储中。</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>活动的 HDInsight 群集。</source>
          <target state="new">活动的 HDInsight 群集。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>在先前的必要条件中链接到 HDInsight 群集的 Azure 存储帐户，以及相应的主要或辅助访问密钥。</source>
          <target state="new">在先前的必要条件中链接到 HDInsight 群集的 Azure 存储帐户，以及相应的主要或辅助访问密钥。</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>运行示例之前，必要条件中的所有信息均应输入到示例配置文件中。要运行此操作有两个可行的方式：</source>
          <target state="new">运行示例之前，必要条件中的所有信息均应输入到示例配置文件中。要运行此操作有两个可行的方式：</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>编辑示例根目录中的 app.config 文件，然后生成示例，或</source>
          <target state="new">编辑示例根目录中的 app.config 文件，然后生成示例，或</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>先生成示例，然后在生成目录中编辑 AvroHDISample.exe.config</source>
          <target state="new">先生成示例，然后在生成目录中编辑 AvroHDISample.exe.config</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>在这两个情况下，所有编辑均应该在 <bpt id="p1">**</bpt><ph id="ph1">&lt;appSettings&gt;</ph><ept id="p1">**</ept> 设置节中完成。请遵循文件中的注释。</source>
          <target state="new">在这两个情况下，所有编辑均应该在 <bpt id="p1">**</bpt><ph id="ph1">&lt;appSettings&gt;</ph><ept id="p1">**</ept> 设置节中完成。请遵循文件中的注释。</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>执行以下命令从命令行运行该示例（其中，包含该示例的 .zip 文件假设已解压缩到 C:\\AvroHDISample；如果不是，请使用相关的文件路径）：</source>
          <target state="new">执行以下命令从命令行运行该示例（其中，包含该示例的 .zip 文件假设已解压缩到 C:\\AvroHDISample；如果不是，请使用相关的文件路径）：</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>若要清理群集，请运行以下命令：</source>
          <target state="new">若要清理群集，请运行以下命令：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>