{
  "nodes": [
    {
      "content": "缓存指南 | Azure",
      "pos": [
        26,
        38
      ]
    },
    {
      "content": "有关配置缓存以提高性能和可缩放性的指南。",
      "pos": [
        56,
        76
      ]
    },
    {
      "content": "缓存设计指南",
      "pos": [
        283,
        289
      ]
    },
    {
      "content": "缓存是一种常见的技术，目标是通过暂时将经常访问的数据复制到位置靠近应用程序的快速存储，从而提高系统的性能和可缩放性。如果这种快速数据存储比原始源更靠近应用程序，则缓存可以通过更快速提供数据，大幅改善客户端应用程序的响应时间。如果客户端实例重复读取同一数据（特别是数据保持相对静态且原始数据存储相对于缓存速度而言较慢时）、受限于激烈的资源争用，或者由于距离遥远，网络延迟会造成访问速度缓慢，则缓存是最有效的方式。",
      "pos": [
        291,
        496
      ]
    },
    {
      "content": "分布式应用程序中的缓存",
      "pos": [
        501,
        512
      ]
    },
    {
      "content": "在缓存数据时，分布式应用程序通常会实施以下一种或两种策略：",
      "pos": [
        514,
        543
      ]
    },
    {
      "content": "使用专用缓存，其中的数据保存在运行应用程序或服务实例的计算机本地。",
      "pos": [
        547,
        580
      ]
    },
    {
      "content": "使用共享缓存，充当可由多个进程和/或计算机访问的公用源。",
      "pos": [
        583,
        611
      ]
    },
    {
      "content": "在这两种情况下，缓存可在客户端（通过为系统提供用户界面（例如 Web 浏览器或桌面应用程序）的进程）和/或服务器端（通过远程运行的提供业务服务的进程）执行。",
      "pos": [
        613,
        691
      ]
    },
    {
      "content": "专用缓存",
      "pos": [
        697,
        701
      ]
    },
    {
      "content": "最基本类型的缓存是内存中存储，这种缓存保留在单个进程的地址空间中，可由该进程中运行的代码直接访问。此缓存类型可进行非常快速的访问，并可提供极其有效的策略用于存储适度的静态数据量，因为缓存大小通常受限于托管进程的计算机上可用内存量。如果缓存的信息需要超过内存中实际可用的信息，你可以将缓存数据写入本地文件系统。这一定比访问保留在内存中的数据更慢，但应该仍比通过网络检索数据更快速且更可靠。",
      "pos": [
        703,
        896
      ]
    },
    {
      "content": "如果有多个并行运行的、使用此模型的应用程序实例，则每个应用程序实例将有自身的独立缓存用于保存自身的数据副本。",
      "pos": [
        898,
        952
      ]
    },
    {
      "content": "你应该将缓存视为过去某个时间点原始数据的快照。如果此数据不是静态的，则有可能不同的应用程序实例将在其缓存中保存不同版本的数据。因此，这些实例执行的同一查询可能会返回不同的结果，如图 1 所示。",
      "pos": [
        954,
        1050
      ]
    },
    {
      "content": "在不同的应用程序实例中使用内存中缓存",
      "pos": [
        1054,
        1072
      ]
    },
    {
      "content": "图 1：在不同的应用程序实例中使用内存中缓存",
      "pos": [
        1120,
        1142
      ]
    },
    {
      "content": "共享缓存",
      "pos": [
        1149,
        1153
      ]
    },
    {
      "content": "使用共享缓存有助于缓解每个缓存中可能存在不同数据的忧虑，这种情况可能会发生于内存中缓存。共享缓存可通过找出位于不同位置的缓存，确保不同的应用程序实例（通常作为不同服务的一部分托管，如图 2 所示）看到同一缓存数据视图。",
      "pos": [
        1155,
        1264
      ]
    },
    {
      "content": "使用共享缓存\\_",
      "pos": [
        1268,
        1276
      ]
    },
    {
      "content": "图 2：使用共享缓存",
      "pos": [
        1324,
        1334
      ]
    },
    {
      "content": "使用共享缓存方法的重要优势在于它有助于提供可缩放性。许多共享缓存服务是使用服务器群集实施的，并以透明方式利用将数据分散到群集的软件。应用程序实例只会将请求发送到缓存服务，底层基础结构负责确定缓存数据在群集中的位置。你可以轻松地通过添加更多服务器来扩展缓存。",
      "pos": [
        1337,
        1465
      ]
    },
    {
      "content": "共享缓存方法的缺点是，缓存的访问速度较慢，因为它不再保留在每个应用程序实例的本地，并且为了满足实施不同缓存服务的要求，可能会增大解决方案的复杂性。",
      "pos": [
        1467,
        1540
      ]
    },
    {
      "content": "使用缓存时的注意事项",
      "pos": [
        1545,
        1555
      ]
    },
    {
      "content": "以下部分更详细地说明了设计和使用缓存时的注意事项。",
      "pos": [
        1557,
        1582
      ]
    },
    {
      "content": "何时应缓存数据？",
      "pos": [
        1588,
        1596
      ]
    },
    {
      "content": "缓存可大幅提高性能、可缩放性和可用性。当你的数据越多且需要访问此数据的用户越多，缓存的优点也就越大，因为在原始数据存储中处理大量并发请求时，可以减少相关的延迟和争用。例如，数据库可以支持有限数目的并发连接，但从共享缓存而不是底层数据库检索数据可让客户端应用程序访问此数据，即使当前可用的连接数已用尽。此外，如果数据库变得不可用，客户端应用程序也许可以使用缓存中保存的数据继续运行。",
      "pos": [
        1598,
        1788
      ]
    },
    {
      "content": "应该考虑使用经常读取但很少修改的缓存（数据读取操作的比例要高于写入操作）。但是，不应将缓存用作关键信息的权威存储；应确保应用程序不可丢失的所有更改始终存储到永久性数据存储中。这样，在缓存不可用时，应用程序仍可以使用数据存储继续操作，且你不会丢失重要信息。",
      "pos": [
        1790,
        1917
      ]
    },
    {
      "content": "数据和缓存填充策略的类型",
      "pos": [
        1923,
        1935
      ]
    },
    {
      "content": "有效使用缓存的关键在于确定最适合缓存的数据，以及最适合缓存的时间。数据可能在第一次由应用程序检索时随选添加到缓存，因此应用程序仅需从数据存储检索一次数据，而后续访问可通过使用缓存来满足。",
      "pos": [
        1937,
        2030
      ]
    },
    {
      "content": "或者，可以事先在缓存中部分或完全填充数据，这通常发生在应用程序启动时（此方法称为种子设定）。但是，不建议对大型缓存实施种子设定，因为这种方法在应用程序开始运行时，可能会在原始数据存储上造成突发性的高负载。",
      "pos": [
        2032,
        2134
      ]
    },
    {
      "content": "使用模式分析通常可以帮助确定是否要完整或部分预先填充缓存，以及选择应该缓存的数据。例如，对于定期（也许是每天）使用应用程序的客户，使用静态用户配置文件数据设定缓存种子可能相当实用，但不适用于一周仅使用一次应用程序的客户。",
      "pos": [
        2136,
        2246
      ]
    },
    {
      "content": "缓存通常适用于不会变化或很少变化的数据。示例包含引用信息，例如电子商务应用程序中的产品和价格信息，或构建成本高昂的共享静态资源。此数据的部分或全部可在应用程序启动时加载到缓存，以便将资源需求降到最低并提高性能。拥有定期更新缓存中引用数据的后台进程可能也是适当的方式，可确保其处于最新状态，或在引用数据更改时刷新缓存。",
      "pos": [
        2248,
        2406
      ]
    },
    {
      "content": "缓存可能较不适合动态数据，但这种考虑因素有一些例外情况（请参阅本指南后面的“缓存高动态数据”部分以了解详细信息）。如果原始数据定期更改，缓存的信息可能很快就会过时，或者为了保持与原始数据存储的缓存同步而产生开销，导致降低缓存的效率。请注意，缓存中不一定会包含实体的完整数据。例如，如果数据项代表多值对象（例如具有名称、地址和帐户余额的银行客户），则其中某些元素可以保持静态（名称和地址），而有些元素（例如帐户余额）则可能更加动态。在这种情况下，缓存数据的静态部分，并只在需要时检索（或计算）剩余信息可能相当有用。",
      "pos": [
        2408,
        2664
      ]
    },
    {
      "content": "应执行性能测试和使用情况分析来确定缓存的预先填充和/或按需加载是否适当。这种判断应该基于数据易变性和使用模式的组合。在会遇到重度负载且必须高度可缩放的应用程序中，缓存利用和性能分析特别重要。例如，在高度可缩放的方案中，有时可以设定缓存种子，以在高峰期降低数据存储的负载。",
      "pos": [
        2666,
        2801
      ]
    },
    {
      "content": "缓存还可用于在应用程序运行时避免重复计算。如果操作会转换数据或执行复杂计算，则可以在缓存中保存操作的结果。如果后续需要相同的计算，应用程序只需从缓存中检索结果。",
      "pos": [
        2803,
        2883
      ]
    },
    {
      "content": "应用程序可以修改保存在缓存中的数据，但是应该将缓存视为可能随时消失的暂时性数据存储。请勿只在缓存中存储重要数据，而是确保同时在原始数据存储中保留信息。这样，在缓存不可用时，可以最大程度地减少数据丢失。",
      "pos": [
        2885,
        2985
      ]
    },
    {
      "content": "缓存高动态数据",
      "pos": [
        2991,
        2998
      ]
    },
    {
      "content": "将快速变化的信息存储在永久性数据存储中可能会给系统造成开销。例如，假设有一个会持续报告状态或其他度量的设备。在缓存信息几乎一直处于过期状态的情况下，如果应用程序选择不要缓存此数据，则在数据存储中存储和检索此信息时，同样存在这种考虑因素；在保存和提取此数据时它可能已经更改。在这种情况下，请考虑直接在缓存而不是永久性数据存储中存储动态信息的优点。如果数据不太重要且不需要审核，则偶尔丢失更改的数据就无关紧要。",
      "pos": [
        3000,
        3203
      ]
    },
    {
      "content": "管理缓存中的数据过期",
      "pos": [
        3209,
        3219
      ]
    },
    {
      "content": "在大多数情况下，缓存中保存的数据是保存在原始数据存储中的数据的副本。原始数据存储中的数据可能在缓存后更改，导致缓存的数据过时。许多缓存系统允许你将缓存配置为使数据过期，以及减少数据可以过期的时间长短。",
      "pos": [
        3221,
        3321
      ]
    },
    {
      "content": "过期的缓存数据将从缓存中删除，应用程序必须从原始数据存储中检索数据（它可以将新提取的信息放回缓存）。在配置缓存时，你可以设置默认的过期策略。在许多缓存服务中，当以编程方式将单个对象存储在缓存中时（某些缓存可让你将过期时间指定为绝对值，或者，如果并未在指定的时间内访问，则从缓存中删除项的滑动值），还可以规定这些对象的过期时间。此设置将重写任何缓存范围的过期策略，但只适用于指定的对象。",
      "pos": [
        3323,
        3515
      ]
    },
    {
      "pos": [
        3519,
        3609
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>请慎重考虑缓存的过期时段及其包含的对象。如果设置的时段太短，则对象很快就会过期，因此就减少了使用缓存带来的优势。如果设置的时段太长，则会面临数据过时的风险。"
    },
    {
      "content": "此外，如果允许数据长时间驻留，则缓存有可能会填满。在此情况下，将新项添加到缓存的任何请求可能会导致某些项被强行删除，这个过程称为逐出。缓存服务通常根据最近最少使用 (LRU) 的原则逐出数据，但你通常可以重写此策略，并防止项被逐出。但是，如果采用这种方法，则会面临缓存超过可用内存，且应用程序尝试将项添加到缓存时失败并发生异常的风险。",
      "pos": [
        3611,
        3778
      ]
    },
    {
      "content": "某些缓存的实施可能会提供其他逐出策略。这些策略通常包括最近使用的策略（预期不再需要数据）、先进先出策略（先逐出最旧的数据）或基于触发事件显式删除（例如，正在修改数据）。",
      "pos": [
        3780,
        3864
      ]
    },
    {
      "content": "使客户端缓存中的数据失效",
      "pos": [
        3870,
        3882
      ]
    },
    {
      "content": "保存在客户端缓存中的数据通常被视为不受向客户端提供数据的服务的支持；服务不能直接强制客户端添加或删除来自客户端缓存的信息。这意味着，当原始数据源中的信息已更改时，使用配置不当的缓存（例如，未正确实施过期策略）的客户端可能继续使用过时的本地缓存信息。",
      "pos": [
        3884,
        4008
      ]
    },
    {
      "content": "如果要构建通过 HTTP 连接提供数据的 Web 应用程序，可以隐式强制 Web 客户端（例如浏览器或 Web 代理）在资源通过更改该资源的 URI 更新时提取最新的信息。Web 客户端通常使用资源的 URI 作为客户端缓存中的键，因此更改 URI 会导致 Web 客户端忽略任何先前缓存的资源版本，并改为提取新的版本。",
      "pos": [
        4010,
        4170
      ]
    },
    {
      "content": "管理缓存中的并发",
      "pos": [
        4175,
        4183
      ]
    },
    {
      "content": "缓存通常设计为由应用程序的多个实例共享。每个应用程序实例可以读取和修改缓存中的数据。因此，任何共享数据存储中会出现的并发问题，在缓存中同样也会出现。在应用程序需要修改缓存中保存的数据的情况下，你可能需要确保应用程序的一个实例所做的更新不会盲目地覆盖另一个实例所做的更改。",
      "pos": [
        4185,
        4320
      ]
    },
    {
      "content": "根据数据的性质和冲突的可能性，你可以采用以下两种并发方式之一：",
      "pos": [
        4322,
        4353
      ]
    },
    {
      "pos": [
        4357,
        4478
      ],
      "content": "<bpt id=\"p1\">__</bpt>乐观并发。<ept id=\"p1\">__</ept> 应用程序检查以确定缓存中的数据自检索之后、更新之前是否已更改。如果数据保持相同，则可以进行更改。否则，应用程序必须确定是否要进行更新（促使做出此决定的业务逻辑特定于应用程序）。这种方法适合不常更新或不太可能发生冲突的情况。"
    },
    {
      "pos": [
        4481,
        4637
      ],
      "content": "<bpt id=\"p1\">__</bpt>悲观并发。<ept id=\"p1\">__</ept> 应用程序在检索缓存中的数据时锁定数据，以避免另一个实例更改数据。此过程可确保不发生冲突，但可能阻止其他需要处理同一数据的实例。悲观并发可能会影响解决方案的可缩放性，只应该对短期操作使用。这种方法可能适用于很可能发生冲突的情况，特别是当应用程序更新缓存中的多个项，且必须确保这些更改一致应用时。"
    },
    {
      "content": "实现高可用性和可缩放性并提高性能",
      "pos": [
        4643,
        4659
      ]
    },
    {
      "content": "缓存不应是数据的主存储库；主存储库应该是从中填充缓存的原始数据存储。原始数据存储负责确保数据的持久性。",
      "pos": [
        4661,
        4712
      ]
    },
    {
      "pos": [
        4714,
        5016
      ],
      "content": "请小心不要将共享缓存服务可用性的重要依赖性引入解决方案。如果提供共享缓存的服务不可用，应用程序应能继续工作；应用程序应该不会在等待缓存服务恢复时停止响应或失败。因此，应用程序必须准备好检测缓存服务的可用性，并在无法访问缓存时回退到原始数据存储。<bpt id=\"p1\">[</bpt>断路器模式<ept id=\"p1\">](http://msdn.microsoft.com/zh-cn/library/dn589784.aspx)</ept>可用于处理这种情况。提供缓存的服务可以恢复，当服务可用时，缓存将在从原始数据存储读取数据时，遵循<bpt id=\"p2\">[</bpt>缓存端模式<ept id=\"p2\">](http://msdn.microsoft.com/zh-cn/library/dn589799.aspx)</ept>等策略重新填充。"
    },
    {
      "content": "但是，在缓存暂时不可用的情况下回退到原始数据存储可能会影响系统的可缩放性；在恢复数据存储时，原始数据存储可能忙于处理数据请求，导致超时和连接失败。应该考虑的策略是在每个应用程序实例中实施本地专用缓存，以及所有应用程序实例访问的共享缓存。当应用程序检索项时，可能会先后在本地缓存、共享缓存和原始数据存储中检查。共享缓存不可用时，本地缓存可以使用共享缓存或数据库中的数据来填充。采用此方法需要经过慎重的配置，以防止本地缓存相对于共享缓存而言太过时，但在无法访问共享缓存时，它可以充当缓冲区。图 3 显示了此结构。",
      "pos": [
        5018,
        5272
      ]
    },
    {
      "content": "<ph id=\"ph1\">![</ph>将本地、专用和共享缓存配合使用\\_<bpt id=\"p1\">](./media/best-practices-caching/Caching3.png)_</bpt>图 3：将本地、专用和共享缓存配合使用<ept id=\"p1\">_</ept>",
      "pos": [
        5274,
        5360
      ]
    },
    {
      "content": "图 3：将本地、专用和共享缓存配合使用",
      "pos": [
        5362,
        5381
      ]
    },
    {
      "content": "为了支持保存相对长期数据的大型缓存，某些缓存服务在缓存不可用时，提供实施自动故障转移的高可用性选项。这种方法通常涉及到将存储在主缓存服务器上的缓存数据复制到辅助缓存服务器，并在主服务器故障或断开连接时切换到辅助服务器。为了减少与写入多个目标相关的延迟，当数据写入主服务器上的缓存时，复制到辅助服务器的操作可以异步发生。此方法可能会导致某些缓存的信息在发生故障时丢失，但是此数据的比例应该小于缓存的总体大小。",
      "pos": [
        5384,
        5587
      ]
    },
    {
      "pos": [
        5589,
        5831
      ],
      "content": "如果共享缓存很大，则在节点上分区缓存数据可能很有帮助，这可减少争用的可能性，并提高可缩放性。许多共享缓存支持动态添加（与删除）节点，以及重新平衡分区之间的数据的功能。这种方法可能涉及到群集，其中，节点集合将作为无缝单一缓存向客户端应用程序呈现，但在内部，数据分散在节点之间并遵循某种预定义的分配策略，以便平均地平衡负载。<bpt id=\"p1\">[</bpt>数据分区指南文档<ept id=\"p1\">](http://msdn.microsoft.com/zh-cn/library/dn589795.aspx)</ept>提供了有关可行分区策略的详细信息。"
    },
    {
      "content": "群集还可以进一步提高缓存的可用性；如果节点发生故障，仍可访问缓存的剩余部分。群集经常与复制和故障转移结合使用；每个节点都可复制且副本在节点故障时可快速联机。",
      "pos": [
        5833,
        5911
      ]
    },
    {
      "content": "许多读取和写入操作可能会涉及到单个数据值或对象。但是，有时可能需要快速存储或检索大量数据。例如，设定缓存种子可能涉及到将数百或数千个项写入到缓存，或应用程序可能需要从缓存中检索属于同一请求的大量相关项。许多大型缓存针对这些目的提供了批处理操作，使客户端应用程序能够将大量的项打包成单个请求，并减少执行大量小型请求时的相关开销。",
      "pos": [
        5913,
        6076
      ]
    },
    {
      "content": "缓存和最终一致性",
      "pos": [
        6081,
        6089
      ]
    },
    {
      "content": "缓存端模式依赖于应用程序的实例，该应用程序填充可访问最新且一致数据版本的缓存。在实施最终一致性的系统（例如复制的数据存储）中，情况可能不是这样。应用程序的一个实例可以修改数据项，使该项的缓存版本失效。应用程序的另一个实例可以尝试从导致缓存未命中的缓存读取此项，因此它将从数据存储中读取数据，并将它添加到缓存。但是，如果数据存储没有完全与其他副本同步，则应用程序实例可能会使用旧值来读取并填充缓存。",
      "pos": [
        6091,
        6289
      ]
    },
    {
      "pos": [
        6291,
        6375
      ],
      "content": "有关处理数据一致性的详细信息，请参阅<bpt id=\"p1\">[</bpt>数据一致性指南<ept id=\"p1\">](http://msdn.microsoft.com/zh-cn/library/dn589800.aspx)</ept>页。"
    },
    {
      "content": "保护缓存的数据",
      "pos": [
        6381,
        6388
      ]
    },
    {
      "content": "无论使用的缓存服务为何，都应该考虑如何防范缓存中保存的数据遭到未经授权的访问。有两个主要考虑因素：",
      "pos": [
        6390,
        6439
      ]
    },
    {
      "content": "缓存中数据的隐私性。",
      "pos": [
        6443,
        6453
      ]
    },
    {
      "content": "数据在缓存与使用缓存的应用程序之间流动时的隐私性。",
      "pos": [
        6456,
        6481
      ]
    },
    {
      "content": "若要保护缓存中的数据，缓存服务可以实施要求应用程序识别本身的身份验证机制，并实施授权方案来指定哪些标识可以访问缓存中的数据，以及这些标识可执行的操作（读取和写入）。为了减少读取和写入数据时的相关开销，当标识已获得写入和/或读取缓存的权限时，该标识可以使用缓存中的任何数据。如果需要限制对缓存数据子集的访问权限，你可以：",
      "pos": [
        6483,
        6642
      ]
    },
    {
      "content": "将缓存拆分成分区（使用不同的缓存服务器），并只向标识授予他们有权使用的分区的访问权限，或者",
      "pos": [
        6646,
        6691
      ]
    },
    {
      "content": "使用不同的密钥来加密每个子集中的数据，并只向应该具有每个子集访问权限的标识提供加密密钥。客户端应用程序可能仍然能够检索缓存中的所有数据，但它只能够解密具有密钥的数据。",
      "pos": [
        6694,
        6777
      ]
    },
    {
      "content": "若要在数据流入或流出缓存时保护数据，你可以依赖于客户端应用程序用来连接缓存的网络基础结构所提供的安全功能。如果在托管客户端应用程序的同一组织中使用现场服务器来实施缓存，则网络本身的隔离可能不需要你采取任何其他措施。如果缓存位于远程，且需要基于公共网络（例如 Internet）的 TCP 或 HTTP 连接，你应该考虑实施 SSL。",
      "pos": [
        6779,
        6945
      ]
    },
    {
      "content": "使用 Azure 实现缓存的注意事项",
      "pos": [
        6950,
        6968
      ]
    },
    {
      "content": "Azure 提供 Azure Redis 缓存。这是开源 Redis 缓存的一种实现，可在 Azure 数据中心作为服务运行。它提供可从任何 Azure 应用程序访问的缓存服务，无论应用程序是实施为云服务、网站，还是在 Azure 虚拟机中。拥有适当访问密钥的客户端应用程序可以共享缓存。",
      "pos": [
        6970,
        7114
      ]
    },
    {
      "content": "Redis 是高性能缓存解决方案，提供可用性、可缩放性和安全性。它通常作为分散在一个或多个专用计算机上的服务运行，并会尝试在内存中存储尽量多的信息以确保快速访问。这种体系结构旨在通过减少执行缓慢 I/O 操作的需要，提供低延迟和高吞吐量。",
      "pos": [
        7116,
        7235
      ]
    },
    {
      "content": "Azure Redis 缓存与客户端应用程序使用的多种 API 兼容。如果现有应用程序已使用运行本地的 Redis，Azure Redis 缓存可在云中提供缓存的快速迁移路径。",
      "pos": [
        7237,
        7325
      ]
    },
    {
      "pos": [
        7329,
        7510
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>Azure 还提供托管缓存服务。此服务基于 Microsoft AppFabric 缓存引擎。使用它可以创建可由松散耦合应用程序共享的分布式缓存。缓存托管在 Azure 数据中心内运行的高性能服务器上。但是，不再建议使用此选项，提供此选项只是为了支持构建为使用此选项的现有应用程序。针对所有新的开发，请改用 Azure Redis 缓存。"
    },
    {
      "content": "此外，Azure 支持角色中缓存。此功能可让你创建云服务专用的缓存。缓存由 Web 角色或辅助角色的实例托管，只能由以同一云服务部署单位（部署单位是作为云服务部署到特定区域的角色实例集合）的一部分来操作的角色进行访问。缓存已组建群集，托管缓存的同一部署单位中的所有角色实例将成为同一缓存群集的一部分。但是，不再建议使用此选项，提供此选项只是为了支持构建为使用此选项的现有应用程序。针对所有新的开发，请改用 Azure Redis 缓存。",
      "pos": [
        7515,
        7733
      ]
    },
    {
      "pos": [
        7738,
        7939
      ],
      "content": "Azure 托管缓存服务和 Azure 角色中缓存目前已预定于 2016 年 11 月 16 日停用。建议你迁移到 Azure Redis 缓存，以便为这次停用做好准备。有关详细信息，请访问<bpt id=\"p1\">[</bpt>我应使用哪种 Redis 缓存产品和大小？<ept id=\"p1\">](/documentation/articles/cache-faq#what-redis-cache-offering-and-size-should-i-use)</ept>"
    },
    {
      "content": "Redis 的功能",
      "pos": [
        7946,
        7955
      ]
    },
    {
      "content": "Redis 不仅是简单的缓存服务器，它还提供分布式内存中数据库，其中包含用于支持许多常见方案的广泛命令集，如本文档后面的“Redis 缓存的用例”部分中所述。本部分汇总了 Redis 提供的一些重要功能。",
      "pos": [
        7957,
        8059
      ]
    },
    {
      "content": "Redis 用作内存中数据库",
      "pos": [
        8065,
        8079
      ]
    },
    {
      "pos": [
        8081,
        8303
      ],
      "content": "Redis 支持读取和写入操作。不同于许多缓存（应被视为暂时性数据存储），它会将写入操作定期存储在本地快照文件或仅限附加的日志文件中，从而写入操作可在系统故障时得到保护。所有写入都是异步的，不会阻止客户端读取和写入数据。当 Redis 开始运行时，将从快照或日志文件中读取数据，并使用它来构建内存中缓存。有关详细信息，请参阅 Redis 网站上的 <bpt id=\"p1\">[</bpt>Redis 持久性<ept id=\"p1\">](http://redis.io/topics/persistence)</ept>。"
    },
    {
      "pos": [
        8307,
        8436
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>Redis 不保证所有写入在发生灾难性故障时都会得到保存，但在最糟的情况下，你只会丢失几秒钟的数据。请记住，缓存并不适合用作权威数据源，应用程序负责使用缓存来确保成功将关键数据保存到适当的数据存储。有关详细信息，请参阅“缓存端模式”。"
    },
    {
      "content": "Redis 数据类型",
      "pos": [
        8443,
        8453
      ]
    },
    {
      "pos": [
        8455,
        8662
      ],
      "content": "Redis 属于键-值存储，其中的值可以包含简单类型或复杂数据结构，例如哈希、列表和集。Redis 支持对这些数据类型执行原子操作。键可以是永久性的，或者标记了一个有限的生存时间，到了该时间后，键及其对应的值将自动从缓存中删除。有关 Redis 键和值的详细信息，请访问 Redis 网站上的 <bpt id=\"p1\">[</bpt>Redis 数据类型和抽象简介<ept id=\"p1\">](http://redis.io/topics/data-types-intro)</ept>页。"
    },
    {
      "content": "Redis 复制和群集",
      "pos": [
        8669,
        8680
      ]
    },
    {
      "pos": [
        8682,
        8868
      ],
      "content": "Redis 支持主/从复制，以帮助确保可用性并保持吞吐量；Redis 主节点的写入操作将复制到一个或多个从属节点，读取操作可由主节点或任何从属节点提供。如果执行了网络分区，从属节点可以继续提供数据，然后在重新建立连接时以透明方式与主节点重新同步。有关详细信息，请访问 Redis 网站上的<bpt id=\"p1\">[</bpt>复制<ept id=\"p1\">](http://redis.io/topics/replication)</ept>页。"
    },
    {
      "pos": [
        8870,
        9087
      ],
      "content": "Redis 还提供群集，可让你以透明方式在服务器之间将数据分区成分片并分散负载。此功能提高了可缩放性，因为可以添加新的 Redis 服务器，并且随着缓存大小的增加，数据将重新分区。此外，群集中的每一台服务器可以使用主/从复制进行复制，以确保整个群集中每个节点的可用性。有关群集和分片的详细信息，请访问 Redis 网站上的 <bpt id=\"p1\">[</bpt>Redis 群集教程<ept id=\"p1\">](http://redis.io/topics/cluster-tutorial)</ept>页。"
    },
    {
      "pos": [
        9092,
        9242
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>Azure Redis 缓存当前只有高级版支持群集。如果想要创建 Redis 群集，请参阅<bpt id=\"p1\">[</bpt>如何为高级 Azure Redis 缓存配置 Redis 群集功能<ept id=\"p1\">](/documentation/articles/cache-how-to-premium-clustering)</ept>。"
    },
    {
      "content": "Redis 内存使用",
      "pos": [
        9248,
        9258
      ]
    },
    {
      "content": "Redis 缓存具有有限的大小，具体取决于主机计算机上可用的资源。在配置 Redis 服务器时，可以指定服务器可使用的最大内存量。可为 Redis 缓存中的键配置过期时间，到时它将自动从缓存中删除。此功能可帮助避免内存中缓存填满陈旧或过时的数据。",
      "pos": [
        9260,
        9383
      ]
    },
    {
      "pos": [
        9385,
        9553
      ],
      "content": "当内存填满时，Redis 可以遵循一些策略自动逐出键及其值。默认策略是 LRU（最近最少使用），但你也可以选择其他策略，例如，随机逐出键，或完全关闭逐出（在此情况下，当缓存已满时，尝试将项添加到缓存将会失败）。<bpt id=\"p1\">[</bpt>使用 Redis 作为 LRU 缓存<ept id=\"p1\">](http://redis.io/topics/lru-cache)</ept>页提供了详细信息。"
    },
    {
      "content": "Redis 事务和批处理",
      "pos": [
        9559,
        9571
      ]
    },
    {
      "pos": [
        9573,
        9997
      ],
      "content": "Redis 可让客户端应用程序提交一系列的操作，用于在缓存中以原子事务的形式读取和写入数据。保证事务中的所有命令按顺序执行，其他并发客户端所发出的命令将不在两者之间交互编排。但是，这不是真正的事务，因为关系数据库将执行这些事务。事务处理包括两个阶段：命令排队和命令执行。在命令排队阶段，客户端将提交构成事务的命令。如果此时发生某种形式的错误（例如语法错误，或参数数目不正确），Redis 将拒绝处理整个事务并将其丢弃。在执行阶段，Redis 将按顺序执行每个队列中的命令。如果在此阶段命令失败，Redis 将继续执行下一个队列中的命令，且它不会回滚任何已执行命令的结果。这种简化的事务形式有助于保持性能，并避免争用所造成的性能问题。Redis 实施某种形式的乐观锁定，以帮助保持一致性。有关事务和使用 Redis 进行锁定的详细信息，请访问 Redis 网站上的<bpt id=\"p1\">[</bpt>事务<ept id=\"p1\">](http://redis.io/topics/transactions)</ept>页。"
    },
    {
      "content": "Redis 还支持非事务式的请求批处理。客户端用于将命令发送到 Redis 服务器的 Redis 协议可让客户端以同一请求的一部分来发送一系列操作。这有助于减少网络上的数据包分段。处理批时，将执行每个命令。不同于事务，如果其中任一命令的格式不当，则将遭到拒绝，但会执行剩余的命令。此外，不保证批中命令的处理顺序。",
      "pos": [
        9999,
        10155
      ]
    },
    {
      "content": "Redis 安全性",
      "pos": [
        10161,
        10170
      ]
    },
    {
      "content": "Redis 专门注重于提供数据快速访问，设计为在受信任的环境中运行，且只能由受信任的客户端访问。Redis 仅支持基于密码身份验证的有限安全模型（可以完全删除身份验证，但不建议这样做）。所有已经过身份验证的客户端共享同一个全局密码，并有权访问相同的资源。如果需要更全面的登录安全性，必须在 Redis 服务器前面实施自己的安全层，并且所有客户端请求应通过此附加层；不应直接向不受信任或未经身份验证的客户端公开 Redis。",
      "pos": [
        10172,
        10383
      ]
    },
    {
      "content": "可以通过禁用命令或重命名命令（仅提供有权限的客户端使用新的名称）来限制对命令的访问。",
      "pos": [
        10385,
        10427
      ]
    },
    {
      "content": "Redis 不直接支持任何形式的数据加密，因此所有编码必须由客户端应用程序执行。此外，Redis 不提供任何形式的传输安全性，因此，如果数据在网络上流动时需要保护数据，应实施 SSL 代理。",
      "pos": [
        10429,
        10524
      ]
    },
    {
      "pos": [
        10526,
        10594
      ],
      "content": "有关详细信息，请访问 Redis 网站上的 <bpt id=\"p1\">[</bpt>Redis 安全性<ept id=\"p1\">](http://redis.io/topics/security)</ept>页。"
    },
    {
      "pos": [
        10598,
        10662
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>Azure Redis 缓存通过连接的客户端提供自身的安全层；底层 Redis 服务器不向公共网络公开。"
    },
    {
      "content": "使用 Azure Redis 缓存",
      "pos": [
        10668,
        10685
      ]
    },
    {
      "content": "Azure Redis 缓存提供对 Redis 服务器的访问权限，这些服务器在 Azure 数据中心托管的服务器上运行；它充当提供访问控制与安全性的机制。可以使用 Azure 管理门户来设置缓存。门户提供多个预定义的配置，范围从作为专用服务运行的 53GB 缓存，用于支持 SSL 通信（适用于隐私性）以及主/从复制配合 99.9% 可用性的 SLA，到共享硬件上运行不含复制（无可用性保证）的 250 MB 缓存。",
      "pos": [
        10687,
        10895
      ]
    },
    {
      "content": "使用 Azure 管理门户还可以配置缓存的逐出策略，并通过将用户添加到所提供角色、所有者、参与者和读取者来控制缓存的访问权限。这些角色定义成员可以执行的操作。例如，所有者角色成员拥有缓存（包含安全性）及其内容的完全控制权，参与者角色成员可以在缓存中读取和写入信息，而读取者角色成员只能从缓存检索数据。",
      "pos": [
        10897,
        11047
      ]
    },
    {
      "content": "大多数管理任务可通过 Azure Powershell 来执行，出于此原因，许多 Redis 标准版中的管理命令都不可用，包括以编程方式修改配置、关闭 Redis 服务器、配置其他从属服务器，或强制将数据存储到磁盘等功能。",
      "pos": [
        11049,
        11160
      ]
    },
    {
      "pos": [
        11165,
        11297
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>Azure Redis 缓存目前只有高级版支持数据暂留。详情请参阅<bpt id=\"p1\">[</bpt>如何为高级 Azure Redis 缓存配置数据暂留<ept id=\"p1\">](/documentation/articles/cache-how-to-premium-persistence)</ept>。"
    },
    {
      "pos": [
        11299,
        11451
      ],
      "content": "有关说明如何创建和配置 Azure Redis 缓存的更多信息和示例，请访问 Redis 博客上的<bpt id=\"p1\">[</bpt>浏览 Azure Redis 缓存<ept id=\"p1\">](http://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/)</ept>页。"
    },
    {
      "content": "缓存会话状态和 HTML 输出",
      "pos": [
        11456,
        11471
      ]
    },
    {
      "content": "如果你要构建通过使用 Azure Web 角色运行的 ASP.NET Web 应用程序，可以将会话状态信息和 HTML 输出保存在 Azure Redis 缓存中。Azure Redis 缓存的会话状态提供程序可让你在 ASP.NET Web 应用程序的不同实例之间共享会话信息，在无法建立客户端与服务器之间的关联性并且内存中缓存会话数据并不适当的 Web 场中非常有用。",
      "pos": [
        11473,
        11659
      ]
    },
    {
      "content": "配合 Azure Redis 缓存使用会话状态提供程序可带来几个好处，包括：",
      "pos": [
        11661,
        11699
      ]
    },
    {
      "content": "可以在 ASP.NET Web 应用程序的大量实例之间共享会话状态，并提供更高的可缩放性，",
      "pos": [
        11703,
        11748
      ]
    },
    {
      "content": "针对多个读取者和单个写入者的同一会话状态数据支持受控的并发访问权限，以及",
      "pos": [
        11751,
        11787
      ]
    },
    {
      "content": "可以使用压缩来节省内存，并提高网络性能。",
      "pos": [
        11790,
        11810
      ]
    },
    {
      "pos": [
        11812,
        11921
      ],
      "content": "有关详细信息，请访问 <bpt id=\"p1\">[</bpt>Azure Redis 缓存的 ASP.NET 会话状态提供程序<ept id=\"p1\">](/documentation/articles/cache-asp.net-session-state-provider)</ept>页。"
    },
    {
      "pos": [
        11925,
        12028
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>不要针对在 Azure 环境外部运行的 ASP.NET 应用程序使用 Azure Redis 缓存的会话状态提供程序。从 Azure 外部访问缓存的延迟会抵消缓存数据带来的性能优势。"
    },
    {
      "pos": [
        12030,
        12298
      ],
      "content": "同样地，Azure Redis 缓存的输出缓存提供程序可让你保存 ASP.NET Web 应用程序生成的 HTTP 响应。配合 Azure Redis 缓存使用输出缓存提供程序可以针对呈现复杂 HTML 输出的应用程序改善响应时间；生成类似响应的应用程序实例可以使用缓存中的共享输出段，而不用重新生成此 HTML 输出。有关详细信息，请访问 <bpt id=\"p1\">[</bpt>Azure Redis 缓存的 ASP.NET 输出缓存提供程序<ept id=\"p1\">](/documentation/articles/cache-asp.net-output-cache-provider)</ept>页。"
    },
    {
      "content": "构建自定义 Redis 缓存",
      "pos": [
        12303,
        12317
      ]
    },
    {
      "pos": [
        12319,
        12881
      ],
      "content": "Azure Redis 缓存充当底层 Redis 服务器的机制。目前它支持固定的一组配置，但没有 Redis 群集提供配置。如果你需要 Azure Redis 缓存未涵盖的高级配置（例如大于 53 GB 的缓存），可以使用 Azure 虚拟机来构建和托管自己的 Redis 服务器。因为你在实施复制时可能需要创建多个 VM 作为主节点和从属节点，这可能是一个复杂的过程。此外，如果想要创建群集，你需要多个主服务器和从属服务器，以及一个可以提供高度可用性和可缩放性，并且至少包含 6 个 VM 并组织成 3 对主/从服务器（一个群集必须至少包含 3 个主节点）的精简群集复制拓扑。每个主/从对应彼此靠近以降低延迟，但如果想要找出靠近的应用程序（该应用程序很可能会使用缓存数据），每一组对可以在位于不同区域的不同 Azure 数据中心运行。<bpt id=\"p1\">[</bpt>在 Azure 中的 CentOS Linux VM 上运行 Redis<ept id=\"p1\">](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)</ept> 页逐步讲解了一个示例，用于演示如何构建和配置作为 Azure VM 运行的 Redis 节点。"
    },
    {
      "content": "请注意，如果以这种方式实施自己的 Redis 缓存，你需要负责监视、管理和保护服务。",
      "pos": [
        12883,
        12925
      ]
    },
    {
      "content": "将 Redis 缓存分区",
      "pos": [
        12930,
        12942
      ]
    },
    {
      "content": "将缓存分区涉及到在多台计算机之间拆分缓存。此结构使用单个缓存服务器，可以提供多种优势，包括：",
      "pos": [
        12944,
        12990
      ]
    },
    {
      "content": "创建的缓存比单个服务器上存储的缓存要大得多。",
      "pos": [
        12994,
        13016
      ]
    },
    {
      "content": "将数据分散到多个服务器，从而提高可用性。如果一台服务器发生故障或不可访问，只有该服务器保存的数据不可用；剩余服务器上的数据仍可访问。对于缓存而言这并不重要，因为缓存数据只是数据库中暂时保存的数据副本，而不可访问的服务器上的缓存数据可以改为在不同的服务器上缓存。",
      "pos": [
        13019,
        13149
      ]
    },
    {
      "content": "在服务器之间分散负载，从而提高性能和可缩放性。",
      "pos": [
        13152,
        13175
      ]
    },
    {
      "content": "将数据放置在靠近用户访问的地理位置以降低延迟。",
      "pos": [
        13178,
        13201
      ]
    },
    {
      "pos": [
        13203,
        13360
      ],
      "content": "对于缓存，最常见的分区形式是分片。在此策略中，每个分区（或分片）本身是一个 Redis 缓存。数据使用分片逻辑定向到特定的分区，该逻辑可以使用各种方法来分布数据。<bpt id=\"p1\">[</bpt>分片模式<ept id=\"p1\">](http://msdn.microsoft.com/zh-cn/library/dn589797.aspx)</ept>提供了有关实施分片的详细信息。"
    },
    {
      "content": "若要在 Redis 缓存中实施分区，可以采用以下方法之一：",
      "pos": [
        13362,
        13391
      ]
    },
    {
      "pos": [
        13395,
        13722
      ],
      "content": "<bpt id=\"p1\">_</bpt>服务器端查询路由。<ept id=\"p1\">_</ept> 使用此方法时，客户端应用程序会将请求发送到构成缓存的任何 Redis 服务器（可能是最靠近的服务器）。每个 Redis 服务器将存储用于描述它所保存的分区的元数据，同时还包含有关哪些分区位于其他服务器上的信息。Redis 服务器将检查客户端请求，如果可以在本地解决，则执行请求的操作，否则将请求转发到相应的服务器。此模型是通过 Redis 群集实施的，Redis 网站上的 <bpt id=\"p2\">[</bpt>Redis 群集教程<ept id=\"p2\">](http://redis.io/topics/cluster-tutorial)</ept>页上提供了更详细的说明。Redis 群集对客户端应用程序而言是透明的，其他 Redis 服务器可以添加到群集（数据将重新分区），而无需重新配置客户端。"
    },
    {
      "pos": [
        13726,
        13914
      ],
      "content": "<bpt id=\"p1\">_</bpt>客户端分区。<ept id=\"p1\">_</ept> 在此模型中，客户端应用程序包含将请求路由到适当 Redis 服务器的逻辑（可能以库的形式）。这种方法可以配合 Azure Redis 缓存使用；创建多个 Azure Redis 缓存（每个数据分区一个缓存），并实施将请求路由到正确缓存的客户端逻辑。如果分区方案发生更改（例如，如果已创建其他 Azure Redis 缓存），则可能需要重新配置客户端应用程序。"
    },
    {
      "pos": [
        13918,
        14074
      ],
      "content": "<bpt id=\"p1\">_</bpt>代理辅助分区。<ept id=\"p1\">_</ept> 在此方案中，客户端应用程序将请求发送到一个知道如何数据分区方式的中间代理服务，然后将请求路由到适当的 Redis 服务器。此方法也可以配合 Azure Redis 缓存使用；代理服务可以实施为 Azure 云服务。使用此方法实施服务需要提高复杂性，并且执行请求的时间可能比使用客户端分区更长。"
    },
    {
      "pos": [
        14076,
        14173
      ],
      "content": "Redis 网站上的<bpt id=\"p1\">[</bpt>分区：如何在多个 Redis 实例之间拆分数据<ept id=\"p1\">](http://redis.io/topics/partitioning)</ept>页提供了有关使用 Redis 实施分区的更多信息。"
    },
    {
      "content": "实施 Redis 缓存客户端应用程序",
      "pos": [
        14179,
        14197
      ]
    },
    {
      "content": "Redis 支持以多种编程语言编写的客户端应用程序。如果要使用.NET Framework 构建新的应用程序，建议的方法是使用 StackExchange.Redis 客户端库。此库提供 .NET Framework 对象模型，用于抽象连接到 Redis 服务器连接、发送命令和接收响应所需的详细信息。在 Visual Studio 中，它以 NuGet 包的形式提供。可以使用同一个库连接到 Azure Redis 缓存，或者 VM 上托管的自定义 Redis 缓存。",
      "pos": [
        14199,
        14434
      ]
    },
    {
      "pos": [
        14436,
        14676
      ],
      "content": "若要连接到 Redis 服务器，可以使用 <ph id=\"ph1\">`ConnectionMultiplexer`</ph> 类的静态 <ph id=\"ph2\">`Connect`</ph> 方法。此方法创建的连接可在客户端应用程序的整个生存期内使用，同一个连接可由多个并发线程使用；每次执行 Redis 操作时，请不要重新连接和断开连接，因为这可能会降低性能。可以指定连接参数，例如 Redis 主机的地址和密码。如果你使用 Azure Redis 缓存，密码可能是使用 Azure 管理门户针对 Azure Redis 缓存生成的主密钥或辅助密钥。"
    },
    {
      "pos": [
        14678,
        14879
      ],
      "content": "在已连接到 Redis 服务器后，可以在用作缓存的 Redis 数据库上获取句柄。Redis 连接提供了 <ph id=\"ph1\">`GetDatabase`</ph> 方法来执行此操作。然后，你可以使用 <ph id=\"ph2\">`StringGet`</ph> 和 <ph id=\"ph3\">`StringSet`</ph> 方法，从缓存中检索项并在缓存中存储数据。这些方法需要将键用作参数，并返回缓存中具有匹配值的项 (<ph id=\"ph4\">`StringGet`</ph>)，或者将项添加到具有此键的缓存 (<ph id=\"ph5\">`StringSet`</ph>)。"
    },
    {
      "pos": [
        14881,
        15069
      ],
      "content": "根据 Redis 服务器的位置，在将请求传输到服务器以及将响应返回给客户端时，许多操作可能会造成一些延迟。StackExchange 库公开了许多方法的异步版本，用于帮助客户端应用程序保持响应。这些方法支持 .NET Framework 中的<bpt id=\"p1\">[</bpt>基于任务的异步模式<ept id=\"p1\">](http://msdn.microsoft.com/zh-cn/library/hh873175.aspx)</ept>。"
    },
    {
      "pos": [
        15071,
        15355
      ],
      "content": "以下代码段显示了一个名为 <ph id=\"ph1\">`RetrieveItem`</ph> 的方法，该方法演示了基于 Redis 和 StackExchange 库实现缓存端模式的示例。该方法采用字符串键值，并通过调用 <ph id=\"ph2\">`StringGetAsync`</ph> 方法（<ph id=\"ph3\">`StringGet`</ph> 的异步版本）尝试从 Redis 缓存中检索相应的项。如果找不到该项，则使用 <ph id=\"ph4\">`GetItemFromDataSourceAsync`</ph> 方法（这是一个本地方法，它不是 StackExchange 库的一部分）从底层数据源提取该项，然后使用 <ph id=\"ph5\">`StringSetAsync`</ph> 方法将该项添加到缓存，以便下一次可以更快地检索。"
    },
    {
      "pos": [
        16266,
        16534
      ],
      "content": "<ph id=\"ph1\">`StringGet`</ph> 和 <ph id=\"ph2\">`StringSet`</ph> 方法不是只能检索或存储字符串值；它们可以采用任何序列化为字节数组的项。如果需要保存 .NET 对象，可以将它序列化为字节流，然后使用 StringSet 方法将它写入缓存。同样地，你可以使用 StringGet 方法从缓存中读取对象，并将其反序列化为 .NET 对象。以下代码演示了 IDatabase 接口的一组扩展方法（Redis 连接的 GetDatabase 方法返回 <ph id=\"ph3\">`IDatabase`</ph> 对象），使用这些方法的某些示例代码可以在缓存中读取和写入 BlogPost 对象："
    },
    {
      "pos": [
        17929,
        18012
      ],
      "content": "以下代码演示了一个名为 <ph id=\"ph1\">`RetrieveBlogPost`</ph> 的方法，该方法使用这些扩展方法，遵循缓存端模式在缓存中读取和写入可序列化的 <ph id=\"ph2\">`BlogPost`</ph> 对象："
    },
    {
      "content": "如果客户端应用程序发送了多个异步请求，Redis 将支持命令管道。Redis 可以使用同一连接来多路复用请求，而不是按照严格的顺序来接收和响应命令。此方法可以更有效地使用网络来帮助降低延迟。以下代码段演示了并行检索两个客户的详细信息的示例。该代码将提交两个请求，再执行其他某种处理（未显示），然后等待接收结果。缓存对象的 Wait 方法类似于 .NET Framework Task.Wait 方法：",
      "pos": [
        18865,
        19065
      ]
    },
    {
      "pos": [
        19358,
        19819
      ],
      "content": "WindowsAzure.cn 网站上的 <bpt id=\"p1\">[</bpt>Azure Redis 缓存文档<ept id=\"p1\">](/documentation/services/redis-cache/)</ept>页提供了有关如何编写可以使用 Azure Redis 缓存的客户端应用程序的详细信息。StackExchange.Redis 网站上的<bpt id=\"p2\">[</bpt>基本用法页<ept id=\"p2\">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md)</ept>提供了更多信息；同一网站上的<bpt id=\"p3\">[</bpt>管道与多路复用器<ept id=\"p3\">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md)</ept>页提供了有关使用 Redis 和 StackExchange 库执行异步操作和管道传输的详细信息。本指南中后面“Redis 缓存用例”部分提供了一些更高级技巧的示例，你可以对 Redis 缓存中保存的数据运用这些技巧。"
    },
    {
      "content": "Redis 缓存用例",
      "pos": [
        19824,
        19834
      ]
    },
    {
      "content": "Redis 缓存的最简单用法包括存储键/值对，其中的值是未解释的字符串，该字符串具有任意长度，可以包含任何二进制数据（本质上是可视为字符串的字节数组）。本指南前面的“实施 Redis 缓存客户端应用程序”部分中已演示这种方案。应该注意，键还包含未解释的数据，因此，你可以使用任何二进制信息作为键，但键越长，存储花费的空间就越多，执行查找操作所需的时间也越长。为了实现可用性和易维护性，请认真设计你的键空间并使用有意义（但非详细）的键。例如，使用类似于“customer:100”的结构化键来表示 ID 为 100 的客户的键，而不是简单地使用“100”。使用此方案可以轻松区分存储不同数据类型的值。例如，你也可以使用键“orders:100”来表示 ID为 100 的订单的键。",
      "pos": [
        19836,
        20175
      ]
    },
    {
      "pos": [
        20177,
        20408
      ],
      "content": "除了一维二进制字符串以外，Redis 键/值对中的值还可以包含更结构化的信息，包括列表、集（已排序和未排序）和哈希。Redis 提供全面的命令集用于处理这些类型，其中的许多命令可以通过 StackExchange 等客户端库用于 .NET Framework 应用程序。Redis 网站上的 <bpt id=\"p1\">[</bpt>Redis 数据类型和抽象简介<ept id=\"p1\">](http://redis.io/topics/data-types-intro)</ept>页更详细地概述了这些类型以及可用于处理这些类型的命令。"
    },
    {
      "content": "本部分汇总了这些数据类型和命令的一些常见用例。",
      "pos": [
        20410,
        20433
      ]
    },
    {
      "content": "执行原子操作和批处理操作",
      "pos": [
        20439,
        20451
      ]
    },
    {
      "pos": [
        20453,
        20532
      ],
      "content": "Redis 支持对字符串值执行一系列原子性“获取和设置”操作。这些操作将删除使用单独的 <ph id=\"ph1\">`GET`</ph> 和 <ph id=\"ph2\">`SET`</ph> 命令时可能发生的争用风险。可用的操作包括："
    },
    {
      "pos": [
        20536,
        20726
      ],
      "content": "<ph id=\"ph1\">`INCR`</ph>、<ph id=\"ph2\">`INCRBY`</ph>、<ph id=\"ph3\">`DECR`</ph> 和 <ph id=\"ph4\">`DECRBY`</ph>，用于对整数数字数据值执行原子递增和递减操作。StackExchange 库提供了 <ph id=\"ph5\">`IDatabase.StringIncrementAsync`</ph> 和 <ph id=\"ph6\">`IDatabase.StringDecrementAsync`</ph> 方法的重载版本，用于执行这些操作并返回存储在缓存中的结果值。以下代码段演示了如何使用这些方法："
    },
    {
      "pos": [
        21168,
        21330
      ],
      "content": "<ph id=\"ph1\">`GETSET`</ph> 用于检索与键关联的值，并将其更改为新值。StackExchange 库通过 <ph id=\"ph2\">`IDatabase.StringGetSetAsync`</ph> 方法使此操作可供使用。以下代码段演示了此方法的示例。此代码从前一示例返回与键 \"data:counter\" 关联的当前值，并将此键的值重置为零，这些都是同一操作的一部分："
    },
    {
      "pos": [
        21535,
        21646
      ],
      "content": "<ph id=\"ph1\">`MGET`</ph> 和 <ph id=\"ph2\">`MSET`</ph> 可以作为单个操作返回或更改一组字符串值。<ph id=\"ph3\">`IDatabase.StringGetAsync`</ph> 和 <ph id=\"ph4\">`IDatabase.StringSetAsync`</ph> 已重载以支持此功能，如以下示例中所示："
    },
    {
      "pos": [
        22469,
        22791
      ],
      "content": "你也可以将多个操作合并成单个 Redis 事务，如本指南的“Redis 事务和批处理”部分中所述。StackExchange 库通过 <ph id=\"ph1\">`ITransaction`</ph> 接口提供事务支持。可以使用 IDatabase.CreateTransaction 方法创建 ITransaction 对象，并使用 <ph id=\"ph2\">`ITransaction`</ph> 对象提供的方法调用对事务的命令。<ph id=\"ph3\">`ITransaction`</ph> 接口像 <ph id=\"ph4\">`IDatabase`</ph> 接口一样提供对类似一组方法的访问，不过，所有方法是异步的；这些方法仅在调用 <ph id=\"ph5\">`ITransaction.Execute`</ph> 方法时执行。execute 方法返回的值指示事务创建是成功 (true) 还是失败 (false)。"
    },
    {
      "content": "以下代码段显示的示例将在执行同一事务期间递增和递减两个计数器：",
      "pos": [
        22793,
        22824
      ]
    },
    {
      "content": "请记住，Redis 事务不同于关系数据库中的事务。Execute 方法只是将构成执行事务的所有命令排入队列，如果其中任何一个命令格式不当，则中止事务。如果已成功将所有命令排入队列，将以异步方式运行每个命令。如果任何命令失败，其他命令仍将继续处理。如果需要验证命令是否已成功完成，你必须使用相应任务的 Result 属性来提取命令的结果，如上述示例中所示。读取 Result 属性将会阻塞，直到任务完成。",
      "pos": [
        23349,
        23550
      ]
    },
    {
      "pos": [
        23552,
        23689
      ],
      "content": "有关详细信息，请参阅 StackExchange.Redis 网站上的 <bpt id=\"p1\">[</bpt>Redis 中的事务<ept id=\"p1\">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md)</ept>页。"
    },
    {
      "content": "若要执行批处理操作，可以使用 StackExchange 库的 IBatch 接口。此接口像 IDatabase 接口一样提供对类似一组方法的访问，不过，所有方法是异步的。可以使用 IDatabase.CreateBatch 方法来创建 IBatch 对象，然后使用 IBatch.Execute 方法来运行批处理，如以下示例所示。这段代码仅设置字符串值，递增和递减前面示例中使用的相同计数器，然后显示结果：",
      "pos": [
        23691,
        23895
      ]
    },
    {
      "content": "必须知道，这不同于事务，如果因为格式不当而导致批中的命令失败，其他命令仍可运行；IBatch.Execute 方法不返回成功或失败的任何指示。",
      "pos": [
        24292,
        24363
      ]
    },
    {
      "content": "执行即发即弃缓存操作",
      "pos": [
        24369,
        24379
      ]
    },
    {
      "content": "Redis 通过使用命令标志来支持即发即弃操作。在此情况下，客户端仅启动操作，但不关注结果，且并不会等待命令完成。以下示例演示了如何以即发即弃操作的形式执行 INCR 命令：",
      "pos": [
        24381,
        24468
      ]
    },
    {
      "content": "自动使密钥过期",
      "pos": [
        24715,
        24722
      ]
    },
    {
      "pos": [
        24724,
        24849
      ],
      "content": "在 Redis 缓存中存储项时，可以指定超时，超时过后，将自动从缓存中删除该项。你还可以在密钥过期之前，使用 <ph id=\"ph1\">`TTL`</ph> 命令来查询剩余时间；StackExchange 应用程序可通过 IDatabase.KeyTimeToLive 方法使用此命令。"
    },
    {
      "content": "以下代码段演示了将密钥过期时间设置为 20 秒并查询密钥剩余生存期的示例：",
      "pos": [
        24851,
        24888
      ]
    },
    {
      "content": "还可以使用 StackExchange 库中作为 KeyExpireAsync 方法提供的 EXPIRE 命令将过期时间设置为特定的日期和时间：",
      "pos": [
        25313,
        25385
      ]
    },
    {
      "pos": [
        25726,
        25806
      ],
      "content": "<bpt id=\"p1\">_</bpt>提示：<ept id=\"p1\">_</ept>可以使用 DEL 命令手动从缓存中删除项，该命令在 StackExchange 库中作为 IDatabase.KeyDeleteAsync 方法提供。"
    },
    {
      "content": "使用标记来交叉关联项",
      "pos": [
        25812,
        25822
      ]
    },
    {
      "content": "Redis 集是共享单个键的多个项集合。可以使用 SADD 命令来创建集。可以使用 SMEMBERS 命令来检索集中的项。StackExchange 库通过 IDatabase.SetAddAsync 方法实现 SADD 命令，并使用 IDatabase.SetMembersAsync 方法实现 SMEMBERS 命令。你还可以使用 SDIFF（差集）、SINTER（交集）和 SUNION（并集）命令来合并现有集以创建新的集。StackExchange 库在 IDatabase.SetCombineAsync 方法中统一了这些操作；此方法的第一个参数指定要执行的设置操作。",
      "pos": [
        25824,
        26113
      ]
    },
    {
      "content": "以下代码段演示了如何使用集来快速存储和检索相关项的集合。此代码使用“实施 Redis 缓存客户端应用程序”部分中所述的 BlogPost 类型。BlogPost 对象包含四个字段：ID、标题、排名分数和标记集合。以下第一个代码段演示了用于填充 BlogPost 对象的 C# 列表的示例数据：",
      "pos": [
        26115,
        26261
      ]
    },
    {
      "content": "可以在 Redis 缓存中针对每个 BlogPost 对象将标记存储为集，并将每个集与 BlogPost ID关联。这样，应用程序便可以快速查找属于特定博客文章的所有标记。若要启用反向搜索并查找所有共享特定标记的博客文章，可以创建另一个集，用于保存引用键中标记 ID 的博客文章：",
      "pos": [
        27337,
        27477
      ]
    },
    {
      "content": "这些结构可让你以非常有效的方式执行许多常见查询。例如，你可以按如下所示查找并显示博客文章 1 的所有标记：",
      "pos": [
        28183,
        28236
      ]
    },
    {
      "content": "你可以通过执行交集操作，查找博客文章 1 和博客文章 2 公用的所有标记，如下所示：",
      "pos": [
        28393,
        28435
      ]
    },
    {
      "content": "你可以查找包含特定标记的所有博客文章：",
      "pos": [
        28678,
        28697
      ]
    },
    {
      "content": "查找最近访问的项",
      "pos": [
        28884,
        28892
      ]
    },
    {
      "content": "许多应用程序遇到的常见问题是如何查找最近访问的项。例如，博客站点可能要显示有关最近读过的博客文章的信息。你可以使用 Redis 列表来实现此功能。Redis 列表包含共享同一个键的多个项，但列表充当双端队列。你可以使用 LPUSH（左推）和 RPUSH（右推）命令将项推送到列表一端。可以使用 LPOP 和 RPOP 命令从列表的一端检索项。你还可以使用 LRANGE 和 RRANGE 命令返回一组元素。以下代码段演示了如何使用 StackExchange 库来执行这些操作。此代码使用前面示例中的 BlogPost 类型。当用户阅读博客文章时，系统会使用 IDatabase.ListLeftPushAsync 方法，将博客文章的标题推送到与 Redis 缓存中键 \"blog:recent\\_posts\" 关联的列表：",
      "pos": [
        28894,
        29256
      ]
    },
    {
      "content": "随着阅读的博客文章越来越多，其标题将推送到同一列表。列表已根据其添加顺序进行排序；最近阅读的博客文章朝向列表左端（如果同一博客文章阅读了一次以上，则它在列表中有多个条目）。可以使用 IDatabase.ListRange 方法显示最近阅读的文章的标题。此方法采用包含列表、起点和终点的键。以下代码将从列表的最左端检索 10 篇博客文章的标题（项为 0 到 9）：",
      "pos": [
        29595,
        29776
      ]
    },
    {
      "content": "请注意，ListRangeAsync 不会从列表中删除项；为此，你可以使用 IDatabase.ListLeftPopAsync 和 IDatabase.ListRightPopAsync 方法。",
      "pos": [
        29929,
        30027
      ]
    },
    {
      "content": "若要防止列表无限增长，可以通过修剪列表来定期删除项。以下代码段只会保留列表中位于最左端的 5 个项，并删除其他所有项：",
      "pos": [
        30029,
        30088
      ]
    },
    {
      "content": "实施排行榜",
      "pos": [
        30152,
        30157
      ]
    },
    {
      "content": "默认情况下，集中的项不以任何特定顺序保存。你可以使用 ZADD 命令（StackExchange 库中的 IDatabase.SortedSetAdd 方法）来创建排序集合。系统使用一个名为 score（作为命令的参数提供）的数字值来为项排序。以下代码段将博客文章的标题添加到排序列表。在示例中，每篇博客文章还有包含博客文章排名的评分字段。",
      "pos": [
        30159,
        30329
      ]
    },
    {
      "content": "可以使用 IDatabase.SortedSetRangeByRankWithScores 方法以评分递增顺序来检索博客文章标题和评分：",
      "pos": [
        30643,
        30711
      ]
    },
    {
      "pos": [
        30843,
        30933
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>StackExchange 库还提供了 IDatabase.SortedSetRangeByRankAsync 方法，用于以评分顺序返回数据，但不返回评分。"
    },
    {
      "content": "你也可以使用评分递减顺序来检索项，并通过将额外参数提供给 IDatabase.SortedSetRangeByRankWithScoresAsync 方法来限制返回项的数目。以下示例演示了排名前 10 位博客文章的标题和评分：",
      "pos": [
        30935,
        31048
      ]
    },
    {
      "content": "以下示例使用了 IDatabase.SortedSetRangeByScoreWithScoresAsync 方法，该方法可用于限制返回给那些处于给定评分范围内的项：",
      "pos": [
        31234,
        31317
      ]
    },
    {
      "content": "使用通道进行消息传送",
      "pos": [
        31548,
        31558
      ]
    },
    {
      "content": "Redis 服务器除了可用作数据缓存以外，还可通过高性能发布者/订阅者机制提供消息传送。客户端应用程序可以订阅通道，其他应用程序或服务可以将消息发布到通道。订阅应用程序随后将会接收这些消息，并可以处理消息。",
      "pos": [
        31560,
        31663
      ]
    },
    {
      "content": "Redis 提供了 SUBSCRIBE 命令用于订阅通道。此命令需要一个或多个可供应用程序接受消息的通道的名称。StackExchange 库包含 ISubscription 接口，可让 .NET Framework 应用程序订阅和发布到通道。使用 Redis 服务器连接的 GetSubscriber 方法创建 ISubscription 对象，然后使用此对象的 SubscribeAsync 方法来侦听通道上的消息。以下代码示例演示了如何订阅名为“messages:blogPosts”的通道：",
      "pos": [
        31665,
        31914
      ]
    },
    {
      "content": "Subscribe 方法的第一个参数为通道的名称。此名称遵循缓存中键使用的相同约定，并且可以包含任何二进制数据，但建议最好使用相对较短且有意义的字符串，以帮助确保良好的性能和易维护性。还应该注意，通道使用的命名空间与键使用的不同，因此你的通道和键可以同名，不过，这可能会导致更难以维护应用程序代码。",
      "pos": [
        32177,
        32326
      ]
    },
    {
      "content": "第二个参数是 Action 委派。每当新的消息出现在通道上时，此委派就会以异步方式运行。此示例仅显示了控制台上的消息（消息将包含博客文章的标题）。",
      "pos": [
        32328,
        32401
      ]
    },
    {
      "content": "若要发布到通道，应用程序可以使用 Redis PUBLISH 命令。StackExchange 库提供了 IServer.PublishAsync 方法来执行此操作。以下代码段演示了如何将消息发布到“messages:blogPosts”通道：",
      "pos": [
        32403,
        32525
      ]
    },
    {
      "content": "关于发布/订阅机制，应该了解几个要点：",
      "pos": [
        32745,
        32764
      ]
    },
    {
      "content": "多个订阅者可以订阅同一个通道，他们都将接收发布到该通道的消息。",
      "pos": [
        32768,
        32799
      ]
    },
    {
      "content": "订阅者仅接收订阅后发布的消息。通道不会缓冲，一旦发布消息，Redis 基础结构就会将消息推送到每个订阅者，然后删除消息。",
      "pos": [
        32802,
        32862
      ]
    },
    {
      "content": "默认情况下，订阅者根据发送顺序来接收消息。在具有大量消息和许多订阅者与发布者的高度活跃系统中，保证依序传送消息可能会降低系统性能。如果每个消息各自独立且顺序并不重要，则你可以通过 Redis 系统启用并发处理，这有助于提高响应度。你可以在 StackExchange 客户端中，通过将订阅者使用的连接的 PreserveAsyncOrder 设置为 false 来实现此目的：",
      "pos": [
        32865,
        33053
      ]
    },
    {
      "content": "相关模式和指南",
      "pos": [
        33241,
        33248
      ]
    },
    {
      "content": "在应用程序中实施缓存时，以下模式也可能与你的方案相关：",
      "pos": [
        33250,
        33277
      ]
    },
    {
      "pos": [
        33281,
        33401
      ],
      "content": "<bpt id=\"p1\">[</bpt>缓存端模式<ept id=\"p1\">](http://msdn.microsoft.com/zh-cn/library/dn589799.aspx)</ept>：此模式描述如何按需将数据从数据存储载入缓存。此模式还有助于在缓存中保存的数据与原始数据存储中的数据之间保持一致性。"
    },
    {
      "pos": [
        33404,
        33501
      ],
      "content": "<bpt id=\"p1\">[</bpt>分片模式<ept id=\"p1\">](http://msdn.microsoft.com/zh-cn/library/dn589797.aspx)</ept>提供了有关实施水平分区，以帮助在存储和访问大量数据时提高可缩放性的信息。"
    },
    {
      "content": "更多信息",
      "pos": [
        33506,
        33510
      ]
    },
    {
      "pos": [
        33514,
        33611
      ],
      "content": "<bpt id=\"p1\">[</bpt>MemoryCache 类<ept id=\"p1\">](http://msdn.microsoft.com/zh-cn/library/system.runtime.caching.memorycache.aspx)</ept>。"
    },
    {
      "pos": [
        33614,
        33693
      ],
      "content": "<bpt id=\"p1\">[</bpt>Azure 缓存<ept id=\"p1\">](http://msdn.microsoft.com/zh-cn/library/windowsazure/gg278356.aspx)</ept>。"
    },
    {
      "pos": [
        33696,
        33802
      ],
      "content": "<bpt id=\"p1\">[</bpt>哪种 Azure Cache 产品/服务适合我？<ept id=\"p1\">](/documentation/articles/cache-faq/#which-azure-cache-offering-is-right-for-me)</ept>。"
    },
    {
      "pos": [
        33805,
        33880
      ],
      "content": "<bpt id=\"p1\">[</bpt>配置模型<ept id=\"p1\">](http://msdn.microsoft.com/zh-cn/library/windowsazure/hh914149.aspx)</ept>。"
    },
    {
      "pos": [
        33883,
        33950
      ],
      "content": "<bpt id=\"p1\">[</bpt>基于任务的异步模式<ept id=\"p1\">](http://msdn.microsoft.com/zh-cn/library/hh873175.aspx)</ept>。"
    },
    {
      "pos": [
        33953,
        34092
      ],
      "content": "StackExchange.Redis GitHub 存储库上的<bpt id=\"p1\">[</bpt>管道和多路复用器<ept id=\"p1\">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md)</ept>。"
    },
    {
      "pos": [
        34095,
        34154
      ],
      "content": "Redis 网站上的 <bpt id=\"p1\">[</bpt>Redis 持久性<ept id=\"p1\">](http://redis.io/topics/persistence)</ept>。"
    },
    {
      "pos": [
        34157,
        34208
      ],
      "content": "Redis 网站上的<bpt id=\"p1\">[</bpt>复制<ept id=\"p1\">](http://redis.io/topics/replication)</ept>。"
    },
    {
      "pos": [
        34211,
        34276
      ],
      "content": "Redis 网站上的 <bpt id=\"p1\">[</bpt>Redis 群集教程<ept id=\"p1\">](http://redis.io/topics/cluster-tutorial)</ept>。"
    },
    {
      "pos": [
        34279,
        34352
      ],
      "content": "Redis 网站上的<bpt id=\"p1\">[</bpt>分区：如何在多个 Redis 实例之间拆分数据<ept id=\"p1\">](http://redis.io/topics/partitioning)</ept>。"
    },
    {
      "pos": [
        34355,
        34420
      ],
      "content": "Redis 网站上的<bpt id=\"p1\">[</bpt>使用 Redis 作为 LRU 缓存<ept id=\"p1\">](http://redis.io/topics/lru-cache)</ept>。"
    },
    {
      "pos": [
        34423,
        34475
      ],
      "content": "Redis 网站上的<bpt id=\"p1\">[</bpt>事务<ept id=\"p1\">](http://redis.io/topics/transactions)</ept>。"
    },
    {
      "pos": [
        34478,
        34534
      ],
      "content": "Redis 网站上的 <bpt id=\"p1\">[</bpt>Redis 安全性<ept id=\"p1\">](http://redis.io/topics/security)</ept>。"
    },
    {
      "pos": [
        34537,
        34684
      ],
      "content": "<bpt id=\"p1\">[</bpt>在 Azure 中的 CentOS Linux VM 上运行 Redis<ept id=\"p1\">](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)</ept>。"
    },
    {
      "pos": [
        34687,
        34784
      ],
      "content": "<bpt id=\"p1\">[</bpt>Azure Redis 缓存的 ASP.NET 会话状态提供程序<ept id=\"p1\">](/documentation/articles/cache-asp.net-session-state-provider)</ept>。"
    },
    {
      "pos": [
        34787,
        34883
      ],
      "content": "<bpt id=\"p1\">[</bpt>Azure Redis 缓存的 ASP.NET 输出缓存提供程序<ept id=\"p1\">](/documentation/articles/cache-asp.net-output-cache-provider)</ept>。"
    },
    {
      "pos": [
        34886,
        34945
      ],
      "content": "<bpt id=\"p1\">[</bpt>Redis 数据类型和抽象简介<ept id=\"p1\">](http://redis.io/topics/data-types-intro)</ept>。"
    },
    {
      "pos": [
        34948,
        35060
      ],
      "content": "StackExchange.Redis 网站上的<bpt id=\"p1\">[</bpt>基本用法<ept id=\"p1\">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md)</ept>。"
    },
    {
      "pos": [
        35063,
        35189
      ],
      "content": "StackExchange.Redis 存储库上的 <bpt id=\"p1\">[</bpt>Redis 中的事务<ept id=\"p1\">](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md)</ept>。"
    },
    {
      "pos": [
        35192,
        35256
      ],
      "content": "<bpt id=\"p1\">[</bpt>数据分区指南<ept id=\"p1\">](http://msdn.microsoft.com/zh-cn/library/dn589795.aspx)</ept>。"
    }
  ],
  "content": "<properties\n   pageTitle=\"缓存指南 | Azure\"\n   description=\"有关配置缓存以提高性能和可缩放性的指南。\"\n   services=\"\"\n   documentationCenter=\"na\"\n   authors=\"dragon119\"\n   manager=\"masimms\"\n   editor=\"\"\n   tags=\"\"/>\n\n<tags\n   ms.service=\"best-practice\"\n   ms.date=\"12/18/2015\"\n   wacn.date=\"02/04/2016\"/>\n\n# 缓存设计指南\n\n缓存是一种常见的技术，目标是通过暂时将经常访问的数据复制到位置靠近应用程序的快速存储，从而提高系统的性能和可缩放性。如果这种快速数据存储比原始源更靠近应用程序，则缓存可以通过更快速提供数据，大幅改善客户端应用程序的响应时间。如果客户端实例重复读取同一数据（特别是数据保持相对静态且原始数据存储相对于缓存速度而言较慢时）、受限于激烈的资源争用，或者由于距离遥远，网络延迟会造成访问速度缓慢，则缓存是最有效的方式。\n\n## 分布式应用程序中的缓存\n\n在缓存数据时，分布式应用程序通常会实施以下一种或两种策略：\n\n- 使用专用缓存，其中的数据保存在运行应用程序或服务实例的计算机本地。\n- 使用共享缓存，充当可由多个进程和/或计算机访问的公用源。\n\n在这两种情况下，缓存可在客户端（通过为系统提供用户界面（例如 Web 浏览器或桌面应用程序）的进程）和/或服务器端（通过远程运行的提供业务服务的进程）执行。\n\n### 专用缓存\n\n最基本类型的缓存是内存中存储，这种缓存保留在单个进程的地址空间中，可由该进程中运行的代码直接访问。此缓存类型可进行非常快速的访问，并可提供极其有效的策略用于存储适度的静态数据量，因为缓存大小通常受限于托管进程的计算机上可用内存量。如果缓存的信息需要超过内存中实际可用的信息，你可以将缓存数据写入本地文件系统。这一定比访问保留在内存中的数据更慢，但应该仍比通过网络检索数据更快速且更可靠。\n\n如果有多个并行运行的、使用此模型的应用程序实例，则每个应用程序实例将有自身的独立缓存用于保存自身的数据副本。\n\n你应该将缓存视为过去某个时间点原始数据的快照。如果此数据不是静态的，则有可能不同的应用程序实例将在其缓存中保存不同版本的数据。因此，这些实例执行的同一查询可能会返回不同的结果，如图 1 所示。\n\n![在不同的应用程序实例中使用内存中缓存](./media/best-practices-caching/Figure1.png)\n\n_图 1：在不同的应用程序实例中使用内存中缓存_\n\n### 共享缓存\n\n使用共享缓存有助于缓解每个缓存中可能存在不同数据的忧虑，这种情况可能会发生于内存中缓存。共享缓存可通过找出位于不同位置的缓存，确保不同的应用程序实例（通常作为不同服务的一部分托管，如图 2 所示）看到同一缓存数据视图。\n\n![使用共享缓存\\_](./media/best-practices-caching/Figure2.png)\n\n_图 2：使用共享缓存_\n\n使用共享缓存方法的重要优势在于它有助于提供可缩放性。许多共享缓存服务是使用服务器群集实施的，并以透明方式利用将数据分散到群集的软件。应用程序实例只会将请求发送到缓存服务，底层基础结构负责确定缓存数据在群集中的位置。你可以轻松地通过添加更多服务器来扩展缓存。\n\n共享缓存方法的缺点是，缓存的访问速度较慢，因为它不再保留在每个应用程序实例的本地，并且为了满足实施不同缓存服务的要求，可能会增大解决方案的复杂性。\n\n## 使用缓存时的注意事项\n\n以下部分更详细地说明了设计和使用缓存时的注意事项。\n\n### 何时应缓存数据？\n\n缓存可大幅提高性能、可缩放性和可用性。当你的数据越多且需要访问此数据的用户越多，缓存的优点也就越大，因为在原始数据存储中处理大量并发请求时，可以减少相关的延迟和争用。例如，数据库可以支持有限数目的并发连接，但从共享缓存而不是底层数据库检索数据可让客户端应用程序访问此数据，即使当前可用的连接数已用尽。此外，如果数据库变得不可用，客户端应用程序也许可以使用缓存中保存的数据继续运行。\n\n应该考虑使用经常读取但很少修改的缓存（数据读取操作的比例要高于写入操作）。但是，不应将缓存用作关键信息的权威存储；应确保应用程序不可丢失的所有更改始终存储到永久性数据存储中。这样，在缓存不可用时，应用程序仍可以使用数据存储继续操作，且你不会丢失重要信息。\n\n### 数据和缓存填充策略的类型\n\n有效使用缓存的关键在于确定最适合缓存的数据，以及最适合缓存的时间。数据可能在第一次由应用程序检索时随选添加到缓存，因此应用程序仅需从数据存储检索一次数据，而后续访问可通过使用缓存来满足。\n\n或者，可以事先在缓存中部分或完全填充数据，这通常发生在应用程序启动时（此方法称为种子设定）。但是，不建议对大型缓存实施种子设定，因为这种方法在应用程序开始运行时，可能会在原始数据存储上造成突发性的高负载。\n\n使用模式分析通常可以帮助确定是否要完整或部分预先填充缓存，以及选择应该缓存的数据。例如，对于定期（也许是每天）使用应用程序的客户，使用静态用户配置文件数据设定缓存种子可能相当实用，但不适用于一周仅使用一次应用程序的客户。\n\n缓存通常适用于不会变化或很少变化的数据。示例包含引用信息，例如电子商务应用程序中的产品和价格信息，或构建成本高昂的共享静态资源。此数据的部分或全部可在应用程序启动时加载到缓存，以便将资源需求降到最低并提高性能。拥有定期更新缓存中引用数据的后台进程可能也是适当的方式，可确保其处于最新状态，或在引用数据更改时刷新缓存。\n\n缓存可能较不适合动态数据，但这种考虑因素有一些例外情况（请参阅本指南后面的“缓存高动态数据”部分以了解详细信息）。如果原始数据定期更改，缓存的信息可能很快就会过时，或者为了保持与原始数据存储的缓存同步而产生开销，导致降低缓存的效率。请注意，缓存中不一定会包含实体的完整数据。例如，如果数据项代表多值对象（例如具有名称、地址和帐户余额的银行客户），则其中某些元素可以保持静态（名称和地址），而有些元素（例如帐户余额）则可能更加动态。在这种情况下，缓存数据的静态部分，并只在需要时检索（或计算）剩余信息可能相当有用。\n\n应执行性能测试和使用情况分析来确定缓存的预先填充和/或按需加载是否适当。这种判断应该基于数据易变性和使用模式的组合。在会遇到重度负载且必须高度可缩放的应用程序中，缓存利用和性能分析特别重要。例如，在高度可缩放的方案中，有时可以设定缓存种子，以在高峰期降低数据存储的负载。\n\n缓存还可用于在应用程序运行时避免重复计算。如果操作会转换数据或执行复杂计算，则可以在缓存中保存操作的结果。如果后续需要相同的计算，应用程序只需从缓存中检索结果。\n\n应用程序可以修改保存在缓存中的数据，但是应该将缓存视为可能随时消失的暂时性数据存储。请勿只在缓存中存储重要数据，而是确保同时在原始数据存储中保留信息。这样，在缓存不可用时，可以最大程度地减少数据丢失。\n\n### 缓存高动态数据\n\n将快速变化的信息存储在永久性数据存储中可能会给系统造成开销。例如，假设有一个会持续报告状态或其他度量的设备。在缓存信息几乎一直处于过期状态的情况下，如果应用程序选择不要缓存此数据，则在数据存储中存储和检索此信息时，同样存在这种考虑因素；在保存和提取此数据时它可能已经更改。在这种情况下，请考虑直接在缓存而不是永久性数据存储中存储动态信息的优点。如果数据不太重要且不需要审核，则偶尔丢失更改的数据就无关紧要。\n\n### 管理缓存中的数据过期\n\n在大多数情况下，缓存中保存的数据是保存在原始数据存储中的数据的副本。原始数据存储中的数据可能在缓存后更改，导致缓存的数据过时。许多缓存系统允许你将缓存配置为使数据过期，以及减少数据可以过期的时间长短。\n\n过期的缓存数据将从缓存中删除，应用程序必须从原始数据存储中检索数据（它可以将新提取的信息放回缓存）。在配置缓存时，你可以设置默认的过期策略。在许多缓存服务中，当以编程方式将单个对象存储在缓存中时（某些缓存可让你将过期时间指定为绝对值，或者，如果并未在指定的时间内访问，则从缓存中删除项的滑动值），还可以规定这些对象的过期时间。此设置将重写任何缓存范围的过期策略，但只适用于指定的对象。\n\n> [AZURE.NOTE]请慎重考虑缓存的过期时段及其包含的对象。如果设置的时段太短，则对象很快就会过期，因此就减少了使用缓存带来的优势。如果设置的时段太长，则会面临数据过时的风险。\n\n此外，如果允许数据长时间驻留，则缓存有可能会填满。在此情况下，将新项添加到缓存的任何请求可能会导致某些项被强行删除，这个过程称为逐出。缓存服务通常根据最近最少使用 (LRU) 的原则逐出数据，但你通常可以重写此策略，并防止项被逐出。但是，如果采用这种方法，则会面临缓存超过可用内存，且应用程序尝试将项添加到缓存时失败并发生异常的风险。\n\n某些缓存的实施可能会提供其他逐出策略。这些策略通常包括最近使用的策略（预期不再需要数据）、先进先出策略（先逐出最旧的数据）或基于触发事件显式删除（例如，正在修改数据）。\n\n### 使客户端缓存中的数据失效\n\n保存在客户端缓存中的数据通常被视为不受向客户端提供数据的服务的支持；服务不能直接强制客户端添加或删除来自客户端缓存的信息。这意味着，当原始数据源中的信息已更改时，使用配置不当的缓存（例如，未正确实施过期策略）的客户端可能继续使用过时的本地缓存信息。\n\n如果要构建通过 HTTP 连接提供数据的 Web 应用程序，可以隐式强制 Web 客户端（例如浏览器或 Web 代理）在资源通过更改该资源的 URI 更新时提取最新的信息。Web 客户端通常使用资源的 URI 作为客户端缓存中的键，因此更改 URI 会导致 Web 客户端忽略任何先前缓存的资源版本，并改为提取新的版本。\n\n## 管理缓存中的并发\n\n缓存通常设计为由应用程序的多个实例共享。每个应用程序实例可以读取和修改缓存中的数据。因此，任何共享数据存储中会出现的并发问题，在缓存中同样也会出现。在应用程序需要修改缓存中保存的数据的情况下，你可能需要确保应用程序的一个实例所做的更新不会盲目地覆盖另一个实例所做的更改。\n\n根据数据的性质和冲突的可能性，你可以采用以下两种并发方式之一：\n\n- __乐观并发。__ 应用程序检查以确定缓存中的数据自检索之后、更新之前是否已更改。如果数据保持相同，则可以进行更改。否则，应用程序必须确定是否要进行更新（促使做出此决定的业务逻辑特定于应用程序）。这种方法适合不常更新或不太可能发生冲突的情况。\n- __悲观并发。__ 应用程序在检索缓存中的数据时锁定数据，以避免另一个实例更改数据。此过程可确保不发生冲突，但可能阻止其他需要处理同一数据的实例。悲观并发可能会影响解决方案的可缩放性，只应该对短期操作使用。这种方法可能适用于很可能发生冲突的情况，特别是当应用程序更新缓存中的多个项，且必须确保这些更改一致应用时。\n\n### 实现高可用性和可缩放性并提高性能\n\n缓存不应是数据的主存储库；主存储库应该是从中填充缓存的原始数据存储。原始数据存储负责确保数据的持久性。\n\n请小心不要将共享缓存服务可用性的重要依赖性引入解决方案。如果提供共享缓存的服务不可用，应用程序应能继续工作；应用程序应该不会在等待缓存服务恢复时停止响应或失败。因此，应用程序必须准备好检测缓存服务的可用性，并在无法访问缓存时回退到原始数据存储。[断路器模式](http://msdn.microsoft.com/zh-cn/library/dn589784.aspx)可用于处理这种情况。提供缓存的服务可以恢复，当服务可用时，缓存将在从原始数据存储读取数据时，遵循[缓存端模式](http://msdn.microsoft.com/zh-cn/library/dn589799.aspx)等策略重新填充。\n\n但是，在缓存暂时不可用的情况下回退到原始数据存储可能会影响系统的可缩放性；在恢复数据存储时，原始数据存储可能忙于处理数据请求，导致超时和连接失败。应该考虑的策略是在每个应用程序实例中实施本地专用缓存，以及所有应用程序实例访问的共享缓存。当应用程序检索项时，可能会先后在本地缓存、共享缓存和原始数据存储中检查。共享缓存不可用时，本地缓存可以使用共享缓存或数据库中的数据来填充。采用此方法需要经过慎重的配置，以防止本地缓存相对于共享缓存而言太过时，但在无法访问共享缓存时，它可以充当缓冲区。图 3 显示了此结构。\n\n![将本地、专用和共享缓存配合使用\\_](./media/best-practices-caching/Caching3.png)_图 3：将本地、专用和共享缓存配合使用_\n_图 3：将本地、专用和共享缓存配合使用_\n\n为了支持保存相对长期数据的大型缓存，某些缓存服务在缓存不可用时，提供实施自动故障转移的高可用性选项。这种方法通常涉及到将存储在主缓存服务器上的缓存数据复制到辅助缓存服务器，并在主服务器故障或断开连接时切换到辅助服务器。为了减少与写入多个目标相关的延迟，当数据写入主服务器上的缓存时，复制到辅助服务器的操作可以异步发生。此方法可能会导致某些缓存的信息在发生故障时丢失，但是此数据的比例应该小于缓存的总体大小。\n\n如果共享缓存很大，则在节点上分区缓存数据可能很有帮助，这可减少争用的可能性，并提高可缩放性。许多共享缓存支持动态添加（与删除）节点，以及重新平衡分区之间的数据的功能。这种方法可能涉及到群集，其中，节点集合将作为无缝单一缓存向客户端应用程序呈现，但在内部，数据分散在节点之间并遵循某种预定义的分配策略，以便平均地平衡负载。[数据分区指南文档](http://msdn.microsoft.com/zh-cn/library/dn589795.aspx)提供了有关可行分区策略的详细信息。\n\n群集还可以进一步提高缓存的可用性；如果节点发生故障，仍可访问缓存的剩余部分。群集经常与复制和故障转移结合使用；每个节点都可复制且副本在节点故障时可快速联机。\n\n许多读取和写入操作可能会涉及到单个数据值或对象。但是，有时可能需要快速存储或检索大量数据。例如，设定缓存种子可能涉及到将数百或数千个项写入到缓存，或应用程序可能需要从缓存中检索属于同一请求的大量相关项。许多大型缓存针对这些目的提供了批处理操作，使客户端应用程序能够将大量的项打包成单个请求，并减少执行大量小型请求时的相关开销。\n\n## 缓存和最终一致性\n\n缓存端模式依赖于应用程序的实例，该应用程序填充可访问最新且一致数据版本的缓存。在实施最终一致性的系统（例如复制的数据存储）中，情况可能不是这样。应用程序的一个实例可以修改数据项，使该项的缓存版本失效。应用程序的另一个实例可以尝试从导致缓存未命中的缓存读取此项，因此它将从数据存储中读取数据，并将它添加到缓存。但是，如果数据存储没有完全与其他副本同步，则应用程序实例可能会使用旧值来读取并填充缓存。\n\n有关处理数据一致性的详细信息，请参阅[数据一致性指南](http://msdn.microsoft.com/zh-cn/library/dn589800.aspx)页。\n\n### 保护缓存的数据\n\n无论使用的缓存服务为何，都应该考虑如何防范缓存中保存的数据遭到未经授权的访问。有两个主要考虑因素：\n\n- 缓存中数据的隐私性。\n- 数据在缓存与使用缓存的应用程序之间流动时的隐私性。\n\n若要保护缓存中的数据，缓存服务可以实施要求应用程序识别本身的身份验证机制，并实施授权方案来指定哪些标识可以访问缓存中的数据，以及这些标识可执行的操作（读取和写入）。为了减少读取和写入数据时的相关开销，当标识已获得写入和/或读取缓存的权限时，该标识可以使用缓存中的任何数据。如果需要限制对缓存数据子集的访问权限，你可以：\n\n- 将缓存拆分成分区（使用不同的缓存服务器），并只向标识授予他们有权使用的分区的访问权限，或者\n- 使用不同的密钥来加密每个子集中的数据，并只向应该具有每个子集访问权限的标识提供加密密钥。客户端应用程序可能仍然能够检索缓存中的所有数据，但它只能够解密具有密钥的数据。\n\n若要在数据流入或流出缓存时保护数据，你可以依赖于客户端应用程序用来连接缓存的网络基础结构所提供的安全功能。如果在托管客户端应用程序的同一组织中使用现场服务器来实施缓存，则网络本身的隔离可能不需要你采取任何其他措施。如果缓存位于远程，且需要基于公共网络（例如 Internet）的 TCP 或 HTTP 连接，你应该考虑实施 SSL。\n\n## 使用 Azure 实现缓存的注意事项\n\nAzure 提供 Azure Redis 缓存。这是开源 Redis 缓存的一种实现，可在 Azure 数据中心作为服务运行。它提供可从任何 Azure 应用程序访问的缓存服务，无论应用程序是实施为云服务、网站，还是在 Azure 虚拟机中。拥有适当访问密钥的客户端应用程序可以共享缓存。\n\nRedis 是高性能缓存解决方案，提供可用性、可缩放性和安全性。它通常作为分散在一个或多个专用计算机上的服务运行，并会尝试在内存中存储尽量多的信息以确保快速访问。这种体系结构旨在通过减少执行缓慢 I/O 操作的需要，提供低延迟和高吞吐量。\n\nAzure Redis 缓存与客户端应用程序使用的多种 API 兼容。如果现有应用程序已使用运行本地的 Redis，Azure Redis 缓存可在云中提供缓存的快速迁移路径。\n\n> [AZURE.NOTE]Azure 还提供托管缓存服务。此服务基于 Microsoft AppFabric 缓存引擎。使用它可以创建可由松散耦合应用程序共享的分布式缓存。缓存托管在 Azure 数据中心内运行的高性能服务器上。但是，不再建议使用此选项，提供此选项只是为了支持构建为使用此选项的现有应用程序。针对所有新的开发，请改用 Azure Redis 缓存。\n>\n> 此外，Azure 支持角色中缓存。此功能可让你创建云服务专用的缓存。缓存由 Web 角色或辅助角色的实例托管，只能由以同一云服务部署单位（部署单位是作为云服务部署到特定区域的角色实例集合）的一部分来操作的角色进行访问。缓存已组建群集，托管缓存的同一部署单位中的所有角色实例将成为同一缓存群集的一部分。但是，不再建议使用此选项，提供此选项只是为了支持构建为使用此选项的现有应用程序。针对所有新的开发，请改用 Azure Redis 缓存。\n>\n> Azure 托管缓存服务和 Azure 角色中缓存目前已预定于 2016 年 11 月 16 日停用。建议你迁移到 Azure Redis 缓存，以便为这次停用做好准备。有关详细信息，请访问[我应使用哪种 Redis 缓存产品和大小？](/documentation/articles/cache-faq#what-redis-cache-offering-and-size-should-i-use)\n\n\n### Redis 的功能\n\nRedis 不仅是简单的缓存服务器，它还提供分布式内存中数据库，其中包含用于支持许多常见方案的广泛命令集，如本文档后面的“Redis 缓存的用例”部分中所述。本部分汇总了 Redis 提供的一些重要功能。\n\n### Redis 用作内存中数据库\n\nRedis 支持读取和写入操作。不同于许多缓存（应被视为暂时性数据存储），它会将写入操作定期存储在本地快照文件或仅限附加的日志文件中，从而写入操作可在系统故障时得到保护。所有写入都是异步的，不会阻止客户端读取和写入数据。当 Redis 开始运行时，将从快照或日志文件中读取数据，并使用它来构建内存中缓存。有关详细信息，请参阅 Redis 网站上的 [Redis 持久性](http://redis.io/topics/persistence)。\n\n> [AZURE.NOTE]Redis 不保证所有写入在发生灾难性故障时都会得到保存，但在最糟的情况下，你只会丢失几秒钟的数据。请记住，缓存并不适合用作权威数据源，应用程序负责使用缓存来确保成功将关键数据保存到适当的数据存储。有关详细信息，请参阅“缓存端模式”。\n\n#### Redis 数据类型\n\nRedis 属于键-值存储，其中的值可以包含简单类型或复杂数据结构，例如哈希、列表和集。Redis 支持对这些数据类型执行原子操作。键可以是永久性的，或者标记了一个有限的生存时间，到了该时间后，键及其对应的值将自动从缓存中删除。有关 Redis 键和值的详细信息，请访问 Redis 网站上的 [Redis 数据类型和抽象简介](http://redis.io/topics/data-types-intro)页。\n\n#### Redis 复制和群集\n\nRedis 支持主/从复制，以帮助确保可用性并保持吞吐量；Redis 主节点的写入操作将复制到一个或多个从属节点，读取操作可由主节点或任何从属节点提供。如果执行了网络分区，从属节点可以继续提供数据，然后在重新建立连接时以透明方式与主节点重新同步。有关详细信息，请访问 Redis 网站上的[复制](http://redis.io/topics/replication)页。\n\nRedis 还提供群集，可让你以透明方式在服务器之间将数据分区成分片并分散负载。此功能提高了可缩放性，因为可以添加新的 Redis 服务器，并且随着缓存大小的增加，数据将重新分区。此外，群集中的每一台服务器可以使用主/从复制进行复制，以确保整个群集中每个节点的可用性。有关群集和分片的详细信息，请访问 Redis 网站上的 [Redis 群集教程](http://redis.io/topics/cluster-tutorial)页。  \n> [AZURE.NOTE]Azure Redis 缓存当前只有高级版支持群集。如果想要创建 Redis 群集，请参阅[如何为高级 Azure Redis 缓存配置 Redis 群集功能](/documentation/articles/cache-how-to-premium-clustering)。\n\n### Redis 内存使用\n\nRedis 缓存具有有限的大小，具体取决于主机计算机上可用的资源。在配置 Redis 服务器时，可以指定服务器可使用的最大内存量。可为 Redis 缓存中的键配置过期时间，到时它将自动从缓存中删除。此功能可帮助避免内存中缓存填满陈旧或过时的数据。\n\n当内存填满时，Redis 可以遵循一些策略自动逐出键及其值。默认策略是 LRU（最近最少使用），但你也可以选择其他策略，例如，随机逐出键，或完全关闭逐出（在此情况下，当缓存已满时，尝试将项添加到缓存将会失败）。[使用 Redis 作为 LRU 缓存](http://redis.io/topics/lru-cache)页提供了详细信息。\n\n### Redis 事务和批处理\n\nRedis 可让客户端应用程序提交一系列的操作，用于在缓存中以原子事务的形式读取和写入数据。保证事务中的所有命令按顺序执行，其他并发客户端所发出的命令将不在两者之间交互编排。但是，这不是真正的事务，因为关系数据库将执行这些事务。事务处理包括两个阶段：命令排队和命令执行。在命令排队阶段，客户端将提交构成事务的命令。如果此时发生某种形式的错误（例如语法错误，或参数数目不正确），Redis 将拒绝处理整个事务并将其丢弃。在执行阶段，Redis 将按顺序执行每个队列中的命令。如果在此阶段命令失败，Redis 将继续执行下一个队列中的命令，且它不会回滚任何已执行命令的结果。这种简化的事务形式有助于保持性能，并避免争用所造成的性能问题。Redis 实施某种形式的乐观锁定，以帮助保持一致性。有关事务和使用 Redis 进行锁定的详细信息，请访问 Redis 网站上的[事务](http://redis.io/topics/transactions)页。\n\nRedis 还支持非事务式的请求批处理。客户端用于将命令发送到 Redis 服务器的 Redis 协议可让客户端以同一请求的一部分来发送一系列操作。这有助于减少网络上的数据包分段。处理批时，将执行每个命令。不同于事务，如果其中任一命令的格式不当，则将遭到拒绝，但会执行剩余的命令。此外，不保证批中命令的处理顺序。\n\n### Redis 安全性\n\nRedis 专门注重于提供数据快速访问，设计为在受信任的环境中运行，且只能由受信任的客户端访问。Redis 仅支持基于密码身份验证的有限安全模型（可以完全删除身份验证，但不建议这样做）。所有已经过身份验证的客户端共享同一个全局密码，并有权访问相同的资源。如果需要更全面的登录安全性，必须在 Redis 服务器前面实施自己的安全层，并且所有客户端请求应通过此附加层；不应直接向不受信任或未经身份验证的客户端公开 Redis。\n\n可以通过禁用命令或重命名命令（仅提供有权限的客户端使用新的名称）来限制对命令的访问。\n\nRedis 不直接支持任何形式的数据加密，因此所有编码必须由客户端应用程序执行。此外，Redis 不提供任何形式的传输安全性，因此，如果数据在网络上流动时需要保护数据，应实施 SSL 代理。\n\n有关详细信息，请访问 Redis 网站上的 [Redis 安全性](http://redis.io/topics/security)页。\n\n> [AZURE.NOTE]Azure Redis 缓存通过连接的客户端提供自身的安全层；底层 Redis 服务器不向公共网络公开。\n\n### 使用 Azure Redis 缓存\n\nAzure Redis 缓存提供对 Redis 服务器的访问权限，这些服务器在 Azure 数据中心托管的服务器上运行；它充当提供访问控制与安全性的机制。可以使用 Azure 管理门户来设置缓存。门户提供多个预定义的配置，范围从作为专用服务运行的 53GB 缓存，用于支持 SSL 通信（适用于隐私性）以及主/从复制配合 99.9% 可用性的 SLA，到共享硬件上运行不含复制（无可用性保证）的 250 MB 缓存。\n\n使用 Azure 管理门户还可以配置缓存的逐出策略，并通过将用户添加到所提供角色、所有者、参与者和读取者来控制缓存的访问权限。这些角色定义成员可以执行的操作。例如，所有者角色成员拥有缓存（包含安全性）及其内容的完全控制权，参与者角色成员可以在缓存中读取和写入信息，而读取者角色成员只能从缓存检索数据。\n\n大多数管理任务可通过 Azure Powershell 来执行，出于此原因，许多 Redis 标准版中的管理命令都不可用，包括以编程方式修改配置、关闭 Redis 服务器、配置其他从属服务器，或强制将数据存储到磁盘等功能。  \n> [AZURE.NOTE]Azure Redis 缓存目前只有高级版支持数据暂留。详情请参阅[如何为高级 Azure Redis 缓存配置数据暂留](/documentation/articles/cache-how-to-premium-persistence)。\n\n有关说明如何创建和配置 Azure Redis 缓存的更多信息和示例，请访问 Redis 博客上的[浏览 Azure Redis 缓存](http://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/)页。\n\n## 缓存会话状态和 HTML 输出\n\n如果你要构建通过使用 Azure Web 角色运行的 ASP.NET Web 应用程序，可以将会话状态信息和 HTML 输出保存在 Azure Redis 缓存中。Azure Redis 缓存的会话状态提供程序可让你在 ASP.NET Web 应用程序的不同实例之间共享会话信息，在无法建立客户端与服务器之间的关联性并且内存中缓存会话数据并不适当的 Web 场中非常有用。\n\n配合 Azure Redis 缓存使用会话状态提供程序可带来几个好处，包括：\n\n- 可以在 ASP.NET Web 应用程序的大量实例之间共享会话状态，并提供更高的可缩放性，\n- 针对多个读取者和单个写入者的同一会话状态数据支持受控的并发访问权限，以及\n- 可以使用压缩来节省内存，并提高网络性能。\n\n有关详细信息，请访问 [Azure Redis 缓存的 ASP.NET 会话状态提供程序](/documentation/articles/cache-asp.net-session-state-provider)页。\n\n> [AZURE.NOTE]不要针对在 Azure 环境外部运行的 ASP.NET 应用程序使用 Azure Redis 缓存的会话状态提供程序。从 Azure 外部访问缓存的延迟会抵消缓存数据带来的性能优势。\n\n同样地，Azure Redis 缓存的输出缓存提供程序可让你保存 ASP.NET Web 应用程序生成的 HTTP 响应。配合 Azure Redis 缓存使用输出缓存提供程序可以针对呈现复杂 HTML 输出的应用程序改善响应时间；生成类似响应的应用程序实例可以使用缓存中的共享输出段，而不用重新生成此 HTML 输出。有关详细信息，请访问 [Azure Redis 缓存的 ASP.NET 输出缓存提供程序](/documentation/articles/cache-asp.net-output-cache-provider)页。\n\n## 构建自定义 Redis 缓存\n\nAzure Redis 缓存充当底层 Redis 服务器的机制。目前它支持固定的一组配置，但没有 Redis 群集提供配置。如果你需要 Azure Redis 缓存未涵盖的高级配置（例如大于 53 GB 的缓存），可以使用 Azure 虚拟机来构建和托管自己的 Redis 服务器。因为你在实施复制时可能需要创建多个 VM 作为主节点和从属节点，这可能是一个复杂的过程。此外，如果想要创建群集，你需要多个主服务器和从属服务器，以及一个可以提供高度可用性和可缩放性，并且至少包含 6 个 VM 并组织成 3 对主/从服务器（一个群集必须至少包含 3 个主节点）的精简群集复制拓扑。每个主/从对应彼此靠近以降低延迟，但如果想要找出靠近的应用程序（该应用程序很可能会使用缓存数据），每一组对可以在位于不同区域的不同 Azure 数据中心运行。[在 Azure 中的 CentOS Linux VM 上运行 Redis](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx) 页逐步讲解了一个示例，用于演示如何构建和配置作为 Azure VM 运行的 Redis 节点。\n\n请注意，如果以这种方式实施自己的 Redis 缓存，你需要负责监视、管理和保护服务。\n\n## 将 Redis 缓存分区\n\n将缓存分区涉及到在多台计算机之间拆分缓存。此结构使用单个缓存服务器，可以提供多种优势，包括：\n\n- 创建的缓存比单个服务器上存储的缓存要大得多。\n- 将数据分散到多个服务器，从而提高可用性。如果一台服务器发生故障或不可访问，只有该服务器保存的数据不可用；剩余服务器上的数据仍可访问。对于缓存而言这并不重要，因为缓存数据只是数据库中暂时保存的数据副本，而不可访问的服务器上的缓存数据可以改为在不同的服务器上缓存。\n- 在服务器之间分散负载，从而提高性能和可缩放性。\n- 将数据放置在靠近用户访问的地理位置以降低延迟。\n\n对于缓存，最常见的分区形式是分片。在此策略中，每个分区（或分片）本身是一个 Redis 缓存。数据使用分片逻辑定向到特定的分区，该逻辑可以使用各种方法来分布数据。[分片模式](http://msdn.microsoft.com/zh-cn/library/dn589797.aspx)提供了有关实施分片的详细信息。\n\n若要在 Redis 缓存中实施分区，可以采用以下方法之一：\n\n- _服务器端查询路由。_ 使用此方法时，客户端应用程序会将请求发送到构成缓存的任何 Redis 服务器（可能是最靠近的服务器）。每个 Redis 服务器将存储用于描述它所保存的分区的元数据，同时还包含有关哪些分区位于其他服务器上的信息。Redis 服务器将检查客户端请求，如果可以在本地解决，则执行请求的操作，否则将请求转发到相应的服务器。此模型是通过 Redis 群集实施的，Redis 网站上的 [Redis 群集教程](http://redis.io/topics/cluster-tutorial)页上提供了更详细的说明。Redis 群集对客户端应用程序而言是透明的，其他 Redis 服务器可以添加到群集（数据将重新分区），而无需重新配置客户端。\n\n- _客户端分区。_ 在此模型中，客户端应用程序包含将请求路由到适当 Redis 服务器的逻辑（可能以库的形式）。这种方法可以配合 Azure Redis 缓存使用；创建多个 Azure Redis 缓存（每个数据分区一个缓存），并实施将请求路由到正确缓存的客户端逻辑。如果分区方案发生更改（例如，如果已创建其他 Azure Redis 缓存），则可能需要重新配置客户端应用程序。\n\n- _代理辅助分区。_ 在此方案中，客户端应用程序将请求发送到一个知道如何数据分区方式的中间代理服务，然后将请求路由到适当的 Redis 服务器。此方法也可以配合 Azure Redis 缓存使用；代理服务可以实施为 Azure 云服务。使用此方法实施服务需要提高复杂性，并且执行请求的时间可能比使用客户端分区更长。\n\nRedis 网站上的[分区：如何在多个 Redis 实例之间拆分数据](http://redis.io/topics/partitioning)页提供了有关使用 Redis 实施分区的更多信息。\n\n### 实施 Redis 缓存客户端应用程序\n\nRedis 支持以多种编程语言编写的客户端应用程序。如果要使用.NET Framework 构建新的应用程序，建议的方法是使用 StackExchange.Redis 客户端库。此库提供 .NET Framework 对象模型，用于抽象连接到 Redis 服务器连接、发送命令和接收响应所需的详细信息。在 Visual Studio 中，它以 NuGet 包的形式提供。可以使用同一个库连接到 Azure Redis 缓存，或者 VM 上托管的自定义 Redis 缓存。\n\n若要连接到 Redis 服务器，可以使用 `ConnectionMultiplexer` 类的静态 `Connect` 方法。此方法创建的连接可在客户端应用程序的整个生存期内使用，同一个连接可由多个并发线程使用；每次执行 Redis 操作时，请不要重新连接和断开连接，因为这可能会降低性能。可以指定连接参数，例如 Redis 主机的地址和密码。如果你使用 Azure Redis 缓存，密码可能是使用 Azure 管理门户针对 Azure Redis 缓存生成的主密钥或辅助密钥。\n\n在已连接到 Redis 服务器后，可以在用作缓存的 Redis 数据库上获取句柄。Redis 连接提供了 `GetDatabase` 方法来执行此操作。然后，你可以使用 `StringGet` 和 `StringSet` 方法，从缓存中检索项并在缓存中存储数据。这些方法需要将键用作参数，并返回缓存中具有匹配值的项 (`StringGet`)，或者将项添加到具有此键的缓存 (`StringSet`)。\n\n根据 Redis 服务器的位置，在将请求传输到服务器以及将响应返回给客户端时，许多操作可能会造成一些延迟。StackExchange 库公开了许多方法的异步版本，用于帮助客户端应用程序保持响应。这些方法支持 .NET Framework 中的[基于任务的异步模式](http://msdn.microsoft.com/zh-cn/library/hh873175.aspx)。\n\n以下代码段显示了一个名为 `RetrieveItem` 的方法，该方法演示了基于 Redis 和 StackExchange 库实现缓存端模式的示例。该方法采用字符串键值，并通过调用 `StringGetAsync` 方法（`StringGet` 的异步版本）尝试从 Redis 缓存中检索相应的项。如果找不到该项，则使用 `GetItemFromDataSourceAsync` 方法（这是一个本地方法，它不是 StackExchange 库的一部分）从底层数据源提取该项，然后使用 `StringSetAsync` 方法将该项添加到缓存，以便下一次可以更快地检索。\n\n```csharp\n// Connect to the Azure Redis cache\nConfigurationOptions config = new ConfigurationOptions();\nconfig.EndPoints.Add(\"<your DNS name>.redis.cache.chinacloudapi.cn\");\nconfig.Password = \"<Redis cache key from Azure PowerShell>\";\nConnectionMultiplexer redisHostConnection = ConnectionMultiplexer.Connect(config);\nIDatabase cache = redisHostConnection.GetDatabase();\n...\nprivate async Task<string> RetrieveItem(string itemKey)\n{\n    // Attempt to retrieve the item from the Redis cache\n    string itemValue = await cache.StringGetAsync(itemKey);\n\n    // If the value returned is null, the item was not found in the cache\n    // So retrieve the item from the data source and add it to the cache\n    if (itemValue == null)\n    {\n        itemValue = await GetItemFromDataSourceAsync(itemKey);\n        await cache.StringSetAsync(itemKey, itemValue);\n    }\n\n    // Return the item\n    return itemValue;\n}\n```\n\n`StringGet` 和 `StringSet` 方法不是只能检索或存储字符串值；它们可以采用任何序列化为字节数组的项。如果需要保存 .NET 对象，可以将它序列化为字节流，然后使用 StringSet 方法将它写入缓存。同样地，你可以使用 StringGet 方法从缓存中读取对象，并将其反序列化为 .NET 对象。以下代码演示了 IDatabase 接口的一组扩展方法（Redis 连接的 GetDatabase 方法返回 `IDatabase` 对象），使用这些方法的某些示例代码可以在缓存中读取和写入 BlogPost 对象：\n\n```csharp\npublic static class RedisCacheExtensions\n{\n    public static async Task<T> GetAsync<T>(this IDatabase cache, string key)\n    {\n        return Deserialize<T>(await cache.StringGetAsync(key));\n    }\n\n    public static async Task<object> GetAsync(this IDatabase cache, string key)\n    {\n        return Deserialize<object>(await cache.StringGetAsync(key));\n    }\n\n    public static async Task SetAsync(this IDatabase cache, string key, object value)\n    {\n        await cache.StringSetAsync(key, Serialize(value));\n    }\n\n    static byte[] Serialize(object o)\n    {\n        byte[] objectDataAsStream = null;\n\n        if (o != null)\n        {\n            BinaryFormatter binaryFormatter = new BinaryFormatter();\n            using (MemoryStream memoryStream = new MemoryStream())\n            {\n                binaryFormatter.Serialize(memoryStream, o);\n                objectDataAsStream = memoryStream.ToArray();\n            }\n        }\n\n        return objectDataAsStream;\n    }\n\n    static T Deserialize<T>(byte[] stream)\n    {\n        T result = default(T);\n\n        if (stream != null)\n        {\n            BinaryFormatter binaryFormatter = new BinaryFormatter();\n            using (MemoryStream memoryStream = new MemoryStream(stream))\n            {\n                result = (T)binaryFormatter.Deserialize(memoryStream);\n            }\n        }\n\n        return result;\n    }\n}\n```\n\n以下代码演示了一个名为 `RetrieveBlogPost` 的方法，该方法使用这些扩展方法，遵循缓存端模式在缓存中读取和写入可序列化的 `BlogPost` 对象：\n\n```csharp\n// The BlogPost type\n[Serializable]\nprivate class BlogPost\n{\n    private HashSet<string> tags = new HashSet<string>();\n\n    public BlogPost(int id, string title, int score, IEnumerable<string> tags)\n    {\n        this.Id = id;\n        this.Title = title;\n        this.Score = score;\n        this.tags = new HashSet<string>(tags);\n    }\n\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public int Score { get; set; }\n    public ICollection<string> Tags { get { return this.tags; } }\n}\n...\nprivate async Task<BlogPost> RetrieveBlogPost(string blogPostKey)\n{\n    BlogPost blogPost = await cache.GetAsync<BlogPost>(blogPostKey);\n    if (blogPost == null)\n    {\n        blogPost = await GetBlogPostFromDataSourceAsync(blogPostKey);\n        await cache.SetAsync(blogPostKey, blogPost);\n    }\n\n    return blogPost;\n}\n```\n\n如果客户端应用程序发送了多个异步请求，Redis 将支持命令管道。Redis 可以使用同一连接来多路复用请求，而不是按照严格的顺序来接收和响应命令。此方法可以更有效地使用网络来帮助降低延迟。以下代码段演示了并行检索两个客户的详细信息的示例。该代码将提交两个请求，再执行其他某种处理（未显示），然后等待接收结果。缓存对象的 Wait 方法类似于 .NET Framework Task.Wait 方法：\n\n```csharp\nConnectionMultiplexer redisHostConnection = ...;\nIDatabase cache = redisHostConnection.GetDatabase();\n...\nvar task1 = cache.StringGetAsync(\"customer:1\");\nvar task2 = cache.StringGetAsync(\"customer:2\");\n...\nvar customer1 = cache.Wait(task1);\nvar customer2 = cache.Wait(task2);\n```\n\nWindowsAzure.cn 网站上的 [Azure Redis 缓存文档](/documentation/services/redis-cache/)页提供了有关如何编写可以使用 Azure Redis 缓存的客户端应用程序的详细信息。StackExchange.Redis 网站上的[基本用法页](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md)提供了更多信息；同一网站上的[管道与多路复用器](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md)页提供了有关使用 Redis 和 StackExchange 库执行异步操作和管道传输的详细信息。本指南中后面“Redis 缓存用例”部分提供了一些更高级技巧的示例，你可以对 Redis 缓存中保存的数据运用这些技巧。\n\n## Redis 缓存用例\n\nRedis 缓存的最简单用法包括存储键/值对，其中的值是未解释的字符串，该字符串具有任意长度，可以包含任何二进制数据（本质上是可视为字符串的字节数组）。本指南前面的“实施 Redis 缓存客户端应用程序”部分中已演示这种方案。应该注意，键还包含未解释的数据，因此，你可以使用任何二进制信息作为键，但键越长，存储花费的空间就越多，执行查找操作所需的时间也越长。为了实现可用性和易维护性，请认真设计你的键空间并使用有意义（但非详细）的键。例如，使用类似于“customer:100”的结构化键来表示 ID 为 100 的客户的键，而不是简单地使用“100”。使用此方案可以轻松区分存储不同数据类型的值。例如，你也可以使用键“orders:100”来表示 ID为 100 的订单的键。\n\n除了一维二进制字符串以外，Redis 键/值对中的值还可以包含更结构化的信息，包括列表、集（已排序和未排序）和哈希。Redis 提供全面的命令集用于处理这些类型，其中的许多命令可以通过 StackExchange 等客户端库用于 .NET Framework 应用程序。Redis 网站上的 [Redis 数据类型和抽象简介](http://redis.io/topics/data-types-intro)页更详细地概述了这些类型以及可用于处理这些类型的命令。\n\n本部分汇总了这些数据类型和命令的一些常见用例。\n\n### 执行原子操作和批处理操作\n\nRedis 支持对字符串值执行一系列原子性“获取和设置”操作。这些操作将删除使用单独的 `GET` 和 `SET` 命令时可能发生的争用风险。可用的操作包括：\n\n- `INCR`、`INCRBY`、`DECR` 和 `DECRBY`，用于对整数数字数据值执行原子递增和递减操作。StackExchange 库提供了 `IDatabase.StringIncrementAsync` 和 `IDatabase.StringDecrementAsync` 方法的重载版本，用于执行这些操作并返回存储在缓存中的结果值。以下代码段演示了如何使用这些方法：\n\n  ```csharp\n  ConnectionMultiplexer redisHostConnection = ...;\n  IDatabase cache = redisHostConnection.GetDatabase();\n  ...\n  await cache.StringSetAsync(\"data:counter\", 99);\n  ...\n  long oldValue = await cache.StringIncrementAsync(\"data:counter\");\n  // Increment by 1 (the default)\n  // oldValue should be 100\n\n  long newValue = await cache.StringDecrementAsync(\"data:counter\", 50);\n  // Decrement by 50\n  // newValue should be 50\n  ```\n\n- `GETSET` 用于检索与键关联的值，并将其更改为新值。StackExchange 库通过 `IDatabase.StringGetSetAsync` 方法使此操作可供使用。以下代码段演示了此方法的示例。此代码从前一示例返回与键 \"data:counter\" 关联的当前值，并将此键的值重置为零，这些都是同一操作的一部分：\n\n  ```csharp\n  ConnectionMultiplexer redisHostConnection = ...;\n  IDatabase cache = redisHostConnection.GetDatabase();\n  ...\n  string oldValue = await cache.StringGetSetAsync(\"data:counter\", 0);\n  ```\n\n- `MGET` 和 `MSET` 可以作为单个操作返回或更改一组字符串值。`IDatabase.StringGetAsync` 和 `IDatabase.StringSetAsync` 已重载以支持此功能，如以下示例中所示：\n\n  ```csharp\n  ConnectionMultiplexer redisHostConnection = ...;\n  IDatabase cache = redisHostConnection.GetDatabase();\n  ...\n  // Create a list of key/value pairs\n  var keysAndValues =\n      new List<KeyValuePair<RedisKey, RedisValue>>()\n      {\n          new KeyValuePair<RedisKey, RedisValue>(\"data:key1\", \"value1\"),\n          new KeyValuePair<RedisKey, RedisValue>(\"data:key99\", \"value2\"),\n          new KeyValuePair<RedisKey, RedisValue>(\"data:key322\", \"value3\")\n      };\n\n  // Store the list of key/value pairs in the cache\n  cache.StringSet(keysAndValues.ToArray());\n  ...\n  // Find all values that match a list of keys\n  RedisKey[] keys = { \"data:key1\", \"data:key99\", \"data:key322\"};\n  RedisValue[] values = null;\n  values = cache.StringGet(keys);\n  // values should contain { \"value1\", \"value2\", \"value3\" }\n  ```\n\n你也可以将多个操作合并成单个 Redis 事务，如本指南的“Redis 事务和批处理”部分中所述。StackExchange 库通过 `ITransaction` 接口提供事务支持。可以使用 IDatabase.CreateTransaction 方法创建 ITransaction 对象，并使用 `ITransaction` 对象提供的方法调用对事务的命令。`ITransaction` 接口像 `IDatabase` 接口一样提供对类似一组方法的访问，不过，所有方法是异步的；这些方法仅在调用 `ITransaction.Execute` 方法时执行。execute 方法返回的值指示事务创建是成功 (true) 还是失败 (false)。\n\n以下代码段显示的示例将在执行同一事务期间递增和递减两个计数器：\n\n```csharp\nConnectionMultiplexer redisHostConnection = ...;\nIDatabase cache = redisHostConnection.GetDatabase();\n...\nITransaction transaction = cache.CreateTransaction();\nvar tx1 = transaction.StringIncrementAsync(\"data:counter1\");\nvar tx2 = transaction.StringDecrementAsync(\"data:counter2\");\nbool result = transaction.Execute();\nConsole.WriteLine(\"Transaction {0}\", result ? \"succeeded\" : \"failed\");\nConsole.WriteLine(\"Result of increment: {0}\", tx1.Result);\nConsole.WriteLine(\"Result of decrement: {0}\", tx2.Result);\n```\n\n请记住，Redis 事务不同于关系数据库中的事务。Execute 方法只是将构成执行事务的所有命令排入队列，如果其中任何一个命令格式不当，则中止事务。如果已成功将所有命令排入队列，将以异步方式运行每个命令。如果任何命令失败，其他命令仍将继续处理。如果需要验证命令是否已成功完成，你必须使用相应任务的 Result 属性来提取命令的结果，如上述示例中所示。读取 Result 属性将会阻塞，直到任务完成。\n\n有关详细信息，请参阅 StackExchange.Redis 网站上的 [Redis 中的事务](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md)页。\n\n若要执行批处理操作，可以使用 StackExchange 库的 IBatch 接口。此接口像 IDatabase 接口一样提供对类似一组方法的访问，不过，所有方法是异步的。可以使用 IDatabase.CreateBatch 方法来创建 IBatch 对象，然后使用 IBatch.Execute 方法来运行批处理，如以下示例所示。这段代码仅设置字符串值，递增和递减前面示例中使用的相同计数器，然后显示结果：\n\n```csharp\nConnectionMultiplexer redisHostConnection = ...;\nIDatabase cache = redisHostConnection.GetDatabase();\n...\nIBatch batch = cache.CreateBatch();\nbatch.StringSetAsync(\"data:key1\", 11);\nvar t1 = batch.StringIncrementAsync(\"data:counter1\");\nvar t2 = batch.StringDecrementAsync(\"data:counter2\");\nbatch.Execute();\nConsole.WriteLine(\"{0}\", t1.Result);\nConsole.WriteLine(\"{0}\", t2.Result);\n```\n\n必须知道，这不同于事务，如果因为格式不当而导致批中的命令失败，其他命令仍可运行；IBatch.Execute 方法不返回成功或失败的任何指示。\n\n### 执行即发即弃缓存操作\n\nRedis 通过使用命令标志来支持即发即弃操作。在此情况下，客户端仅启动操作，但不关注结果，且并不会等待命令完成。以下示例演示了如何以即发即弃操作的形式执行 INCR 命令：\n\n```csharp\nConnectionMultiplexer redisHostConnection = ...;\nIDatabase cache = redisHostConnection.GetDatabase();\n...\nawait cache.StringSetAsync(\"data:key1\", 99);\n...\ncache.StringIncrement(\"data:key1\", flags: CommandFlags.FireAndForget);\n```\n\n### 自动使密钥过期\n\n在 Redis 缓存中存储项时，可以指定超时，超时过后，将自动从缓存中删除该项。你还可以在密钥过期之前，使用 `TTL` 命令来查询剩余时间；StackExchange 应用程序可通过 IDatabase.KeyTimeToLive 方法使用此命令。\n\n以下代码段演示了将密钥过期时间设置为 20 秒并查询密钥剩余生存期的示例：\n\n```csharp\nConnectionMultiplexer redisHostConnection = ...;\nIDatabase cache = redisHostConnection.GetDatabase();\n...\n// Add a key with an expiration time of 20 seconds\nawait cache.StringSetAsync(\"data:key1\", 99, TimeSpan.FromSeconds(20));\n...\n// Query how much time a key has left to live\n// If the key has already expired, the KeyTimeToLive function returns a null\nTimeSpan? expiry = cache.KeyTimeToLive(\"data:key1\");\n```\n\n还可以使用 StackExchange 库中作为 KeyExpireAsync 方法提供的 EXPIRE 命令将过期时间设置为特定的日期和时间：\n\n```csharp\nConnectionMultiplexer redisHostConnection = ...;\nIDatabase cache = redisHostConnection.GetDatabase();\n...\n// Add a key with an expiration date of midnight on 1st January 2015\nawait cache.StringSetAsync(\"data:key1\", 99);\nawait cache.KeyExpireAsync(\"data:key1\",\n    new DateTime(2015, 1, 1, 0, 0, 0, DateTimeKind.Utc));\n...\n```\n\n> _提示：_可以使用 DEL 命令手动从缓存中删除项，该命令在 StackExchange 库中作为 IDatabase.KeyDeleteAsync 方法提供。\n\n### 使用标记来交叉关联项\n\nRedis 集是共享单个键的多个项集合。可以使用 SADD 命令来创建集。可以使用 SMEMBERS 命令来检索集中的项。StackExchange 库通过 IDatabase.SetAddAsync 方法实现 SADD 命令，并使用 IDatabase.SetMembersAsync 方法实现 SMEMBERS 命令。你还可以使用 SDIFF（差集）、SINTER（交集）和 SUNION（并集）命令来合并现有集以创建新的集。StackExchange 库在 IDatabase.SetCombineAsync 方法中统一了这些操作；此方法的第一个参数指定要执行的设置操作。\n\n以下代码段演示了如何使用集来快速存储和检索相关项的集合。此代码使用“实施 Redis 缓存客户端应用程序”部分中所述的 BlogPost 类型。BlogPost 对象包含四个字段：ID、标题、排名分数和标记集合。以下第一个代码段演示了用于填充 BlogPost 对象的 C# 列表的示例数据：\n\n```csharp\nList<string[]> tags = new List<string[]>()\n{\n    new string[] { \"iot\",\"csharp\" },\n    new string[] { \"iot\",\"azure\",\"csharp\" },\n    new string[] { \"csharp\",\"git\",\"big data\" },\n    new string[] { \"iot\",\"git\",\"database\" },\n    new string[] { \"database\",\"git\" },\n    new string[] { \"csharp\",\"database\" },\n    new string[] { \"iot\" },\n    new string[] { \"iot\",\"database\",\"git\" },\n    new string[] { \"azure\",\"database\",\"big data\",\"git\",\"csharp\" },\n    new string[] { \"azure\" }\n};\n\nList<BlogPost> posts = new List<BlogPost>();\nint blogKey = 0;\nint blogPostId = 0;\nint numberOfPosts = 20;\nRandom random = new Random();\nfor (int i = 0; i < numberOfPosts; i++)\n{\n    blogPostId = blogKey++;\n    posts.Add(new BlogPost(\n        blogPostId,               // Blog post ID\n        string.Format(CultureInfo.InvariantCulture, \"Blog Post #{0}\",\n            blogPostId),          // Blog post title\n        random.Next(100, 10000),  // Ranking score\n        tags[i % tags.Count]));   // Tags – assigned from a collection\n                                  // in the tags list\n}\n```\n\n可以在 Redis 缓存中针对每个 BlogPost 对象将标记存储为集，并将每个集与 BlogPost ID关联。这样，应用程序便可以快速查找属于特定博客文章的所有标记。若要启用反向搜索并查找所有共享特定标记的博客文章，可以创建另一个集，用于保存引用键中标记 ID 的博客文章：\n\n```csharp\nConnectionMultiplexer redisHostConnection = ...;\nIDatabase cache = redisHostConnection.GetDatabase();\n...\n// Tags are easily represented as Redis Sets\nforeach (BlogPost post in posts)\n{\n    string redisKey = string.Format(CultureInfo.InvariantCulture,\n        \"blog:posts:{0}:tags\", post.Id);\n    // Add tags to the blog post in redis\n    await cache.SetAddAsync(\n        redisKey, post.Tags.Select(s => (RedisValue)s).ToArray());\n\n    // Now do the inverse so we can figure how which blog posts have a given tag.\n    foreach (var tag in post.Tags)\n    {\n        await cache.SetAddAsync(string.Format(CultureInfo.InvariantCulture,\n            \"tag:{0}:blog:posts\", tag), post.Id);\n    }\n}\n```\n\n这些结构可让你以非常有效的方式执行许多常见查询。例如，你可以按如下所示查找并显示博客文章 1 的所有标记：\n\n```csharp\n// Show the tags for blog post #1\nforeach (var value in await cache.SetMembersAsync(\"blog:posts:1:tags\"))\n{\n    Console.WriteLine(value);\n}\n```\n\n你可以通过执行交集操作，查找博客文章 1 和博客文章 2 公用的所有标记，如下所示：\n\n```csharp\n// Show the tags in common for blog posts #1 and #2\nforeach (var value in await cache.SetCombineAsync(SetOperation.Intersect, new RedisKey[]\n    { \"blog:posts:1:tags\", \"blog:posts:2:tags\" }))\n{\n    Console.WriteLine(value);\n}\n```\n\n你可以查找包含特定标记的所有博客文章：\n\n```csharp\n// Show the ids of the blog posts that have the tag \"iot\".\nforeach (var value in await cache.SetMembersAsync(\"tag:iot:blog:posts\"))\n{\n    Console.WriteLine(value);\n}\n```\n\n### 查找最近访问的项\n\n许多应用程序遇到的常见问题是如何查找最近访问的项。例如，博客站点可能要显示有关最近读过的博客文章的信息。你可以使用 Redis 列表来实现此功能。Redis 列表包含共享同一个键的多个项，但列表充当双端队列。你可以使用 LPUSH（左推）和 RPUSH（右推）命令将项推送到列表一端。可以使用 LPOP 和 RPOP 命令从列表的一端检索项。你还可以使用 LRANGE 和 RRANGE 命令返回一组元素。以下代码段演示了如何使用 StackExchange 库来执行这些操作。此代码使用前面示例中的 BlogPost 类型。当用户阅读博客文章时，系统会使用 IDatabase.ListLeftPushAsync 方法，将博客文章的标题推送到与 Redis 缓存中键 \"blog:recent\\_posts\" 关联的列表：\n\n```csharp\nConnectionMultiplexer redisHostConnection = ...;\nIDatabase cache = redisHostConnection.GetDatabase();\n...\nstring redisKey = \"blog:recent_posts\";\nBlogPost blogPost = ...; // reference to the blog post that has just been read\nawait cache.ListLeftPushAsync(\n    redisKey, blogPost.Title); // push the blog post onto the list\n```\n\n随着阅读的博客文章越来越多，其标题将推送到同一列表。列表已根据其添加顺序进行排序；最近阅读的博客文章朝向列表左端（如果同一博客文章阅读了一次以上，则它在列表中有多个条目）。可以使用 IDatabase.ListRange 方法显示最近阅读的文章的标题。此方法采用包含列表、起点和终点的键。以下代码将从列表的最左端检索 10 篇博客文章的标题（项为 0 到 9）：\n\n```csharp\n// Show latest ten posts\nforeach (string postTitle in await cache.ListRangeAsync(redisKey, 0, 9))\n{\n    Console.WriteLine(postTitle);\n}\n```\n\n请注意，ListRangeAsync 不会从列表中删除项；为此，你可以使用 IDatabase.ListLeftPopAsync 和 IDatabase.ListRightPopAsync 方法。\n\n若要防止列表无限增长，可以通过修剪列表来定期删除项。以下代码段只会保留列表中位于最左端的 5 个项，并删除其他所有项：\n\n```csharp\nawait cache.ListTrimAsync(redisKey, 0, 5);\n```\n\n### 实施排行榜\n\n默认情况下，集中的项不以任何特定顺序保存。你可以使用 ZADD 命令（StackExchange 库中的 IDatabase.SortedSetAdd 方法）来创建排序集合。系统使用一个名为 score（作为命令的参数提供）的数字值来为项排序。以下代码段将博客文章的标题添加到排序列表。在示例中，每篇博客文章还有包含博客文章排名的评分字段。\n\n```csharp\nConnectionMultiplexer redisHostConnection = ...;\nIDatabase cache = redisHostConnection.GetDatabase();\n...\nstring redisKey = \"blog:post_rankings\";\nBlogPost blogPost = ...; // reference to a blog post that has just been rated\nawait cache.SortedSetAddAsync(redisKey, blogPost.Title, blogpost.Score);\n```\n\n可以使用 IDatabase.SortedSetRangeByRankWithScores 方法以评分递增顺序来检索博客文章标题和评分：\n\n```csharp\nforeach (var post in await cache.SortedSetRangeByRankWithScoresAsync(redisKey))\n{\n    Console.WriteLine(post);\n}\n```\n\n> [AZURE.NOTE]StackExchange 库还提供了 IDatabase.SortedSetRangeByRankAsync 方法，用于以评分顺序返回数据，但不返回评分。\n\n你也可以使用评分递减顺序来检索项，并通过将额外参数提供给 IDatabase.SortedSetRangeByRankWithScoresAsync 方法来限制返回项的数目。以下示例演示了排名前 10 位博客文章的标题和评分：\n\n```csharp\nforeach (var post in await cache.SortedSetRangeByRankWithScoresAsync(\n                               redisKey, 0, 9, Order.Descending))\n{\n    Console.WriteLine(post);\n}\n```\n\n以下示例使用了 IDatabase.SortedSetRangeByScoreWithScoresAsync 方法，该方法可用于限制返回给那些处于给定评分范围内的项：\n\n```csharp\n// Blog posts with scores between 5000 and 100000\nforeach (var post in await cache.SortedSetRangeByScoreWithScoresAsync(\n                               redisKey, 5000, 100000))\n{\n    Console.WriteLine(post);\n}\n```\n\n### 使用通道进行消息传送\n\nRedis 服务器除了可用作数据缓存以外，还可通过高性能发布者/订阅者机制提供消息传送。客户端应用程序可以订阅通道，其他应用程序或服务可以将消息发布到通道。订阅应用程序随后将会接收这些消息，并可以处理消息。\n\nRedis 提供了 SUBSCRIBE 命令用于订阅通道。此命令需要一个或多个可供应用程序接受消息的通道的名称。StackExchange 库包含 ISubscription 接口，可让 .NET Framework 应用程序订阅和发布到通道。使用 Redis 服务器连接的 GetSubscriber 方法创建 ISubscription 对象，然后使用此对象的 SubscribeAsync 方法来侦听通道上的消息。以下代码示例演示了如何订阅名为“messages:blogPosts”的通道：\n\n```csharp\nConnectionMultiplexer redisHostConnection = ...;\nISubscriber subscriber = redisHostConnection.GetSubscriber();\n...\nawait subscriber.SubscribeAsync(\"messages:blogPosts\", (channel, message) =>\n{\n    Console.WriteLine(\"Title is: {0}\", message);\n});\n```\n\nSubscribe 方法的第一个参数为通道的名称。此名称遵循缓存中键使用的相同约定，并且可以包含任何二进制数据，但建议最好使用相对较短且有意义的字符串，以帮助确保良好的性能和易维护性。还应该注意，通道使用的命名空间与键使用的不同，因此你的通道和键可以同名，不过，这可能会导致更难以维护应用程序代码。\n\n第二个参数是 Action 委派。每当新的消息出现在通道上时，此委派就会以异步方式运行。此示例仅显示了控制台上的消息（消息将包含博客文章的标题）。\n\n若要发布到通道，应用程序可以使用 Redis PUBLISH 命令。StackExchange 库提供了 IServer.PublishAsync 方法来执行此操作。以下代码段演示了如何将消息发布到“messages:blogPosts”通道：\n\n```csharp\nConnectionMultiplexer redisHostConnection = ...;\nISubscriber subscriber = redisHostConnection.GetSubscriber();\n...\nBlogPost blogpost = ...;\nsubscriber.PublishAsync(\"messages:blogPosts\", blogPost.Title);\n```\n\n关于发布/订阅机制，应该了解几个要点：\n\n- 多个订阅者可以订阅同一个通道，他们都将接收发布到该通道的消息。\n- 订阅者仅接收订阅后发布的消息。通道不会缓冲，一旦发布消息，Redis 基础结构就会将消息推送到每个订阅者，然后删除消息。\n- 默认情况下，订阅者根据发送顺序来接收消息。在具有大量消息和许多订阅者与发布者的高度活跃系统中，保证依序传送消息可能会降低系统性能。如果每个消息各自独立且顺序并不重要，则你可以通过 Redis 系统启用并发处理，这有助于提高响应度。你可以在 StackExchange 客户端中，通过将订阅者使用的连接的 PreserveAsyncOrder 设置为 false 来实现此目的：\n  ```csharp\n  ConnectionMultiplexer redisHostConnection = ...;\n  redisHostConnection.PreserveAsyncOrder = false;\n  ISubscriber subscriber = redisHostConnection.GetSubscriber();\n  ```\n\n## 相关模式和指南\n\n在应用程序中实施缓存时，以下模式也可能与你的方案相关：\n\n- [缓存端模式](http://msdn.microsoft.com/zh-cn/library/dn589799.aspx)：此模式描述如何按需将数据从数据存储载入缓存。此模式还有助于在缓存中保存的数据与原始数据存储中的数据之间保持一致性。\n- [分片模式](http://msdn.microsoft.com/zh-cn/library/dn589797.aspx)提供了有关实施水平分区，以帮助在存储和访问大量数据时提高可缩放性的信息。\n\n## 更多信息\n\n- [MemoryCache 类](http://msdn.microsoft.com/zh-cn/library/system.runtime.caching.memorycache.aspx)。\n- [Azure 缓存](http://msdn.microsoft.com/zh-cn/library/windowsazure/gg278356.aspx)。\n- [哪种 Azure Cache 产品/服务适合我？](/documentation/articles/cache-faq/#which-azure-cache-offering-is-right-for-me)。\n- [配置模型](http://msdn.microsoft.com/zh-cn/library/windowsazure/hh914149.aspx)。\n- [基于任务的异步模式](http://msdn.microsoft.com/zh-cn/library/hh873175.aspx)。\n- StackExchange.Redis GitHub 存储库上的[管道和多路复用器](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md)。\n- Redis 网站上的 [Redis 持久性](http://redis.io/topics/persistence)。\n- Redis 网站上的[复制](http://redis.io/topics/replication)。\n- Redis 网站上的 [Redis 群集教程](http://redis.io/topics/cluster-tutorial)。\n- Redis 网站上的[分区：如何在多个 Redis 实例之间拆分数据](http://redis.io/topics/partitioning)。\n- Redis 网站上的[使用 Redis 作为 LRU 缓存](http://redis.io/topics/lru-cache)。\n- Redis 网站上的[事务](http://redis.io/topics/transactions)。\n- Redis 网站上的 [Redis 安全性](http://redis.io/topics/security)。\n- [在 Azure 中的 CentOS Linux VM 上运行 Redis](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)。\n- [Azure Redis 缓存的 ASP.NET 会话状态提供程序](/documentation/articles/cache-asp.net-session-state-provider)。\n- [Azure Redis 缓存的 ASP.NET 输出缓存提供程序](/documentation/articles/cache-asp.net-output-cache-provider)。\n- [Redis 数据类型和抽象简介](http://redis.io/topics/data-types-intro)。\n- StackExchange.Redis 网站上的[基本用法](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md)。\n- StackExchange.Redis 存储库上的 [Redis 中的事务](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md)。\n- [数据分区指南](http://msdn.microsoft.com/zh-cn/library/dn589795.aspx)。\n\n<!---HONumber=Mooncake_0118_2016-->"
}