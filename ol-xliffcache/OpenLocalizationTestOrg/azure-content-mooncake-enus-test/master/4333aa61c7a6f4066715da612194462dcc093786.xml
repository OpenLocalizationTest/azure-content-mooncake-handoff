{
  "nodes": [
    {
      "content": "哈希分布及其对 SQL 数据仓库中查询性能的影响 | Azure",
      "pos": [
        26,
        58
      ]
    },
    {
      "content": "在开发解决方案之前，了解哈希分布表及其如何影响 Azure SQL 数据仓库中的查询性能。",
      "pos": [
        76,
        121
      ]
    },
    {
      "content": "哈希分布及其对 SQL 数据仓库中查询性能的影响",
      "pos": [
        345,
        369
      ]
    },
    {
      "content": "做出明智的哈希分布决策是改善查询性能最重要的方式之一。",
      "pos": [
        371,
        398
      ]
    },
    {
      "content": "事实上，有三个主要因素：",
      "pos": [
        400,
        412
      ]
    },
    {
      "content": "最小化数据移动",
      "pos": [
        417,
        424
      ]
    },
    {
      "content": "避免数据偏斜",
      "pos": [
        428,
        434
      ]
    },
    {
      "content": "提供平衡的执行",
      "pos": [
        438,
        445
      ]
    },
    {
      "content": "最小化数据移动",
      "pos": [
        450,
        457
      ]
    },
    {
      "content": "将表联接在一起或在表上执行聚合时，最常发生的情况就是数据移动。共享密钥中的哈希分布表是最小化此移动的最有效方法之一。",
      "pos": [
        458,
        516
      ]
    },
    {
      "content": "但是，若要让哈希分布对最小化移动发挥效果，必须符合以下所有条件：",
      "pos": [
        518,
        550
      ]
    },
    {
      "content": "这两个表需为哈希分布式，并在共享的分布密钥上联接",
      "pos": [
        555,
        579
      ]
    },
    {
      "content": "这两个列的数据类型需要匹配",
      "pos": [
        583,
        596
      ]
    },
    {
      "content": "联接的列需为等值联接（即，左表列中的值需要等于右表列中的值）",
      "pos": [
        600,
        630
      ]
    },
    {
      "pos": [
        634,
        655
      ],
      "content": "联接<bpt id=\"p1\">**</bpt>不是<ept id=\"p1\">**</ept> <ph id=\"ph1\">`CROSS JOIN`</ph>"
    },
    {
      "pos": [
        659,
        787
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>在 <ph id=\"ph2\">`JOIN`</ph>、<ph id=\"ph3\">`GROUP BY`</ph>、<ph id=\"ph4\">`DISTINCT`</ph> 和 <ph id=\"ph5\">`HAVING`</ph> 子句中使用的列都生成适当的哈希列候选项。另一方面，用于 <ph id=\"ph6\">`WHERE`</ph> 子句的列<bpt id=\"p1\">**</bpt>不会<ept id=\"p1\">**</ept>生成适当的哈希列候选项。请参阅以下与平衡执行相关的部分。"
    },
    {
      "pos": [
        789,
        859
      ],
      "content": "当查询语法（<ph id=\"ph1\">`COUNT DISTINCT`</ph> 和 <ph id=\"ph2\">`OVER`</ph> 两个子句都是绝佳示例）和不包含哈希分布键的列配合使用时，也可能发生数据移动。"
    },
    {
      "pos": [
        863,
        927
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>轮循机制表通常产生数据移动。表中的数据已经以不具确定性的方式分配，因此必须在大多数查询完成之前移动数据。"
    },
    {
      "content": "避免数据偏斜",
      "pos": [
        932,
        938
      ]
    },
    {
      "content": "为了使哈希分布有效，选择的列必须展示以下属性：",
      "pos": [
        939,
        962
      ]
    },
    {
      "content": "该列包含大量的相异值。",
      "pos": [
        967,
        978
      ]
    },
    {
      "pos": [
        982,
        1000
      ],
      "content": "该列不会受到<bpt id=\"p1\">**</bpt>数据偏斜<ept id=\"p1\">**</ept>的影响。"
    },
    {
      "content": "每个相异值将分配到某个分布区。因此，数据需要合理数目的相异值，以确保生成足够的唯一哈希值。否则，我们可能会获得质量不佳的哈希。例如，如果分布区数目超过相异值的数目，某些分布区将保留空白。这会降低性能。",
      "pos": [
        1002,
        1102
      ]
    },
    {
      "pos": [
        1104,
        1195
      ],
      "content": "同样，如果哈希列的所有行都包含相同值，则数据就会<bpt id=\"p1\">**</bpt>偏斜<ept id=\"p1\">**</ept>。在此极端情况下，只能创建一个哈希值，导致所有行最后都在单个分布区内。在理想情况下，哈希列中的每个相异值都有相同数目的行。"
    },
    {
      "pos": [
        1199,
        1242
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>轮循机制表不会表现出偏斜的迹象。这是因为数据跨分布区平均存储。"
    },
    {
      "content": "提供平衡的执行",
      "pos": [
        1247,
        1254
      ]
    },
    {
      "content": "当每个分布区有相同数量的工作要执行时，就会实现平衡的执行。大规模并行处理 (MPP) 是一种团队游戏；在任何人被声明为赢家之前，每个人都必须取得胜利。如果每个分布区有相同数量的工作（也就是要处理的数据），则所有查询都会在大致相同的时间完成。这就是所谓的平衡执行。",
      "pos": [
        1255,
        1386
      ]
    },
    {
      "pos": [
        1388,
        1460
      ],
      "content": "我们知道，数据偏斜可能影响平衡的执行。但是，也因此可以选择哈希分布键。如果已选择出现在查询的 <ph id=\"ph1\">`WHERE`</ph> 子句中的列，则查询很有可能不平衡。"
    },
    {
      "pos": [
        1464,
        1503
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph><ph id=\"ph2\">`WHERE`</ph> 子句通常有助于识别最适合用于分区的列。"
    },
    {
      "pos": [
        1505,
        1724
      ],
      "content": "出现在 <ph id=\"ph1\">`WHERE`</ph> 子句中的列的代表性示例是日期字段。日期字段是分区列极好、但哈希分布列通常极差的典型示例。一般而言，数据仓库查询将维持一段指定的时间，例如日、周或月。基于日期的哈希分布可能真正限制了我们的缩放性并损害了性能。例如，如果指定的日期范围是一周（即 7 天），则哈希的最大数目就是 7 - 每天一个。这意味着只有 7 个分布区包含数据。其余的分布区没有任何数据。这会导致不平衡的查询执行，因为只有 7 个分布区在处理数据。"
    },
    {
      "pos": [
        1728,
        1770
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>轮循机制表通常提供平衡的执行。这是因为数据跨分布区平均存储。"
    },
    {
      "content": "建议",
      "pos": [
        1775,
        1777
      ]
    },
    {
      "content": "若要最大化性能和整体查询吞吐量，请尽量确保哈希分布表遵循以下模式：",
      "pos": [
        1778,
        1811
      ]
    },
    {
      "content": "哈希分布键：",
      "pos": [
        1813,
        1819
      ]
    },
    {
      "pos": [
        1824,
        1875
      ],
      "content": "在查询的 <ph id=\"ph1\">`JOIN`</ph>、<ph id=\"ph2\">`GROUP BY`</ph>、<ph id=\"ph3\">`DISTINCT`</ph> 或 <ph id=\"ph4\">`HAVING`</ph> 子句中使用。"
    },
    {
      "pos": [
        1879,
        1895
      ],
      "content": "不在 <ph id=\"ph1\">`WHERE`</ph> 子句中使用"
    },
    {
      "content": "至少有 1000 个不同的值。",
      "pos": [
        1899,
        1914
      ]
    },
    {
      "content": "不会将大量的不成比例的行哈希到少量的分布区。",
      "pos": [
        1918,
        1940
      ]
    },
    {
      "content": "定义为 NOT NULL。NULL 行将聚集在单个分布区中。",
      "pos": [
        1944,
        1974
      ]
    },
    {
      "content": "摘要",
      "pos": [
        1979,
        1981
      ]
    },
    {
      "content": "哈希分布可总结如下：",
      "pos": [
        1983,
        1993
      ]
    },
    {
      "content": "哈希函数具确定性。相同的值始终分配到同一个分布区。",
      "pos": [
        1997,
        2022
      ]
    },
    {
      "content": "一个列用作分布列。哈希函数使用指定的列来计算分布区的行分配。",
      "pos": [
        2025,
        2055
      ]
    },
    {
      "content": "哈希函数基于列的类型，而不是本身的值",
      "pos": [
        2058,
        2076
      ]
    },
    {
      "content": "哈希分布表有时可能造成偏斜的表",
      "pos": [
        2079,
        2094
      ]
    },
    {
      "content": "解析查询时，哈希分布表通常需要较少的数据，因此可以改善大型事实表的查询性能。",
      "pos": [
        2097,
        2135
      ]
    },
    {
      "content": "遵循有关选择哈希分布列的建议，以增强查询吞吐量。",
      "pos": [
        2138,
        2162
      ]
    },
    {
      "pos": [
        2166,
        2289
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph>在 SQL 数据仓库中，数据类型一致性相当重要！ 请确保现有架构一致使用相同类型的列。这对分布键尤其重要。如果未同步分布键数据类型，且表已联接，将会发生不必要的数据移动。如果表很大，成本可能很高，并且导致吞吐量和性能降低。"
    },
    {
      "content": "后续步骤",
      "pos": [
        2295,
        2299
      ]
    },
    {
      "pos": [
        2300,
        2321
      ],
      "content": "有关更多开发技巧，请参阅<bpt id=\"p1\">[</bpt>开发概述<ept id=\"p1\">][]</ept>。"
    }
  ],
  "content": "<properties\n   pageTitle=\"哈希分布及其对 SQL 数据仓库中查询性能的影响 | Azure\"\n   description=\"在开发解决方案之前，了解哈希分布表及其如何影响 Azure SQL 数据仓库中的查询性能。\"\n   services=\"sql-data-warehouse\"\n   documentationCenter=\"NA\"\n   authors=\"jrowlandjones\"\n   manager=\"barbkess\"\n   editor=\"\"/>\n\n<tags\n   ms.service=\"sql-data-warehouse\"\n   ms.date=\"09/22/2015\"\n   wacn.date=\"01/20/2016\"/>\n\n# 哈希分布及其对 SQL 数据仓库中查询性能的影响\n\n做出明智的哈希分布决策是改善查询性能最重要的方式之一。\n\n事实上，有三个主要因素：\n\n1. 最小化数据移动\n2. 避免数据偏斜\n3. 提供平衡的执行\n\n## 最小化数据移动\n将表联接在一起或在表上执行聚合时，最常发生的情况就是数据移动。共享密钥中的哈希分布表是最小化此移动的最有效方法之一。\n\n但是，若要让哈希分布对最小化移动发挥效果，必须符合以下所有条件：\n\n1. 这两个表需为哈希分布式，并在共享的分布密钥上联接\n2. 这两个列的数据类型需要匹配\n3. 联接的列需为等值联接（即，左表列中的值需要等于右表列中的值）\n4. 联接**不是** `CROSS JOIN`\n\n> [AZURE.NOTE]在 `JOIN`、`GROUP BY`、`DISTINCT` 和 `HAVING` 子句中使用的列都生成适当的哈希列候选项。另一方面，用于 `WHERE` 子句的列**不会**生成适当的哈希列候选项。请参阅以下与平衡执行相关的部分。\n\n当查询语法（`COUNT DISTINCT` 和 `OVER` 两个子句都是绝佳示例）和不包含哈希分布键的列配合使用时，也可能发生数据移动。\n\n> [AZURE.NOTE]轮循机制表通常产生数据移动。表中的数据已经以不具确定性的方式分配，因此必须在大多数查询完成之前移动数据。\n\n## 避免数据偏斜\n为了使哈希分布有效，选择的列必须展示以下属性：\n\n1. 该列包含大量的相异值。\n2. 该列不会受到**数据偏斜**的影响。\n\n每个相异值将分配到某个分布区。因此，数据需要合理数目的相异值，以确保生成足够的唯一哈希值。否则，我们可能会获得质量不佳的哈希。例如，如果分布区数目超过相异值的数目，某些分布区将保留空白。这会降低性能。\n\n同样，如果哈希列的所有行都包含相同值，则数据就会**偏斜**。在此极端情况下，只能创建一个哈希值，导致所有行最后都在单个分布区内。在理想情况下，哈希列中的每个相异值都有相同数目的行。\n\n> [AZURE.NOTE]轮循机制表不会表现出偏斜的迹象。这是因为数据跨分布区平均存储。\n\n## 提供平衡的执行\n当每个分布区有相同数量的工作要执行时，就会实现平衡的执行。大规模并行处理 (MPP) 是一种团队游戏；在任何人被声明为赢家之前，每个人都必须取得胜利。如果每个分布区有相同数量的工作（也就是要处理的数据），则所有查询都会在大致相同的时间完成。这就是所谓的平衡执行。\n\n我们知道，数据偏斜可能影响平衡的执行。但是，也因此可以选择哈希分布键。如果已选择出现在查询的 `WHERE` 子句中的列，则查询很有可能不平衡。\n\n> [AZURE.NOTE]`WHERE` 子句通常有助于识别最适合用于分区的列。\n\n出现在 `WHERE` 子句中的列的代表性示例是日期字段。日期字段是分区列极好、但哈希分布列通常极差的典型示例。一般而言，数据仓库查询将维持一段指定的时间，例如日、周或月。基于日期的哈希分布可能真正限制了我们的缩放性并损害了性能。例如，如果指定的日期范围是一周（即 7 天），则哈希的最大数目就是 7 - 每天一个。这意味着只有 7 个分布区包含数据。其余的分布区没有任何数据。这会导致不平衡的查询执行，因为只有 7 个分布区在处理数据。\n\n> [AZURE.NOTE]轮循机制表通常提供平衡的执行。这是因为数据跨分布区平均存储。\n\n## 建议\n若要最大化性能和整体查询吞吐量，请尽量确保哈希分布表遵循以下模式：\n\n哈希分布键：\n\n1. 在查询的 `JOIN`、`GROUP BY`、`DISTINCT` 或 `HAVING` 子句中使用。\n2. 不在 `WHERE` 子句中使用\n3. 至少有 1000 个不同的值。\n4. 不会将大量的不成比例的行哈希到少量的分布区。\n5. 定义为 NOT NULL。NULL 行将聚集在单个分布区中。\n\n## 摘要\n\n哈希分布可总结如下：\n\n- 哈希函数具确定性。相同的值始终分配到同一个分布区。\n- 一个列用作分布列。哈希函数使用指定的列来计算分布区的行分配。\n- 哈希函数基于列的类型，而不是本身的值\n- 哈希分布表有时可能造成偏斜的表\n- 解析查询时，哈希分布表通常需要较少的数据，因此可以改善大型事实表的查询性能。\n- 遵循有关选择哈希分布列的建议，以增强查询吞吐量。\n\n> [AZURE.NOTE]在 SQL 数据仓库中，数据类型一致性相当重要！ 请确保现有架构一致使用相同类型的列。这对分布键尤其重要。如果未同步分布键数据类型，且表已联接，将会发生不必要的数据移动。如果表很大，成本可能很高，并且导致吞吐量和性能降低。\n\n\n## 后续步骤\n有关更多开发技巧，请参阅[开发概述][]。\n\n<!--Image references-->\n\n<!--Article references-->\n[开发概述]: /documentation/articles/sql-data-warehouse-overview-develop\n\n<!--MSDN references-->\n\n<!--Other Web references-->\n\n<!---HONumber=Mooncake_1207_2015-->\n"
}