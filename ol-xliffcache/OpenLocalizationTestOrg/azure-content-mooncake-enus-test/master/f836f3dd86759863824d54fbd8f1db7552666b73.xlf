<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f836f3dd86759863824d54fbd8f1db7552666b73</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>服务总线中继消息传送教程 | Microsoft Azure</source>
          <target state="new">服务总线中继消息传送教程 | Microsoft Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>使用服务总线中继消息传送继构建服务总线客户端应用程序。</source>
          <target state="new">使用服务总线中继消息传送继构建服务总线客户端应用程序。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>服务总线中继消息传送教程</source>
          <target state="new">服务总线中继消息传送教程</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>本教程介绍了如何使用服务总线“中继”功能，构建简单的服务总线客户端应用程序和服务。有关使用服务总线<bpt id="p1">[</bpt>中转消息传送<ept id="p1">](/documentation/articles/service-bus-messaging-overview#Brokered-messaging)</ept>的相应教程，请参阅<bpt id="p2">[</bpt>服务总线中转消息传送 .NET 教程<ept id="p2">](/documentation/articles/service-bus-brokered-tutorial-dotnet)</ept>。</source>
          <target state="new">本教程介绍了如何使用服务总线“中继”功能，构建简单的服务总线客户端应用程序和服务。有关使用服务总线<bpt id="p1">[</bpt>中转消息传送<ept id="p1">](/documentation/articles/service-bus-messaging-overview#Brokered-messaging)</ept>的相应教程，请参阅<bpt id="p2">[</bpt>服务总线中转消息传送 .NET 教程<ept id="p2">](/documentation/articles/service-bus-brokered-tutorial-dotnet)</ept>。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>通过此教程，你可以了解创建服务总线客户端和服务应用程序所需的步骤。正如其 WCF 对应项，服务是公开一个或多个终结点的构造，其中每个终结点都公开一个或多个服务操作。服务的终结点用于指定可在其中找到服务的地址、包含客户端必须与服务进行通信的信息的绑定，以及定义服务向其客户端提供的功能的协定。WCF 和服务总线服务之间的主要区别在于：终结点在云中公开，而不是在本地计算机中公开。</source>
          <target state="new">通过此教程，你可以了解创建服务总线客户端和服务应用程序所需的步骤。正如其 WCF 对应项，服务是公开一个或多个终结点的构造，其中每个终结点都公开一个或多个服务操作。服务的终结点用于指定可在其中找到服务的地址、包含客户端必须与服务进行通信的信息的绑定，以及定义服务向其客户端提供的功能的协定。WCF 和服务总线服务之间的主要区别在于：终结点在云中公开，而不是在本地计算机中公开。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>完成本教程中的一系列主题后，你将具有一项正在运行的服务和可以调用服务操作的客户端。第一个主题描述了如何设置帐户。接下来的步骤描述了如何定义使用协定的服务、如何实现服务，以及如何使用代码配置该服务。这些主题还描述了如何托管和运行该服务。创建的服务是自托管的，并且客户端和服务在同一台计算机上运行。你可以通过使用代码或配置文件配置服务。</source>
          <target state="new">完成本教程中的一系列主题后，你将具有一项正在运行的服务和可以调用服务操作的客户端。第一个主题描述了如何设置帐户。接下来的步骤描述了如何定义使用协定的服务、如何实现服务，以及如何使用代码配置该服务。这些主题还描述了如何托管和运行该服务。创建的服务是自托管的，并且客户端和服务在同一台计算机上运行。你可以通过使用代码或配置文件配置服务。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>最后三个步骤介绍如何创建客户端应用程序、如何配置客户端应用程序，以及如何创建和使用可以访问主机功能的客户端。</source>
          <target state="new">最后三个步骤介绍如何创建客户端应用程序、如何配置客户端应用程序，以及如何创建和使用可以访问主机功能的客户端。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>本部分中的所有主题均假定使用 Visual Studio 作为开发环境。</source>
          <target state="new">本部分中的所有主题均假定使用 Visual Studio 作为开发环境。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>注册帐户</source>
          <target state="new">注册帐户</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>第一步是创建服务总线服务命名空间并获取共享访问签名 (SAS) 密钥。服务命名空间为每个通过服务总线公开的应用程序提供应用程序边界。服务命名空间与 SAS 密钥的组合为服务总线提供了一个用于验证应用程序访问权限的凭据。</source>
          <target state="new">第一步是创建服务总线服务命名空间并获取共享访问签名 (SAS) 密钥。服务命名空间为每个通过服务总线公开的应用程序提供应用程序边界。服务命名空间与 SAS 密钥的组合为服务总线提供了一个用于验证应用程序访问权限的凭据。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>若要创建服务命名空间，请访问 [Azure 经典门户][]。单击左侧的“服务总线”，然后单击“创建”。为你的命名空间键入一个名称，然后单击复选标记。</source>
          <target state="new">若要创建服务命名空间，请访问 [Azure 经典门户][]。单击左侧的“服务总线”，然后单击“创建”。为你的命名空间键入一个名称，然后单击复选标记。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 无需针对客户端和服务应用程序使用相同的命名空间。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 无需针对客户端和服务应用程序使用相同的命名空间。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>在门户的主窗口中，单击在上一步中创建的命名空间的名称。</source>
          <target state="new">在门户的主窗口中，单击在上一步中创建的命名空间的名称。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>单击“配置”以查看命名空间的默认共享访问策略。</source>
          <target state="new">单击“配置”以查看命名空间的默认共享访问策略。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>记下 <bpt id="p1">**</bpt>RootManageSharedAccessKey<ept id="p1">**</ept> 策略的主键，或将其复制到剪贴板上。你将在本教程的后面部分使用此值。</source>
          <target state="new">记下 <bpt id="p1">**</bpt>RootManageSharedAccessKey<ept id="p1">**</ept> 策略的主键，或将其复制到剪贴板上。你将在本教程的后面部分使用此值。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>定义 WCF 服务协定以用于服务总线</source>
          <target state="new">定义 WCF 服务协定以用于服务总线</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>服务协定用于指定服务支持的操作类型（方法或函数的 Web 服务术语）。约定通过定义 C++、C# 或 Visual Basic 接口来创建。接口中的每个方法都对应一个特定的服务操作。必须将 <bpt id="p1">[</bpt>ServiceContractAttribute<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.servicecontractattribute.aspx)</ept> 属性应用于每个接口，并且必须将 <bpt id="p2">[</bpt>OperationContractAttribute<ept id="p2">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.operationcontractattribute.aspx)</ept> 属性应用于每个操作。如果具有 <bpt id="p3">[</bpt>ServiceContractAttribute<ept id="p3">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.servicecontractattribute.aspx)</ept> 属性的接口中的方法没有 <bpt id="p4">[</bpt>OperationContractAttribute<ept id="p4">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.operationcontractattribute.aspx)</ept> 属性，则该方法是不公开的。该过程后面的示例中提供了这些任务的代码。有关协定和服务的更多讨论，请参阅 WCF 文档中的<bpt id="p5">[</bpt>设计和实现服务<ept id="p5">](https://msdn.microsoft.com/zh-cn/library/ms729746.aspx)</ept>。</source>
          <target state="new">服务协定用于指定服务支持的操作类型（方法或函数的 Web 服务术语）。约定通过定义 C++、C# 或 Visual Basic 接口来创建。接口中的每个方法都对应一个特定的服务操作。必须将 <bpt id="p1">[</bpt>ServiceContractAttribute<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.servicecontractattribute.aspx)</ept> 属性应用于每个接口，并且必须将 <bpt id="p2">[</bpt>OperationContractAttribute<ept id="p2">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.operationcontractattribute.aspx)</ept> 属性应用于每个操作。如果具有 <bpt id="p3">[</bpt>ServiceContractAttribute<ept id="p3">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.servicecontractattribute.aspx)</ept> 属性的接口中的方法没有 <bpt id="p4">[</bpt>OperationContractAttribute<ept id="p4">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.operationcontractattribute.aspx)</ept> 属性，则该方法是不公开的。该过程后面的示例中提供了这些任务的代码。有关协定和服务的更多讨论，请参阅 WCF 文档中的<bpt id="p5">[</bpt>设计和实现服务<ept id="p5">](https://msdn.microsoft.com/zh-cn/library/ms729746.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>使用接口创建服务总线约定</source>
          <target state="new">使用接口创建服务总线约定</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>在“开始”菜单中右键单击 Visual Studio，以便以管理员身份启动该程序，然后选择“以管理员身份运行”。</source>
          <target state="new">在“开始”菜单中右键单击 Visual Studio，以便以管理员身份启动该程序，然后选择“以管理员身份运行”。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>创建新的控制台应用程序项目。单击“文件”菜单并选择“新建”，然后单击“项目”。在“新建项目”对话框中，单击“Visual C#”（如果“Visual C#”未出现，则在“其他语言”下方查看）。单击“控制台应用程序”模板，并将其命名为 <bpt id="p1">**</bpt>EchoService<ept id="p1">**</ept>。使用默认“位置”。单击“确定”以创建该项目。</source>
          <target state="new">创建新的控制台应用程序项目。单击“文件”菜单并选择“新建”，然后单击“项目”。在“新建项目”对话框中，单击“Visual C#”（如果“Visual C#”未出现，则在“其他语言”下方查看）。单击“控制台应用程序”模板，并将其命名为 <bpt id="p1">**</bpt>EchoService<ept id="p1">**</ept>。使用默认“位置”。单击“确定”以创建该项目。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>在项目中添加对 <ph id="ph1">`System.ServiceModel.dll`</ph> 的引用：在“解决方案资源管理器”中，右键单击项目文件夹下的“引用”文件夹，然后单击“添加引用”。在“添加引用”对话框中选择“.NET”选项卡并向下滚动，直到看到“System.ServiceModel”。选中后单击“确定”。</source>
          <target state="new">在项目中添加对 <ph id="ph1">`System.ServiceModel.dll`</ph> 的引用：在“解决方案资源管理器”中，右键单击项目文件夹下的“引用”文件夹，然后单击“添加引用”。在“添加引用”对话框中选择“.NET”选项卡并向下滚动，直到看到“System.ServiceModel”。选中后单击“确定”。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>在解决方案资源管理中，双击 Program.cs 文件以在编辑器中将其打开。</source>
          <target state="new">在解决方案资源管理中，双击 Program.cs 文件以在编辑器中将其打开。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>为 System.ServiceModel 命名空间添加 <ph id="ph1">`using`</ph> 语句。</source>
          <target state="new">为 System.ServiceModel 命名空间添加 <ph id="ph1">`using`</ph> 语句。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.ServiceModel<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.aspx)</ept> 是可以以编程方式访问 WCF 基本功能的命名空间。服务总线使用 WCF 的许多对象和属性来定义服务约定。</source>
          <target state="new"><bpt id="p1">[</bpt>System.ServiceModel<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.aspx)</ept> 是可以以编程方式访问 WCF 基本功能的命名空间。服务总线使用 WCF 的许多对象和属性来定义服务约定。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>将命名空间的默认名称 <bpt id="p1">**</bpt>EchoService<ept id="p1">**</ept> 更改为 <bpt id="p2">**</bpt>Microsoft.ServiceBus.Samples<ept id="p2">**</ept>。</source>
          <target state="new">将命名空间的默认名称 <bpt id="p1">**</bpt>EchoService<ept id="p1">**</ept> 更改为 <bpt id="p2">**</bpt>Microsoft.ServiceBus.Samples<ept id="p2">**</ept>。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph> 本教程使用 C# 命名空间 <bpt id="p1">**</bpt>Microsoft.ServiceBus.Samples<ept id="p1">**</ept>，它是协定管理类型的命名空间，此类型用于<bpt id="p2">[</bpt>配置 WCF 客户端中<ept id="p2">](#configure-the-wcf-client)</ept>步骤中的配置文件。在构建此示例时，你可以指定任何想要的命名空间，当你在配置文件中修改了协定以及相应服务的命名空间后，本教程才会生效。在 App.config 文件中指定的命名空间必须与在 C# 文件中指定的命名空间相同。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph> 本教程使用 C# 命名空间 <bpt id="p1">**</bpt>Microsoft.ServiceBus.Samples<ept id="p1">**</ept>，它是协定管理类型的命名空间，此类型用于<bpt id="p2">[</bpt>配置 WCF 客户端中<ept id="p2">](#configure-the-wcf-client)</ept>步骤中的配置文件。在构建此示例时，你可以指定任何想要的命名空间，当你在配置文件中修改了协定以及相应服务的命名空间后，本教程才会生效。在 App.config 文件中指定的命名空间必须与在 C# 文件中指定的命名空间相同。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>直接在完成 <ph id="ph1">`Microsoft.ServiceBus.Samples`</ph> 命名空间声明后，在命名空间内定义一个名为 <ph id="ph2">`IEchoContract`</ph> 的新接口，然后将 <ph id="ph3">`ServiceContractAttribute`</ph> 属性应用于该接口，其值为 <bpt id="p1">**</bpt>http://samples.microsoft.com/ServiceModel/Relay/<ept id="p1">**</ept>。该命名空间值不同于你在整个代码范围内使用的命名空间。相反，该命名空间值将用作此协定的唯一标识符。显式指定命名空间可防止将默认的命名空间值添加到约定名称中。</source>
          <target state="new">直接在完成 <ph id="ph1">`Microsoft.ServiceBus.Samples`</ph> 命名空间声明后，在命名空间内定义一个名为 <ph id="ph2">`IEchoContract`</ph> 的新接口，然后将 <ph id="ph3">`ServiceContractAttribute`</ph> 属性应用于该接口，其值为 <bpt id="p1">**</bpt>http://samples.microsoft.com/ServiceModel/Relay/<ept id="p1">**</ept>。该命名空间值不同于你在整个代码范围内使用的命名空间。相反，该命名空间值将用作此协定的唯一标识符。显式指定命名空间可防止将默认的命名空间值添加到约定名称中。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>通常情况下，服务协定命名空间包含一个包括版本信息的命名方案。服务协定命名空间中包括的版本信息可以使服务通过将新服务协定定义为新命名空间并将其公开到新的终结点上，来隔离重大更改。以这种方式，客户端可以继续使用旧的服务协定，而无需进行更新。版本信息可能包含日期或内部版本号。有关详细信息，请参阅<bpt id="p1">[</bpt>服务版本控制<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=180498)</ept>。鉴于此教程的目的，服务协定命名空间的命名方案不包含版本信息。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>通常情况下，服务协定命名空间包含一个包括版本信息的命名方案。服务协定命名空间中包括的版本信息可以使服务通过将新服务协定定义为新命名空间并将其公开到新的终结点上，来隔离重大更改。以这种方式，客户端可以继续使用旧的服务协定，而无需进行更新。版本信息可能包含日期或内部版本号。有关详细信息，请参阅<bpt id="p1">[</bpt>服务版本控制<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=180498)</ept>。鉴于此教程的目的，服务协定命名空间的命名方案不包含版本信息。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>在 <ph id="ph1">`IEchoContract`</ph> 接口中，为 <ph id="ph2">`IEchoContract`</ph> 约定在接口中公开的单个操作声明一个方法，然后将 <ph id="ph3">`OperationContractAttribute`</ph> 属性应用到你希望将其作为公共服务总线约定的一部分进行公开的方法中。</source>
          <target state="new">在 <ph id="ph1">`IEchoContract`</ph> 接口中，为 <ph id="ph2">`IEchoContract`</ph> 约定在接口中公开的单个操作声明一个方法，然后将 <ph id="ph3">`OperationContractAttribute`</ph> 属性应用到你希望将其作为公共服务总线约定的一部分进行公开的方法中。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>在该协定外，声明从 <ph id="ph1">`IEchoChannel`</ph> 中继承，并可传承到 <ph id="ph2">`IClientChannel`</ph> 接口的通道，如下所示：</source>
          <target state="new">在该协定外，声明从 <ph id="ph1">`IEchoChannel`</ph> 中继承，并可传承到 <ph id="ph2">`IClientChannel`</ph> 接口的通道，如下所示：</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>通道是主机和客户端用来互相传递信息的 WCF 对象。随后，你将针对通道编写代码，以在两个应用程序之间回显信息。</source>
          <target state="new">通道是主机和客户端用来互相传递信息的 WCF 对象。随后，你将针对通道编写代码，以在两个应用程序之间回显信息。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>在“生成”菜单中，单击“生成解决方案”或按 F6 以确认到目前为止操作的准确性。</source>
          <target state="new">在“生成”菜单中，单击“生成解决方案”或按 F6 以确认到目前为止操作的准确性。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>示例</source>
          <target state="new">示例</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>以下代码显示了一个用于定义服务总线协定的基本接口。</source>
          <target state="new">以下代码显示了一个用于定义服务总线协定的基本接口。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>既然已创建接口，你可以实现该接口。</source>
          <target state="new">既然已创建接口，你可以实现该接口。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>实现 WCF 协定以使用服务总线</source>
          <target state="new">实现 WCF 协定以使用服务总线</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>创建服务总线服务首先需要你创建使用接口定义的协定。有关创建接口的详细信息，请参阅上一步。下一步是实现该接口。此步骤包括创建名为 <ph id="ph1">`EchoService`</ph> 的类，用于实现用户定义的 <ph id="ph2">`IEchoContract`</ph> 接口。实现接口后，即可使用 App.config 配置文件配置接口。该配置文件包含应用程序所需的信息，如服务的名称、约定的名称，以及用来与服务总线通信的协议类型。该过程后面的示例中提供了这些任务所用的代码。有关如何实现服务协定的更多常规讨论，请参阅 Windows Communication Foundation (WCF) 文档中的<bpt id="p1">[</bpt>实现服务协定<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/ms733764.aspx)</ept>。</source>
          <target state="new">创建服务总线服务首先需要你创建使用接口定义的协定。有关创建接口的详细信息，请参阅上一步。下一步是实现该接口。此步骤包括创建名为 <ph id="ph1">`EchoService`</ph> 的类，用于实现用户定义的 <ph id="ph2">`IEchoContract`</ph> 接口。实现接口后，即可使用 App.config 配置文件配置接口。该配置文件包含应用程序所需的信息，如服务的名称、约定的名称，以及用来与服务总线通信的协议类型。该过程后面的示例中提供了这些任务所用的代码。有关如何实现服务协定的更多常规讨论，请参阅 Windows Communication Foundation (WCF) 文档中的<bpt id="p1">[</bpt>实现服务协定<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/ms733764.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>在 <ph id="ph1">`IEchoContract`</ph> 接口定义的正下方创建名为 <ph id="ph2">`EchoService`</ph> 的新类。<ph id="ph3">`EchoService`</ph> 类实现 <ph id="ph4">`IEchoContract`</ph> 接口。</source>
          <target state="new">在 <ph id="ph1">`IEchoContract`</ph> 接口定义的正下方创建名为 <ph id="ph2">`EchoService`</ph> 的新类。<ph id="ph3">`EchoService`</ph> 类实现 <ph id="ph4">`IEchoContract`</ph> 接口。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>与其他接口实现类似，你可以在另一个文件中实现定义。但是，在本教程中，实现所在的文件与接口定义和 <ph id="ph1">`Main`</ph> 方法所在的文件相同。</source>
          <target state="new">与其他接口实现类似，你可以在另一个文件中实现定义。但是，在本教程中，实现所在的文件与接口定义和 <ph id="ph1">`Main`</ph> 方法所在的文件相同。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>应用指示服务名称和命名空间属性的 <bpt id="p1">[</bpt>ServiceBehaviorAttribute<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.servicebehaviorattribute.aspx)</ept> 属性.</source>
          <target state="new">应用指示服务名称和命名空间属性的 <bpt id="p1">[</bpt>ServiceBehaviorAttribute<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.servicebehaviorattribute.aspx)</ept> 属性.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>在 <ph id="ph1">`EchoService`</ph> 类中，实现 <ph id="ph2">`IEchoContract`</ph> 接口中定义的 <ph id="ph3">`Echo`</ph> 方法。</source>
          <target state="new">在 <ph id="ph1">`EchoService`</ph> 类中，实现 <ph id="ph2">`IEchoContract`</ph> 接口中定义的 <ph id="ph3">`Echo`</ph> 方法。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>单击“生成”，然后单击“生成解决方案”以确认工作的准确性。</source>
          <target state="new">单击“生成”，然后单击“生成解决方案”以确认工作的准确性。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>定义服务主机的配置</source>
          <target state="new">定义服务主机的配置</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>配置文件非常类似于 WCF 配置文件。该配置文件包括服务名称、终结点（即，服务总线公开的、让客户端和主机相互通信的位置）和绑定（用于通信的协议类型）。此处的主要差别在于，配置的服务终结点是指 <bpt id="p1">[</bpt>netTcpRelayBinding<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/azure/microsoft.servicebus.nettcprelaybinding.aspx)</ept>，它不是 .NET Framework 的一部分。<bpt id="p2">[</bpt>NetTcpRelayBinding<ept id="p2">](https://msdn.microsoft.com/zh-cn/library/microsoft.servicebus.nettcprelaybinding.aspx)</ept> 是通过服务总线定义的绑定之一。</source>
          <target state="new">配置文件非常类似于 WCF 配置文件。该配置文件包括服务名称、终结点（即，服务总线公开的、让客户端和主机相互通信的位置）和绑定（用于通信的协议类型）。此处的主要差别在于，配置的服务终结点是指 <bpt id="p1">[</bpt>netTcpRelayBinding<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/azure/microsoft.servicebus.nettcprelaybinding.aspx)</ept>，它不是 .NET Framework 的一部分。<bpt id="p2">[</bpt>NetTcpRelayBinding<ept id="p2">](https://msdn.microsoft.com/zh-cn/library/microsoft.servicebus.nettcprelaybinding.aspx)</ept> 是通过服务总线定义的绑定之一。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>在“解决方案资源管理器”中单击 App.config 文件，该文件当前包含以下 XML 元素：</source>
          <target state="new">在“解决方案资源管理器”中单击 App.config 文件，该文件当前包含以下 XML 元素：</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>在 App.config 文件中添加一个 <ph id="ph1">`&lt;system.serviceModel&gt;`</ph> XML 元素。该元素是一个 WCF 元素，用于定义一个或多个服务。在本示例中，它用于定义服务名称和终结点。</source>
          <target state="new">在 App.config 文件中添加一个 <ph id="ph1">`&lt;system.serviceModel&gt;`</ph> XML 元素。该元素是一个 WCF 元素，用于定义一个或多个服务。在本示例中，它用于定义服务名称和终结点。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>在 <ph id="ph1">`&lt;system.serviceModel&gt;`</ph> 标记中，添加 <ph id="ph2">`&lt;services&gt;`</ph> 元素。可以在单个配置文件中定义多个服务总线应用程序。但是，本教程只定义一个。</source>
          <target state="new">在 <ph id="ph1">`&lt;system.serviceModel&gt;`</ph> 标记中，添加 <ph id="ph2">`&lt;services&gt;`</ph> 元素。可以在单个配置文件中定义多个服务总线应用程序。但是，本教程只定义一个。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>在 <ph id="ph1">`&lt;services&gt;`</ph> 元素中，添加 <ph id="ph2">`&lt;service&gt;`</ph> 元素来定义服务名称。</source>
          <target state="new">在 <ph id="ph1">`&lt;services&gt;`</ph> 元素中，添加 <ph id="ph2">`&lt;service&gt;`</ph> 元素来定义服务名称。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>在 <ph id="ph1">`&lt;service&gt;`</ph> 元素中，定义终结点协定的位置，以及终结点绑定的类型。</source>
          <target state="new">在 <ph id="ph1">`&lt;service&gt;`</ph> 元素中，定义终结点协定的位置，以及终结点绑定的类型。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>终结点用于定义客户端将在何处查找主机应用程序。接下来，本教程将使用此步骤来创建一个通过服务总线完全公开主机的 URI。绑定声明我们正在将 TCP 用作协议，以与服务总线进行通信。</source>
          <target state="new">终结点用于定义客户端将在何处查找主机应用程序。接下来，本教程将使用此步骤来创建一个通过服务总线完全公开主机的 URI。绑定声明我们正在将 TCP 用作协议，以与服务总线进行通信。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>直接在 <ph id="ph1">`&lt;services&gt;`</ph> 元素的后面，添加以下绑定扩展。</source>
          <target state="new">直接在 <ph id="ph1">`&lt;services&gt;`</ph> 元素的后面，添加以下绑定扩展。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>在“生成”菜单中，单击“生成解决方案”以确认工作的准确性。</source>
          <target state="new">在“生成”菜单中，单击“生成解决方案”以确认工作的准确性。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>示例</source>
          <target state="new">示例</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>下面的代码显示服务协定的实现。</source>
          <target state="new">下面的代码显示服务协定的实现。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>以下代码显示了与该服务主机关联的 App.config 文件的基本格式。</source>
          <target state="new">以下代码显示了与该服务主机关联的 App.config 文件的基本格式。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>托管并运行基本 Web 服务以向服务总线注册</source>
          <target state="new">托管并运行基本 Web 服务以向服务总线注册</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>此步骤介绍如何运行基本服务总线服务。</source>
          <target state="new">此步骤介绍如何运行基本服务总线服务。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>创建服务总线凭据</source>
          <target state="new">创建服务总线凭据</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>安装<bpt id="p1">[</bpt>服务总线 NuGet 包<ept id="p1">](https://www.nuget.org/packages/WindowsAzure.ServiceBus)</ept></source>
          <target state="new">安装<bpt id="p1">[</bpt>服务总线 NuGet 包<ept id="p1">](https://www.nuget.org/packages/WindowsAzure.ServiceBus)</ept></target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>在 <ph id="ph1">`Main()`</ph> 中，创建两个变量，将命名空间和从控制台窗口中读取的 SAS 密钥存储在其中。</source>
          <target state="new">在 <ph id="ph1">`Main()`</ph> 中，创建两个变量，将命名空间和从控制台窗口中读取的 SAS 密钥存储在其中。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>随后将使用 SAS 密钥来访问你的服务总线项目。命名空间作为参数传递给 <ph id="ph1">`CreateServiceUri`</ph> 以创建服务 URI。</source>
          <target state="new">随后将使用 SAS 密钥来访问你的服务总线项目。命名空间作为参数传递给 <ph id="ph1">`CreateServiceUri`</ph> 以创建服务 URI。</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">[</bpt>TransportClientEndpointBehavior<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/microsoft.servicebus.transportclientendpointbehavior.aspx)</ept> 对象声明你将使用 SAS 密钥作为凭据类型。在最后一步中添加的代码后直接添加以下代码。</source>
          <target state="new">使用 <bpt id="p1">[</bpt>TransportClientEndpointBehavior<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/microsoft.servicebus.transportclientendpointbehavior.aspx)</ept> 对象声明你将使用 SAS 密钥作为凭据类型。在最后一步中添加的代码后直接添加以下代码。</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>为服务创建基本地址</source>
          <target state="new">为服务创建基本地址</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>在上一个步骤添加的代码后，为服务的基址创建 <ph id="ph1">`Uri`</ph> 实例。此 URI 指定服务总线方案、命名空间，以及服务接口的路径。</source>
          <target state="new">在上一个步骤添加的代码后，为服务的基址创建 <ph id="ph1">`Uri`</ph> 实例。此 URI 指定服务总线方案、命名空间，以及服务接口的路径。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>"sb" 是服务总线方案的缩写，并指示我们正在使用 TCP 作为协议。先前当 <bpt id="p1">[</bpt>NetTcpRelayBinding<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/microsoft.servicebus.nettcprelaybinding.aspx)</ept> 被指定为绑定时，在配置文件中也指示了这一点。</source>
          <target state="new">"sb" 是服务总线方案的缩写，并指示我们正在使用 TCP 作为协议。先前当 <bpt id="p1">[</bpt>NetTcpRelayBinding<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/microsoft.servicebus.nettcprelaybinding.aspx)</ept> 被指定为绑定时，在配置文件中也指示了这一点。</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>对于本教程中，URI 是 <ph id="ph1">`sb://putServiceNamespaceHere.windows.net/EchoService`</ph>。</source>
          <target state="new">对于本教程中，URI 是 <ph id="ph1">`sb://putServiceNamespaceHere.windows.net/EchoService`</ph>。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>创建并配置服务主机</source>
          <target state="new">创建并配置服务主机</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>将连接模式设置为 <ph id="ph1">`AutoDetect`</ph></source>
          <target state="new">将连接模式设置为 <ph id="ph1">`AutoDetect`</ph></target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>连接模式描述服务用于与服务总线进行通信的协议；连接模式为 HTTP 或 TCP。使用默认设置 <ph id="ph1">`AutoDetect`</ph>，服务尝试通过 TCP（如果可用）或 HTTP（如果 TCP 不可用）连接到服务总线。请注意这与服务为客户端通信指定的协议不同。为客户端通信指定的协议由所使用的绑定所决定。例如，服务可以使用指定其终结点（公开在服务总线上）的 <bpt id="p1">[</bpt>BasicHttpRelayBinding<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/microsoft.servicebus.basichttprelaybinding.aspx)</ept> 绑定通过 HTTP 与客户端通信。同一个服务可以指定 <bpt id="p2">**</bpt>ConnectivityMode.AutoDetect<ept id="p2">**</ept>，以便服务通过 TCP 与服务总线通信。</source>
          <target state="new">连接模式描述服务用于与服务总线进行通信的协议；连接模式为 HTTP 或 TCP。使用默认设置 <ph id="ph1">`AutoDetect`</ph>，服务尝试通过 TCP（如果可用）或 HTTP（如果 TCP 不可用）连接到服务总线。请注意这与服务为客户端通信指定的协议不同。为客户端通信指定的协议由所使用的绑定所决定。例如，服务可以使用指定其终结点（公开在服务总线上）的 <bpt id="p1">[</bpt>BasicHttpRelayBinding<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/microsoft.servicebus.basichttprelaybinding.aspx)</ept> 绑定通过 HTTP 与客户端通信。同一个服务可以指定 <bpt id="p2">**</bpt>ConnectivityMode.AutoDetect<ept id="p2">**</ept>，以便服务通过 TCP 与服务总线通信。</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>使用之前在本部分中创建的 URI 创建服务主机。</source>
          <target state="new">使用之前在本部分中创建的 URI 创建服务主机。</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>该服务主机是可实例化服务的 WCF 对象。在这里你将传递想要创建的服务类型（<ph id="ph1">`EchoService`</ph> 类型），以及想要公开服务的地址。</source>
          <target state="new">该服务主机是可实例化服务的 WCF 对象。在这里你将传递想要创建的服务类型（<ph id="ph1">`EchoService`</ph> 类型），以及想要公开服务的地址。</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>在 Program.cs 文件的顶部，添加对 <bpt id="p1">[</bpt>System.ServiceModel.Description<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.description.aspx)</ept> 和 <bpt id="p2">[</bpt>Microsoft.ServiceBus.Description<ept id="p2">](https://msdn.microsoft.com/zh-cn/library/microsoft.servicebus.description.aspx)</ept> 的引用。</source>
          <target state="new">在 Program.cs 文件的顶部，添加对 <bpt id="p1">[</bpt>System.ServiceModel.Description<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.description.aspx)</ept> 和 <bpt id="p2">[</bpt>Microsoft.ServiceBus.Description<ept id="p2">](https://msdn.microsoft.com/zh-cn/library/microsoft.servicebus.description.aspx)</ept> 的引用。</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>返回到 <ph id="ph1">`Main()`</ph>，配置终结点以启用公开访问。</source>
          <target state="new">返回到 <ph id="ph1">`Main()`</ph>，配置终结点以启用公开访问。</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>此步骤告知服务总线可以通过检查项目的服务总线 ATOM 源公开找到你的应用程序。如果你将 <bpt id="p1">**</bpt>DiscoveryType<ept id="p1">**</ept> 设置为 <bpt id="p2">**</bpt>private<ept id="p2">**</ept>，客户端将仍将能够访问该服务。但是，当搜索服务总线命名空间时不会显示该服务。相反，客户端必须事先知道终结点路径。</source>
          <target state="new">此步骤告知服务总线可以通过检查项目的服务总线 ATOM 源公开找到你的应用程序。如果你将 <bpt id="p1">**</bpt>DiscoveryType<ept id="p1">**</ept> 设置为 <bpt id="p2">**</bpt>private<ept id="p2">**</ept>，客户端将仍将能够访问该服务。但是，当搜索服务总线命名空间时不会显示该服务。相反，客户端必须事先知道终结点路径。</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>将服务凭据应用到 App.config 文件中定义的服务终结点：</source>
          <target state="new">将服务凭据应用到 App.config 文件中定义的服务终结点：</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>如在上一步中所述，你可能已经在配置文件中声明多个服务和终结点。如果你已配置，此代码将遍历配置文件并且搜索可能应用了凭据的每个终结点。但是，对于本教程中，配置文件只有一个终结点。</source>
          <target state="new">如在上一步中所述，你可能已经在配置文件中声明多个服务和终结点。如果你已配置，此代码将遍历配置文件并且搜索可能应用了凭据的每个终结点。但是，对于本教程中，配置文件只有一个终结点。</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>打开服务主机</source>
          <target state="new">打开服务主机</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>打开服务。</source>
          <target state="new">打开服务。</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>通知用户该服务正在运行，并说明如何关闭服务。</source>
          <target state="new">通知用户该服务正在运行，并说明如何关闭服务。</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>完成后，关闭服务主机。</source>
          <target state="new">完成后，关闭服务主机。</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>按“F6”生成项目。</source>
          <target state="new">按“F6”生成项目。</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>示例</source>
          <target state="new">示例</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>下例包括本教程中前面步骤中使用的服务协定和实现，并将服务托管在控制台应用程序中。将以下编译到名为 EchoService.exe 的可执行文件。</source>
          <target state="new">下例包括本教程中前面步骤中使用的服务协定和实现，并将服务托管在控制台应用程序中。将以下编译到名为 EchoService.exe 的可执行文件。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>创建服务协定的 WCF 客户端</source>
          <target state="new">创建服务协定的 WCF 客户端</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>下一步将创建基本服务总线客户端，并定义将在后续步骤中实现的服务协定。请注意，许多这样的步骤类似于用于创建服务的步骤：定义协定、编辑 App.config 文件、使用凭据来连接到服务总线等。该过程后面的示例中提供了这些任务所用的代码。</source>
          <target state="new">下一步将创建基本服务总线客户端，并定义将在后续步骤中实现的服务协定。请注意，许多这样的步骤类似于用于创建服务的步骤：定义协定、编辑 App.config 文件、使用凭据来连接到服务总线等。该过程后面的示例中提供了这些任务所用的代码。</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>通过执行以下操作为客户端通在当前 Visual Studio 解决方案中创建一个新的项目：</source>
          <target state="new">通过执行以下操作为客户端通在当前 Visual Studio 解决方案中创建一个新的项目：</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>在解决方案资源管理器中，在包含该服务的同一解决方案中，右键单击当前解决方案（不是项目），然后单击“添加”。然后单击“新建项目”。</source>
          <target state="new">在解决方案资源管理器中，在包含该服务的同一解决方案中，右键单击当前解决方案（不是项目），然后单击“添加”。然后单击“新建项目”。</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>在“添加新项目”对话框中，单击“Visual C#”（如果未显示“Visual C#”，则在“其他语言”下方查看），再选择“控制台应用程序”模板，并将其命名为“EchoClient”。</source>
          <target state="new">在“添加新项目”对话框中，单击“Visual C#”（如果未显示“Visual C#”，则在“其他语言”下方查看），再选择“控制台应用程序”模板，并将其命名为“EchoClient”。</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>单击“确定”。</source>
          <target state="new">单击“确定”。</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>在解决方案资源管理中，双击“EchoClient”项目中的 Program.cs 文件以在编辑器中将其打开。</source>
          <target state="new">在解决方案资源管理中，双击“EchoClient”项目中的 Program.cs 文件以在编辑器中将其打开。</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>将命名空间名称从其默认名称 <ph id="ph1">`EchoClient`</ph> 更改为 <ph id="ph2">`Microsoft.ServiceBus.Samples`</ph>。</source>
          <target state="new">将命名空间名称从其默认名称 <ph id="ph1">`EchoClient`</ph> 更改为 <ph id="ph2">`Microsoft.ServiceBus.Samples`</ph>。</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>在项目中添加对 System.ServiceModel.dll 的引用：</source>
          <target state="new">在项目中添加对 System.ServiceModel.dll 的引用：</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>在解决方案资源管理器中的“EchoClient”项目下，右键单击“引用”。然后单击“添加引用”。</source>
          <target state="new">在解决方案资源管理器中的“EchoClient”项目下，右键单击“引用”。然后单击“添加引用”。</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>因为在本教程的第一步你已添加对此程序集的引用，现在此引用列在“最近”选项卡中。单击“最近”，然后从列表中选择 <bpt id="p1">**</bpt>System.ServiceModel.dll<ept id="p1">**</ept>。然后，单击“确定”。如果你在“最近”选项卡上没有看到“System.ServiceModel.dll”，单击“浏览”选项卡，然后转到 <bpt id="p2">**</bpt>C:\\Windows\\Microsoft.NET\\Framework\\v3.0\\Windows Communication Foundation<ept id="p2">**</ept>。然后从此处选择程序集。</source>
          <target state="new">因为在本教程的第一步你已添加对此程序集的引用，现在此引用列在“最近”选项卡中。单击“最近”，然后从列表中选择 <bpt id="p1">**</bpt>System.ServiceModel.dll<ept id="p1">**</ept>。然后，单击“确定”。如果你在“最近”选项卡上没有看到“System.ServiceModel.dll”，单击“浏览”选项卡，然后转到 <bpt id="p2">**</bpt>C:\\Windows\\Microsoft.NET\\Framework\\v3.0\\Windows Communication Foundation<ept id="p2">**</ept>。然后从此处选择程序集。</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>为 Program.cs 文件中的 <bpt id="p1">[</bpt>System.ServiceModel<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.aspx)</ept> 命名空间添加 <ph id="ph1">`using`</ph> 语句。</source>
          <target state="new">为 Program.cs 文件中的 <bpt id="p1">[</bpt>System.ServiceModel<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/system.servicemodel.aspx)</ept> 命名空间添加 <ph id="ph1">`using`</ph> 语句。</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>重复前面的步骤，将对 Microsoft.ServiceBus.dll 的引用和 <bpt id="p1">[</bpt>Microsoft.ServiceBus<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/microsoft.servicebus.aspx)</ept> 命名空间添加到你的项目中。</source>
          <target state="new">重复前面的步骤，将对 Microsoft.ServiceBus.dll 的引用和 <bpt id="p1">[</bpt>Microsoft.ServiceBus<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/microsoft.servicebus.aspx)</ept> 命名空间添加到你的项目中。</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>如下面的示例中所示，将服务协定定义添加到命名空间。请注意，此定义等同于“服务”项目中所使用的定义。应将此代码添加到 <ph id="ph1">`Microsoft.ServiceBus.Samples`</ph> 命名空间的顶部。</source>
          <target state="new">如下面的示例中所示，将服务协定定义添加到命名空间。请注意，此定义等同于“服务”项目中所使用的定义。应将此代码添加到 <ph id="ph1">`Microsoft.ServiceBus.Samples`</ph> 命名空间的顶部。</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>按“F6”生成客户端。</source>
          <target state="new">按“F6”生成客户端。</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>示例</source>
          <target state="new">示例</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>下面的代码显示了 EchoClient 项目中的 Program.cs 文件的当前状态。</source>
          <target state="new">下面的代码显示了 EchoClient 项目中的 Program.cs 文件的当前状态。</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>配置 WCF 客户端</source>
          <target state="new">配置 WCF 客户端</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>在此步骤中，你可以为之前在本教程中创建的访问服务的基本客户端应用程序创建 App.config 文件。此 App.config 文件用于定义终结点的协定、绑定和名称。该过程后面的示例中提供了这些任务所用的代码。</source>
          <target state="new">在此步骤中，你可以为之前在本教程中创建的访问服务的基本客户端应用程序创建 App.config 文件。此 App.config 文件用于定义终结点的协定、绑定和名称。该过程后面的示例中提供了这些任务所用的代码。</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>在解决方案资源管理器中的客户端项目中，双击“App.config”以打开文件，该文件当前包含以下 XML 元素：</source>
          <target state="new">在解决方案资源管理器中的客户端项目中，双击“App.config”以打开文件，该文件当前包含以下 XML 元素：</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>在 App.config 文件中为 <ph id="ph1">`system.serviceModel`</ph> 添加一个 XML 元素。</source>
          <target state="new">在 App.config 文件中为 <ph id="ph1">`system.serviceModel`</ph> 添加一个 XML 元素。</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>此元素声明你的应用程序使用 WCF 样式终结点。如前面所述，服务总线应用程序的大部分配置都与 WCF 应用程序的配置相同；主要的区别在于配置文件所指向的位置。</source>
          <target state="new">此元素声明你的应用程序使用 WCF 样式终结点。如前面所述，服务总线应用程序的大部分配置都与 WCF 应用程序的配置相同；主要的区别在于配置文件所指向的位置。</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>在 system.serviceModel 元素中，添加 <ph id="ph1">`&lt;client&gt;`</ph> 元素。</source>
          <target state="new">在 system.serviceModel 元素中，添加 <ph id="ph1">`&lt;client&gt;`</ph> 元素。</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>此步骤声明你正在定义一个 WCF 样式的客户端应用程序。</source>
          <target state="new">此步骤声明你正在定义一个 WCF 样式的客户端应用程序。</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>在 <ph id="ph1">`client`</ph> 元素中，定义终结点的名称、协定和绑定类型。</source>
          <target state="new">在 <ph id="ph1">`client`</ph> 元素中，定义终结点的名称、协定和绑定类型。</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>此步骤中定义终结点的名称、服务中定义的协定，以及客户端应用程序使用 TCP 与服务总线进行通信的事实。终结点名称在下一步中用于将此终结点配置与服务 URI 链接。</source>
          <target state="new">此步骤中定义终结点的名称、服务中定义的协定，以及客户端应用程序使用 TCP 与服务总线进行通信的事实。终结点名称在下一步中用于将此终结点配置与服务 URI 链接。</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>直接在</source>
          <target state="new">直接在</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>元素的后面，添加以下绑定扩展。</source>
          <target state="new">元素的后面，添加以下绑定扩展。</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>单击“文件”，然后单击“全部保存”。</source>
          <target state="new">单击“文件”，然后单击“全部保存”。</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>示例</source>
          <target state="new">示例</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>下面的代码显示了 Echo 客户端的 App.config 文件。</source>
          <target state="new">下面的代码显示了 Echo 客户端的 App.config 文件。</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>实现 WCF 客户端以调用服务总线</source>
          <target state="new">实现 WCF 客户端以调用服务总线</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>在此步骤中，你实现了可访问之前在本教程中创建的服务的基本客户端应用程序。与服务相似，该客户端访问服务总线的操作步骤大多数都相同：</source>
          <target state="new">在此步骤中，你实现了可访问之前在本教程中创建的服务的基本客户端应用程序。与服务相似，该客户端访问服务总线的操作步骤大多数都相同：</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>设置连接模式。</source>
          <target state="new">设置连接模式。</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>创建用于定位主机服务的 URI。</source>
          <target state="new">创建用于定位主机服务的 URI。</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>定义安全凭据。</source>
          <target state="new">定义安全凭据。</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>将凭据应用到连接。</source>
          <target state="new">将凭据应用到连接。</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>打开连接。</source>
          <target state="new">打开连接。</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>执行应用程序特定的任务。</source>
          <target state="new">执行应用程序特定的任务。</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>关闭连接。</source>
          <target state="new">关闭连接。</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>但是，主要的区别之一在于，客户端应用程序使用通道连接到服务总线，而服务则使用一个对 <bpt id="p1">**</bpt>ServiceHost<ept id="p1">**</ept> 的调用。该过程后面的示例中提供了这些任务所用的代码。</source>
          <target state="new">但是，主要的区别之一在于，客户端应用程序使用通道连接到服务总线，而服务则使用一个对 <bpt id="p1">**</bpt>ServiceHost<ept id="p1">**</ept> 的调用。该过程后面的示例中提供了这些任务所用的代码。</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>实现客户端应用程序</source>
          <target state="new">实现客户端应用程序</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>将连接模式设置为 <bpt id="p1">**</bpt>AutoDetect<ept id="p1">**</ept>。添加客户端应用程序的 <ph id="ph1">`Main()`</ph> 方法中的以下代码。</source>
          <target state="new">将连接模式设置为 <bpt id="p1">**</bpt>AutoDetect<ept id="p1">**</ept>。添加客户端应用程序的 <ph id="ph1">`Main()`</ph> 方法中的以下代码。</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>定义变量以保存用于服务命名空间的值，以及从控制台读取的 SAS 密钥。</source>
          <target state="new">定义变量以保存用于服务命名空间的值，以及从控制台读取的 SAS 密钥。</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>创建用于定义服务总线项目中托管位置的 URI。</source>
          <target state="new">创建用于定义服务总线项目中托管位置的 URI。</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>创建服务命名空间终结点的凭据对象。</source>
          <target state="new">创建服务命名空间终结点的凭据对象。</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>创建加载在 App.config 文件中所述的配置的通道工厂。</source>
          <target state="new">创建加载在 App.config 文件中所述的配置的通道工厂。</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>通道工厂是创建通道（通过该通道，服务和客户端可以进行通信）的一个 WCF 对象。</source>
          <target state="new">通道工厂是创建通道（通过该通道，服务和客户端可以进行通信）的一个 WCF 对象。</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>应用服务总线凭据</source>
          <target state="new">应用服务总线凭据</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>创建并打开服务通道。</source>
          <target state="new">创建并打开服务通道。</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>编写用于回显的基本用户界面和功能。</source>
          <target state="new">编写用于回显的基本用户界面和功能。</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>请注意，代码使用通道对象的实例作为服务代理。</source>
          <target state="new">请注意，代码使用通道对象的实例作为服务代理。</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>关闭通道，然后关闭工厂。</source>
          <target state="new">关闭通道，然后关闭工厂。</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>启动客户端应用程序</source>
          <target state="new">启动客户端应用程序</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>按“F6”生成解决方案。这将生成客户端项目和你在本教程的上一步创建的服务项目，并为每一个项目创建一个可执行文件。</source>
          <target state="new">按“F6”生成解决方案。这将生成客户端项目和你在本教程的上一步创建的服务项目，并为每一个项目创建一个可执行文件。</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>在运行客户端应用程序之前，请确保服务应用程序正在运行。</source>
          <target state="new">在运行客户端应用程序之前，请确保服务应用程序正在运行。</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>现在，你应该具有 Echo 服务应用程序的名为 EchoService.exe 的可执行文件，该文件位于 \\bin\\Debug\\EchoService.exe（针对调试配置）或 \\bin\\Release\\EchoService.exe（针对发布配置）下的服务项目文件夹中。双击此文件以启动服务应用程序。</source>
          <target state="new">现在，你应该具有 Echo 服务应用程序的名为 EchoService.exe 的可执行文件，该文件位于 \\bin\\Debug\\EchoService.exe（针对调试配置）或 \\bin\\Release\\EchoService.exe（针对发布配置）下的服务项目文件夹中。双击此文件以启动服务应用程序。</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>将打开一个控制台窗口并提示你输入命名空间。在此控制台窗口中，输入服务命名空间并按“Enter”。</source>
          <target state="new">将打开一个控制台窗口并提示你输入命名空间。在此控制台窗口中，输入服务命名空间并按“Enter”。</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>接下来，将提示你提供 SAS 密钥。输入 SAS 密钥并按“ENTER”。</source>
          <target state="new">接下来，将提示你提供 SAS 密钥。输入 SAS 密钥并按“ENTER”。</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>以下是来自控制台窗口的示例输出。请注意，此处提供的值仅限于示例目的。</source>
          <target state="new">以下是来自控制台窗口的示例输出。请注意，此处提供的值仅限于示例目的。</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>启动服务应用程序，并将其正在侦听的地址打印到控制台窗口中，如下面的示例中所示。</source>
          <target state="new">启动服务应用程序，并将其正在侦听的地址打印到控制台窗口中，如下面的示例中所示。</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>运行客户端应用程序。你应该具有 Echo 客户端应用程序的名为 EchoClient.exe 的可执行文件，该文件位于 .\\bin\\Debug\\EchoClient.exe（针对调试配置）或 .\\bin\\Release\\EchoClient.exe（针对发布配置）下的客户端项目中。双击此文件以启动客户端应用程序。</source>
          <target state="new">运行客户端应用程序。你应该具有 Echo 客户端应用程序的名为 EchoClient.exe 的可执行文件，该文件位于 .\\bin\\Debug\\EchoClient.exe（针对调试配置）或 .\\bin\\Release\\EchoClient.exe（针对发布配置）下的客户端项目中。双击此文件以启动客户端应用程序。</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>将打开控制台窗口并提示你输入之前输入的用于服务应用程序的相同信息。请按照前面的步骤，在服务命名空间、颁发者名称和颁发者密钥中输入相同的客户端应用程序值。</source>
          <target state="new">将打开控制台窗口并提示你输入之前输入的用于服务应用程序的相同信息。请按照前面的步骤，在服务命名空间、颁发者名称和颁发者密钥中输入相同的客户端应用程序值。</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>输入这些值后，客户端将打开服务通道并提示你输入如以下控制台输出示例中所示的某些文本。</source>
          <target state="new">输入这些值后，客户端将打开服务通道并提示你输入如以下控制台输出示例中所示的某些文本。</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>输入将发送到服务应用程序的某些文本，并按“Enter”。此文本通过 Echo 服务操作发送到服务并显示在服务控制台窗口中，如下面的示例输出所示。</source>
          <target state="new">输入将发送到服务应用程序的某些文本，并按“Enter”。此文本通过 Echo 服务操作发送到服务并显示在服务控制台窗口中，如下面的示例输出所示。</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>客户端应用程序接收 <ph id="ph1">`Echo`</ph> 操作的返回值（此为原始文本），并将其打印到控制台窗口。以下是来自客户端控制台窗口的示例输出。</source>
          <target state="new">客户端应用程序接收 <ph id="ph1">`Echo`</ph> 操作的返回值（此为原始文本），并将其打印到控制台窗口。以下是来自客户端控制台窗口的示例输出。</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>你可以继续以这种方式将来自客户端的短信发送至服务。完成后，在客户端和服务控制台窗口中按 Enter 以结束这两个应用程序。</source>
          <target state="new">你可以继续以这种方式将来自客户端的短信发送至服务。完成后，在客户端和服务控制台窗口中按 Enter 以结束这两个应用程序。</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>示例</source>
          <target state="new">示例</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>下面的示例演示了如何创建客户端应用程序、如何调用服务操作以及如何在完成操作调用后关闭客户端。</source>
          <target state="new">下面的示例演示了如何创建客户端应用程序、如何调用服务操作以及如何在完成操作调用后关闭客户端。</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>请确保在启动客户端之前服务正在运行。</source>
          <target state="new">请确保在启动客户端之前服务正在运行。</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>本教程介绍了如何使用服务总线“中继”功能，构建服务总线客户端应用程序和服务。有关使用服务总线<bpt id="p1">[</bpt>中转消息传送<ept id="p1">](/documentation/articles/service-bus-messaging-overview/#Brokered-messaging)</ept>的类似教程，请参阅<bpt id="p2">[</bpt>服务总线中转消息传送 .NET 教程<ept id="p2">](/documentation/articles/service-bus-brokered-tutorial-dotnet)</ept>。</source>
          <target state="new">本教程介绍了如何使用服务总线“中继”功能，构建服务总线客户端应用程序和服务。有关使用服务总线<bpt id="p1">[</bpt>中转消息传送<ept id="p1">](/documentation/articles/service-bus-messaging-overview/#Brokered-messaging)</ept>的类似教程，请参阅<bpt id="p2">[</bpt>服务总线中转消息传送 .NET 教程<ept id="p2">](/documentation/articles/service-bus-brokered-tutorial-dotnet)</ept>。</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>若要了解有关服务总线的详细信息，请参阅以下主题。</source>
          <target state="new">若要了解有关服务总线的详细信息，请参阅以下主题。</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>服务总线消息传送概述</source>
          <target state="new">服务总线消息传送概述</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>服务总线基础知识</source>
          <target state="new">服务总线基础知识</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>服务总线体系结构</source>
          <target state="new">服务总线体系结构</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>[Azure 经典门户]: http://manage.windowsazure.cn</source>
          <target state="new">[Azure 经典门户]: http://manage.windowsazure.cn</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>