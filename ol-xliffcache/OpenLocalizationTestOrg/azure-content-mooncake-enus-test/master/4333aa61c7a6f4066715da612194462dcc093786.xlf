<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4333aa61c7a6f4066715da612194462dcc093786</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>哈希分布及其对 SQL 数据仓库中查询性能的影响 | Azure</source>
          <target state="new">哈希分布及其对 SQL 数据仓库中查询性能的影响 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>在开发解决方案之前，了解哈希分布表及其如何影响 Azure SQL 数据仓库中的查询性能。</source>
          <target state="new">在开发解决方案之前，了解哈希分布表及其如何影响 Azure SQL 数据仓库中的查询性能。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>哈希分布及其对 SQL 数据仓库中查询性能的影响</source>
          <target state="new">哈希分布及其对 SQL 数据仓库中查询性能的影响</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>做出明智的哈希分布决策是改善查询性能最重要的方式之一。</source>
          <target state="new">做出明智的哈希分布决策是改善查询性能最重要的方式之一。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>事实上，有三个主要因素：</source>
          <target state="new">事实上，有三个主要因素：</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>最小化数据移动</source>
          <target state="new">最小化数据移动</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>避免数据偏斜</source>
          <target state="new">避免数据偏斜</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>提供平衡的执行</source>
          <target state="new">提供平衡的执行</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>最小化数据移动</source>
          <target state="new">最小化数据移动</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>将表联接在一起或在表上执行聚合时，最常发生的情况就是数据移动。共享密钥中的哈希分布表是最小化此移动的最有效方法之一。</source>
          <target state="new">将表联接在一起或在表上执行聚合时，最常发生的情况就是数据移动。共享密钥中的哈希分布表是最小化此移动的最有效方法之一。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>但是，若要让哈希分布对最小化移动发挥效果，必须符合以下所有条件：</source>
          <target state="new">但是，若要让哈希分布对最小化移动发挥效果，必须符合以下所有条件：</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>这两个表需为哈希分布式，并在共享的分布密钥上联接</source>
          <target state="new">这两个表需为哈希分布式，并在共享的分布密钥上联接</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>这两个列的数据类型需要匹配</source>
          <target state="new">这两个列的数据类型需要匹配</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>联接的列需为等值联接（即，左表列中的值需要等于右表列中的值）</source>
          <target state="new">联接的列需为等值联接（即，左表列中的值需要等于右表列中的值）</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>联接<bpt id="p1">**</bpt>不是<ept id="p1">**</ept> <ph id="ph1">`CROSS JOIN`</ph></source>
          <target state="new">联接<bpt id="p1">**</bpt>不是<ept id="p1">**</ept> <ph id="ph1">`CROSS JOIN`</ph></target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>在 <ph id="ph2">`JOIN`</ph>、<ph id="ph3">`GROUP BY`</ph>、<ph id="ph4">`DISTINCT`</ph> 和 <ph id="ph5">`HAVING`</ph> 子句中使用的列都生成适当的哈希列候选项。另一方面，用于 <ph id="ph6">`WHERE`</ph> 子句的列<bpt id="p1">**</bpt>不会<ept id="p1">**</ept>生成适当的哈希列候选项。请参阅以下与平衡执行相关的部分。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>在 <ph id="ph2">`JOIN`</ph>、<ph id="ph3">`GROUP BY`</ph>、<ph id="ph4">`DISTINCT`</ph> 和 <ph id="ph5">`HAVING`</ph> 子句中使用的列都生成适当的哈希列候选项。另一方面，用于 <ph id="ph6">`WHERE`</ph> 子句的列<bpt id="p1">**</bpt>不会<ept id="p1">**</ept>生成适当的哈希列候选项。请参阅以下与平衡执行相关的部分。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>当查询语法（<ph id="ph1">`COUNT DISTINCT`</ph> 和 <ph id="ph2">`OVER`</ph> 两个子句都是绝佳示例）和不包含哈希分布键的列配合使用时，也可能发生数据移动。</source>
          <target state="new">当查询语法（<ph id="ph1">`COUNT DISTINCT`</ph> 和 <ph id="ph2">`OVER`</ph> 两个子句都是绝佳示例）和不包含哈希分布键的列配合使用时，也可能发生数据移动。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>轮循机制表通常产生数据移动。表中的数据已经以不具确定性的方式分配，因此必须在大多数查询完成之前移动数据。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>轮循机制表通常产生数据移动。表中的数据已经以不具确定性的方式分配，因此必须在大多数查询完成之前移动数据。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>避免数据偏斜</source>
          <target state="new">避免数据偏斜</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>为了使哈希分布有效，选择的列必须展示以下属性：</source>
          <target state="new">为了使哈希分布有效，选择的列必须展示以下属性：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>该列包含大量的相异值。</source>
          <target state="new">该列包含大量的相异值。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>该列不会受到<bpt id="p1">**</bpt>数据偏斜<ept id="p1">**</ept>的影响。</source>
          <target state="new">该列不会受到<bpt id="p1">**</bpt>数据偏斜<ept id="p1">**</ept>的影响。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>每个相异值将分配到某个分布区。因此，数据需要合理数目的相异值，以确保生成足够的唯一哈希值。否则，我们可能会获得质量不佳的哈希。例如，如果分布区数目超过相异值的数目，某些分布区将保留空白。这会降低性能。</source>
          <target state="new">每个相异值将分配到某个分布区。因此，数据需要合理数目的相异值，以确保生成足够的唯一哈希值。否则，我们可能会获得质量不佳的哈希。例如，如果分布区数目超过相异值的数目，某些分布区将保留空白。这会降低性能。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>同样，如果哈希列的所有行都包含相同值，则数据就会<bpt id="p1">**</bpt>偏斜<ept id="p1">**</ept>。在此极端情况下，只能创建一个哈希值，导致所有行最后都在单个分布区内。在理想情况下，哈希列中的每个相异值都有相同数目的行。</source>
          <target state="new">同样，如果哈希列的所有行都包含相同值，则数据就会<bpt id="p1">**</bpt>偏斜<ept id="p1">**</ept>。在此极端情况下，只能创建一个哈希值，导致所有行最后都在单个分布区内。在理想情况下，哈希列中的每个相异值都有相同数目的行。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>轮循机制表不会表现出偏斜的迹象。这是因为数据跨分布区平均存储。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>轮循机制表不会表现出偏斜的迹象。这是因为数据跨分布区平均存储。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>提供平衡的执行</source>
          <target state="new">提供平衡的执行</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>当每个分布区有相同数量的工作要执行时，就会实现平衡的执行。大规模并行处理 (MPP) 是一种团队游戏；在任何人被声明为赢家之前，每个人都必须取得胜利。如果每个分布区有相同数量的工作（也就是要处理的数据），则所有查询都会在大致相同的时间完成。这就是所谓的平衡执行。</source>
          <target state="new">当每个分布区有相同数量的工作要执行时，就会实现平衡的执行。大规模并行处理 (MPP) 是一种团队游戏；在任何人被声明为赢家之前，每个人都必须取得胜利。如果每个分布区有相同数量的工作（也就是要处理的数据），则所有查询都会在大致相同的时间完成。这就是所谓的平衡执行。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>我们知道，数据偏斜可能影响平衡的执行。但是，也因此可以选择哈希分布键。如果已选择出现在查询的 <ph id="ph1">`WHERE`</ph> 子句中的列，则查询很有可能不平衡。</source>
          <target state="new">我们知道，数据偏斜可能影响平衡的执行。但是，也因此可以选择哈希分布键。如果已选择出现在查询的 <ph id="ph1">`WHERE`</ph> 子句中的列，则查询很有可能不平衡。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph><ph id="ph2">`WHERE`</ph> 子句通常有助于识别最适合用于分区的列。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph><ph id="ph2">`WHERE`</ph> 子句通常有助于识别最适合用于分区的列。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>出现在 <ph id="ph1">`WHERE`</ph> 子句中的列的代表性示例是日期字段。日期字段是分区列极好、但哈希分布列通常极差的典型示例。一般而言，数据仓库查询将维持一段指定的时间，例如日、周或月。基于日期的哈希分布可能真正限制了我们的缩放性并损害了性能。例如，如果指定的日期范围是一周（即 7 天），则哈希的最大数目就是 7 - 每天一个。这意味着只有 7 个分布区包含数据。其余的分布区没有任何数据。这会导致不平衡的查询执行，因为只有 7 个分布区在处理数据。</source>
          <target state="new">出现在 <ph id="ph1">`WHERE`</ph> 子句中的列的代表性示例是日期字段。日期字段是分区列极好、但哈希分布列通常极差的典型示例。一般而言，数据仓库查询将维持一段指定的时间，例如日、周或月。基于日期的哈希分布可能真正限制了我们的缩放性并损害了性能。例如，如果指定的日期范围是一周（即 7 天），则哈希的最大数目就是 7 - 每天一个。这意味着只有 7 个分布区包含数据。其余的分布区没有任何数据。这会导致不平衡的查询执行，因为只有 7 个分布区在处理数据。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>轮循机制表通常提供平衡的执行。这是因为数据跨分布区平均存储。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>轮循机制表通常提供平衡的执行。这是因为数据跨分布区平均存储。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>建议</source>
          <target state="new">建议</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>若要最大化性能和整体查询吞吐量，请尽量确保哈希分布表遵循以下模式：</source>
          <target state="new">若要最大化性能和整体查询吞吐量，请尽量确保哈希分布表遵循以下模式：</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>哈希分布键：</source>
          <target state="new">哈希分布键：</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>在查询的 <ph id="ph1">`JOIN`</ph>、<ph id="ph2">`GROUP BY`</ph>、<ph id="ph3">`DISTINCT`</ph> 或 <ph id="ph4">`HAVING`</ph> 子句中使用。</source>
          <target state="new">在查询的 <ph id="ph1">`JOIN`</ph>、<ph id="ph2">`GROUP BY`</ph>、<ph id="ph3">`DISTINCT`</ph> 或 <ph id="ph4">`HAVING`</ph> 子句中使用。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>不在 <ph id="ph1">`WHERE`</ph> 子句中使用</source>
          <target state="new">不在 <ph id="ph1">`WHERE`</ph> 子句中使用</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>至少有 1000 个不同的值。</source>
          <target state="new">至少有 1000 个不同的值。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>不会将大量的不成比例的行哈希到少量的分布区。</source>
          <target state="new">不会将大量的不成比例的行哈希到少量的分布区。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>定义为 NOT NULL。NULL 行将聚集在单个分布区中。</source>
          <target state="new">定义为 NOT NULL。NULL 行将聚集在单个分布区中。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>摘要</source>
          <target state="new">摘要</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>哈希分布可总结如下：</source>
          <target state="new">哈希分布可总结如下：</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>哈希函数具确定性。相同的值始终分配到同一个分布区。</source>
          <target state="new">哈希函数具确定性。相同的值始终分配到同一个分布区。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>一个列用作分布列。哈希函数使用指定的列来计算分布区的行分配。</source>
          <target state="new">一个列用作分布列。哈希函数使用指定的列来计算分布区的行分配。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>哈希函数基于列的类型，而不是本身的值</source>
          <target state="new">哈希函数基于列的类型，而不是本身的值</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>哈希分布表有时可能造成偏斜的表</source>
          <target state="new">哈希分布表有时可能造成偏斜的表</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>解析查询时，哈希分布表通常需要较少的数据，因此可以改善大型事实表的查询性能。</source>
          <target state="new">解析查询时，哈希分布表通常需要较少的数据，因此可以改善大型事实表的查询性能。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>遵循有关选择哈希分布列的建议，以增强查询吞吐量。</source>
          <target state="new">遵循有关选择哈希分布列的建议，以增强查询吞吐量。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>在 SQL 数据仓库中，数据类型一致性相当重要！ 请确保现有架构一致使用相同类型的列。这对分布键尤其重要。如果未同步分布键数据类型，且表已联接，将会发生不必要的数据移动。如果表很大，成本可能很高，并且导致吞吐量和性能降低。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>在 SQL 数据仓库中，数据类型一致性相当重要！ 请确保现有架构一致使用相同类型的列。这对分布键尤其重要。如果未同步分布键数据类型，且表已联接，将会发生不必要的数据移动。如果表很大，成本可能很高，并且导致吞吐量和性能降低。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>有关更多开发技巧，请参阅<bpt id="p1">[</bpt>开发概述<ept id="p1">][]</ept>。</source>
          <target state="new">有关更多开发技巧，请参阅<bpt id="p1">[</bpt>开发概述<ept id="p1">][]</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>