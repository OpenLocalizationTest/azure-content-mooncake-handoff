<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">815edb3023a148b29a4f4f337a7c37fdbb3320ab</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何使用表存储 (C++) | Azure</source>
          <target state="new">如何使用表存储 (C++) | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何在 Azure 中使用表存储服务。示例用 C++ 编写。</source>
          <target state="new">了解如何在 Azure 中使用表存储服务。示例用 C++ 编写。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何通过 C++ 使用表存储</source>
          <target state="new">如何通过 C++ 使用表存储</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本指南将演示如何使用 Azure 表存储服务执行常见方案。示例用 C++ 编写，并使用<bpt id="p1">[</bpt>适用于 C++ 的 Azure 存储空间客户端库<ept id="p1">](https://github.com/Azure/azure-storage-cpp/blob/v1.0.0/README.md)</ept>。涉及的方案包括<bpt id="p2">**</bpt>创建和删除表<ept id="p2">**</ept>，以及<bpt id="p3">**</bpt>使用表实体<ept id="p3">**</ept>。</source>
          <target state="new">本指南将演示如何使用 Azure 表存储服务执行常见方案。示例用 C++ 编写，并使用<bpt id="p1">[</bpt>适用于 C++ 的 Azure 存储空间客户端库<ept id="p1">](https://github.com/Azure/azure-storage-cpp/blob/v1.0.0/README.md)</ept>。涉及的方案包括<bpt id="p2">**</bpt>创建和删除表<ept id="p2">**</ept>，以及<bpt id="p3">**</bpt>使用表实体<ept id="p3">**</ept>。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 本指南主要面向适用于 C++ 的 Azure 存储空间客户端库 1.0.0 版及更高版本。建议的版本是存储空间客户端库 1.0.0，它可以通过 <bpt id="p1">[</bpt>NuGet<ept id="p1">](http://www.nuget.org/packages/wastorage)</ept> 或 <bpt id="p2">[</bpt>GitHub<ept id="p2">](https://github.com/)</ept> 获得。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 本指南主要面向适用于 C++ 的 Azure 存储空间客户端库 1.0.0 版及更高版本。建议的版本是存储空间客户端库 1.0.0，它可以通过 <bpt id="p1">[</bpt>NuGet<ept id="p1">](http://www.nuget.org/packages/wastorage)</ept> 或 <bpt id="p2">[</bpt>GitHub<ept id="p2">](https://github.com/)</ept> 获得。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>创建 C++ 应用程序</source>
          <target state="new">创建 C++ 应用程序</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>在本指南中，你将使用存储功能，这些功能可以在 C++ 应用程序中运行。为此，你将需要安装适用于 C++ 的 Azure 存储客户端库，并在你的 Azure 订阅中创建 Azure 存储帐户。</source>
          <target state="new">在本指南中，你将使用存储功能，这些功能可以在 C++ 应用程序中运行。为此，你将需要安装适用于 C++ 的 Azure 存储客户端库，并在你的 Azure 订阅中创建 Azure 存储帐户。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>若要安装适用于 C++ 的 Azure 存储客户端库，你可以使用以下方法：</source>
          <target state="new">若要安装适用于 C++ 的 Azure 存储客户端库，你可以使用以下方法：</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Linux：<ept id="p1">**</ept>按照<bpt id="p2">[</bpt>适用于 C++ 的 Azure 存储空间客户端库自述文件<ept id="p2">](https://github.com/Azure/azure-storage-cpp/blob/master/README.md)</ept>页中提供的说明进行操作。</source>
          <target state="new"><bpt id="p1">**</bpt>Linux：<ept id="p1">**</ept>按照<bpt id="p2">[</bpt>适用于 C++ 的 Azure 存储空间客户端库自述文件<ept id="p2">](https://github.com/Azure/azure-storage-cpp/blob/master/README.md)</ept>页中提供的说明进行操作。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Windows：<ept id="p1">**</ept>在 Visual Studio 主菜单中，单击“工具”-&gt;“NuGet 程序包管理器”-&gt;“程序包管理器控制台”。在 <bpt id="p2">[</bpt>NuGet 包管理器控制台<ept id="p2">](http://docs.nuget.org/docs/start-here/using-the-package-manager-console)</ept>窗口中键入以下命令，然后按 Enter。</source>
          <target state="new"><bpt id="p1">**</bpt>Windows：<ept id="p1">**</ept>在 Visual Studio 主菜单中，单击“工具”-&gt;“NuGet 程序包管理器”-&gt;“程序包管理器控制台”。在 <bpt id="p2">[</bpt>NuGet 包管理器控制台<ept id="p2">](http://docs.nuget.org/docs/start-here/using-the-package-manager-console)</ept>窗口中键入以下命令，然后按 Enter。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>配置应用程序以访问表存储</source>
          <target state="new">配置应用程序以访问表存储</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>将以下 include 语句添加到要在其中使用 Azure 存储 API 访问表的 C++ 文件的顶部：</source>
          <target state="new">将以下 include 语句添加到要在其中使用 Azure 存储 API 访问表的 C++ 文件的顶部：</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>设置 Azure 存储连接字符串</source>
          <target state="new">设置 Azure 存储连接字符串</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Azure 存储客户端使用存储连接字符串来存储用于访问数据管理服务的终结点和凭据。运行客户端应用程序时，必须提供以下格式的存储连接字符串。使用<bpt id="p1">[</bpt>管理门户<ept id="p1">](https://manage.windowsazure.cn)</ept>中列出的存储帐户的存储帐户名称和存储访问密钥作为 <bpt id="p2">*</bpt>AccountName<ept id="p2">*</ept> 和 <bpt id="p3">*</bpt>AccountKey<ept id="p3">*</ept> 值。有关存储帐户和访问密钥的信息，请参阅<bpt id="p4">[</bpt>关于 Azure 存储帐户<ept id="p4">](/documentation/articles/storage-create-storage-account)</ept>。此示例演示如何声明一个静态字段以保存连接字符串：</source>
          <target state="new">Azure 存储客户端使用存储连接字符串来存储用于访问数据管理服务的终结点和凭据。运行客户端应用程序时，必须提供以下格式的存储连接字符串。使用<bpt id="p1">[</bpt>管理门户<ept id="p1">](https://manage.windowsazure.cn)</ept>中列出的存储帐户的存储帐户名称和存储访问密钥作为 <bpt id="p2">*</bpt>AccountName<ept id="p2">*</ept> 和 <bpt id="p3">*</bpt>AccountKey<ept id="p3">*</ept> 值。有关存储帐户和访问密钥的信息，请参阅<bpt id="p4">[</bpt>关于 Azure 存储帐户<ept id="p4">](/documentation/articles/storage-create-storage-account)</ept>。此示例演示如何声明一个静态字段以保存连接字符串：</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>若要在本地基于 Windows 的计算机中测试你的应用程序，可以使用随 <bpt id="p1">[</bpt>Azure SDK<ept id="p1">](/downloads/)</ept> 一起安装的 Azure <bpt id="p2">[</bpt>存储模拟器<ept id="p2">](/documentation/articles/storage-use-emulator)</ept>。存储模拟器是一种用于模拟本地开发计算机上提供的 Azure Blob、队列和表服务的实用程序。以下示例演示如何声明一个静态字段以将连接字符串保存到你的本地存储模拟器：</source>
          <target state="new">若要在本地基于 Windows 的计算机中测试你的应用程序，可以使用随 <bpt id="p1">[</bpt>Azure SDK<ept id="p1">](/downloads/)</ept> 一起安装的 Azure <bpt id="p2">[</bpt>存储模拟器<ept id="p2">](/documentation/articles/storage-use-emulator)</ept>。存储模拟器是一种用于模拟本地开发计算机上提供的 Azure Blob、队列和表服务的实用程序。以下示例演示如何声明一个静态字段以将连接字符串保存到你的本地存储模拟器：</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>若要启动 Azure 存储模拟器，请单击“开始”按钮或按 Windows 键。开始键入“Azure 存储模拟器”，然后从应用程序列表中选择“Azure 存储模拟器”。</source>
          <target state="new">若要启动 Azure 存储模拟器，请单击“开始”按钮或按 Windows 键。开始键入“Azure 存储模拟器”，然后从应用程序列表中选择“Azure 存储模拟器”。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>下面的示例假定你使用了这两个方法之一来获取存储连接字符串。</source>
          <target state="new">下面的示例假定你使用了这两个方法之一来获取存储连接字符串。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>检索你的连接字符串</source>
          <target state="new">检索你的连接字符串</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>可以使用 <bpt id="p1">**</bpt>cloud_storage_account<ept id="p1">**</ept> 类来表示您的存储帐户信息。若要从存储连接字符串中检索你的存储帐户信息，你可以使用 parse 方法。</source>
          <target state="new">可以使用 <bpt id="p1">**</bpt>cloud_storage_account<ept id="p1">**</ept> 类来表示您的存储帐户信息。若要从存储连接字符串中检索你的存储帐户信息，你可以使用 parse 方法。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>接下来，获取对 <bpt id="p1">**</bpt>cloud_table_client<ept id="p1">**</ept> 类的引用，因为使用它可以获取表存储服务中存储的表和实体的引用对象。以下代码使用我们在上面检索到的存储帐户对象创建 <bpt id="p2">**</bpt>cloud_table_client<ept id="p2">**</ept> 对象：</source>
          <target state="new">接下来，获取对 <bpt id="p1">**</bpt>cloud_table_client<ept id="p1">**</ept> 类的引用，因为使用它可以获取表存储服务中存储的表和实体的引用对象。以下代码使用我们在上面检索到的存储帐户对象创建 <bpt id="p2">**</bpt>cloud_table_client<ept id="p2">**</ept> 对象：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>创建表</source>
          <target state="new">创建表</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>cloud_table_client<ept id="p1">**</ept> 对象，可以获得表和实体的引用对象。以下代码将创建 <bpt id="p2">**</bpt>cloud_table_client<ept id="p2">**</ept> 对象并使用它创建新表。</source>
          <target state="new">使用 <bpt id="p1">**</bpt>cloud_table_client<ept id="p1">**</ept> 对象，可以获得表和实体的引用对象。以下代码将创建 <bpt id="p2">**</bpt>cloud_table_client<ept id="p2">**</ept> 对象并使用它创建新表。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>将实体添加到表</source>
          <target state="new">将实体添加到表</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>若要将实体添加到表，请创建一个新的 <bpt id="p1">**</bpt>table_entity<ept id="p1">**</ept> 对象并将其传递到 <bpt id="p2">**</bpt>table_operation::insert_entity<ept id="p2">**</ept>。以下代码使用客户的名字作为行键，并使用姓氏作为分区键。实体的分区键和行键共同唯一地标识表中的实体。查询分区键相同的实体的速度快于查询分区键不同的实体的速度，但使用不同的分区键可实现更高的并行操作可伸缩性。有关详细信息，请参阅 <bpt id="p3">[</bpt>Azure 存储性能和可伸缩性清单<ept id="p3">](/documentation/articles/storage-performance-checklist)</ept>。</source>
          <target state="new">若要将实体添加到表，请创建一个新的 <bpt id="p1">**</bpt>table_entity<ept id="p1">**</ept> 对象并将其传递到 <bpt id="p2">**</bpt>table_operation::insert_entity<ept id="p2">**</ept>。以下代码使用客户的名字作为行键，并使用姓氏作为分区键。实体的分区键和行键共同唯一地标识表中的实体。查询分区键相同的实体的速度快于查询分区键不同的实体的速度，但使用不同的分区键可实现更高的并行操作可伸缩性。有关详细信息，请参阅 <bpt id="p3">[</bpt>Azure 存储性能和可伸缩性清单<ept id="p3">](/documentation/articles/storage-performance-checklist)</ept>。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>以下代码创建了包含要存储的某些客户数据的 <bpt id="p1">**</bpt>table_entity<ept id="p1">**</ept> 类的新实例。接下来，该代码调用 <bpt id="p2">**</bpt>table_operation::insert_entity<ept id="p2">**</ept> 以创建一个 <bpt id="p3">**</bpt>table_operation<ept id="p3">**</ept> 对象，以便将实体插入表中，并将新的表实体与之关联。最后，该代码调用 <bpt id="p4">**</bpt>cloud_table<ept id="p4">**</ept> 对象的 execute 方法。并且新的 <bpt id="p5">**</bpt>table_operation<ept id="p5">**</ept> 向表服务发送请求，以将新的客户实体插入"people"表中。</source>
          <target state="new">以下代码创建了包含要存储的某些客户数据的 <bpt id="p1">**</bpt>table_entity<ept id="p1">**</ept> 类的新实例。接下来，该代码调用 <bpt id="p2">**</bpt>table_operation::insert_entity<ept id="p2">**</ept> 以创建一个 <bpt id="p3">**</bpt>table_operation<ept id="p3">**</ept> 对象，以便将实体插入表中，并将新的表实体与之关联。最后，该代码调用 <bpt id="p4">**</bpt>cloud_table<ept id="p4">**</ept> 对象的 execute 方法。并且新的 <bpt id="p5">**</bpt>table_operation<ept id="p5">**</ept> 向表服务发送请求，以将新的客户实体插入"people"表中。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>插入一批实体</source>
          <target state="new">插入一批实体</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>你可以通过一次写入操作将一批实体插入到表服务。以下代码创建一个 <bpt id="p1">**</bpt>table_batch_operation<ept id="p1">**</ept> 对象，然后向其中添加三个插入操作。每个插入操作的添加方法如下：创建一个新的实体对象，设置它的值，然后对 <bpt id="p2">**</bpt>table_batch_operation<ept id="p2">**</ept> 对象调用 insert 方法以将实体与新的插入操作相关联。然后调用 <bpt id="p3">**</bpt>cloud_table.execute<ept id="p3">**</ept> 以执行此操作。</source>
          <target state="new">你可以通过一次写入操作将一批实体插入到表服务。以下代码创建一个 <bpt id="p1">**</bpt>table_batch_operation<ept id="p1">**</ept> 对象，然后向其中添加三个插入操作。每个插入操作的添加方法如下：创建一个新的实体对象，设置它的值，然后对 <bpt id="p2">**</bpt>table_batch_operation<ept id="p2">**</ept> 对象调用 insert 方法以将实体与新的插入操作相关联。然后调用 <bpt id="p3">**</bpt>cloud_table.execute<ept id="p3">**</ept> 以执行此操作。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>批处理操作的注意事项如下：</source>
          <target state="new">批处理操作的注意事项如下：</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>您在单次批处理操作中最多可以执行 100 个插入、删除、合并、替换、插入或合并以及插入或替换操作（可以是这些操作的任意组合）。</source>
          <target state="new">您在单次批处理操作中最多可以执行 100 个插入、删除、合并、替换、插入或合并以及插入或替换操作（可以是这些操作的任意组合）。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>批处理操作也可以包含检索操作，但前提是检索操作是批处理中仅有的操作。</source>
          <target state="new">批处理操作也可以包含检索操作，但前提是检索操作是批处理中仅有的操作。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>单次批处理操作中的所有实体都必须具有相同的分区键。</source>
          <target state="new">单次批处理操作中的所有实体都必须具有相同的分区键。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>批处理操作的数据负载限制为 4MB。</source>
          <target state="new">批处理操作的数据负载限制为 4MB。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>检索分区中的所有实体</source>
          <target state="new">检索分区中的所有实体</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>若要查询表以获取分区中的所有实体，请使用 <bpt id="p1">**</bpt>table_query<ept id="p1">**</ept> 对象。以下代码示例指定了一个筛选器，以筛选分区键为  'Smith' 的实体。此示例会将查询结果中每个实体的字段输出到控制台。</source>
          <target state="new">若要查询表以获取分区中的所有实体，请使用 <bpt id="p1">**</bpt>table_query<ept id="p1">**</ept> 对象。以下代码示例指定了一个筛选器，以筛选分区键为  'Smith' 的实体。此示例会将查询结果中每个实体的字段输出到控制台。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>此示例中的查询将检索出与筛选条件匹配的所有实体。如果你有大型表并需要经常下载表实体，我们建议你改为将数据存储在 Azure 存储 Blob 中。</source>
          <target state="new">此示例中的查询将检索出与筛选条件匹配的所有实体。如果你有大型表并需要经常下载表实体，我们建议你改为将数据存储在 Azure 存储 Blob 中。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>检索分区中的一部分实体</source>
          <target state="new">检索分区中的一部分实体</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>如果不想查询分区中的所有实体，则可以通过结合使用分区键筛选器与行键筛选器来指定一个范围。以下代码示例使用两个筛选器来获取分区“Smith”中的、行键（名字）以字母“E”前面的字母开头的所有实体，然后输出查询结果。</source>
          <target state="new">如果不想查询分区中的所有实体，则可以通过结合使用分区键筛选器与行键筛选器来指定一个范围。以下代码示例使用两个筛选器来获取分区“Smith”中的、行键（名字）以字母“E”前面的字母开头的所有实体，然后输出查询结果。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>检索单个实体</source>
          <target state="new">检索单个实体</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>你可以编写查询以检索单个特定实体。以下代码使用 <bpt id="p1">**</bpt>table_operation::retrive_entity<ept id="p1">**</ept> 来指定客户  'Jeff Smith'。此方法只返回一个实体，而不是一个集合，并且返回的值在 <bpt id="p2">**</bpt>table_result<ept id="p2">**</ept> 中。在查询中指定分区键和行键是从表服务中检索单个实体的最快方法。</source>
          <target state="new">你可以编写查询以检索单个特定实体。以下代码使用 <bpt id="p1">**</bpt>table_operation::retrive_entity<ept id="p1">**</ept> 来指定客户  'Jeff Smith'。此方法只返回一个实体，而不是一个集合，并且返回的值在 <bpt id="p2">**</bpt>table_result<ept id="p2">**</ept> 中。在查询中指定分区键和行键是从表服务中检索单个实体的最快方法。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>替换实体</source>
          <target state="new">替换实体</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>若要替换实体，请从表服务中检索它，修改实体对象，然后将更改保存回表服务。以下代码更改现有客户的电话号码和电子邮件地址。此代码不是调用 <bpt id="p1">**</bpt>table_operation::insert_entity<ept id="p1">**</ept>，而是使用 <bpt id="p2">**</bpt>table_operation::replace_entity<ept id="p2">**</ept>。这将导致在服务器上完全替换该实体，除非服务器上的该实体自检索到它以后发生更改，在此情况下，该操作将失败。操作失败将防止您的应用程序无意中覆盖应用程序的其他组件在检索与更新之间所做的更改。正确处理此失败的方法是再次检索实体，进行更改（如果仍有效），然后执行另一个 <bpt id="p3">**</bpt>table_operation::replace_entity<ept id="p3">**</ept> 操作。下一节将为你演示如何重写此行为。</source>
          <target state="new">若要替换实体，请从表服务中检索它，修改实体对象，然后将更改保存回表服务。以下代码更改现有客户的电话号码和电子邮件地址。此代码不是调用 <bpt id="p1">**</bpt>table_operation::insert_entity<ept id="p1">**</ept>，而是使用 <bpt id="p2">**</bpt>table_operation::replace_entity<ept id="p2">**</ept>。这将导致在服务器上完全替换该实体，除非服务器上的该实体自检索到它以后发生更改，在此情况下，该操作将失败。操作失败将防止您的应用程序无意中覆盖应用程序的其他组件在检索与更新之间所做的更改。正确处理此失败的方法是再次检索实体，进行更改（如果仍有效），然后执行另一个 <bpt id="p3">**</bpt>table_operation::replace_entity<ept id="p3">**</ept> 操作。下一节将为你演示如何重写此行为。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>插入或替换实体</source>
          <target state="new">插入或替换实体</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>如果该实体自从服务器中检索到它以后发生更改，则 <bpt id="p1">**</bpt>table_operation::replace_entity<ept id="p1">**</ept> 操作将失败。此外，你必须首先从服务器中检索该实体，<bpt id="p2">**</bpt>table_operation::replace_entity<ept id="p2">**</ept> 才能成功。但是，有时您不知道服务器上是否存在该实体以及存储在其中的当前值是否无关 - 更新操作会将其全部覆盖。为实现此目的，你将使用 <bpt id="p3">**</bpt>table_operation::insert_or_replace_entity<ept id="p3">**</ept> 操作。如果该实体不存在，此操作将插入它，如果存在，则替换它，而不管上次更新是何时进行的。在以下代码示例中，仍将检索 Jeff Smith 的客户实体，但稍后会使用 <bpt id="p4">**</bpt>table_operation::insert_or_replace_entity<ept id="p4">**</ept> 将其保存回服务器。将覆盖在检索与更新操作之间对实体进行的任何更新。</source>
          <target state="new">如果该实体自从服务器中检索到它以后发生更改，则 <bpt id="p1">**</bpt>table_operation::replace_entity<ept id="p1">**</ept> 操作将失败。此外，你必须首先从服务器中检索该实体，<bpt id="p2">**</bpt>table_operation::replace_entity<ept id="p2">**</ept> 才能成功。但是，有时您不知道服务器上是否存在该实体以及存储在其中的当前值是否无关 - 更新操作会将其全部覆盖。为实现此目的，你将使用 <bpt id="p3">**</bpt>table_operation::insert_or_replace_entity<ept id="p3">**</ept> 操作。如果该实体不存在，此操作将插入它，如果存在，则替换它，而不管上次更新是何时进行的。在以下代码示例中，仍将检索 Jeff Smith 的客户实体，但稍后会使用 <bpt id="p4">**</bpt>table_operation::insert_or_replace_entity<ept id="p4">**</ept> 将其保存回服务器。将覆盖在检索与更新操作之间对实体进行的任何更新。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>查询一部分实体属性</source>
          <target state="new">查询一部分实体属性</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>对表的查询可以只检索实体中的少数几个属性。以下代码中的查询使用 <bpt id="p1">**</bpt>table_query::set_select_columns<ept id="p1">**</ept> 方法，仅返回表中实体的电子邮件地址。</source>
          <target state="new">对表的查询可以只检索实体中的少数几个属性。以下代码中的查询使用 <bpt id="p1">**</bpt>table_query::set_select_columns<ept id="p1">**</ept> 方法，仅返回表中实体的电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 查询实体的几个属性是比检索所有属性更高效的操作。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 查询实体的几个属性是比检索所有属性更高效的操作。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>删除实体</source>
          <target state="new">删除实体</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>你可以在检索到实体后轻松将其删除。检索到实体后，对要删除的实体调用 <bpt id="p1">**</bpt>table_operation::delete_entity<ept id="p1">**</ept>。然后调用 <bpt id="p2">**</bpt>cloud_table.execute<ept id="p2">**</ept> 方法。以下代码检索并删除分区键为"Smith"、行键为"Jeff"的实体。</source>
          <target state="new">你可以在检索到实体后轻松将其删除。检索到实体后，对要删除的实体调用 <bpt id="p1">**</bpt>table_operation::delete_entity<ept id="p1">**</ept>。然后调用 <bpt id="p2">**</bpt>cloud_table.execute<ept id="p2">**</ept> 方法。以下代码检索并删除分区键为"Smith"、行键为"Jeff"的实体。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>删除表</source>
          <target state="new">删除表</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>最后，以下代码示例将从存储帐户中删除表。在删除表之后的一段时间内无法重新创建它。</source>
          <target state="new">最后，以下代码示例将从存储帐户中删除表。在删除表之后的一段时间内无法重新创建它。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>现在，你已了解表存储的基础知识，请打开以下链接了解有关 Azure 存储空间的详细信息：</source>
          <target state="new">现在，你已了解表存储的基础知识，请打开以下链接了解有关 Azure 存储空间的详细信息：</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>如何通过 C++ 使用 Blob 存储</source>
          <target state="new">如何通过 C++ 使用 Blob 存储</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>如何通过 C++ 使用队列存储</source>
          <target state="new">如何通过 C++ 使用队列存储</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>使用 C++ 列出 Azure 存储资源</source>
          <target state="new">使用 C++ 列出 Azure 存储资源</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>适用于 C++ 的存储空间客户端库参考</source>
          <target state="new">适用于 C++ 的存储空间客户端库参考</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Azure 存档文档</source>
          <target state="new">Azure 存档文档</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>