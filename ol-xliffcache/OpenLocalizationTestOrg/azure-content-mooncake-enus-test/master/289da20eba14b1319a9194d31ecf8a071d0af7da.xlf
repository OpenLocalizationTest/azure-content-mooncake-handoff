<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">289da20eba14b1319a9194d31ecf8a071d0af7da</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Azure 通知中心 - 使用 .NET 后端通知 iOS 用户</source>
          <target state="new">Azure 通知中心 - 使用 .NET 后端通知 iOS 用户</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何向 Azure 中的用户发送推送通知。使用 Objective-C 和 .NET API 为后端编写的代码示例。</source>
          <target state="new">了解如何向 Azure 中的用户发送推送通知。使用 Objective-C 和 .NET API 为后端编写的代码示例。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Azure 通知中心 - 使用 .NET 后端通知 iOS 用户</source>
          <target state="new">Azure 通知中心 - 使用 .NET 后端通知 iOS 用户</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>利用 Azure 中的推送通知支持，你可以访问易于使用且向外扩展的多平台推送基础结构，这大大简化了为移动平台的使用者应用程序和企业应用程序实现推送通知的过程。本教程说明如何使用 Azure 通知中心将推送通知发送到特定设备上的特定应用程序用户。ASP.NET WebAPI 后端用于对客户端进行身份验证并生成通知，如指南主题<bpt id="p1">[</bpt>从应用后端注册<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/dn743807.aspx)</ept>中所述。</source>
          <target state="new">利用 Azure 中的推送通知支持，你可以访问易于使用且向外扩展的多平台推送基础结构，这大大简化了为移动平台的使用者应用程序和企业应用程序实现推送通知的过程。本教程说明如何使用 Azure 通知中心将推送通知发送到特定设备上的特定应用程序用户。ASP.NET WebAPI 后端用于对客户端进行身份验证并生成通知，如指南主题<bpt id="p1">[</bpt>从应用后端注册<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/dn743807.aspx)</ept>中所述。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>本教程假设您已根据<bpt id="p1">[</bpt>通知中心入门 (iOS)<ept id="p1">](/documentation/articles/notification-hubs-ios-get-started)</ept> 中所述创建并配置了通知中心。此外，只有在学习本教程后，才可以学习<bpt id="p2">[</bpt>安全推送 (iOS)<ept id="p2">](/documentation/articles/notification-hubs-aspnet-backend-ios-secure-push)</ept> 教程。如果你使用移动服务作为后端服务，请参阅本教程的<bpt id="p3">[</bpt>移动服务版本<ept id="p3">](/documentation/articles/mobile-services-javascript-backend-ios-push-notifications-app-users)</ept>。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>本教程假设您已根据<bpt id="p1">[</bpt>通知中心入门 (iOS)<ept id="p1">](/documentation/articles/notification-hubs-ios-get-started)</ept> 中所述创建并配置了通知中心。此外，只有在学习本教程后，才可以学习<bpt id="p2">[</bpt>安全推送 (iOS)<ept id="p2">](/documentation/articles/notification-hubs-aspnet-backend-ios-secure-push)</ept> 教程。如果你使用移动服务作为后端服务，请参阅本教程的<bpt id="p3">[</bpt>移动服务版本<ept id="p3">](/documentation/articles/mobile-services-javascript-backend-ios-push-notifications-app-users)</ept>。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>修改 iOS 应用</source>
          <target state="new">修改 iOS 应用</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>打开你在<bpt id="p1">[</bpt>通知中心入门 (iOS)<ept id="p1">](/documentation/articles/notification-hubs-ios-get-started)</ept> 教程中创建的“单页视图”应用。</source>
          <target state="new">打开你在<bpt id="p1">[</bpt>通知中心入门 (iOS)<ept id="p1">](/documentation/articles/notification-hubs-ios-get-started)</ept> 教程中创建的“单页视图”应用。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>在本节中我们假定你的项目已配置了空的组织名称。如果未配置，你将需要在所有类名前面追加组织名称。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>在本节中我们假定你的项目已配置了空的组织名称。如果未配置，你将需要在所有类名前面追加组织名称。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>在 Main.storyboard 中添加对象库中的组件，如下面的屏幕截图中所示。</source>
          <target state="new">在 Main.storyboard 中添加对象库中的组件，如下面的屏幕截图中所示。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>用户名<ept id="p1">**</ept>：包含占位符文本“输入用户名”的 UITextField，直接位于发送结果标签的下面并受左边距和右边距约束。</source>
          <target state="new"><bpt id="p1">**</bpt>用户名<ept id="p1">**</ept>：包含占位符文本“输入用户名”的 UITextField，直接位于发送结果标签的下面并受左边距和右边距约束。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>密码<ept id="p1">**</ept>：包含占位符文本“输入密码”的 UITextField，直接位于用户名文本字段的下面并受左边距和右边距约束。选中属性检查器中“返回密钥”下的“安全文本输入”选项。</source>
          <target state="new"><bpt id="p1">**</bpt>密码<ept id="p1">**</ept>：包含占位符文本“输入密码”的 UITextField，直接位于用户名文本字段的下面并受左边距和右边距约束。选中属性检查器中“返回密钥”下的“安全文本输入”选项。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>登录<ept id="p1">**</ept>：在密码文本字段的直接下方标记的 UIButton 并取消选中属性检查器中“控件内容”下的“已启用”选项</source>
          <target state="new"><bpt id="p1">**</bpt>登录<ept id="p1">**</ept>：在密码文本字段的直接下方标记的 UIButton 并取消选中属性检查器中“控件内容”下的“已启用”选项</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>WNS<ept id="p1">**</ept>：标签和开关，用于已在中心设置 Windows 通知服务时，启用将通知发送到 Windows 通知服务。请参阅 <bpt id="p2">[</bpt>Windows 入门<ept id="p2">](/documentation/articles/notification-hubs-windows-store-dotnet-get-started)</ept>教程。</source>
          <target state="new"><bpt id="p1">**</bpt>WNS<ept id="p1">**</ept>：标签和开关，用于已在中心设置 Windows 通知服务时，启用将通知发送到 Windows 通知服务。请参阅 <bpt id="p2">[</bpt>Windows 入门<ept id="p2">](/documentation/articles/notification-hubs-windows-store-dotnet-get-started)</ept>教程。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>GCM<ept id="p1">**</ept>：标签和开关，用于已在中心设置 Google Cloud Messaging 时，启用将通知发送到 Google Cloud Messaging。请参阅 <bpt id="p2">[</bpt>Android 入门<ept id="p2">](/documentation/articles/notification-hubs-android-get-started)</ept>教程。</source>
          <target state="new"><bpt id="p1">**</bpt>GCM<ept id="p1">**</ept>：标签和开关，用于已在中心设置 Google Cloud Messaging 时，启用将通知发送到 Google Cloud Messaging。请参阅 <bpt id="p2">[</bpt>Android 入门<ept id="p2">](/documentation/articles/notification-hubs-android-get-started)</ept>教程。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>APNS<ept id="p1">**</ept>：标签和开关，用于启用将通知发送到 Apple 平台通知服务。</source>
          <target state="new"><bpt id="p1">**</bpt>APNS<ept id="p1">**</ept>：标签和开关，用于启用将通知发送到 Apple 平台通知服务。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>收件人用户名<ept id="p1">**</ept>：包含占位符文本“收件人用户名标记”的 UITextField，直接位于 GCM 标签的下面并受左边距和右边距约束。</source>
          <target state="new"><bpt id="p1">**</bpt>收件人用户名<ept id="p1">**</ept>：包含占位符文本“收件人用户名标记”的 UITextField，直接位于 GCM 标签的下面并受左边距和右边距约束。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>按 <bpt id="p1">**</bpt>Ctrl<ept id="p1">**</ept> 的同时从视图中的组件拖至 ViewController.h 并添加这些新插座。</source>
          <target state="new">按 <bpt id="p1">**</bpt>Ctrl<ept id="p1">**</ept> 的同时从视图中的组件拖至 ViewController.h 并添加这些新插座。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>在 ViewController.h 中，在 import 语句的正下方添加以下 <ph id="ph1">`#define`</ph>。将 <bpt id="p1">*</bpt>&lt; 输入你的后端终结点&gt;<ept id="p1">*</ept> 占位符替换为在上一节中用于部署应用后端的目标 URL。例如，<bpt id="p2">*</bpt>http://you_backend.chinacloudsites.cn<ept id="p2">*</ept>。</source>
          <target state="new">在 ViewController.h 中，在 import 语句的正下方添加以下 <ph id="ph1">`#define`</ph>。将 <bpt id="p1">*</bpt>&lt; 输入你的后端终结点&gt;<ept id="p1">*</ept> 占位符替换为在上一节中用于部署应用后端的目标 URL。例如，<bpt id="p2">*</bpt>http://you_backend.chinacloudsites.cn<ept id="p2">*</ept>。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>在你的项目中，创建一个名为 <bpt id="p1">**</bpt>RegisterClient<ept id="p1">**</ept> 的新 <bpt id="p2">**</bpt>Cocoa Touch 类<ept id="p2">**</ept>，以便与你创建的 ASP.NET 后端交互。创建继承自 <ph id="ph1">`NSObject`</ph> 的类。然后在 RegisterClient.h 中添加以下代码。</source>
          <target state="new">在你的项目中，创建一个名为 <bpt id="p1">**</bpt>RegisterClient<ept id="p1">**</ept> 的新 <bpt id="p2">**</bpt>Cocoa Touch 类<ept id="p2">**</ept>，以便与你创建的 ASP.NET 后端交互。创建继承自 <ph id="ph1">`NSObject`</ph> 的类。然后在 RegisterClient.h 中添加以下代码。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>在 RegisterClient.m 中，更新 <ph id="ph1">`@interface`</ph> 节：</source>
          <target state="new">在 RegisterClient.m 中，更新 <ph id="ph1">`@interface`</ph> 节：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>将 RegisterClient.m 中的 <ph id="ph1">`@implementation`</ph> 节替换为以下代码。</source>
          <target state="new">将 RegisterClient.m 中的 <ph id="ph1">`@implementation`</ph> 节替换为以下代码。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>在 ViewController.h 中，为 RegisterClient.h 添加 <ph id="ph1">`#import`</ph> 语句。然后，在 <ph id="ph2">`@interface`</ph> 中添加设备令牌的声明和对 <ph id="ph3">`RegisterClient`</ph> 实例的引用：</source>
          <target state="new">在 ViewController.h 中，为 RegisterClient.h 添加 <ph id="ph1">`#import`</ph> 语句。然后，在 <ph id="ph2">`@interface`</ph> 中添加设备令牌的声明和对 <ph id="ph3">`RegisterClient`</ph> 实例的引用：</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>在 ViewController.m 的 <ph id="ph1">`@interface`</ph> 中添加私有方法声明：</source>
          <target state="new">在 ViewController.m 的 <ph id="ph1">`@interface`</ph> 中添加私有方法声明：</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>下面的代码段不是安全的身份验证方案，你应将 <bpt id="p1">**</bpt>createAndSetAuthenticationHeaderWithUsername:AndPassword:<ept id="p1">**</ept> 的实现替换为你的特定身份验证机制，该机制将生成要供注册客户端类（例如，OAuth、Active Directory）使用的身份验证令牌。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>下面的代码段不是安全的身份验证方案，你应将 <bpt id="p1">**</bpt>createAndSetAuthenticationHeaderWithUsername:AndPassword:<ept id="p1">**</ept> 的实现替换为你的特定身份验证机制，该机制将生成要供注册客户端类（例如，OAuth、Active Directory）使用的身份验证令牌。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>然后在 ViewController.m 的 <ph id="ph1">`@implementation`</ph> 节中添加以下代码，以添加用于设置设备令牌的实现和身份验证标头。</source>
          <target state="new">然后在 ViewController.m 的 <ph id="ph1">`@implementation`</ph> 节中添加以下代码，以添加用于设置设备令牌的实现和身份验证标头。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>请注意设置设备令牌时如何启用登录按钮。这是因为在登录操作过程中，视图控制器将使用应用后端注册推送通知。因此，我们不希望在正确设置设备令牌前可以访问登录操作。可以只要登录在推送注册之前发生，就将前者与后者解耦。</source>
          <target state="new">请注意设置设备令牌时如何启用登录按钮。这是因为在登录操作过程中，视图控制器将使用应用后端注册推送通知。因此，我们不希望在正确设置设备令牌前可以访问登录操作。可以只要登录在推送注册之前发生，就将前者与后者解耦。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>在 ViewController.m 中，使用以下代码段实现“登录”按钮的操作方法以及使用 ASP.NET 后端发送通知消息的方法。</source>
          <target state="new">在 ViewController.m 中，使用以下代码段实现“登录”按钮的操作方法以及使用 ASP.NET 后端发送通知消息的方法。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>更新“发送通知”按钮的操作以使用 ASP.NET 后端，发送开关启用的任何 PNS。</source>
          <target state="new">更新“发送通知”按钮的操作以使用 ASP.NET 后端，发送开关启用的任何 PNS。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>在函数 <bpt id="p1">**</bpt>ViewDidLoad<ept id="p1">**</ept> 中，添加以下内容来实例化 RegisterClient 实例并设置文本字段的委托。</source>
          <target state="new">在函数 <bpt id="p1">**</bpt>ViewDidLoad<ept id="p1">**</ept> 中，添加以下内容来实例化 RegisterClient 实例并设置文本字段的委托。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>现在，在 <bpt id="p1">**</bpt>AppDelegate.m<ept id="p1">**</ept> 中，删除方法 <bpt id="p2">**</bpt>application:didRegisterForPushNotificationWithDeviceToken:<ept id="p2">**</ept> 的所有内容并将其替换为以下内容，以确保视图控制器包含从 APN 中检索到的最新设备令牌：</source>
          <target state="new">现在，在 <bpt id="p1">**</bpt>AppDelegate.m<ept id="p1">**</ept> 中，删除方法 <bpt id="p2">**</bpt>application:didRegisterForPushNotificationWithDeviceToken:<ept id="p2">**</ept> 的所有内容并将其替换为以下内容，以确保视图控制器包含从 APN 中检索到的最新设备令牌：</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>最后，在 <bpt id="p1">**</bpt>AppDelegate.m<ept id="p1">**</ept> 中，确保你使用了以下方法：</source>
          <target state="new">最后，在 <bpt id="p1">**</bpt>AppDelegate.m<ept id="p1">**</ept> 中，确保你使用了以下方法：</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>测试应用程序</source>
          <target state="new">测试应用程序</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>在 XCode 中，在物理 iOS 设备上运行此应用（推送通知将无法在模拟器中正常工作）。</source>
          <target state="new">在 XCode 中，在物理 iOS 设备上运行此应用（推送通知将无法在模拟器中正常工作）。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>在 iOS 应用 UI 中，输入用户名和密码。这些信息可以是任意字符串，但必须是相同的字符串值。然后，单击“登录”。</source>
          <target state="new">在 iOS 应用 UI 中，输入用户名和密码。这些信息可以是任意字符串，但必须是相同的字符串值。然后，单击“登录”。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>你应看到弹出窗口通知你注册成功。单击<bpt id="p1">**</bpt>“确定”<ept id="p1">**</ept>。</source>
          <target state="new">你应看到弹出窗口通知你注册成功。单击<bpt id="p1">**</bpt>“确定”<ept id="p1">**</ept>。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>在 *<bpt id="p1">*</bpt>“收件人用户名标记”<ept id="p1">*</ept> 文本字段中，输入用于从另一台设备注册的用户名标记。</source>
          <target state="new">在 *<bpt id="p1">*</bpt>“收件人用户名标记”<ept id="p1">*</ept> 文本字段中，输入用于从另一台设备注册的用户名标记。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>输入通知消息，然后单击“发送通知”。只有使用该用户名标记注册的设备才会收到通知消息。该消息将只发送给那些用户。</source>
          <target state="new">输入通知消息，然后单击“发送通知”。只有使用该用户名标记注册的设备才会收到通知消息。该消息将只发送给那些用户。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>