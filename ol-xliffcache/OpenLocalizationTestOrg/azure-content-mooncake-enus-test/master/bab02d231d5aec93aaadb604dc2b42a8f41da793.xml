{
  "nodes": [
    {
      "content": "教程 - Azure  批处理( Batch ) .NET 库入门",
      "pos": [
        27,
        60
      ]
    },
    {
      "content": "了解 Azure  批处理( Batch )的基本概念，以及如何使用一个简单方案开发 批处理( Batch )服务",
      "pos": [
        79,
        136
      ]
    },
    {
      "content": "适用于 .NET 的 Azure 批处理 ( Batch )库入门",
      "pos": [
        333,
        366
      ]
    },
    {
      "pos": [
        370,
        605
      ],
      "content": "逐步演示 C# 示例应用程序如何利用 Batch 服务来处理云中的并行工作负荷，以及如何与 <bpt id=\"p1\">[</bpt>Azure 存储空间<ept id=\"p1\">](/documentation/articles/storage-introduction)</ept>交互来暂存和检索文件，从而让你了解 <bpt id=\"p2\">[</bpt>Azure Batch<ept id=\"p2\">][azure_batch]</ept> 和 <bpt id=\"p3\">[</bpt>Batch .NET<ept id=\"p3\">][net_api]</ept> 库的基础知识。了解常见的 Batch 应用程序工作流技术，并基本了解 Batch 的主要组件，例如作业、任务、池和计算节点。"
    },
    {
      "content": "Batch 解决方案工作流（精简）",
      "pos": [
        609,
        626
      ]
    },
    {
      "content": "先决条件",
      "pos": [
        636,
        640
      ]
    },
    {
      "content": "本文假设你已具备 C# 和 Visual Studio 的实践知识，并且你满足下面针对 Azure Batch 和存储服务指定的帐户创建要求。",
      "pos": [
        642,
        713
      ]
    },
    {
      "content": "帐户",
      "pos": [
        719,
        721
      ]
    },
    {
      "pos": [
        725,
        811
      ],
      "content": "<bpt id=\"p1\">**</bpt>Azure 订阅<ept id=\"p1\">**</ept> - 如果你没有 Azure 订阅，只需几分钟就可以通过 <bpt id=\"p2\">[</bpt>Azure 免费试用<ept id=\"p2\">](/pricing/free-trial/)</ept>创建一个免费试用帐户。"
    },
    {
      "pos": [
        814,
        921
      ],
      "content": "<bpt id=\"p1\">**</bpt>Batch 帐户<ept id=\"p1\">**</ept> - 获取 Azure 订阅后，请参阅<bpt id=\"p2\">[</bpt>创建和管理 Azure Batch 帐户<ept id=\"p2\">](/documentation/articles/batch-account-create-portal)</ept>。"
    },
    {
      "pos": [
        924,
        1024
      ],
      "content": "<bpt id=\"p1\">**</bpt>存储帐户<ept id=\"p1\">**</ept> - 请参阅<bpt id=\"p2\">[</bpt>关于 Azure 存储帐户<ept id=\"p2\">](/documentation/articles/storage-create-storage-account)</ept>中的 <bpt id=\"p3\">*</bpt>创建存储帐户<ept id=\"p3\">*</ept> 部分。"
    },
    {
      "content": "Visual Studio",
      "pos": [
        1030,
        1043
      ]
    },
    {
      "pos": [
        1045,
        1155
      ],
      "content": "必须拥有 <bpt id=\"p1\">**</bpt>Visual Studio 2013 或更高版本<ept id=\"p1\">**</ept>才能构建示例项目。可以在 <bpt id=\"p2\">[</bpt>Visual Studio 2015 产品概述<ept id=\"p2\">][visual_studio]</ept>中找到免费试用版的 Visual Studio。"
    },
    {
      "pos": [
        1161,
        1182
      ],
      "content": "<bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 代码示例"
    },
    {
      "pos": [
        1184,
        1415
      ],
      "content": "<bpt id=\"p1\">[</bpt>DotNetTutorial<ept id=\"p1\">][github_dotnettutorial]</ept> 示例是 GitHub 上的 <bpt id=\"p2\">[</bpt>azure-batch-samples<ept id=\"p2\">][github_samples]</ept> 存储库中提供的众多代码示例之一。单击存储库主页上的“下载 ZIP”按钮，或单击“azure-batch-samples-master.zip”直接下载链接即可下载该示例。<bpt id=\"p3\">[</bpt><ept id=\"p3\">][github_samples_zip]</ept>将 ZIP 文件的内容解压缩后，可在以下文件夹中找到该解决方案："
    },
    {
      "content": "Azure Batch 资源管理器（可选）",
      "pos": [
        1483,
        1504
      ]
    },
    {
      "pos": [
        1506,
        1741
      ],
      "content": "<bpt id=\"p1\">[</bpt>Azure Batch 资源管理器<ept id=\"p1\">][github_batchexplorer]</ept>是 GitHub 上的 <bpt id=\"p2\">[</bpt>azure-batch-samples<ept id=\"p2\">][github_samples]</ept> 存储库随附的免费实用程序。尽管完成本教程不要求使用 Batch 资源管理器，但我们强烈建议使用它来调试和管理 Batch 帐户中的实体。你可以在 <bpt id=\"p3\">[</bpt>Azure Batch 资源管理器示例演练<ept id=\"p3\">][batch_explorer_blog]</ept>博客文章中了解有关旧版 Batch 资源管理器的信息。"
    },
    {
      "content": "DotNetTutorial 示例项目概述",
      "pos": [
        1746,
        1767
      ]
    },
    {
      "pos": [
        1769,
        1867
      ],
      "content": "<bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 代码示例是由以下两个项目组成的 Visual Studio 2013 解决方案：<bpt id=\"p2\">**</bpt>DotNetTutorial<ept id=\"p2\">**</ept> 和 <bpt id=\"p3\">**</bpt>TaskApplication<ept id=\"p3\">**</ept>。"
    },
    {
      "pos": [
        1871,
        1961
      ],
      "content": "<bpt id=\"p1\">**</bpt>DotNetTutorial<ept id=\"p1\">**</ept> 是与 Batch 和存储服务交互，以在计算节点（虚拟机）上执行并行工作负荷的客户端应用程序。DotNetTutorial 在本地工作站上运行。"
    },
    {
      "pos": [
        1965,
        2210
      ],
      "content": "<bpt id=\"p1\">**</bpt>TaskApplication<ept id=\"p1\">**</ept> 是在 Azure 中的计算节点上运行以执行实际工作的可执行文件。在示例中，<ph id=\"ph1\">`TaskApplication.exe`</ph> 将分析从 Azure 存储空间下载的文件（输入文件）中的文本，然后生成一个文本文件（输出文件），其中包含输入文件中最常出现的三个单词的列表。在创建输出文件后，TaskApplication 将该文件上载到 Azure 存储空间，以供客户端应用程序下载。TaskApplication 在 Batch 服务中的多个计算节点上并行运行。"
    },
    {
      "pos": [
        2212,
        2361
      ],
      "content": "下图演示了客户端应用程序 <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 执行的主要操作，以及任务执行的应用程序 <bpt id=\"p2\">*</bpt>TaskApplication<ept id=\"p2\">*</ept> 。此基本工作流通常包括使用 Batch 创建的许多计算解决方案。尽管本教程并未演示 Batch 服务提供的每项功能，但几乎每个 Batch 方案都包含类似的过程。"
    },
    {
      "content": "Batch 示例工作流",
      "pos": [
        2365,
        2376
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>1.<ept id=\"p1\">**</ept> 在 Azure Blob 存储中创建<bpt id=\"p2\">**</bpt>容器<ept id=\"p2\">**</ept>",
      "pos": [
        2382,
        2413
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>2.<ept id=\"p1\">**</ept> 将任务应用程序和输入文件上载到容器",
      "pos": [
        2419,
        2443
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>3.<ept id=\"p1\">**</ept> 创建 Batch <bpt id=\"p2\">**</bpt>池<ept id=\"p2\">**</ept>",
      "pos": [
        2449,
        2470
      ]
    },
    {
      "content": "&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bpt id=\"p1\">**</bpt>3a.<ept id=\"p1\">**</ept>",
      "pos": [
        2478,
        2509
      ]
    },
    {
      "content": "池 <bpt id=\"p1\">**</bpt>StartTask<ept id=\"p1\">**</ept> 在节点加入池时将任务二进制文件 (TaskApplication) 下载到节点",
      "pos": [
        2510,
        2565
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>4.<ept id=\"p1\">**</ept> 创建 Batch <bpt id=\"p2\">**</bpt>作业<ept id=\"p2\">**</ept>",
      "pos": [
        2571,
        2593
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>5.<ept id=\"p1\">**</ept> 将<bpt id=\"p2\">**</bpt>任务<ept id=\"p2\">**</ept>添加到作业",
      "pos": [
        2599,
        2618
      ]
    },
    {
      "content": "&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bpt id=\"p1\">**</bpt>5a.<ept id=\"p1\">**</ept>",
      "pos": [
        2626,
        2657
      ]
    },
    {
      "content": "任务计划在节点上执行",
      "pos": [
        2658,
        2668
      ]
    },
    {
      "content": "&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bpt id=\"p1\">**</bpt>5b.<ept id=\"p1\">**</ept>",
      "pos": [
        2678,
        2709
      ]
    },
    {
      "content": "每项任务从 Azure 存储空间下载其输入数据，然后开始执行",
      "pos": [
        2710,
        2740
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>6.<ept id=\"p1\">**</ept> 监视任务",
      "pos": [
        2746,
        2757
      ]
    },
    {
      "content": "&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bpt id=\"p1\">**</bpt>6a.<ept id=\"p1\">**</ept>",
      "pos": [
        2765,
        2796
      ]
    },
    {
      "content": "当任务完成时，会将其输出数据上载到 Azure 存储空间",
      "pos": [
        2797,
        2825
      ]
    },
    {
      "content": "<bpt id=\"p1\">**</bpt>7.<ept id=\"p1\">**</ept> 从存储空间下载任务输出",
      "pos": [
        2831,
        2849
      ]
    },
    {
      "pos": [
        2851,
        2938
      ],
      "content": "如前所述，并非每个 Batch 解决方案都会确切地执行这些步骤，并且可能包含更多步骤，但 <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 示例应用程序将演示 Batch 方案中的常见过程。"
    },
    {
      "pos": [
        2943,
        2967
      ],
      "content": "构建 <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 示例项目"
    },
    {
      "pos": [
        2969,
        3148
      ],
      "content": "你必须先在 <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 项目的 <ph id=\"ph1\">`Program.cs`</ph> 文件中指定 Batch 和存储帐户凭据才能成功运行该示例。如果你尚未这样做，请双击 <ph id=\"ph2\">`DotNetTutorial.sln`</ph> 解决方案文件，或者在 Visual Studio 中使用“文件”&gt;“打开”&gt;“项目/解决方案”菜单，以在 Visual Studio 中打开该解决方案。"
    },
    {
      "pos": [
        3150,
        3211
      ],
      "content": "打开 <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 项目中的 <ph id=\"ph1\">`Program.cs`</ph>，然后，根据文件顶部附近的指定内容添加你的凭据："
    },
    {
      "pos": [
        3711,
        3770
      ],
      "content": "可以在 <bpt id=\"p1\">[</bpt>Azure 门户<ept id=\"p1\">][azure_portal]</ept>中每个服务的帐户边栏选项卡中找到 Batch 和存储帐户凭据："
    },
    {
      "content": "门户中的 Batch 凭据",
      "pos": [
        3774,
        3787
      ]
    },
    {
      "content": "门户中的存储空间凭据",
      "pos": [
        3794,
        3804
      ]
    },
    {
      "content": "使用凭据更新项目后，在“解决方案资源管理器”中右键单击该解决方案，然后单击“构建解决方案”。出现提示时，请确认还原任何 NuGet 包。",
      "pos": [
        3816,
        3884
      ]
    },
    {
      "pos": [
        3888,
        4021
      ],
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> 如果未自动还原 NuGet 包，或者你看到了有关包还原失败的错误，请确保已安装 <bpt id=\"p1\">[</bpt>NuGet 包管理器<ept id=\"p1\">][nuget_packagemgr]</ept>，然后启用遗失包的下载。若要启用包下载，请参阅<bpt id=\"p2\">[</bpt>在构建期间启用包还原<ept id=\"p2\">][nuget_restore]</ept>。"
    },
    {
      "content": "在以下部分中，我们将示例应用程序细分为用于处理 Batch 服务中工作负荷的多个步骤，并详细讨论这些步骤。建议你在学习本文的余下部分时参考 Visual Studio 中打开的解决方案，因为我们并不会讨论示例中的每一行代码。",
      "pos": [
        4023,
        4135
      ]
    },
    {
      "pos": [
        4137,
        4238
      ],
      "content": "导航到 <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 项目的 <ph id=\"ph1\">`Program.cs`</ph> 文件中 <ph id=\"ph2\">`MainAsync`</ph> 方法的顶部，开始执行步骤 1。以下每个步骤大致遵循 <ph id=\"ph3\">`MainAsync`</ph> 中方法调用的进度。"
    },
    {
      "content": "步骤 1：创建存储容器",
      "pos": [
        4243,
        4254
      ]
    },
    {
      "content": "在 Azure 存储空间中创建容器",
      "pos": [
        4258,
        4275
      ]
    },
    {
      "pos": [
        4287,
        4467
      ],
      "content": "Batch 包含与 Azure 存储空间进行交互的内置支持，存储帐户中的容器提供可在 Batch 帐户中运行的任务及其所需执行的文件，另外还提供一个位置用于存储任务生成的输出数据。 <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 客户端应用程序首先在 <bpt id=\"p2\">[</bpt>Azure Blob 存储<ept id=\"p2\">](./../storage/storage-introduction.md)</ept>中创建三个容器："
    },
    {
      "pos": [
        4471,
        4513
      ],
      "content": "<bpt id=\"p1\">**</bpt>应用程序<ept id=\"p1\">**</ept> - 此容器用于容装任务所要运行的应用程序及其依赖项，例如 DLL。"
    },
    {
      "pos": [
        4516,
        4549
      ],
      "content": "<bpt id=\"p1\">**</bpt>输入<ept id=\"p1\">**</ept> - 任务将从 <bpt id=\"p2\">*</bpt>输入<ept id=\"p2\">*</ept> 容器下载所要处理的数据文件。"
    },
    {
      "pos": [
        4552,
        4592
      ],
      "content": "<bpt id=\"p1\">**</bpt>输出<ept id=\"p1\">**</ept> - 当任务完成输入文件的处理时，会将其结果上载到 <bpt id=\"p2\">*</bpt>输出<ept id=\"p2\">*</ept> 容器。"
    },
    {
      "pos": [
        4594,
        4761
      ],
      "content": "若要与存储帐户交互并创建容器，可以使用<bpt id=\"p1\">[</bpt>适用于 .NET 的 Azure 存储空间客户端库<ept id=\"p1\">][net_api_storage]</ept>来创建包含 <bpt id=\"p2\">[</bpt>CloudStorageAccount<ept id=\"p2\">][net_cloudstorageaccount]</ept> 的帐户引用，并从中获取 <bpt id=\"p3\">[</bpt>CloudBlobClient<ept id=\"p3\">][net_cloudblobclient]</ept>："
    },
    {
      "pos": [
        5301,
        5413
      ],
      "content": "我们将在整个应用程序中使用 <ph id=\"ph1\">`blobClient`</ph> 引用，并将它作为参数传递给多个方法。紧接在上述代码的代码块中提供了示例，我们在其中调用 <ph id=\"ph2\">`CreateContainerIfNotExistAsync`</ph> 以实际创建容器。"
    },
    {
      "content": "创建容器之后，应用程序现在即可上载任务使用的文件。",
      "pos": [
        6351,
        6376
      ]
    },
    {
      "pos": [
        6380,
        6549
      ],
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> <bpt id=\"p1\">[</bpt>How to use Blob storage from .NET<ept id=\"p1\">](/documentation/articles/storage-dotnet-how-to-use-blobs)</ept> 提供了有关使用 Azure 存储空间容器和 Blob 的概述，当你开始使用 Batch 时，此概述应会出现在阅读列表的顶部附近。"
    },
    {
      "content": "步骤 2：上载任务应用程序和数据文件",
      "pos": [
        6554,
        6572
      ]
    },
    {
      "content": "将任务应用程序和输入（数据）文件上载到容器",
      "pos": [
        6576,
        6597
      ]
    },
    {
      "pos": [
        6609,
        6690
      ],
      "content": "在文件上载操作中， <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 先定义<bpt id=\"p2\">**</bpt>应用程序<ept id=\"p2\">**</ept>和<bpt id=\"p3\">**</bpt>输入<ept id=\"p3\">**</ept>文件在本地计算机上的路径的集合，然后将这些文件上载到上一步骤创建的容器。"
    },
    {
      "pos": [
        7889,
        7916
      ],
      "content": "<ph id=\"ph1\">`Program.cs`</ph> 中有两个方法涉及到上载过程："
    },
    {
      "pos": [
        7920,
        8069
      ],
      "content": "<ph id=\"ph1\">`UploadFilesToContainerAsync`</ph> - 此方法返回 <bpt id=\"p1\">[</bpt>ResourceFile<ept id=\"p1\">][net_resourcefile]</ept> 对象的集合（下面将会介绍），并在内部调用 <ph id=\"ph2\">`UploadFileToContainerAsync`</ph> 以上载在 <bpt id=\"p2\">*</bpt>filePaths<ept id=\"p2\">*</ept> 参数中传入的每个文件。"
    },
    {
      "pos": [
        8072,
        8220
      ],
      "content": "<ph id=\"ph1\">`UploadFileToContainerAsync`</ph> - 这是实际执行文件上载并创建 <bpt id=\"p1\">[</bpt>ResourceFile<ept id=\"p1\">][net_resourcefile]</ept> 对象的方法。上载文件后，它将获取该文件的共享访问签名 (SAS) 并返回代表它的 ResourceFile 对象。下面也会介绍共享访问签名。"
    },
    {
      "content": "ResourceFiles",
      "pos": [
        9445,
        9458
      ]
    },
    {
      "pos": [
        9460,
        9711
      ],
      "content": "<bpt id=\"p1\">[</bpt>ResourceFile<ept id=\"p1\">][net_resourcefile]</ept> 提供 Batch 中的任务，以及 Azure 存储空间中将在任务运行之前下载到计算节点的文件的 URL。<bpt id=\"p2\">[</bpt>ResourceFile.BlobSource<ept id=\"p2\">][net_resourcefile_blobsource]</ept> 属性指定 Azure 存储空间中现有文件的完整 URL，该 URL 也可能包含可供安全访问文件的共享访问签名 (SAS)。Batch .NET 中的大多数任务类型都包含 <bpt id=\"p3\">*</bpt>ResourceFiles<ept id=\"p3\">*</ept> 属性，这些类型包括："
    },
    {
      "content": "CloudTask",
      "pos": [
        9716,
        9725
      ]
    },
    {
      "content": "StartTask",
      "pos": [
        9740,
        9749
      ]
    },
    {
      "content": "JobPreparationTask",
      "pos": [
        9774,
        9792
      ]
    },
    {
      "content": "JobReleaseTask",
      "pos": [
        9814,
        9828
      ]
    },
    {
      "pos": [
        9847,
        9990
      ],
      "content": "DotNetTutorial 示例应用程序不使用 JobPreparationTask 或 JobReleaseTask 任务类型，但你可以通过<bpt id=\"p1\">[</bpt>在 Azure Batch 计算节点上运行作业准备和完成任务<ept id=\"p1\">](batch-job-prep-release.md)</ept>来详细了解这些任务类型。"
    },
    {
      "content": "共享访问签名 (SAS)",
      "pos": [
        9996,
        10008
      ]
    },
    {
      "content": "共享访问签名是一些字符串，包含为 URL 的一部分时，它们可以提供对 Azure 存储空间中容器和 Blob 的安全访问。DotNetTutorial 应用程序使用 Blob 和容器共享访问签名 URL，并演示如何从存储空间服务获取这些 SAS 字符串。",
      "pos": [
        10010,
        10137
      ]
    },
    {
      "pos": [
        10141,
        10382
      ],
      "content": "<bpt id=\"p1\">**</bpt>Blob SAS<ept id=\"p1\">**</ept> - DotNetTutorial 中池的 StartTask 在从存储空间下载应用程序二进制文件和输入数据文件时使用 Blob 共享访问签名（请参阅下面步骤 3）。DotNetTutorial 的 <ph id=\"ph1\">`Program.cs`</ph> 中的 <ph id=\"ph2\">`UploadFileToContainerAsync`</ph> 方法包含通过调用 <bpt id=\"p2\">[</bpt>CloudblobData.GetSharedAccessSignature<ept id=\"p2\">][net_sas_blob]</ept> 获取每个 Blob 的 SAS 的代码。"
    },
    {
      "pos": [
        10386,
        10710
      ],
      "content": "<bpt id=\"p1\">**</bpt>容器 SAS<ept id=\"p1\">**</ept> - 每个任务在计算节点上完成其工作后，会将其输出文件上载到 Azure 存储空间中的 <bpt id=\"p2\">*</bpt>输出<ept id=\"p2\">*</ept> 容器。为此，TaskApplication 使用容器 SAS，在上载文件时，该 SAS 提供对路径中包含的容器的写访问。获取容器 SAS 与获取 Blob SAS 的方法很类似。在 DotNetTutorial 中，你会发现 <ph id=\"ph1\">`GetContainerSasUrl`</ph> 帮助器方法调用 <bpt id=\"p3\">[</bpt>CloudBlobContainer.GetSharedAccessSignature<ept id=\"p3\">][net_sas_container]</ept> 来实现此目的。你可以在下面的“步骤 6：监视任务”中详细了解 TaskApplication 如何使用容器 SAS。"
    },
    {
      "pos": [
        10714,
        10943
      ],
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> 请查看有关共享访问签名的两篇系列教程的<bpt id=\"p1\">[</bpt>第 1 部分：了解 SAS 模型<ept id=\"p1\">](./../storage/storage-dotnet-shared-access-signature-part-1.md)</ept>和<bpt id=\"p2\">[</bpt>第 2 部分：创建 SAS 并将其用于 Blob 服务<ept id=\"p2\">](./../storage/storage-dotnet-shared-access-signature-part-2.md)</ept>，以详细了解如何提供对存储帐户中数据的安全访问。"
    },
    {
      "content": "步骤 3：创建 Batch 池",
      "pos": [
        10948,
        10963
      ]
    },
    {
      "content": "创建 Batch 池",
      "pos": [
        10967,
        10977
      ]
    },
    {
      "pos": [
        10989,
        11100
      ],
      "content": "将应用程序和数据文件上载到存储帐户之后， <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 将使用 Batch .NET 库开始与 Batch 服务交互。为此，需要先创建一个 <bpt id=\"p2\">[</bpt>BatchClient<ept id=\"p2\">][net_batchclient]</ept>："
    },
    {
      "pos": [
        11294,
        11436
      ],
      "content": "然后，调用 <ph id=\"ph1\">`CreatePoolAsync`</ph> 以在 Batch 帐户中创建计算节点池。<ph id=\"ph2\">`CreatePoolAsync`</ph> 使用 <bpt id=\"p1\">[</bpt>BatchClient.PoolOperations.CreatePool<ept id=\"p1\">][net_pool_create]</ept> 方法在 Batch 服务中实际创建该池。"
    },
    {
      "pos": [
        13321,
        13525
      ],
      "content": "使用 <bpt id=\"p1\">[</bpt>CreatePool<ept id=\"p1\">][net_pool_create]</ept> 创建池时，需指定一些参数，例如计算节点数目、<bpt id=\"p2\">[</bpt>节点大小<ept id=\"p2\">](/documentation/articles/cloud-services/cloud-services-sizes-specs.md)</ept>以及节点的<bpt id=\"p3\">[</bpt>操作系统<ept id=\"p3\">](./../cloud-services/cloud-services-guestos-update-matrix.md)</ept>。"
    },
    {
      "pos": [
        13529,
        13613
      ],
      "content": "<ph id=\"ph1\">[AZURE.IMPORTANT]</ph> 你需要支付 Batch 中计算资源的费用。若要将费用降到最低，可以在运行示例之前，将 <ph id=\"ph2\">`targetDedicated`</ph> 降为 1。"
    },
    {
      "pos": [
        13615,
        13799
      ],
      "content": "你也可以连同这些实体节点属性一起指定池的 <bpt id=\"p1\">[</bpt>StartTask<ept id=\"p1\">][net_pool_starttask]</ept>。StartTask 将在每个节点加入池以及每次重新启动节点时在该节点上运行。StartTask 特别适合用于在任务执行之前在计算节点上安装应用程序。例如，如果任务使用 Python 脚本处理数据，则你可以使用 StartTask 在计算节点上安装 Python。"
    },
    {
      "pos": [
        13801,
        13915
      ],
      "content": "在此示例应用程序中，StartTask 将它从存储空间下载的文件（使用 StartTask 的 <bpt id=\"p1\">*</bpt>ResourceFiles<ept id=\"p1\">*</ept> 属性指定），从 StartTask 工作目录复制到在节点上运行的 <bpt id=\"p2\">*</bpt>所有<ept id=\"p2\">*</ept> 任务可以访问的共享目录。"
    },
    {
      "pos": [
        13917,
        14097
      ],
      "content": "此外，在上述代码段中，值得注意的问题是，StartTask 的 <bpt id=\"p1\">*</bpt>CommandLine<ept id=\"p1\">*</ept> 属性中使用了两个环境变量：<ph id=\"ph1\">`%AZ_BATCH_TASK_WORKING_DIR%`</ph> 和 <ph id=\"ph2\">`%AZ_BATCH_NODE_SHARED_DIR%`</ph>。Batch 池中的每个计算节点自动以 Batch 特定的多个环境变量进行配置，任务执行的任何过程都可以访问这些环境变量。"
    },
    {
      "pos": [
        14101,
        14224
      ],
      "content": "<ph id=\"ph1\">[AZURE.TIP]</ph> 若要深入了解 Batch 池中计算节点上可用的环境变量，以及有关任务工作目录的信息，请参阅 <bpt id=\"p1\">[</bpt>Azure Batch 功能概述<ept id=\"p1\">](batch-api-basics.md)</ept>中的<bpt id=\"p2\">**</bpt>任务的环境设置<ept id=\"p2\">**</ept>及<bpt id=\"p3\">**</bpt>文件和目录<ept id=\"p3\">**</ept>部分。"
    },
    {
      "content": "步骤 4：创建 Batch 作业",
      "pos": [
        14229,
        14245
      ]
    },
    {
      "content": "创建 Batch 作业",
      "pos": [
        14249,
        14260
      ]
    },
    {
      "content": "Batch 作业基本上是与计算节点池关联的任务集合，它不仅可用来组织和跟踪相关工作负荷中的任务，也可以实施特定的约束，例如作业（并扩展到其任务）的最大运行时，以及 Batch 帐户中其他作业的相关作业优先级。不过，在此示例中，作业只与步骤 3 中创建的池关联，而没有配置任何其他属性。",
      "pos": [
        14266,
        14408
      ]
    },
    {
      "pos": [
        14410,
        14521
      ],
      "content": "所有 Batch 作业都与特定的池关联。这种关联指示了要在哪些节点上执行作业的任务。你可以使用 <bpt id=\"p1\">[</bpt>CloudJob.PoolInformation<ept id=\"p1\">][net_job_poolinfo]</ept> 属性来指定此关联，如以下代码段所示。"
    },
    {
      "content": "创建作业后，可以添加任务来执行工作。",
      "pos": [
        14862,
        14880
      ]
    },
    {
      "content": "步骤 5：将任务添加到作业",
      "pos": [
        14885,
        14898
      ]
    },
    {
      "content": "<ph id=\"ph1\">![</ph>将任务添加到作业<ph id=\"ph2\">][5]</ph>",
      "pos": [
        14900,
        14914
      ]
    },
    {
      "content": "(1) 将任务添加到作业，(2) 将任务计划为在节点上运行，(3) 任务下载要处理的数据文件",
      "pos": [
        14921,
        14967
      ]
    },
    {
      "pos": [
        14970,
        15171
      ],
      "content": "若要实际执行工作，必须将任务添加到作业。每个 <bpt id=\"p1\">[</bpt>CloudTask<ept id=\"p1\">][net_task]</ept> 都是使用命令列属性以及任务在其命令行自动运行前下载到节点的 <bpt id=\"p2\">[</bpt>ResourceFiles<ept id=\"p2\">][net_task_resourcefiles]</ept>（如同池的 StartTask）进行配置的。在 <bpt id=\"p3\">*</bpt>DotNetTutorial<ept id=\"p3\">*</ept> 示例项目中，每个任务只处理一个文件，因此其 ResourceFiles 集合只包含单个元素。"
    },
    {
      "pos": [
        16496,
        16711
      ],
      "content": "<ph id=\"ph1\">[AZURE.IMPORTANT]</ph> 访问环境变量（例如 <ph id=\"ph2\">`%AZ_BATCH_NODE_SHARED_DIR%`</ph>）或执行在节点的 <ph id=\"ph3\">`PATH`</ph> 中找不到的应用程序时，必须在任务命令行的前面加上 <ph id=\"ph4\">`cmd /c`</ph>，以显式执行命令解释器，并指示它在执行命令之后终止。如果任务在节点的 PATH 中执行应用程序（例如 <bpt id=\"p1\">*</bpt>robocopy.exe<ept id=\"p1\">*</ept> 或 <bpt id=\"p2\">*</bpt>powershell.exe<ept id=\"p2\">*</ept> ），而且未使用任何环境变量，则就不必要满足此要求。"
    },
    {
      "pos": [
        16713,
        16788
      ],
      "content": "在上述代码段中的 <ph id=\"ph1\">`foreach`</ph> 循环内，可以看到已构造任务的命令行，因此有三个命令行参数已传递到 <bpt id=\"p1\">*</bpt>TaskApplication.exe<ept id=\"p1\">*</ept> ："
    },
    {
      "pos": [
        16793,
        16960
      ],
      "content": "<bpt id=\"p1\">**</bpt>第一个参数<ept id=\"p1\">**</ept>是要处理的文件的路径。这是节点上现有文件的本地路径。首次在上述 <ph id=\"ph1\">`UploadFileToContainerAsync`</ph> 中创建 ResourceFile 对象时，文件名用于此属性（做为 ResourceFile 构造函数的参数），这表示可以在与 <bpt id=\"p2\">*</bpt>TaskApplication.exe<ept id=\"p2\">*</ept> 相同的目录中找到该文件。"
    },
    {
      "pos": [
        16965,
        17027
      ],
      "content": "<bpt id=\"p1\">**</bpt>第二个参数<ept id=\"p1\">**</ept>指定应将前 <bpt id=\"p2\">*</bpt>N<ept id=\"p2\">*</ept> 个单词写入输出文件。在示例中，此参数已经过硬编码，因此会将前 3 个单词写入输出文件。"
    },
    {
      "pos": [
        17032,
        17216
      ],
      "content": "<bpt id=\"p1\">**</bpt>第三个参数<ept id=\"p1\">**</ept>是共享访问签名 (SAS)，提供对 Azure 存储空间中<bpt id=\"p2\">**</bpt>输出<ept id=\"p2\">**</ept>容器的写访问。 <bpt id=\"p3\">*</bpt>TaskApplication.exe<ept id=\"p3\">*</ept> 将输出文件上载到 Azure 存储空间时，会使用此 SAS URL。你可以在 TaskApplication 项目的 <ph id=\"ph1\">`Program.cs`</ph> 文件的 <ph id=\"ph2\">`UploadFileToContainer`</ph> 方法中找到相关代码："
    },
    {
      "content": "步骤 6：监视任务",
      "pos": [
        18525,
        18534
      ]
    },
    {
      "content": "<ph id=\"ph1\">![</ph>监视任务<ph id=\"ph2\">][6]</ph>",
      "pos": [
        18536,
        18546
      ]
    },
    {
      "content": "客户端应用程序将会：(1) 监视任务的完成和成功状态，(2) 监视将结果数据上载到 Azure 存储空间的任务",
      "pos": [
        18553,
        18608
      ]
    },
    {
      "content": "任务在添加到作业后，将自动排入队列并计划在与作业关联的池中的计算节点上执行。根据你指定的设置，Batch 将为你处理所有任务排队、计划、重试和其他任务管理工作。监视任务执行的方法有许多种 - DotNetTutorial 显示了一个只报告完成状态以及任务或成功状态的简单示例。",
      "pos": [
        18611,
        18749
      ]
    },
    {
      "pos": [
        18751,
        18839
      ],
      "content": "DotNetTutorial 的 <ph id=\"ph1\">`Program.cs`</ph> 中的 <ph id=\"ph2\">`MonitorTasks`</ph> 方法内有三个 Batch .NET 概念值得讨论，下面按出现顺序列出了这些概念："
    },
    {
      "pos": [
        18844,
        19046
      ],
      "content": "<bpt id=\"p1\">**</bpt>ODATADetailLevel<ept id=\"p1\">**</ept> - 必须在列出操作（例如获取作业的任务列表）中指定 <bpt id=\"p2\">[</bpt>ODATADetailLevel<ept id=\"p2\">][net_odatadetaillevel]</ept>，以确保 Batch 应用程序的性能。如果你打算在 Batch 应用程序中进行任何类型的状态监视，请将<bpt id=\"p3\">[</bpt>有效地查询 Azure Batch 服务<ept id=\"p3\">](batch-efficient-list-queries.md)</ept>加入你的阅读列表。"
    },
    {
      "pos": [
        19051,
        19245
      ],
      "content": "<bpt id=\"p1\">**</bpt>TaskStateMonitor<ept id=\"p1\">**</ept> - <bpt id=\"p2\">[</bpt>TaskStateMonitor<ept id=\"p2\">][net_taskstatemonitor]</ept> 为 Batch .NET 应用程提供用于监视任务状态的帮助器实用程序。在 <ph id=\"ph1\">`MonitorTasks`</ph> 中， <bpt id=\"p3\">*</bpt>DotNetTutorial<ept id=\"p3\">*</ept> 将等待所有任务在时限内达到 <bpt id=\"p4\">[</bpt>TaskState.Completed<ept id=\"p4\">][net_taskstate]</ept>，然后终止作业。"
    },
    {
      "pos": [
        19250,
        19500
      ],
      "content": "<bpt id=\"p1\">**</bpt>TerminateJobAsync<ept id=\"p1\">**</ept> - 通过 <bpt id=\"p2\">[</bpt>JobOperations.TerminateJobAsync<ept id=\"p2\">][net_joboperations_terminatejob]</ept> 终止作业（或阻止 JobOperations.TerminateJob）会将该作业标记为已完成。如果 Batch 解决方案使用 <bpt id=\"p3\">[</bpt>JobReleaseTask<ept id=\"p3\">][net_jobreltask]</ept>，则你必须这样做。如<bpt id=\"p4\">[</bpt>作业准备和完成任务<ept id=\"p4\">](batch-job-prep-release)</ept>中所述，这是一种特殊的任务类型。"
    },
    {
      "pos": [
        19502,
        19559
      ],
      "content": "<bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 的 <ph id=\"ph1\">`Program.cs`</ph> 中的 <ph id=\"ph2\">`MonitorTasks`</ph> 方法如下所示："
    },
    {
      "content": "步骤 7：下载任务输出",
      "pos": [
        23111,
        23122
      ]
    },
    {
      "content": "从存储空间下载任务输出",
      "pos": [
        23126,
        23137
      ]
    },
    {
      "pos": [
        23143,
        23252
      ],
      "content": "完成作业后，可以从 Azure 存储空间下载任务的输出。可以在 <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 的 <ph id=\"ph1\">`Program.cs`</ph> 中调用 <ph id=\"ph2\">`DownloadBlobsFromContainerAsync`</ph> 来实现此目的："
    },
    {
      "pos": [
        24264,
        24376
      ],
      "content": "<ph id=\"ph1\">[AZURE.NOTE]</ph> 对 <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 应用程序中 <ph id=\"ph2\">`DownloadBlobsFromContainerAsync`</ph> 的调用可以指定应将文件下载到 <ph id=\"ph3\">`%TEMP%`</ph> 文件夹。可以随意修改此输出位置。"
    },
    {
      "content": "步骤 8：删除容器",
      "pos": [
        24381,
        24390
      ]
    },
    {
      "pos": [
        24392,
        24523
      ],
      "content": "由于你需要对位于 Azure 存储空间中的数据付费，因此我们建议删除 Batch 作业不再需要的所有 Blob。在 DotNetTutorial 的 <ph id=\"ph1\">`Program.cs`</ph> 中，调用帮助器方法 <ph id=\"ph2\">`DeleteContainerAsync`</ph> 三次即可实现此目的："
    },
    {
      "pos": [
        24743,
        24826
      ],
      "content": "该方法本身只获取对容器的引用，然后调用 <bpt id=\"p1\">[</bpt>CloudBlobContainer.DeleteIfExistsAsync<ept id=\"p1\">][net_container_delete]</ept>："
    },
    {
      "content": "步骤 9：删除作业和池",
      "pos": [
        25272,
        25283
      ]
    },
    {
      "pos": [
        25285,
        25399
      ],
      "content": "在最后一个步骤，系统将提示用户删除 DotNetTutorial 应用程序创建的作业和池。尽管你不需要支付作业和任务本身的费用，但 <bpt id=\"p1\">*</bpt>需要<ept id=\"p1\">*</ept> 支付计算节点的费用。因此，我们建议只在必要时才分配节点，并在维护过程中删除未使用的池。"
    },
    {
      "pos": [
        25401,
        25511
      ],
      "content": "BatchClient 的 <bpt id=\"p1\">[</bpt>JobOperations<ept id=\"p1\">][net_joboperations]</ept> 和 <bpt id=\"p2\">[</bpt>PoolOperations<ept id=\"p2\">][net_pooloperations]</ept> 都有对应的删除方法（在用户确认删除时调用）："
    },
    {
      "pos": [
        26007,
        26103
      ],
      "content": "<ph id=\"ph1\">[AZURE.IMPORTANT]</ph> 请记住，你需要支付计算资源的费用，而删除未使用的池可将费用降到最低。另请注意，删除池也会删除该池内的所有计算节点，并且删除池后，将无法恢复节点上的任何数据。"
    },
    {
      "pos": [
        26108,
        26130
      ],
      "content": "运行 <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 示例"
    },
    {
      "pos": [
        26132,
        26390
      ],
      "content": "当你运行示例应用程序时，控制台输出如下所示。在执行期间启动池的计算节点时，你将会遇到暂停并看到<ph id=\"ph1\">`Awaiting task completion, timeout in 00:30:00...`</ph>。在执行期间和之后，可以使用 <bpt id=\"p1\">[</bpt>Batch 资源管理器<ept id=\"p1\">][github_batchexplorer]</ept>来监视池、计算节点、作业和任务。使用 <bpt id=\"p2\">[</bpt>Azure 门户<ept id=\"p2\">][azure_portal]</ept>或某个可用的 <bpt id=\"p3\">[</bpt>Azure 存储空间资源管理器<ept id=\"p3\">][storage_explorers]</ept>来查看应用程序创建的存储资源（容器和 Blob）。"
    },
    {
      "pos": [
        26392,
        26425
      ],
      "content": "以默认配置运行应用程序时，典型的执行时间<bpt id=\"p1\">**</bpt>大约为 5 分钟<ept id=\"p1\">**</ept>。"
    },
    {
      "content": "后续步骤",
      "pos": [
        27565,
        27569
      ]
    },
    {
      "pos": [
        27571,
        27918
      ],
      "content": "你可以随意更改 <bpt id=\"p1\">*</bpt>DotNetTutorial<ept id=\"p1\">*</ept> 和 <bpt id=\"p2\">*</bpt>TaskApplication<ept id=\"p2\">*</ept> ，以体验不同的计算方案。尝试将执行延迟添加到 <bpt id=\"p3\">*</bpt>TaskApplication<ept id=\"p3\">*</ept> （例如使用 <bpt id=\"p4\">[</bpt>Thread.Sleep<ept id=\"p4\">][net_thread_sleep]</ept>），以模拟长时间运行的任务并使用 Batch 资源管理器的“热图”功能监视这些任务。尝试添加更多任务，或调整计算节点的数目。添加逻辑来检查并允许使用现有的池加速执行时间（ <bpt id=\"p5\">*</bpt>提示<ept id=\"p5\">*</ept> ：请查看 <bpt id=\"p6\">[</bpt>azure-batch-samples<ept id=\"p6\">][github_samples]</ept> 中 <bpt id=\"p7\">[</bpt>Microsoft.Azure.Batch.Samples.Common<ept id=\"p7\">][github_samples_common]</ept> 项目的 <ph id=\"ph1\">`ArticleHelpers.cs`</ph>）。"
    },
    {
      "content": "熟悉 Batch 解决方案的基本工作流后，接下来可以深入了解 Batch 服务的其他功能。",
      "pos": [
        27920,
        27965
      ]
    },
    {
      "pos": [
        27969,
        28046
      ],
      "content": "<bpt id=\"p1\">[</bpt>Azure Batch 功能概述<ept id=\"p1\">](batch-api-basics.md)</ept> - 此文概述了 Batch 的许多功能，建议 Batch 服务的新手阅读。"
    },
    {
      "pos": [
        28049,
        28119
      ],
      "content": "从 <bpt id=\"p1\">[</bpt>Batch 学习路径<ept id=\"p1\">][batch_learning_path]</ept>中<bpt id=\"p2\">**</bpt>有关开发的深度知识<ept id=\"p2\">**</ept>下面列出的其他 Batch 开发文章着手。"
    },
    {
      "pos": [
        28122,
        28193
      ],
      "content": "通过 <bpt id=\"p1\">[</bpt>TopNWords<ept id=\"p1\">][github_topnwords]</ept> 示例了解有关使用 Batch 处理“前 N 个单词”工作负荷的不同实现方式。"
    }
  ],
  "content": "<properties\n    pageTitle=\"教程 - Azure  批处理( Batch ) .NET 库入门\"\n    description=\"了解 Azure  批处理( Batch )的基本概念，以及如何使用一个简单方案开发 批处理( Batch )服务\"\n    services=\"batch\"\n    documentationCenter=\".net\"\n    authors=\"mmacy\"\n    manager=\"timlt\"\n    editor=\"\"/>\n\n<tags\n    ms.service=\"batch\"\n    ms.date=\"01/08/2016\"\n    wacn.date=\"01/21/2016\"/>\n\n# 适用于 .NET 的 Azure 批处理 ( Batch )库入门  \n\n逐步演示 C# 示例应用程序如何利用 Batch 服务来处理云中的并行工作负荷，以及如何与 [Azure 存储空间](/documentation/articles/storage-introduction)交互来暂存和检索文件，从而让你了解 [Azure Batch][azure_batch] 和 [Batch .NET][net_api] 库的基础知识。了解常见的 Batch 应用程序工作流技术，并基本了解 Batch 的主要组件，例如作业、任务、池和计算节点。\n\n![Batch 解决方案工作流（精简）][11]\n\n## 先决条件\n\n本文假设你已具备 C# 和 Visual Studio 的实践知识，并且你满足下面针对 Azure Batch 和存储服务指定的帐户创建要求。\n\n### 帐户\n\n- **Azure 订阅** - 如果你没有 Azure 订阅，只需几分钟就可以通过 [Azure 免费试用](/pricing/free-trial/)创建一个免费试用帐户。\n- **Batch 帐户** - 获取 Azure 订阅后，请参阅[创建和管理 Azure Batch 帐户](/documentation/articles/batch-account-create-portal)。\n- **存储帐户** - 请参阅[关于 Azure 存储帐户](/documentation/articles/storage-create-storage-account)中的 *创建存储帐户* 部分。\n\n### Visual Studio\n\n必须拥有 **Visual Studio 2013 或更高版本**才能构建示例项目。可以在 [Visual Studio 2015 产品概述][visual_studio]中找到免费试用版的 Visual Studio。\n\n### *DotNetTutorial* 代码示例\n\n[DotNetTutorial][github_dotnettutorial] 示例是 GitHub 上的 [azure-batch-samples][github_samples] 存储库中提供的众多代码示例之一。单击存储库主页上的“下载 ZIP”按钮，或单击“azure-batch-samples-master.zip”直接下载链接即可下载该示例。[][github_samples_zip]将 ZIP 文件的内容解压缩后，可在以下文件夹中找到该解决方案：\n\n`\\azure-batch-samples\\CSharp\\ArticleProjects\\DotNetTutorial`\n\n### Azure Batch 资源管理器（可选）\n\n[Azure Batch 资源管理器][github_batchexplorer]是 GitHub 上的 [azure-batch-samples][github_samples] 存储库随附的免费实用程序。尽管完成本教程不要求使用 Batch 资源管理器，但我们强烈建议使用它来调试和管理 Batch 帐户中的实体。你可以在 [Azure Batch 资源管理器示例演练][batch_explorer_blog]博客文章中了解有关旧版 Batch 资源管理器的信息。\n\n## DotNetTutorial 示例项目概述\n\n*DotNetTutorial* 代码示例是由以下两个项目组成的 Visual Studio 2013 解决方案：**DotNetTutorial** 和 **TaskApplication**。\n\n- **DotNetTutorial** 是与 Batch 和存储服务交互，以在计算节点（虚拟机）上执行并行工作负荷的客户端应用程序。DotNetTutorial 在本地工作站上运行。\n\n- **TaskApplication** 是在 Azure 中的计算节点上运行以执行实际工作的可执行文件。在示例中，`TaskApplication.exe` 将分析从 Azure 存储空间下载的文件（输入文件）中的文本，然后生成一个文本文件（输出文件），其中包含输入文件中最常出现的三个单词的列表。在创建输出文件后，TaskApplication 将该文件上载到 Azure 存储空间，以供客户端应用程序下载。TaskApplication 在 Batch 服务中的多个计算节点上并行运行。\n\n下图演示了客户端应用程序 *DotNetTutorial* 执行的主要操作，以及任务执行的应用程序 *TaskApplication* 。此基本工作流通常包括使用 Batch 创建的许多计算解决方案。尽管本教程并未演示 Batch 服务提供的每项功能，但几乎每个 Batch 方案都包含类似的过程。\n\n![Batch 示例工作流][8]\n\n**1.** 在 Azure Blob 存储中创建**容器**<br/>\n**2.** 将任务应用程序和输入文件上载到容器<br/>\n**3.** 创建 Batch **池**<br/>\n  &nbsp;&nbsp;&nbsp;&nbsp;**3a.** 池 **StartTask** 在节点加入池时将任务二进制文件 (TaskApplication) 下载到节点<br/>\n**4.** 创建 Batch **作业**<br/>\n**5.** 将**任务**添加到作业<br/>\n  &nbsp;&nbsp;&nbsp;&nbsp;**5a.** 任务计划在节点上执行<br/>\n    &nbsp;&nbsp;&nbsp;&nbsp;**5b.** 每项任务从 Azure 存储空间下载其输入数据，然后开始执行<br/>\n**6.** 监视任务<br/>\n  &nbsp;&nbsp;&nbsp;&nbsp;**6a.** 当任务完成时，会将其输出数据上载到 Azure 存储空间<br/>\n**7.** 从存储空间下载任务输出\n\n如前所述，并非每个 Batch 解决方案都会确切地执行这些步骤，并且可能包含更多步骤，但 *DotNetTutorial* 示例应用程序将演示 Batch 方案中的常见过程。\n\n## 构建 *DotNetTutorial* 示例项目\n\n你必须先在 *DotNetTutorial* 项目的 `Program.cs` 文件中指定 Batch 和存储帐户凭据才能成功运行该示例。如果你尚未这样做，请双击 `DotNetTutorial.sln` 解决方案文件，或者在 Visual Studio 中使用“文件”>“打开”>“项目/解决方案”菜单，以在 Visual Studio 中打开该解决方案。\n\n打开 *DotNetTutorial* 项目中的 `Program.cs`，然后，根据文件顶部附近的指定内容添加你的凭据：\n\n```\n// Update the Batch and Storage account credential strings below with the values unique to your accounts.\n// These are used when constructing connection strings for the Batch and Storage client objects.\n\n// Batch account credentials\nprivate const string BatchAccountName = \"\";\nprivate const string BatchAccountKey  = \"\";\nprivate const string BatchAccountUrl  = \"\";\n\n// Storage account credentials\nprivate const string StorageAccountName = \"\";\nprivate const string StorageAccountKey  = \"\";\n```\n\n可以在 [Azure 门户][azure_portal]中每个服务的帐户边栏选项卡中找到 Batch 和存储帐户凭据：\n\n![门户中的 Batch 凭据][9]\n![门户中的存储空间凭据][10]<br/>\n\n使用凭据更新项目后，在“解决方案资源管理器”中右键单击该解决方案，然后单击“构建解决方案”。出现提示时，请确认还原任何 NuGet 包。\n\n> [AZURE.TIP] 如果未自动还原 NuGet 包，或者你看到了有关包还原失败的错误，请确保已安装 [NuGet 包管理器][nuget_packagemgr]，然后启用遗失包的下载。若要启用包下载，请参阅[在构建期间启用包还原][nuget_restore]。\n\n在以下部分中，我们将示例应用程序细分为用于处理 Batch 服务中工作负荷的多个步骤，并详细讨论这些步骤。建议你在学习本文的余下部分时参考 Visual Studio 中打开的解决方案，因为我们并不会讨论示例中的每一行代码。\n\n导航到 *DotNetTutorial* 项目的 `Program.cs` 文件中 `MainAsync` 方法的顶部，开始执行步骤 1。以下每个步骤大致遵循 `MainAsync` 中方法调用的进度。\n\n## 步骤 1：创建存储容器\n\n![在 Azure 存储空间中创建容器][1]\n<br/>\n\nBatch 包含与 Azure 存储空间进行交互的内置支持，存储帐户中的容器提供可在 Batch 帐户中运行的任务及其所需执行的文件，另外还提供一个位置用于存储任务生成的输出数据。 *DotNetTutorial* 客户端应用程序首先在 [Azure Blob 存储](./../storage/storage-introduction.md)中创建三个容器：\n\n- **应用程序** - 此容器用于容装任务所要运行的应用程序及其依赖项，例如 DLL。\n- **输入** - 任务将从 *输入* 容器下载所要处理的数据文件。\n- **输出** - 当任务完成输入文件的处理时，会将其结果上载到 *输出* 容器。\n\n若要与存储帐户交互并创建容器，可以使用[适用于 .NET 的 Azure 存储空间客户端库][net_api_storage]来创建包含 [CloudStorageAccount][net_cloudstorageaccount] 的帐户引用，并从中获取 [CloudBlobClient][net_cloudblobclient]：\n\n```\n// Construct the Storage account connection string\nstring storageConnectionString = String.Format(\"DefaultEndpointsProtocol=https;AccountName={0};AccountKey={1}\",\n                                                StorageAccountName, StorageAccountKey);\n\n// Retrieve the storage account\nCloudStorageAccount storageAccount = CloudStorageAccount.Parse(storageConnectionString);\n\n// Create the blob client, for use in obtaining references to blob storage containers\nCloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();\n```\n\n我们将在整个应用程序中使用 `blobClient` 引用，并将它作为参数传递给多个方法。紧接在上述代码的代码块中提供了示例，我们在其中调用 `CreateContainerIfNotExistAsync` 以实际创建容器。\n\n```\n// Use the blob client to create the containers in Azure Storage if they don't yet exist\nconst string appContainerName    = \"application\";\nconst string inputContainerName  = \"input\";\nconst string outputContainerName = \"output\";\nawait CreateContainerIfNotExistAsync(blobClient, appContainerName);\nawait CreateContainerIfNotExistAsync(blobClient, inputContainerName);\nawait CreateContainerIfNotExistAsync(blobClient, outputContainerName);\n```\n\n```\nprivate static async Task CreateContainerIfNotExistAsync(CloudBlobClient blobClient, string containerName)\n{\n        CloudBlobContainer container = blobClient.GetContainerReference(containerName);\n\n        if (await container.CreateIfNotExistsAsync())\n        {\n                Console.WriteLine(\"Container [{0}] created.\", containerName);\n        }\n        else\n        {\n                Console.WriteLine(\"Container [{0}] exists, skipping creation.\", containerName);\n        }\n}\n```\n\n创建容器之后，应用程序现在即可上载任务使用的文件。\n\n> [AZURE.TIP] [How to use Blob storage from .NET](/documentation/articles/storage-dotnet-how-to-use-blobs) 提供了有关使用 Azure 存储空间容器和 Blob 的概述，当你开始使用 Batch 时，此概述应会出现在阅读列表的顶部附近。\n\n## 步骤 2：上载任务应用程序和数据文件\n\n![将任务应用程序和输入（数据）文件上载到容器][2]\n<br/>\n\n在文件上载操作中， *DotNetTutorial* 先定义**应用程序**和**输入**文件在本地计算机上的路径的集合，然后将这些文件上载到上一步骤创建的容器。\n\n```\n// Paths to the executable and its dependencies that will be executed by the tasks\nList<string> applicationFilePaths = new List<string>\n{\n    // The DotNetTutorial project includes a project reference to TaskApplication, allowing us to\n    // determine the path of the task application binary dynamically\n    typeof(TaskApplication.Program).Assembly.Location,\n    \"Microsoft.WindowsAzure.Storage.dll\"\n};\n\n// The collection of data files that are to be processed by the tasks\nList<string> inputFilePaths = new List<string>\n{\n    @\"..\\..\\taskdata1.txt\",\n    @\"..\\..\\taskdata2.txt\",\n    @\"..\\..\\taskdata3.txt\"\n};\n\n// Upload the application and its dependencies to Azure Storage. This is the application that will\n// process the data files, and will be executed by each of the tasks on the compute nodes.\nList<ResourceFile> applicationFiles = await UploadFilesToContainerAsync(blobClient, appContainerName, applicationFilePaths);\n\n// Upload the data files. This is the data that will be processed by each of the tasks that are\n// executed on the compute nodes within the pool.\nList<ResourceFile> inputFiles = await UploadFilesToContainerAsync(blobClient, inputContainerName, inputFilePaths);\n```\n\n`Program.cs` 中有两个方法涉及到上载过程：\n\n- `UploadFilesToContainerAsync` - 此方法返回 [ResourceFile][net_resourcefile] 对象的集合（下面将会介绍），并在内部调用 `UploadFileToContainerAsync` 以上载在 *filePaths* 参数中传入的每个文件。\n- `UploadFileToContainerAsync` - 这是实际执行文件上载并创建 [ResourceFile][net_resourcefile] 对象的方法。上载文件后，它将获取该文件的共享访问签名 (SAS) 并返回代表它的 ResourceFile 对象。下面也会介绍共享访问签名。\n\n```\nprivate static async Task<ResourceFile> UploadFileToContainerAsync(CloudBlobClient blobClient, string containerName, string filePath)\n{\n        Console.WriteLine(\"Uploading file {0} to container [{1}]...\", filePath, containerName);\n\n        string blobName = Path.GetFileName(filePath);\n\n        CloudBlobContainer container = blobClient.GetContainerReference(containerName);\n        CloudBlockBlob blobData = container.GetBlockBlobReference(blobName);\n        await blobData.UploadFromFileAsync(filePath, FileMode.Open);\n\n        // Set the expiry time and permissions for the blob shared access signature. In this case, no start time is specified,\n        // so the shared access signature becomes valid immediately\n        SharedAccessBlobPolicy sasConstraints = new SharedAccessBlobPolicy\n        {\n                SharedAccessExpiryTime = DateTime.UtcNow.AddHours(2),\n                Permissions = SharedAccessBlobPermissions.Read\n        };\n\n        // Construct the SAS URL for blob\n        string sasBlobToken = blobData.GetSharedAccessSignature(sasConstraints);\n        string blobSasUri = String.Format(\"{0}{1}\", blobData.Uri, sasBlobToken);\n\n        return new ResourceFile(blobSasUri, blobName);\n}\n```\n\n### ResourceFiles\n\n[ResourceFile][net_resourcefile] 提供 Batch 中的任务，以及 Azure 存储空间中将在任务运行之前下载到计算节点的文件的 URL。[ResourceFile.BlobSource][net_resourcefile_blobsource] 属性指定 Azure 存储空间中现有文件的完整 URL，该 URL 也可能包含可供安全访问文件的共享访问签名 (SAS)。Batch .NET 中的大多数任务类型都包含 *ResourceFiles* 属性，这些类型包括：\n\n- [CloudTask][net_task]\n- [StartTask][net_pool_starttask]\n- [JobPreparationTask][net_jobpreptask]\n- [JobReleaseTask][net_jobreltask]\n\nDotNetTutorial 示例应用程序不使用 JobPreparationTask 或 JobReleaseTask 任务类型，但你可以通过[在 Azure Batch 计算节点上运行作业准备和完成任务](batch-job-prep-release.md)来详细了解这些任务类型。\n\n### 共享访问签名 (SAS)\n\n共享访问签名是一些字符串，包含为 URL 的一部分时，它们可以提供对 Azure 存储空间中容器和 Blob 的安全访问。DotNetTutorial 应用程序使用 Blob 和容器共享访问签名 URL，并演示如何从存储空间服务获取这些 SAS 字符串。\n\n- **Blob SAS** - DotNetTutorial 中池的 StartTask 在从存储空间下载应用程序二进制文件和输入数据文件时使用 Blob 共享访问签名（请参阅下面步骤 3）。DotNetTutorial 的 `Program.cs` 中的 `UploadFileToContainerAsync` 方法包含通过调用 [CloudblobData.GetSharedAccessSignature][net_sas_blob] 获取每个 Blob 的 SAS 的代码。\n\n- **容器 SAS** - 每个任务在计算节点上完成其工作后，会将其输出文件上载到 Azure 存储空间中的 *输出* 容器。为此，TaskApplication 使用容器 SAS，在上载文件时，该 SAS 提供对路径中包含的容器的写访问。获取容器 SAS 与获取 Blob SAS 的方法很类似。在 DotNetTutorial 中，你会发现 `GetContainerSasUrl` 帮助器方法调用 [CloudBlobContainer.GetSharedAccessSignature][net_sas_container] 来实现此目的。你可以在下面的“步骤 6：监视任务”中详细了解 TaskApplication 如何使用容器 SAS。\n\n> [AZURE.TIP] 请查看有关共享访问签名的两篇系列教程的[第 1 部分：了解 SAS 模型](./../storage/storage-dotnet-shared-access-signature-part-1.md)和[第 2 部分：创建 SAS 并将其用于 Blob 服务](./../storage/storage-dotnet-shared-access-signature-part-2.md)，以详细了解如何提供对存储帐户中数据的安全访问。\n\n## 步骤 3：创建 Batch 池\n\n![创建 Batch 池][3]\n<br/>\n\n将应用程序和数据文件上载到存储帐户之后， *DotNetTutorial* 将使用 Batch .NET 库开始与 Batch 服务交互。为此，需要先创建一个 [BatchClient][net_batchclient]：\n\n```\nBatchSharedKeyCredentials cred = new BatchSharedKeyCredentials(BatchAccountUrl, BatchAccountName, BatchAccountKey);\nusing (BatchClient batchClient = BatchClient.Open(cred))\n{\n    ...\n```\n\n然后，调用 `CreatePoolAsync` 以在 Batch 帐户中创建计算节点池。`CreatePoolAsync` 使用 [BatchClient.PoolOperations.CreatePool][net_pool_create] 方法在 Batch 服务中实际创建该池。\n\n```\nprivate static async Task CreatePoolAsync(BatchClient batchClient, string poolId, IList<ResourceFile> resourceFiles)\n{\n    Console.WriteLine(\"Creating pool [{0}]...\", poolId);\n\n    // Create the unbound pool. Until we call CloudPool.Commit() or CommitAsync(), no pool is actually created in the\n    // Batch service. This CloudPool instance is therefore considered \"unbound,\" and we can modify its properties.\n    CloudPool pool = batchClient.PoolOperations.CreatePool(\n                poolId: poolId,\n                targetDedicated: 3,           // 3 compute nodes\n                virtualMachineSize: \"small\",  // single-core, 1.75 GB memory, 225 GB disk\n                osFamily: \"4\");               // Windows Server 2012 R2\n\n    // Create and assign the StartTask that will be executed when compute nodes join the pool.\n    // In this case, we copy the StartTask's resource files (that will be automatically downloaded\n    // to the node by the StartTask) into the shared directory that all tasks will have access to.\n    pool.StartTask = new StartTask\n    {\n        // Specify a command line for the StartTask that copies the task application files to the\n        // node's shared directory. Every compute node in a Batch pool is configured with a number\n        // of pre-defined environment variables that can be referenced by commands or applications\n        // run by tasks.\n\n        // Since a successful execution of robocopy can return a non-zero exit code (e.g. 1 when one or\n        // more files were successfully copied) we need to manually exit with a 0 for Batch to recognize\n        // StartTask execution success.\n        CommandLine = \"cmd /c (robocopy %AZ_BATCH_TASK_WORKING_DIR% %AZ_BATCH_NODE_SHARED_DIR%) ^& IF %ERRORLEVEL% LEQ 1 exit 0\",\n        ResourceFiles = resourceFiles,\n        WaitForSuccess = true\n    };\n\n    await pool.CommitAsync();\n}\n```\n\n使用 [CreatePool][net_pool_create] 创建池时，需指定一些参数，例如计算节点数目、[节点大小](/documentation/articles/cloud-services/cloud-services-sizes-specs.md)以及节点的[操作系统](./../cloud-services/cloud-services-guestos-update-matrix.md)。\n\n> [AZURE.IMPORTANT] 你需要支付 Batch 中计算资源的费用。若要将费用降到最低，可以在运行示例之前，将 `targetDedicated` 降为 1。\n\n你也可以连同这些实体节点属性一起指定池的 [StartTask][net_pool_starttask]。StartTask 将在每个节点加入池以及每次重新启动节点时在该节点上运行。StartTask 特别适合用于在任务执行之前在计算节点上安装应用程序。例如，如果任务使用 Python 脚本处理数据，则你可以使用 StartTask 在计算节点上安装 Python。\n\n在此示例应用程序中，StartTask 将它从存储空间下载的文件（使用 StartTask 的 *ResourceFiles* 属性指定），从 StartTask 工作目录复制到在节点上运行的 *所有* 任务可以访问的共享目录。\n\n此外，在上述代码段中，值得注意的问题是，StartTask 的 *CommandLine* 属性中使用了两个环境变量：`%AZ_BATCH_TASK_WORKING_DIR%` 和 `%AZ_BATCH_NODE_SHARED_DIR%`。Batch 池中的每个计算节点自动以 Batch 特定的多个环境变量进行配置，任务执行的任何过程都可以访问这些环境变量。\n\n> [AZURE.TIP] 若要深入了解 Batch 池中计算节点上可用的环境变量，以及有关任务工作目录的信息，请参阅 [Azure Batch 功能概述](batch-api-basics.md)中的**任务的环境设置**及**文件和目录**部分。\n\n## 步骤 4：创建 Batch 作业\n\n![创建 Batch 作业][4]\n\nBatch 作业基本上是与计算节点池关联的任务集合，它不仅可用来组织和跟踪相关工作负荷中的任务，也可以实施特定的约束，例如作业（并扩展到其任务）的最大运行时，以及 Batch 帐户中其他作业的相关作业优先级。不过，在此示例中，作业只与步骤 3 中创建的池关联，而没有配置任何其他属性。\n\n所有 Batch 作业都与特定的池关联。这种关联指示了要在哪些节点上执行作业的任务。你可以使用 [CloudJob.PoolInformation][net_job_poolinfo] 属性来指定此关联，如以下代码段所示。\n\n```\nprivate static async Task CreateJobAsync(BatchClient batchClient, string jobId, string poolId)\n{\n    Console.WriteLine(\"Creating job [{0}]...\", jobId);\n\n    CloudJob job = batchClient.JobOperations.CreateJob();\n    job.Id = jobId;\n    job.PoolInformation = new PoolInformation { PoolId = poolId };\n\n    await job.CommitAsync();\n}\n```\n\n创建作业后，可以添加任务来执行工作。\n\n## 步骤 5：将任务添加到作业\n\n![将任务添加到作业][5]<br/>\n*(1) 将任务添加到作业，(2) 将任务计划为在节点上运行，(3) 任务下载要处理的数据文件*\n\n若要实际执行工作，必须将任务添加到作业。每个 [CloudTask][net_task] 都是使用命令列属性以及任务在其命令行自动运行前下载到节点的 [ResourceFiles][net_task_resourcefiles]（如同池的 StartTask）进行配置的。在 *DotNetTutorial* 示例项目中，每个任务只处理一个文件，因此其 ResourceFiles 集合只包含单个元素。\n\n```\nprivate static async Task<List<CloudTask>> AddTasksAsync(BatchClient batchClient, string jobId, List<ResourceFile> inputFiles, string outputContainerSasUrl)\n{\n    Console.WriteLine(\"Adding {0} tasks to job [{1}]...\", inputFiles.Count, jobId);\n\n    // Create a collection to hold the tasks that we'll be adding to the job\n    List<CloudTask> tasks = new List<CloudTask>();\n\n    // Create each of the tasks. Because we copied the task application to the\n    // node's shared directory with the pool's StartTask, we can access it via\n    // the shared directory on whichever node each task will run.\n    foreach (ResourceFile inputFile in inputFiles)\n    {\n        string taskId = \"topNtask\" + inputFiles.IndexOf(inputFile);\n        string taskCommandLine = String.Format(\"cmd /c %AZ_BATCH_NODE_SHARED_DIR%\\\\TaskApplication.exe {0} 3 \"{1}\"\", inputFile.FilePath, outputContainerSasUrl);\n\n        CloudTask task = new CloudTask(taskId, taskCommandLine);\n        task.ResourceFiles = new List<ResourceFile> { inputFile };\n        tasks.Add(task);\n    }\n\n    // Add the tasks as a collection opposed to a separate AddTask call for each. Bulk task submission\n    // helps to ensure efficient underlying API calls to the Batch service.\n    await batchClient.JobOperations.AddTaskAsync(jobId, tasks);\n\n    return tasks;\n}\n```\n\n> [AZURE.IMPORTANT] 访问环境变量（例如 `%AZ_BATCH_NODE_SHARED_DIR%`）或执行在节点的 `PATH` 中找不到的应用程序时，必须在任务命令行的前面加上 `cmd /c`，以显式执行命令解释器，并指示它在执行命令之后终止。如果任务在节点的 PATH 中执行应用程序（例如 *robocopy.exe* 或 *powershell.exe* ），而且未使用任何环境变量，则就不必要满足此要求。\n\n在上述代码段中的 `foreach` 循环内，可以看到已构造任务的命令行，因此有三个命令行参数已传递到 *TaskApplication.exe* ：\n\n1. **第一个参数**是要处理的文件的路径。这是节点上现有文件的本地路径。首次在上述 `UploadFileToContainerAsync` 中创建 ResourceFile 对象时，文件名用于此属性（做为 ResourceFile 构造函数的参数），这表示可以在与 *TaskApplication.exe* 相同的目录中找到该文件。\n\n2. **第二个参数**指定应将前 *N* 个单词写入输出文件。在示例中，此参数已经过硬编码，因此会将前 3 个单词写入输出文件。\n\n3. **第三个参数**是共享访问签名 (SAS)，提供对 Azure 存储空间中**输出**容器的写访问。 *TaskApplication.exe* 将输出文件上载到 Azure 存储空间时，会使用此 SAS URL。你可以在 TaskApplication 项目的 `Program.cs` 文件的 `UploadFileToContainer` 方法中找到相关代码：\n\n```\n// NOTE: From project TaskApplication Program.cs\n\nprivate static void UploadFileToContainer(string filePath, string containerSas)\n{\n        string blobName = Path.GetFileName(filePath);\n\n        // Obtain a reference to the container using the SAS URI.\n        CloudBlobContainer container = new CloudBlobContainer(new Uri(containerSas));\n\n        // Upload the file (as a new blob) to the container\n        try\n        {\n                CloudBlockBlob blob = container.GetBlockBlobReference(blobName);\n                blob.UploadFromFile(filePath, FileMode.Open);\n\n                Console.WriteLine(\"Write operation succeeded for SAS URL \" + containerSas);\n                Console.WriteLine();\n        }\n        catch (StorageException e)\n        {\n\n                Console.WriteLine(\"Write operation failed for SAS URL \" + containerSas);\n                Console.WriteLine(\"Additional error information: \" + e.Message);\n                Console.WriteLine();\n\n                // Indicate that a failure has occurred so that when the Batch service sets the\n                // CloudTask.ExecutionInformation.ExitCode for the task that executed this application,\n                // it properly indicates that there was a problem with the task.\n                Environment.ExitCode = -1;\n        }\n}\n```\n\n## 步骤 6：监视任务\n\n![监视任务][6]<br/>\n*客户端应用程序将会：(1) 监视任务的完成和成功状态，(2) 监视将结果数据上载到 Azure 存储空间的任务*\n\n任务在添加到作业后，将自动排入队列并计划在与作业关联的池中的计算节点上执行。根据你指定的设置，Batch 将为你处理所有任务排队、计划、重试和其他任务管理工作。监视任务执行的方法有许多种 - DotNetTutorial 显示了一个只报告完成状态以及任务或成功状态的简单示例。\n\nDotNetTutorial 的 `Program.cs` 中的 `MonitorTasks` 方法内有三个 Batch .NET 概念值得讨论，下面按出现顺序列出了这些概念：\n\n1. **ODATADetailLevel** - 必须在列出操作（例如获取作业的任务列表）中指定 [ODATADetailLevel][net_odatadetaillevel]，以确保 Batch 应用程序的性能。如果你打算在 Batch 应用程序中进行任何类型的状态监视，请将[有效地查询 Azure Batch 服务](batch-efficient-list-queries.md)加入你的阅读列表。\n\n2. **TaskStateMonitor** - [TaskStateMonitor][net_taskstatemonitor] 为 Batch .NET 应用程提供用于监视任务状态的帮助器实用程序。在 `MonitorTasks` 中， *DotNetTutorial* 将等待所有任务在时限内达到 [TaskState.Completed][net_taskstate]，然后终止作业。\n\n3. **TerminateJobAsync** - 通过 [JobOperations.TerminateJobAsync][net_joboperations_terminatejob] 终止作业（或阻止 JobOperations.TerminateJob）会将该作业标记为已完成。如果 Batch 解决方案使用 [JobReleaseTask][net_jobreltask]，则你必须这样做。如[作业准备和完成任务](batch-job-prep-release)中所述，这是一种特殊的任务类型。\n\n*DotNetTutorial* 的 `Program.cs` 中的 `MonitorTasks` 方法如下所示：\n\n```\nprivate static async Task<bool> MonitorTasks(BatchClient batchClient, string jobId, TimeSpan timeout)\n{\n    bool allTasksSuccessful = true;\n    const string successMessage = \"All tasks reached state Completed.\";\n    const string failureMessage = \"One or more tasks failed to reach the Completed state within the timeout period.\";\n\n    // Obtain the collection of tasks currently managed by the job. Note that we use a detail level to\n    // specify that only the \"id\" property of each task should be populated. Using a detail level for\n    // all list operations helps to lower response time from the Batch service.\n    ODATADetailLevel detail = new ODATADetailLevel(selectClause: \"id\");\n    List<CloudTask> tasks = await batchClient.JobOperations.ListTasks(JobId, detail).ToListAsync();\n\n    Console.WriteLine(\"Awaiting task completion, timeout in {0}...\", timeout.ToString());\n\n    // We use a TaskStateMonitor to monitor the state of our tasks. In this case, we will wait for all tasks to\n    // reach the Completed state.\n    TaskStateMonitor taskStateMonitor = batchClient.Utilities.CreateTaskStateMonitor();\n    bool timedOut = await taskStateMonitor.WaitAllAsync(tasks, TaskState.Completed, timeout);\n\n    if (timedOut)\n    {\n        allTasksSuccessful = false;\n\n        await batchClient.JobOperations.TerminateJobAsync(jobId, failureMessage);\n\n        Console.WriteLine(failureMessage);\n    }\n    else\n    {\n        await batchClient.JobOperations.TerminateJobAsync(jobId, successMessage);\n\n        // All tasks have reached the \"Completed\" state, however, this does not guarantee all tasks completed successfully.\n        // Here we further check each task's ExecutionInfo property to ensure that it did not encounter a scheduling error\n        // or return a non-zero exit code.\n\n        // Update the detail level to populate only the task id and executionInfo properties.\n        // We refresh the tasks below, and need only this information for each task.\n        detail.SelectClause = \"id, executionInfo\";\n\n        foreach (CloudTask task in tasks)\n        {\n            // Populate the task's properties with the latest info from the Batch service\n            await task.RefreshAsync(detail);\n\n            if (task.ExecutionInformation.SchedulingError != null)\n            {\n                // A scheduling error indicates a problem starting the task on the node. It is important to note that\n                // the task's state can be \"Completed,\" yet still have encountered a scheduling error.\n\n                allTasksSuccessful = false;\n\n                Console.WriteLine(\"WARNING: Task [{0}] encountered a scheduling error: {1}\", task.Id, task.ExecutionInformation.SchedulingError.Message);\n            }\n            else if (task.ExecutionInformation.ExitCode != 0)\n            {\n                // A non-zero exit code may indicate that the application executed by the task encountered an error\n                // during execution. As not every application returns non-zero on failure by default (e.g. robocopy),\n                // your implementation of error checking may differ from this example.\n\n                allTasksSuccessful = false;\n\n                Console.WriteLine(\"WARNING: Task [{0}] returned a non-zero exit code - this may indicate task execution or completion failure.\", task.Id);\n            }\n        }\n    }\n\n    if (allTasksSuccessful)\n    {\n        Console.WriteLine(\"Success! All tasks completed successfully within the specified timeout period.\");\n    }\n\n    return allTasksSuccessful;\n}\n```\n\n## 步骤 7：下载任务输出\n\n![从存储空间下载任务输出][7]\n\n完成作业后，可以从 Azure 存储空间下载任务的输出。可以在 *DotNetTutorial* 的 `Program.cs` 中调用 `DownloadBlobsFromContainerAsync` 来实现此目的：\n\n```\nprivate static async Task DownloadBlobsFromContainerAsync(CloudBlobClient blobClient, string containerName, string directoryPath)\n{\n        Console.WriteLine(\"Downloading all files from container [{0}]...\", containerName);\n\n        // Retrieve a reference to a previously created container\n        CloudBlobContainer container = blobClient.GetContainerReference(containerName);\n\n        // Get a flat listing of all the block blobs in the specified container\n        foreach (IListBlobItem item in container.ListBlobs(prefix: null, useFlatBlobListing: true))\n        {\n                // Retrieve reference to the current blob\n                CloudBlob blob = (CloudBlob)item;\n\n                // Save blob contents to a file in the specified folder\n                string localOutputFile = Path.Combine(directoryPath, blob.Name);\n                await blob.DownloadToFileAsync(localOutputFile, FileMode.Create);\n        }\n\n        Console.WriteLine(\"All files downloaded to {0}\", directoryPath);\n}\n```\n\n> [AZURE.NOTE] 对 *DotNetTutorial* 应用程序中 `DownloadBlobsFromContainerAsync` 的调用可以指定应将文件下载到 `%TEMP%` 文件夹。可以随意修改此输出位置。\n\n## 步骤 8：删除容器\n\n由于你需要对位于 Azure 存储空间中的数据付费，因此我们建议删除 Batch 作业不再需要的所有 Blob。在 DotNetTutorial 的 `Program.cs` 中，调用帮助器方法 `DeleteContainerAsync` 三次即可实现此目的：\n\n```\n// Clean up Storage resources\nawait DeleteContainerAsync(blobClient, appContainerName);\nawait DeleteContainerAsync(blobClient, inputContainerName);\nawait DeleteContainerAsync(blobClient, outputContainerName);\n```\n\n该方法本身只获取对容器的引用，然后调用 [CloudBlobContainer.DeleteIfExistsAsync][net_container_delete]：\n\n```\nprivate static async Task DeleteContainerAsync(CloudBlobClient blobClient, string containerName)\n{\n    CloudBlobContainer container = blobClient.GetContainerReference(containerName);\n\n    if (await container.DeleteIfExistsAsync())\n    {\n        Console.WriteLine(\"Container [{0}] deleted.\", containerName);\n    }\n    else\n    {\n        Console.WriteLine(\"Container [{0}] does not exist, skipping deletion.\", containerName);\n    }\n}\n```\n\n## 步骤 9：删除作业和池\n\n在最后一个步骤，系统将提示用户删除 DotNetTutorial 应用程序创建的作业和池。尽管你不需要支付作业和任务本身的费用，但 *需要* 支付计算节点的费用。因此，我们建议只在必要时才分配节点，并在维护过程中删除未使用的池。\n\nBatchClient 的 [JobOperations][net_joboperations] 和 [PoolOperations][net_pooloperations] 都有对应的删除方法（在用户确认删除时调用）：\n\n```\n// Clean up the resources we've created in the Batch account if the user so chooses\nConsole.WriteLine();\nConsole.WriteLine(\"Delete job? [yes] no\");\nstring response = Console.ReadLine().ToLower();\nif (response != \"n\" && response != \"no\")\n{\n    await batchClient.JobOperations.DeleteJobAsync(JobId);\n}\n\nConsole.WriteLine(\"Delete pool? [yes] no\");\nresponse = Console.ReadLine();\nif (response != \"n\" && response != \"no\")\n{\n    await batchClient.PoolOperations.DeletePoolAsync(PoolId);\n}\n```\n\n> [AZURE.IMPORTANT] 请记住，你需要支付计算资源的费用，而删除未使用的池可将费用降到最低。另请注意，删除池也会删除该池内的所有计算节点，并且删除池后，将无法恢复节点上的任何数据。\n\n## 运行 *DotNetTutorial* 示例\n\n当你运行示例应用程序时，控制台输出如下所示。在执行期间启动池的计算节点时，你将会遇到暂停并看到`Awaiting task completion, timeout in 00:30:00...`。在执行期间和之后，可以使用 [Batch 资源管理器][github_batchexplorer]来监视池、计算节点、作业和任务。使用 [Azure 门户][azure_portal]或某个可用的 [Azure 存储空间资源管理器][storage_explorers]来查看应用程序创建的存储资源（容器和 Blob）。\n\n以默认配置运行应用程序时，典型的执行时间**大约为 5 分钟**。\n\n```\nSample start: 1/8/2016 09:42:58 AM\n\nContainer [application] created.\nContainer [input] created.\nContainer [output] created.\nUploading file C:\\repos\\azure-batch-samples\\CSharp\\ArticleProjects\\DotNetTutorial\\bin\\Debug\\TaskApplication.exe to container [application]...\nUploading file Microsoft.WindowsAzure.Storage.dll to container [application]...\nUploading file ..\\..\\taskdata1.txt to container [input]...\nUploading file ..\\..\\taskdata2.txt to container [input]...\nUploading file ..\\..\\taskdata3.txt to container [input]...\nCreating pool [DotNetTutorialPool]...\nCreating job [DotNetTutorialJob]...\nAdding 3 tasks to job [DotNetTutorialJob]...\nAwaiting task completion, timeout in 00:30:00...\nSuccess! All tasks completed successfully within the specified timeout period.\nDownloading all files from container [output]...\nAll files downloaded to C:\\Users\\USERNAME\\AppData\\Local\\Temp\nContainer [application] deleted.\nContainer [input] deleted.\nContainer [output] deleted.\n\nSample end: 1/8/2016 09:47:47 AM\nElapsed time: 00:04:48.5358142\n\nDelete job? [yes] no: yes\nDelete pool? [yes] no: yes\n\nSample complete, hit ENTER to exit...\n```\n\n## 后续步骤\n\n你可以随意更改 *DotNetTutorial* 和 *TaskApplication* ，以体验不同的计算方案。尝试将执行延迟添加到 *TaskApplication* （例如使用 [Thread.Sleep][net_thread_sleep]），以模拟长时间运行的任务并使用 Batch 资源管理器的“热图”功能监视这些任务。尝试添加更多任务，或调整计算节点的数目。添加逻辑来检查并允许使用现有的池加速执行时间（ *提示* ：请查看 [azure-batch-samples][github_samples] 中 [Microsoft.Azure.Batch.Samples.Common][github_samples_common] 项目的 `ArticleHelpers.cs`）。\n\n熟悉 Batch 解决方案的基本工作流后，接下来可以深入了解 Batch 服务的其他功能。\n\n- [Azure Batch 功能概述](batch-api-basics.md) - 此文概述了 Batch 的许多功能，建议 Batch 服务的新手阅读。\n- 从 [Batch 学习路径][batch_learning_path]中**有关开发的深度知识**下面列出的其他 Batch 开发文章着手。\n- 通过 [TopNWords][github_topnwords] 示例了解有关使用 Batch 处理“前 N 个单词”工作负荷的不同实现方式。\n\n[azure_batch]: https://azure.microsoft.com/services/batch/\n[azure_portal]: https://portal.azure.com\n[batch_explorer_blog]: http://blogs.technet.com/b/windowshpc/archive/2015/01/20/azure-batch-explorer-sample-walkthrough.aspx\n[batch_learning_path]: https://azure.microsoft.com/documentation/learning-paths/batch/\n[github_batchexplorer]: https://github.com/Azure/azure-batch-samples/tree/master/CSharp/BatchExplorer\n[github_dotnettutorial]: https://github.com/Azure/azure-batch-samples/tree/master/CSharp/ArticleProjects/DotNetTutorial\n[github_samples]: https://github.com/Azure/azure-batch-samples\n[github_samples_common]: https://github.com/Azure/azure-batch-samples/tree/master/CSharp/Common\n[github_samples_zip]: https://github.com/Azure/azure-batch-samples/archive/master.zip\n[github_topnwords]: https://github.com/Azure/azure-batch-samples/tree/master/CSharp/TopNWords\n[net_api]: http://msdn.microsoft.com/library/azure/mt348682.aspx\n[net_api_storage]: https://msdn.microsoft.com/library/azure/mt347887.aspx\n[net_batchclient]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.batchclient.aspx\n[net_job]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudjob.aspx\n[net_job_poolinfo]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.protocol.models.cloudjob.poolinformation.aspx\n[net_joboperations]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.batchclient.joboperations\n[net_joboperations_terminatejob]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.joboperations.terminatejobasync.aspx\n[net_jobpreptask]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudjob.jobpreparationtask.aspx\n[net_jobreltask]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudjob.jobreleasetask.aspx\n[net_node]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.computenode.aspx\n[net_odatadetaillevel]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.odatadetaillevel.aspx\n[net_pool]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.aspx\n[net_pool_create]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.createpool.aspx\n[net_pool_starttask]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.starttask.aspx\n[net_pooloperations]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.batchclient.pooloperations\n[net_resourcefile]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.resourcefile.aspx\n[net_resourcefile_blobsource]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.resourcefile.blobsource.aspx\n[net_sas_blob]: https://msdn.microsoft.com/library/azure/microsoft.windowsazure.storage.blob.cloudblob.getsharedaccesssignature.aspx\n[net_sas_container]: https://msdn.microsoft.com/library/azure/microsoft.windowsazure.storage.blob.cloudblobcontainer.getsharedaccesssignature.aspx\n[net_task]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudtask.aspx\n[net_task_resourcefiles]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudtask.resourcefiles.aspx\n[net_taskstate]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.common.taskstate.aspx\n[net_taskstatemonitor]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.taskstatemonitor.aspx\n[net_thread_sleep]: https://msdn.microsoft.com/library/274eh01d(v=vs.110).aspx\n[net_cloudblobclient]: https://msdn.microsoft.com/library/microsoft.windowsazure.storage.blob.cloudblobclient.aspx\n[net_cloudblobcontainer]: https://msdn.microsoft.com/library/microsoft.windowsazure.storage.blob.cloudblobcontainer.aspx\n[net_cloudstorageaccount]: https://msdn.microsoft.com/library/azure/microsoft.windowsazure.storage.cloudstorageaccount.aspx\n[net_container_delete]: https://msdn.microsoft.com/library/microsoft.windowsazure.storage.blob.cloudblobcontainer.deleteifexistsasync.aspx\n[nuget_packagemgr]: https://visualstudiogallery.msdn.microsoft.com/27077b70-9dad-4c64-adcf-c7cf6bc9970c\n[nuget_restore]: https://docs.nuget.org/consume/package-restore/msbuild-integrated#enabling-package-restore-during-build\n[storage_explorers]: http://blogs.msdn.com/b/windowsazurestorage/archive/2014/03/11/windows-azure-storage-explorers-2014.aspx\n[visual_studio]: https://www.visualstudio.com/products/vs-2015-product-editions\n\n[1]: ./media/batch-dotnet-get-started/batch_workflow_01_sm.png \"在 Azure 存储空间中创建容器\"\n[2]: ./media/batch-dotnet-get-started/batch_workflow_02_sm.png \"将任务应用程序和输入（数据）文件上载到容器\"\n[3]: ./media/batch-dotnet-get-started/batch_workflow_03_sm.png \"创建 Batch 池\"\n[4]: ./media/batch-dotnet-get-started/batch_workflow_04_sm.png \"创建 Batch 作业\"\n[5]: ./media/batch-dotnet-get-started/batch_workflow_05_sm.png \"将任务添加到作业\"\n[6]: ./media/batch-dotnet-get-started/batch_workflow_06_sm.png \"监视任务\"\n[7]: ./media/batch-dotnet-get-started/batch_workflow_07_sm.png \"从存储空间下载任务输出\"\n[8]: ./media/batch-dotnet-get-started/batch_workflow_sm.png \"Batch 解决方案工作流（完整流程图）\"\n[9]: ./media/batch-dotnet-get-started/credentials_batch_sm.png \"门户中的 Batch 凭据\"\n[10]: ./media/batch-dotnet-get-started/credentials_storage_sm.png \"门户中的存储空间凭据\"\n[11]: ./media/batch-dotnet-get-started/batch_workflow_minimal_sm.png \"Batch 解决方案工作流（精简流程图）\"\n\n<!---HONumber=Mooncake_0215_2016-->"
}