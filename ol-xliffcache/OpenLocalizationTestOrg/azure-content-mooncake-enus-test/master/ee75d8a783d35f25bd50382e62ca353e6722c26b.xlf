<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ee75d8a783d35f25bd50382e62ca353e6722c26b</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>在 Azure 中使用 TFS 持续交付云服务 | Azure</source>
          <target state="new">在 Azure 中使用 TFS 持续交付云服务 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何设置 Azure 云应用程序的持续交付。MSBuild 命令行语句和 PowerShell 脚本的代码示例。</source>
          <target state="new">了解如何设置 Azure 云应用程序的持续交付。MSBuild 命令行语句和 PowerShell 脚本的代码示例。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>在 Azure 中持续交付云服务</source>
          <target state="new">在 Azure 中持续交付云服务</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>本文中所述过程向你演示如何设置对 Azure 云应用程序的持续交付。此过程使你能够在签入每个代码后，自动创建服务包并将其部署到 Azure。本文中介绍的包生成过程与 Visual Studio 中的 <bpt id="p1">**</bpt>Package<ept id="p1">**</ept> 命令等效，而发布步骤与 Visual Studio 中的 <bpt id="p2">**</bpt>Publish<ept id="p2">**</ept> 命令等效。本文包含用于创建生成服务器的方法以及 MSBuild 命令行语句和 Windows PowerShell 脚本，并演示了如何选择性地配置 Visual Studio Team Foundation Server - Team Build 定义以使用 MSBuild 命令和 PowerShell 脚本。可针对你的生成环境和 Azure 目标环境自定义此过程。</source>
          <target state="new">本文中所述过程向你演示如何设置对 Azure 云应用程序的持续交付。此过程使你能够在签入每个代码后，自动创建服务包并将其部署到 Azure。本文中介绍的包生成过程与 Visual Studio 中的 <bpt id="p1">**</bpt>Package<ept id="p1">**</ept> 命令等效，而发布步骤与 Visual Studio 中的 <bpt id="p2">**</bpt>Publish<ept id="p2">**</ept> 命令等效。本文包含用于创建生成服务器的方法以及 MSBuild 命令行语句和 Windows PowerShell 脚本，并演示了如何选择性地配置 Visual Studio Team Foundation Server - Team Build 定义以使用 MSBuild 命令和 PowerShell 脚本。可针对你的生成环境和 Azure 目标环境自定义此过程。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>你也可以使用 Visual Studio Team Services（Azure 中托管的 TFS 版本）更轻松地实现此目的。有关详细信息，请参阅<bpt id="p1">[</bpt>使用 Visual Studio Team Services 向 Azure 持续传送项目<ept id="p1">][]</ept>。</source>
          <target state="new">你也可以使用 Visual Studio Team Services（Azure 中托管的 TFS 版本）更轻松地实现此目的。有关详细信息，请参阅<bpt id="p1">[</bpt>使用 Visual Studio Team Services 向 Azure 持续传送项目<ept id="p1">][]</ept>。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>开始之前，您应从 Visual Studio 中发布应用程序。这将确保所有资源在您尝试实现发布过程的自动化时可用并进行初始化。</source>
          <target state="new">开始之前，您应从 Visual Studio 中发布应用程序。这将确保所有资源在您尝试实现发布过程的自动化时可用并进行初始化。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>步骤 1：配置生成服务器</source>
          <target state="new">步骤 1：配置生成服务器</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>你必须先在生成服务器上安装必需的软件和工具，然后才能使用 MSBuild 创建 Azure 包。</source>
          <target state="new">你必须先在生成服务器上安装必需的软件和工具，然后才能使用 MSBuild 创建 Azure 包。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>无需在生成服务器上安装 Visual Studio。若要使用 Team Foundation 生成服务管理生成服务器，请按照 <bpt id="p1">[</bpt>Team Foundation 生成服务<ept id="p1">][]</ept>文档中的说明操作。</source>
          <target state="new">无需在生成服务器上安装 Visual Studio。若要使用 Team Foundation 生成服务管理生成服务器，请按照 <bpt id="p1">[</bpt>Team Foundation 生成服务<ept id="p1">][]</ept>文档中的说明操作。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>在生成服务器上，安装包含 MSBuild 的 <bpt id="p1">[</bpt>.NET Framework 4.5.2<ept id="p1">][]</ept>。</source>
          <target state="new">在生成服务器上，安装包含 MSBuild 的 <bpt id="p1">[</bpt>.NET Framework 4.5.2<ept id="p1">][]</ept>。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>安装最新的 <bpt id="p1">[</bpt>Azure Authoring Tools for .NET<ept id="p1">](/develop/net)</ept>。</source>
          <target state="new">安装最新的 <bpt id="p1">[</bpt>Azure Authoring Tools for .NET<ept id="p1">](/develop/net)</ept>。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>安装 <bpt id="p1">[</bpt>Azure Libraries for .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=623519)</ept>。</source>
          <target state="new">安装 <bpt id="p1">[</bpt>Azure Libraries for .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=623519)</ept>。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>将 Microsoft.WebApplication.targets 文件从 Visual Studio 安装复制到生成服务器。</source>
          <target state="new">将 Microsoft.WebApplication.targets 文件从 Visual Studio 安装复制到生成服务器。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>在已安装 Visual Studio 的计算机上，此文件位于目录 C:\\Program Files(x86)\\MSBuild\\Microsoft\\VisualStudio\\v14.0\\WebApplications。您应将该文件复制到生成服务器上的同一目录中。</source>
          <target state="new">在已安装 Visual Studio 的计算机上，此文件位于目录 C:\\Program Files(x86)\\MSBuild\\Microsoft\\VisualStudio\\v14.0\\WebApplications。您应将该文件复制到生成服务器上的同一目录中。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>安装 <bpt id="p1">[</bpt>Azure Tools for Visual Studio<ept id="p1">](https://www.visualstudio.com/features/azure-tools-vs.aspx)</ept>。</source>
          <target state="new">安装 <bpt id="p1">[</bpt>Azure Tools for Visual Studio<ept id="p1">](https://www.visualstudio.com/features/azure-tools-vs.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>步骤 2：使用 MSBuild 命令生成包</source>
          <target state="new">步骤 2：使用 MSBuild 命令生成包</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>本部分介绍如何构造用于生成 Azure 包的 MSBuild 命令。在生成服务器上执行此步骤可确认所有内容配置正确并且 MSBuild 命令起到预期作用。你可将此命令行添加到生成服务器上的现有生成脚本中，也可在 TFS 生成定义中使用此命令行，如下一部分所述。有关命令行参数和 MSBuild 的详细信息，请参阅 <bpt id="p1">[</bpt>MSBuild 命令行参考<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/ms164311%28v=vs.140%29.aspx)</ept>。</source>
          <target state="new">本部分介绍如何构造用于生成 Azure 包的 MSBuild 命令。在生成服务器上执行此步骤可确认所有内容配置正确并且 MSBuild 命令起到预期作用。你可将此命令行添加到生成服务器上的现有生成脚本中，也可在 TFS 生成定义中使用此命令行，如下一部分所述。有关命令行参数和 MSBuild 的详细信息，请参阅 <bpt id="p1">[</bpt>MSBuild 命令行参考<ept id="p1">](https://msdn.microsoft.com/zh-cn/library/ms164311%28v=vs.140%29.aspx)</ept>。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>如果在生成服务器上安装了 Visual Studio，请在 Windows 上的“Visual Studio 工具”文件夹中找到并选择“Visual Studio 命令提示符”。</source>
          <target state="new">如果在生成服务器上安装了 Visual Studio，请在 Windows 上的“Visual Studio 工具”文件夹中找到并选择“Visual Studio 命令提示符”。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>如果未在生成服务器上安装 Visual Studio，则请打开命令提示符并确保可按相应的路径访问 MSBuild.exe。MSBuild 与 .NET Framework 一起安装在路径 %WINDIR%\\Microsoft.NET\\Framework\*版本* 中。例如，若要在已安装 .NET Framework 4 的情况下将 MSBuild.exe 添加到 PATH 环境变量，请在命令提示符处键入以下命令：</source>
          <target state="new">如果未在生成服务器上安装 Visual Studio，则请打开命令提示符并确保可按相应的路径访问 MSBuild.exe。MSBuild 与 .NET Framework 一起安装在路径 %WINDIR%\\Microsoft.NET\\Framework\*版本* 中。例如，若要在已安装 .NET Framework 4 的情况下将 MSBuild.exe 添加到 PATH 环境变量，请在命令提示符处键入以下命令：</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>在命令提示符处，导航到包含要生成的 Azure 项目文件的文件夹。</source>
          <target state="new">在命令提示符处，导航到包含要生成的 Azure 项目文件的文件夹。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>将 MSBuild 与 /target:Publish 选项一起运行，如以下示例所示：</source>
          <target state="new">将 MSBuild 与 /target:Publish 选项一起运行，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>此选项可缩写为 /t:Publish。安装 Azure SDK 后，MSBuild 中的 /t:Publish 选项不应与 Visual Studio 中的可用 Publish 命令混淆。/t:Publish 选项仅生成 Azure 包。其部署包的方式与 Visual Studio 中的 Publish 命令部署包的方式不同。</source>
          <target state="new">此选项可缩写为 /t:Publish。安装 Azure SDK 后，MSBuild 中的 /t:Publish 选项不应与 Visual Studio 中的可用 Publish 命令混淆。/t:Publish 选项仅生成 Azure 包。其部署包的方式与 Visual Studio 中的 Publish 命令部署包的方式不同。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>您也可以将项目名称指定为 MSBuild 参数。如果未指定，则将使用当前目录。有关 MSBuild 命令行选项的详细信息，请参阅 [MSBuild 命令行参考][1]。</source>
          <target state="new">您也可以将项目名称指定为 MSBuild 参数。如果未指定，则将使用当前目录。有关 MSBuild 命令行选项的详细信息，请参阅 [MSBuild 命令行参考][1]。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>查找输出。默认情况下，此命令将创建与项目的根文件夹相关的目录，例如 <bpt id="p1">*</bpt>ProjectDir<ept id="p1">*</ept>\\bin\\<bpt id="p2">*</bpt>Configuration<ept id="p2">*</ept>\\app.publish\\。在生成 Azure 项目时，将生成两个文件，即包文件本身和附带的配置文件：</source>
          <target state="new">查找输出。默认情况下，此命令将创建与项目的根文件夹相关的目录，例如 <bpt id="p1">*</bpt>ProjectDir<ept id="p1">*</ept>\\bin\\<bpt id="p2">*</bpt>Configuration<ept id="p2">*</ept>\\app.publish\\。在生成 Azure 项目时，将生成两个文件，即包文件本身和附带的配置文件：</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Project.cspkg</source>
          <target state="new">Project.cspkg</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>ServiceConfiguration.<bpt id="p1">*</bpt>TargetProfile<ept id="p1">*</ept>.cscfg</source>
          <target state="new">ServiceConfiguration.<bpt id="p1">*</bpt>TargetProfile<ept id="p1">*</ept>.cscfg</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>默认情况下，每个 Azure 项目均包含两个服务配置文件（.cscfg 文件），这两个文件分别针对本地（调试）生成和云（过渡或生产）生成，你可根据需要添加或删除服务配置文件。在 Visual Studio 中生成包时，系统会询问您要将哪个服务配置文件与包一起包含。</source>
          <target state="new">默认情况下，每个 Azure 项目均包含两个服务配置文件（.cscfg 文件），这两个文件分别针对本地（调试）生成和云（过渡或生产）生成，你可根据需要添加或删除服务配置文件。在 Visual Studio 中生成包时，系统会询问您要将哪个服务配置文件与包一起包含。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>指定服务配置文件。使用 MSBuild 生成包时，默认情况下将包含本地服务配置文件。若要包含其他服务配置文件，请设置 MSBuild 命令的 TargetProfile 属性，如以下示例所示：</source>
          <target state="new">指定服务配置文件。使用 MSBuild 生成包时，默认情况下将包含本地服务配置文件。若要包含其他服务配置文件，请设置 MSBuild 命令的 TargetProfile 属性，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>指定输出的位置。使用 /p:PublishDir=<bpt id="p1">*</bpt>Directory<ept id="p1">*</ept>\\ 选项设置路径，包含尾随反斜杠分隔符，如以下示例所示：</source>
          <target state="new">指定输出的位置。使用 /p:PublishDir=<bpt id="p1">*</bpt>Directory<ept id="p1">*</ept>\\ 选项设置路径，包含尾随反斜杠分隔符，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>构造并测试相应的 MSBuild 命令行以生成项目并将其并入一个 Azure 包后，你可将此命令行添加到生成脚本中。如果生成服务器使用自定义脚本，则此过程将依赖自定义生成过程的细节。如果你要将 TFS 用作生成环境，则可按照下一步中的说明操作来将 Azure 包生成添加到生成过程中。</source>
          <target state="new">构造并测试相应的 MSBuild 命令行以生成项目并将其并入一个 Azure 包后，你可将此命令行添加到生成脚本中。如果生成服务器使用自定义脚本，则此过程将依赖自定义生成过程的细节。如果你要将 TFS 用作生成环境，则可按照下一步中的说明操作来将 Azure 包生成添加到生成过程中。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>步骤 3：使用 TFS Team Build 生成包</source>
          <target state="new">步骤 3：使用 TFS Team Build 生成包</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>如果你已将 Team Foundation Server (TFS) 设置为生成控制器并将生成服务器设置为 TFS 生成计算机，则可以选择为 Azure 包设置自动化生成。有关如何设置 Team Foundation Server 并将其用作生成系统的信息，请参阅<bpt id="p1">[</bpt>扩大生成系统<ept id="p1">][]</ept>。具体而言，以下过程假设你已根据<bpt id="p2">[</bpt>部署和配置生成服务器<ept id="p2">][]</ept>中所述配置了生成服务器，此外，你已创建了一个团队项目并在该团队项目中创建了一个云服务项目。</source>
          <target state="new">如果你已将 Team Foundation Server (TFS) 设置为生成控制器并将生成服务器设置为 TFS 生成计算机，则可以选择为 Azure 包设置自动化生成。有关如何设置 Team Foundation Server 并将其用作生成系统的信息，请参阅<bpt id="p1">[</bpt>扩大生成系统<ept id="p1">][]</ept>。具体而言，以下过程假设你已根据<bpt id="p2">[</bpt>部署和配置生成服务器<ept id="p2">][]</ept>中所述配置了生成服务器，此外，你已创建了一个团队项目并在该团队项目中创建了一个云服务项目。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>若要将 TFS 配置为生成 Azure 包，请执行下列步骤：</source>
          <target state="new">若要将 TFS 配置为生成 Azure 包，请执行下列步骤：</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>在开发计算机上的 Visual Studio 中，从“视图”菜单中选择“团队资源管理器”，或选择 Ctrl+\\、Ctrl+M。在“团队资源管理器”窗口中，展开“生成”节点，或者选择“生成” 页，然后选择“新建生成定义”。</source>
          <target state="new">在开发计算机上的 Visual Studio 中，从“视图”菜单中选择“团队资源管理器”，或选择 Ctrl+\\、Ctrl+M。在“团队资源管理器”窗口中，展开“生成”节点，或者选择“生成” 页，然后选择“新建生成定义”。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>选择“触发器”选项卡，然后为希望生成包的时间指定所需条件。例如，指定“持续集成”可在进行源代码管理签入时生成包。</source>
          <target state="new">选择“触发器”选项卡，然后为希望生成包的时间指定所需条件。例如，指定“持续集成”可在进行源代码管理签入时生成包。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>选择“源设置”选项卡，并确保你的项目文件夹已列在“源代码管理文件夹”列中，并且状态为“活动”。</source>
          <target state="new">选择“源设置”选项卡，并确保你的项目文件夹已列在“源代码管理文件夹”列中，并且状态为“活动”。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>选择“生成默认值”选项卡，并在生成控制器下确认生成服务器的名称。此外，选择“将生成输出复制到以下放置文件夹”选项并指定所需的放置位置。</source>
          <target state="new">选择“生成默认值”选项卡，并在生成控制器下确认生成服务器的名称。此外，选择“将生成输出复制到以下放置文件夹”选项并指定所需的放置位置。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>选择“进程”选项卡。在“进程”选项卡上选择默认模板，在“生成”下选择项目（如果尚未选择），然后展开网格“生成”部分中的“高级”部分。</source>
          <target state="new">选择“进程”选项卡。在“进程”选项卡上选择默认模板，在“生成”下选择项目（如果尚未选择），然后展开网格“生成”部分中的“高级”部分。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>选择“MSBuild 参数”，并按上面步骤 2 中所述设置相应的 MSBuild 命令行参数。例如，输入 *<bpt id="p1">*</bpt>/t:Publish /p:PublishDir=\\\myserver\\drops\*<ept id="p1">*</ept> 可以生成一个包并将包文件复制到位置 \\\myserver\\drops\\：</source>
          <target state="new">选择“MSBuild 参数”，并按上面步骤 2 中所述设置相应的 MSBuild 命令行参数。例如，输入 *<bpt id="p1">*</bpt>/t:Publish /p:PublishDir=\\\myserver\\drops\*<ept id="p1">*</ept> 可以生成一个包并将包文件复制到位置 \\\myserver\\drops\\：</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>注意：<ept id="p1">**</ept>通过将这些文件复制到公共共享，可以更轻松地手动从开发计算机部署包。</source>
          <target state="new"><bpt id="p1">**</bpt>注意：<ept id="p1">**</ept>通过将这些文件复制到公共共享，可以更轻松地手动从开发计算机部署包。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>通过签入对项目的更改来测试生成步骤是否成功或对新生成进行排队。若要对新生成进行排队，请在团队资源管理器中，右键单击“所有生成定义”，然后选择“使新生成入队”。</source>
          <target state="new">通过签入对项目的更改来测试生成步骤是否成功或对新生成进行排队。若要对新生成进行排队，请在团队资源管理器中，右键单击“所有生成定义”，然后选择“使新生成入队”。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>步骤 4：使用 Powershell 脚本发布包</source>
          <target state="new">步骤 4：使用 Powershell 脚本发布包</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>本节介绍如何构造使用可选参数将云应用程序包输出发布到 Azure 的 Windows PowerShell 脚本。在执行自定义生成自动化中的生成步骤后，可以调用此脚本。也可以从 Visual Studio TFS Team Build 中的过程模板工作流活动中调用此脚本。</source>
          <target state="new">本节介绍如何构造使用可选参数将云应用程序包输出发布到 Azure 的 Windows PowerShell 脚本。在执行自定义生成自动化中的生成步骤后，可以调用此脚本。也可以从 Visual Studio TFS Team Build 中的过程模板工作流活动中调用此脚本。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>安装 <bpt id="p1">[</bpt>Azure PowerShell cmdlet<ept id="p1">][]</ept>（v0.6.1 或更高版本）。在 cmdlet 设置阶段，选择作为管理单元安装。请注意，此受支持的正式版本将替代通过 CodePlex 提供的旧版本，尽管早期版本已采用 2.x.x 的形式进行编号。</source>
          <target state="new">安装 <bpt id="p1">[</bpt>Azure PowerShell cmdlet<ept id="p1">][]</ept>（v0.6.1 或更高版本）。在 cmdlet 设置阶段，选择作为管理单元安装。请注意，此受支持的正式版本将替代通过 CodePlex 提供的旧版本，尽管早期版本已采用 2.x.x 的形式进行编号。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>使用“开始”菜单或“开始”页启动 Azure PowerShell。如果通过此方式启动，则将加载 Azure PowerShell cmdlet。</source>
          <target state="new">使用“开始”菜单或“开始”页启动 Azure PowerShell。如果通过此方式启动，则将加载 Azure PowerShell cmdlet。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>在 PowerShell 提示符下，通过输入部分命令 <ph id="ph1">`Get-Azure`</ph>，然后按 Tab 键完成语句，从而验证是否已加载 PowerShell cmdlet。</source>
          <target state="new">在 PowerShell 提示符下，通过输入部分命令 <ph id="ph1">`Get-Azure`</ph>，然后按 Tab 键完成语句，从而验证是否已加载 PowerShell cmdlet。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>重复按 Tab 键应会看到各个 Azure PowerShell 命令。</source>
          <target state="new">重复按 Tab 键应会看到各个 Azure PowerShell 命令。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>通过导入 .publishsettings 文件中的订阅信息来确认你能够连接到 Azure 订阅。</source>
          <target state="new">通过导入 .publishsettings 文件中的订阅信息来确认你能够连接到 Azure 订阅。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>然后输入该命令</source>
          <target state="new">然后输入该命令</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>这会显示有关你的订阅的信息。确认所有内容正确。</source>
          <target state="new">这会显示有关你的订阅的信息。确认所有内容正确。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>将本文末尾提供的脚本模板保存到脚本文件夹，路径为 c:\\scripts\\WindowsAzure\*<bpt id="p1">*</bpt>PublishCloudService.ps1<ept id="p1">*</ept>*。</source>
          <target state="new">将本文末尾提供的脚本模板保存到脚本文件夹，路径为 c:\\scripts\\WindowsAzure\*<bpt id="p1">*</bpt>PublishCloudService.ps1<ept id="p1">*</ept>*。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>查看脚本的参数部分。添加或修改任何默认值。始终可通过传入显式参数来覆盖这些值。</source>
          <target state="new">查看脚本的参数部分。添加或修改任何默认值。始终可通过传入显式参数来覆盖这些值。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>确保已在订阅中创建可通过发布脚本定位的有效云服务和存储帐户。存储帐户（Blob 存储）将用于在创建部署时上载和临时存储部署包和配置文件。</source>
          <target state="new">确保已在订阅中创建可通过发布脚本定位的有效云服务和存储帐户。存储帐户（Blob 存储）将用于在创建部署时上载和临时存储部署包和配置文件。</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>若要创建新的云服务，你可调用此脚本或使用 Azure 管理门户。云服务名称将用作完全限定域名中的前缀，因此该名称必须是唯一的。</source>
          <target state="new">若要创建新的云服务，你可调用此脚本或使用 Azure 管理门户。云服务名称将用作完全限定域名中的前缀，因此该名称必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>若要创建新的存储帐户，你可调用此脚本或使用 Azure 管理门户。存储帐户名称将用作完全限定域名中的前缀，因此该名称必须是唯一的。您可尝试使用与云服务相同的名称。</source>
          <target state="new">若要创建新的存储帐户，你可调用此脚本或使用 Azure 管理门户。存储帐户名称将用作完全限定域名中的前缀，因此该名称必须是唯一的。您可尝试使用与云服务相同的名称。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>直接从 Azure PowerShell 调用脚本，或将此脚本连接到在包生成后进行的主机生成自动化。</source>
          <target state="new">直接从 Azure PowerShell 调用脚本，或将此脚本连接到在包生成后进行的主机生成自动化。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>默认情况下，此脚本将始终删除或替换现有部署（如果检测到这些部署）。这对于从没有用户提示的自动化中启用持续集成是必需的。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>默认情况下，此脚本将始终删除或替换现有部署（如果检测到这些部署）。这对于从没有用户提示的自动化中启用持续集成是必需的。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>示例方案 1：<ept id="p1">**</ept>对服务的过渡环境进行持续部署：</source>
          <target state="new"><bpt id="p1">**</bpt>示例方案 1：<ept id="p1">**</ept>对服务的过渡环境进行持续部署：</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>通常，此操作后跟测试运行验证和 VIP 交换。VIP 交换可通过 Azure 管理门户或使用 Move-Deployment cmdlet 执行。</source>
          <target state="new">通常，此操作后跟测试运行验证和 VIP 交换。VIP 交换可通过 Azure 管理门户或使用 Move-Deployment cmdlet 执行。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>示例方案 2：<ept id="p1">**</ept>对专用测试服务的生产环境进行持续部署</source>
          <target state="new"><bpt id="p1">**</bpt>示例方案 2：<ept id="p1">**</ept>对专用测试服务的生产环境进行持续部署</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>远程桌面：</source>
          <target state="new">远程桌面：</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>如果在 Azure 项目中启用远程桌面，则将需要执行额外的一次性步骤以确保将正确的云服务证书上载到通过此脚本定位的所有云服务中。</source>
          <target state="new">如果在 Azure 项目中启用远程桌面，则将需要执行额外的一次性步骤以确保将正确的云服务证书上载到通过此脚本定位的所有云服务中。</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>查找角色所需的证书指纹值。这些指纹值在云配置文件（即 ServiceConfiguration.Cloud.cscfg）的“证书”部分中可见。此外，在显示选项并查看选定证书时，可在 Visual Studio 的“远程桌面配置”对话框中查看这些指纹值。</source>
          <target state="new">查找角色所需的证书指纹值。这些指纹值在云配置文件（即 ServiceConfiguration.Cloud.cscfg）的“证书”部分中可见。此外，在显示选项并查看选定证书时，可在 Visual Studio 的“远程桌面配置”对话框中查看这些指纹值。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>使用以下 cmdlet 脚本将远程桌面证书作为一次性安装步骤上载：</source>
          <target state="new">使用以下 cmdlet 脚本将远程桌面证书作为一次性安装步骤上载：</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>例如：</source>
          <target state="new">例如：</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>或者，可以导出带私钥的证书文件 PFX，并使用 Azure 管理门户将证书上载到每个目标云服务。阅读以下文章以了解详细信息：[http://msdn.microsoft.com/zh-cn/library/windowsazure/gg443832.aspx][]。</source>
          <target state="new">或者，可以导出带私钥的证书文件 PFX，并使用 Azure 管理门户将证书上载到每个目标云服务。阅读以下文章以了解详细信息：[http://msdn.microsoft.com/zh-cn/library/windowsazure/gg443832.aspx][]。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>升级部署与删除部署 -&gt; 新建部署</source>
          <target state="new">升级部署与删除部署 -&gt; 新建部署</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>默认情况下，此脚本将在未传入参数或显式传递值 1 时执行升级部署 ($enableDeploymentUpgrade = 1)。对于单一实例，此部署相对于完整部署的好处是，花费的时间更少。对于需要高可用性的实例，此部署的好处是，在升级一些实例的同时使其他实例保持运行（检查更新域）且不会删除您的 VIP。</source>
          <target state="new">默认情况下，此脚本将在未传入参数或显式传递值 1 时执行升级部署 ($enableDeploymentUpgrade = 1)。对于单一实例，此部署相对于完整部署的好处是，花费的时间更少。对于需要高可用性的实例，此部署的好处是，在升级一些实例的同时使其他实例保持运行（检查更新域）且不会删除您的 VIP。</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>可使用脚本 ($enableDeploymentUpgrade = 0) 或将 <bpt id="p1">*</bpt>-enableDeploymentUpgrade 0<ept id="p1">*</ept> 作为参数传递（这会将脚本行为更改为首先删除任何现有部署，然后创建新的部署）来禁用升级部署。</source>
          <target state="new">可使用脚本 ($enableDeploymentUpgrade = 0) 或将 <bpt id="p1">*</bpt>-enableDeploymentUpgrade 0<ept id="p1">*</ept> 作为参数传递（这会将脚本行为更改为首先删除任何现有部署，然后创建新的部署）来禁用升级部署。</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.IMPORTANT]</ph>默认情况下，此脚本将始终删除或替换现有部署（如果检测到这些部署）。这对于从没有用户/操作员提示的自动化中启用持续集成是必需的。</source>
          <target state="new"><ph id="ph1">[AZURE.IMPORTANT]</ph>默认情况下，此脚本将始终删除或替换现有部署（如果检测到这些部署）。这对于从没有用户/操作员提示的自动化中启用持续集成是必需的。</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>步骤 5：使用 TFS Team Build 发布包</source>
          <target state="new">步骤 5：使用 TFS Team Build 发布包</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>此可选步骤会将 TFS Team Build 连接到步骤 4 中创建的脚本，这将其处理将包生成发布到 Azure 的过程。这就需要修改生成定义所使用的过程模板，使其在工作流结束时运行 Publish 活动。Publish 活动将执行从生成传入参数的 PowerShell 命令。MSBuild 目标和发布脚本的输出将传送到标准生成输出中。</source>
          <target state="new">此可选步骤会将 TFS Team Build 连接到步骤 4 中创建的脚本，这将其处理将包生成发布到 Azure 的过程。这就需要修改生成定义所使用的过程模板，使其在工作流结束时运行 Publish 活动。Publish 活动将执行从生成传入参数的 PowerShell 命令。MSBuild 目标和发布脚本的输出将传送到标准生成输出中。</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>编辑负责持续部署的生成定义。</source>
          <target state="new">编辑负责持续部署的生成定义。</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>选择“进程”选项卡。</source>
          <target state="new">选择“进程”选项卡。</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>按照<bpt id="p1">[</bpt>这些说明<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/dd647551.aspx)</ept>添加生成过程模板的活动项目，下载默认模板，将其添加到项目并将其签入。为生成过程模板指定新名称，如 AzureBuildProcessTemplate。</source>
          <target state="new">按照<bpt id="p1">[</bpt>这些说明<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/dd647551.aspx)</ept>添加生成过程模板的活动项目，下载默认模板，将其添加到项目并将其签入。为生成过程模板指定新名称，如 AzureBuildProcessTemplate。</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>返回到“进程”选项卡，然后使用“显示详细信息”显示可用生成过程模板的列表。选择“新建...”按钮，然后导航到你刚刚添加并签入的项目。找到刚刚创建的模板，然后选择“确定”。</source>
          <target state="new">返回到“进程”选项卡，然后使用“显示详细信息”显示可用生成过程模板的列表。选择“新建...”按钮，然后导航到你刚刚添加并签入的项目。找到刚刚创建的模板，然后选择“确定”。</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>打开选定的过程模板以进行编辑。可以直接在工作流设计器或 XML 编辑器中打开以处理 XAML。</source>
          <target state="new">打开选定的过程模板以进行编辑。可以直接在工作流设计器或 XML 编辑器中打开以处理 XAML。</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>在工作流设计器的参数选项卡中将以下一系列新参数作为单独的行项添加。所有参数应具有 direction=In 和 type=String。这两个值将用于将参数从生成定义流入工作流中，然后用于调用发布脚本。</source>
          <target state="new">在工作流设计器的参数选项卡中将以下一系列新参数作为单独的行项添加。所有参数应具有 direction=In 和 type=String。这两个值将用于将参数从生成定义流入工作流中，然后用于调用发布脚本。</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>相应的 XAML 与下面类似：</source>
          <target state="new">相应的 XAML 与下面类似：</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>在“在代理上运行”结束时添加一个新的序列：</source>
          <target state="new">在“在代理上运行”结束时添加一个新的序列：</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>首先，通过添加 If 语句活动来检查有效的脚本文件。将条件设置为此值：</source>
          <target state="new">首先，通过添加 If 语句活动来检查有效的脚本文件。将条件设置为此值：</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>在 If 语句的 Then 事例中，添加一个新的 Sequence 活动。将显示名称设置为 'Start publish'</source>
          <target state="new">在 If 语句的 Then 事例中，添加一个新的 Sequence 活动。将显示名称设置为 'Start publish'</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>在 Start publish 序列仍处于选定状态的情况下，在工作流设计器的变量选项卡中将以下一系列新变量作为单独的行项添加。所有变量应具有 Variable type =String 和 Scope=Start publish。这两个值将用于将参数从生成定义流入工作流中，然后用于调用发布脚本。</source>
          <target state="new">在 Start publish 序列仍处于选定状态的情况下，在工作流设计器的变量选项卡中将以下一系列新变量作为单独的行项添加。所有变量应具有 Variable type =String 和 Scope=Start publish。这两个值将用于将参数从生成定义流入工作流中，然后用于调用发布脚本。</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>String 类型的 SubscriptionDataFilePath</source>
          <target state="new">String 类型的 SubscriptionDataFilePath</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>String 类型的 PublishScriptFilePath</source>
          <target state="new">String 类型的 PublishScriptFilePath</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>如果你使用的是 TFS 2012 或更低版本，请在新序列的开头添加一个 ConvertWorkspaceItem 活动。如果你使用的是 TFS 2013 或更高版本，请在新序列的开头添加一个 GetLocalPath 活动。对于 ConvertWorkspaceItem，请按如下所示设置属性：Direction=ServerToLocal, DisplayName='Convert publish script filename', Input=' PublishScriptLocation', Result='PublishScriptFilePath', Workspace='Workspace'。对于 GetLocalPath 活动，请将属性 IncomingPath 设置为“PublishScriptLocation”，将 Result 设置为“PublishScriptFilePath”。此活动将发布脚本的路径从 TFS 服务器位置（如果适用）转换为标准本地磁盘路径。</source>
          <target state="new">如果你使用的是 TFS 2012 或更低版本，请在新序列的开头添加一个 ConvertWorkspaceItem 活动。如果你使用的是 TFS 2013 或更高版本，请在新序列的开头添加一个 GetLocalPath 活动。对于 ConvertWorkspaceItem，请按如下所示设置属性：Direction=ServerToLocal, DisplayName='Convert publish script filename', Input=' PublishScriptLocation', Result='PublishScriptFilePath', Workspace='Workspace'。对于 GetLocalPath 活动，请将属性 IncomingPath 设置为“PublishScriptLocation”，将 Result 设置为“PublishScriptFilePath”。此活动将发布脚本的路径从 TFS 服务器位置（如果适用）转换为标准本地磁盘路径。</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>如果你使用的是 TFS 2012 或更低版本，请在新序列的末尾添加另一个 ConvertWorkspaceItem 活动。Direction=ServerToLocal, DisplayName='Convert subscription filename', Input=' SubscriptionDataFileLocation', Result= 'SubscriptionDataFilePath', Workspace='Workspace'。如果你使用的是 TFS 2013 或更高版本，请添加另一个 GetLocalPath。IncomingPath='SubscriptionDataFileLocation' 和 Result='SubscriptionDataFilePath'。</source>
          <target state="new">如果你使用的是 TFS 2012 或更低版本，请在新序列的末尾添加另一个 ConvertWorkspaceItem 活动。Direction=ServerToLocal, DisplayName='Convert subscription filename', Input=' SubscriptionDataFileLocation', Result= 'SubscriptionDataFilePath', Workspace='Workspace'。如果你使用的是 TFS 2013 或更高版本，请添加另一个 GetLocalPath。IncomingPath='SubscriptionDataFileLocation' 和 Result='SubscriptionDataFilePath'。</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>在新的 Sequence 的末尾添加一个 InvokeProcess 活动。此活动使用生成定义传入的参数调用 PowerShell.exe。</source>
          <target state="new">在新的 Sequence 的末尾添加一个 InvokeProcess 活动。此活动使用生成定义传入的参数调用 PowerShell.exe。</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Arguments = String.Format(" -File ""{0}"" -serviceName {1} -storageAccountName {2} -packageLocation ""{3}"" -cloudConfigLocation ""{4}"" -subscriptionDataFile ""{5}"" -selectedSubscription {6} -environment ""{7}""", PublishScriptFilePath, ServiceName, StorageAccountName, PackageLocation, CloudConfigLocation, SubscriptionDataFilePath, SubscriptionName, Environment)</source>
          <target state="new">Arguments = String.Format(" -File ""{0}"" -serviceName {1} -storageAccountName {2} -packageLocation ""{3}"" -cloudConfigLocation ""{4}"" -subscriptionDataFile ""{5}"" -selectedSubscription {6} -environment ""{7}""", PublishScriptFilePath, ServiceName, StorageAccountName, PackageLocation, CloudConfigLocation, SubscriptionDataFilePath, SubscriptionName, Environment)</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>DisplayName = Execute publish script</source>
          <target state="new">DisplayName = Execute publish script</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>FileName = "PowerShell" (include the quotes)</source>
          <target state="new">FileName = "PowerShell" (include the quotes)</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>OutputEncoding= System.Text.Encoding.GetEncoding(System.Globalization.CultureInfo.InstalledUICulture.TextInfo.OEMCodePage)</source>
          <target state="new">OutputEncoding= System.Text.Encoding.GetEncoding(System.Globalization.CultureInfo.InstalledUICulture.TextInfo.OEMCodePage)</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>在 InvokeProcess 的“处理标准输出”部分文本框中，将文本框值设置为“data”。这是一个用于存储标准输出数据的变量。</source>
          <target state="new">在 InvokeProcess 的“处理标准输出”部分文本框中，将文本框值设置为“data”。这是一个用于存储标准输出数据的变量。</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>在“处理错误输出”部分的正下方添加一个 WriteBuildError 活动。设置 Importance = 'Microsoft.TeamFoundation.Build.Client.BuildMessageImportance.High' 和 Message='data'。这可确保脚本的标准输出将写入到生成输出中。</source>
          <target state="new">在“处理错误输出”部分的正下方添加一个 WriteBuildError 活动。设置 Importance = 'Microsoft.TeamFoundation.Build.Client.BuildMessageImportance.High' 和 Message='data'。这可确保脚本的标准输出将写入到生成输出中。</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>在 InvokeProcess 的“处理错误输出”部分文本框中，将文本框值设置为“data”。这是一个用于存储标准错误数据的变量。</source>
          <target state="new">在 InvokeProcess 的“处理错误输出”部分文本框中，将文本框值设置为“data”。这是一个用于存储标准错误数据的变量。</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>在“处理错误输出”部分的正下方添加一个 WriteBuildError 活动。设置 Message='data'。这可确保脚本的标准错误将写入到生成错误输出中。</source>
          <target state="new">在“处理错误输出”部分的正下方添加一个 WriteBuildError 活动。设置 Message='data'。这可确保脚本的标准错误将写入到生成错误输出中。</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>更正蓝色感叹号指示的任何错误。将鼠标悬停在感叹号上可以获取有关错误的提示。保存工作流以清除错误。</source>
          <target state="new">更正蓝色感叹号指示的任何错误。将鼠标悬停在感叹号上可以获取有关错误的提示。保存工作流以清除错误。</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>发布工作流活动的最终结果将与设计器中的以下内容类似：</source>
          <target state="new">发布工作流活动的最终结果将与设计器中的以下内容类似：</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>发布工作流活动的最终结果将与 XAML 中的以下内容类似：</source>
          <target state="new">发布工作流活动的最终结果将与 XAML 中的以下内容类似：</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>保存生成过程模板工作流并签入此文件。</source>
          <target state="new">保存生成过程模板工作流并签入此文件。</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>编辑生成定义（如果已打开，请将它关闭）。如果在“过程模板”列表中看不到新模板，请选择“新建”按钮。</source>
          <target state="new">编辑生成定义（如果已打开，请将它关闭）。如果在“过程模板”列表中看不到新模板，请选择“新建”按钮。</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>在“杂项”部分中设置参数属性，如下所示：</source>
          <target state="new">在“杂项”部分中设置参数属性，如下所示：</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>CloudConfigLocation ='c:\\drops\\app.publish\\ServiceConfiguration.Cloud.cscfg'</source>
          <target state="new">CloudConfigLocation ='c:\\drops\\app.publish\\ServiceConfiguration.Cloud.cscfg'</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>此值派生自：
($PublishDir)ServiceConfiguration.Cloud.cscfg</source>
          <target state="new">此值派生自：
($PublishDir)ServiceConfiguration.Cloud.cscfg</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>PackageLocation = 'c:\\drops\\app.publish\\ContactManager.Azure.cspkg'</source>
          <target state="new">PackageLocation = 'c:\\drops\\app.publish\\ContactManager.Azure.cspkg'</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>此值派生自：($PublishDir)($ProjectName).cspkg</source>
          <target state="new">此值派生自：($PublishDir)($ProjectName).cspkg</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>PublishScriptLocation = 'c:\\scripts\\WindowsAzure\\PublishCloudService.ps1'</source>
          <target state="new">PublishScriptLocation = 'c:\\scripts\\WindowsAzure\\PublishCloudService.ps1'</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>ServiceName = 'mycloudservicename'</source>
          <target state="new">ServiceName = 'mycloudservicename'</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>在此处使用适当的云服务名称</source>
          <target state="new">在此处使用适当的云服务名称</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Environment = 'Staging'</source>
          <target state="new">Environment = 'Staging'</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>StorageAccountName = 'mystorageaccountname'</source>
          <target state="new">StorageAccountName = 'mystorageaccountname'</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>在此处使用适当的存储帐户名称</source>
          <target state="new">在此处使用适当的存储帐户名称</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>SubscriptionDataFileLocation =</source>
          <target state="new">SubscriptionDataFileLocation =</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>'c:\\scripts\\WindowsAzure\\Subscription.xml'</source>
          <target state="new">'c:\\scripts\\WindowsAzure\\Subscription.xml'</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>SubscriptionName = 'default'</source>
          <target state="new">SubscriptionName = 'default'</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>保存对生成定义所做的更改。</source>
          <target state="new">保存对生成定义所做的更改。</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>对生成进行排队以便同时执行包生成和发布。如果你的触发器设置为“持续集成”，则将在每次签入时执行此行为。</source>
          <target state="new">对生成进行排队以便同时执行包生成和发布。如果你的触发器设置为“持续集成”，则将在每次签入时执行此行为。</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>PublishCloudService.ps1 脚本模板</source>
          <target state="new">PublishCloudService.ps1 脚本模板</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>若要在使用持续交付时启用远程调试，请参阅<bpt id="p1">[</bpt>使用连续交付功能发布到 Azure 时如何启用远程调试<ept id="p1">](/documentation/articles/cloud-services-virtual-machines-dotnet-continuous-delivery-remote-debugging)</ept>。</source>
          <target state="new">若要在使用持续交付时启用远程调试，请参阅<bpt id="p1">[</bpt>使用连续交付功能发布到 Azure 时如何启用远程调试<ept id="p1">](/documentation/articles/cloud-services-virtual-machines-dotnet-continuous-delivery-remote-debugging)</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>