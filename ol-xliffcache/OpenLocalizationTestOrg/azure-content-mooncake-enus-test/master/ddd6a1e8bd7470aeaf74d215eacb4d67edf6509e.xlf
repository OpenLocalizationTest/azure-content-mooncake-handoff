<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ddd6a1e8bd7470aeaf74d215eacb4d67edf6509e</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何通过 Java 使用表存储 | Azure</source>
          <target state="new">如何通过 Java 使用表存储 | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>了解如何在 Azure 中使用表存储服务。代码示例用 Java 代码编写。</source>
          <target state="new">了解如何在 Azure 中使用表存储服务。代码示例用 Java 代码编写。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何通过 Java 使用表存储</source>
          <target state="new">如何通过 Java 使用表存储</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>概述</source>
          <target state="new">概述</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>本指南将演示如何使用 Azure 表存储服务执行常见方案。这些示例用 Java 编写并使用 <bpt id="p1">[</bpt>Azure Storage SDK for Java<ept id="p1">][]</ept>。涉及的方案包括“创建”、“列出”和“删除”表，以及“插入”、“查询”、“修改”和“删除”表中的实体。有关表的详细信息，请参阅<bpt id="p2">[</bpt>后续步骤<ept id="p2">](#NextSteps)</ept>部分。</source>
          <target state="new">本指南将演示如何使用 Azure 表存储服务执行常见方案。这些示例用 Java 编写并使用 <bpt id="p1">[</bpt>Azure Storage SDK for Java<ept id="p1">][]</ept>。涉及的方案包括“创建”、“列出”和“删除”表，以及“插入”、“查询”、“修改”和“删除”表中的实体。有关表的详细信息，请参阅<bpt id="p2">[</bpt>后续步骤<ept id="p2">](#NextSteps)</ept>部分。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>注意：为在 Android 设备上使用 Azure 存储的开发人员提供了 SDK。有关详细信息，请参阅 <bpt id="p1">[</bpt>Azure Storage SDK for Android<ept id="p1">][]</ept>。</source>
          <target state="new">注意：为在 Android 设备上使用 Azure 存储的开发人员提供了 SDK。有关详细信息，请参阅 <bpt id="p1">[</bpt>Azure Storage SDK for Android<ept id="p1">][]</ept>。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>创建 Java 应用程序</source>
          <target state="new">创建 Java 应用程序</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>在本指南中，你将使用存储功能，这些功能可在本地 Java 应用程序中运行，或在 Azure 的 Web 角色或辅助角色中通过运行的代码来运行。</source>
          <target state="new">在本指南中，你将使用存储功能，这些功能可在本地 Java 应用程序中运行，或在 Azure 的 Web 角色或辅助角色中通过运行的代码来运行。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>为此，你将需要安装 Java 开发工具包 (JDK)，并在你的 Azure 订阅中创建一个 Azure 存储帐户。完成此操作后，你将需要验证开发系统满足最低要求和 GitHub 上的 <bpt id="p1">[</bpt>Azure Storage SDK for Java<ept id="p1">][]</ept> 存储库中列出的依赖项。如果你的系统满足这些要求，你可以按照说明下载和安装系统中该存储库的 Azure Storage Libraries for Java。完成这些任务后，您将能够创建一个 Java 应用程序，以便使用本文中的示例。</source>
          <target state="new">为此，你将需要安装 Java 开发工具包 (JDK)，并在你的 Azure 订阅中创建一个 Azure 存储帐户。完成此操作后，你将需要验证开发系统满足最低要求和 GitHub 上的 <bpt id="p1">[</bpt>Azure Storage SDK for Java<ept id="p1">][]</ept> 存储库中列出的依赖项。如果你的系统满足这些要求，你可以按照说明下载和安装系统中该存储库的 Azure Storage Libraries for Java。完成这些任务后，您将能够创建一个 Java 应用程序，以便使用本文中的示例。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>配置应用程序以访问表存储</source>
          <target state="new">配置应用程序以访问表存储</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>将以下导入语句添加到要在其中使用 Azure 存储 API 访问表的 Java 文件的顶部：</source>
          <target state="new">将以下导入语句添加到要在其中使用 Azure 存储 API 访问表的 Java 文件的顶部：</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>设置 Azure 存储连接字符串</source>
          <target state="new">设置 Azure 存储连接字符串</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Azure 存储客户端使用存储连接字符串来存储用于访问数据管理服务的终结点和凭据。在客户端应用程序中运行时，必须提供以下格式的存储连接字符串，并对 <bpt id="p1">*</bpt>AccountName<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>AccountKey<ept id="p2">*</ept> 值使用管理门户中列出的存储帐户的名称和存储帐户的主访问密钥。此示例演示如何声明一个静态字段以保存连接字符串：</source>
          <target state="new">Azure 存储客户端使用存储连接字符串来存储用于访问数据管理服务的终结点和凭据。在客户端应用程序中运行时，必须提供以下格式的存储连接字符串，并对 <bpt id="p1">*</bpt>AccountName<ept id="p1">*</ept> 和 <bpt id="p2">*</bpt>AccountKey<ept id="p2">*</ept> 值使用管理门户中列出的存储帐户的名称和存储帐户的主访问密钥。此示例演示如何声明一个静态字段以保存连接字符串：</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>在 Azure 的角色中运行的应用程序中，此字符串可存储在服务配置文件 <bpt id="p1">*</bpt>ServiceConfiguration.cscfg<ept id="p1">*</ept> 中，并可通过调用 <bpt id="p2">**</bpt>RoleEnvironment.getConfigurationSettings<ept id="p2">**</ept> 方法进行访问。下面是从服务配置文件中名为 <bpt id="p3">*</bpt>StorageConnectionString<ept id="p3">*</ept> 的 <bpt id="p4">**</bpt>Setting<ept id="p4">**</ept> 元素中获取连接字符串的示例：</source>
          <target state="new">在 Azure 的角色中运行的应用程序中，此字符串可存储在服务配置文件 <bpt id="p1">*</bpt>ServiceConfiguration.cscfg<ept id="p1">*</ept> 中，并可通过调用 <bpt id="p2">**</bpt>RoleEnvironment.getConfigurationSettings<ept id="p2">**</ept> 方法进行访问。下面是从服务配置文件中名为 <bpt id="p3">*</bpt>StorageConnectionString<ept id="p3">*</ept> 的 <bpt id="p4">**</bpt>Setting<ept id="p4">**</ept> 元素中获取连接字符串的示例：</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>下面的示例假定你使用了这两个方法之一来获取存储连接字符串。</source>
          <target state="new">下面的示例假定你使用了这两个方法之一来获取存储连接字符串。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>如何：创建表</source>
          <target state="new">如何：创建表</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>利用 <bpt id="p1">**</bpt>CloudTableClient<ept id="p1">**</ept> 对象，您可以获得表和实体的引用对象。以下代码将创建 <bpt id="p2">**</bpt>CloudTableClient<ept id="p2">**</ept> 对象并使用它创建新的 <bpt id="p3">**</bpt>CloudTable<ept id="p3">**</ept> 对象，用于表示名为“people”的表。（注意：还有其他方式来创建 <bpt id="p4">**</bpt>CloudStorageAccount<ept id="p4">**</ept> 对象；有关详细信息，请参阅 <bpt id="p5">[</bpt><ept id="p5">Azure 存储客户端 SDK 参考]</ept>中的 <bpt id="p6">**</bpt>CloudStorageAccount<ept id="p6">**</ept>。）</source>
          <target state="new">利用 <bpt id="p1">**</bpt>CloudTableClient<ept id="p1">**</ept> 对象，您可以获得表和实体的引用对象。以下代码将创建 <bpt id="p2">**</bpt>CloudTableClient<ept id="p2">**</ept> 对象并使用它创建新的 <bpt id="p3">**</bpt>CloudTable<ept id="p3">**</ept> 对象，用于表示名为“people”的表。（注意：还有其他方式来创建 <bpt id="p4">**</bpt>CloudStorageAccount<ept id="p4">**</ept> 对象；有关详细信息，请参阅 <bpt id="p5">[</bpt><ept id="p5">Azure 存储客户端 SDK 参考]</ept>中的 <bpt id="p6">**</bpt>CloudStorageAccount<ept id="p6">**</ept>。）</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>如何：列出表</source>
          <target state="new">如何：列出表</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>若要获取表的列表，请调用 <bpt id="p1">**</bpt>CloudTableClient.listTables()<ept id="p1">**</ept> 方法来检索表名称的迭代列表。</source>
          <target state="new">若要获取表的列表，请调用 <bpt id="p1">**</bpt>CloudTableClient.listTables()<ept id="p1">**</ept> 方法来检索表名称的迭代列表。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>如何：向表中添加实体</source>
          <target state="new">如何：向表中添加实体</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>实体将映射到使用实现了 <bpt id="p1">**</bpt>TableEntity<ept id="p1">**</ept> 的自定义类的 Java 对象。为方便起见，<bpt id="p2">**</bpt>TableServiceEntity<ept id="p2">**</ept> 类实现 <bpt id="p3">**</bpt>TableEntity<ept id="p3">**</ept>，并使用反射将属性映射到以它们本身命名的 getter 和 setter 方法。若要将实体添加到表，首先要创建用于定义实体的属性的类。以下代码定义了将客户的名字和姓氏分别用作行键和分区键的实体类。实体的分区键和行键共同唯一地标识表中的实体。查询分区键相同的实体的速度可以快于查询分区键不同的实体的速度。</source>
          <target state="new">实体将映射到使用实现了 <bpt id="p1">**</bpt>TableEntity<ept id="p1">**</ept> 的自定义类的 Java 对象。为方便起见，<bpt id="p2">**</bpt>TableServiceEntity<ept id="p2">**</ept> 类实现 <bpt id="p3">**</bpt>TableEntity<ept id="p3">**</ept>，并使用反射将属性映射到以它们本身命名的 getter 和 setter 方法。若要将实体添加到表，首先要创建用于定义实体的属性的类。以下代码定义了将客户的名字和姓氏分别用作行键和分区键的实体类。实体的分区键和行键共同唯一地标识表中的实体。查询分区键相同的实体的速度可以快于查询分区键不同的实体的速度。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>涉及实体的表操作需要 <bpt id="p1">**</bpt>TableOperation<ept id="p1">**</ept> 对象。此对象用于定义要对实体执行的操作，该操作可使用 <bpt id="p2">**</bpt>CloudTable<ept id="p2">**</ept> 对象执行。以下代码创建了包含要存储的某些客户数据的 <bpt id="p3">**</bpt>CustomerEntity<ept id="p3">**</ept> 类的新实例。接下来，该代码调用 <bpt id="p4">**</bpt>TableOperation.insertOrReplace<ept id="p4">**</ept> 创建一个 <bpt id="p5">**</bpt>TableOperation<ept id="p5">**</ept> 对象，以便将实体插入表中，并将新的 <bpt id="p6">**</bpt>CustomerEntity<ept id="p6">**</ept> 与之关联。最后，该代码对 <bpt id="p7">**</bpt>CloudTable<ept id="p7">**</ept> 对象调用 <bpt id="p8">**</bpt>execute<ept id="p8">**</ept> 方法，并指定了“people”表和新的 <bpt id="p9">**</bpt>TableOperation<ept id="p9">**</ept>，后者随后向存储服务发送将新客户实体插入“people”表或在实体已存在的情况下替换实体的请求。</source>
          <target state="new">涉及实体的表操作需要 <bpt id="p1">**</bpt>TableOperation<ept id="p1">**</ept> 对象。此对象用于定义要对实体执行的操作，该操作可使用 <bpt id="p2">**</bpt>CloudTable<ept id="p2">**</ept> 对象执行。以下代码创建了包含要存储的某些客户数据的 <bpt id="p3">**</bpt>CustomerEntity<ept id="p3">**</ept> 类的新实例。接下来，该代码调用 <bpt id="p4">**</bpt>TableOperation.insertOrReplace<ept id="p4">**</ept> 创建一个 <bpt id="p5">**</bpt>TableOperation<ept id="p5">**</ept> 对象，以便将实体插入表中，并将新的 <bpt id="p6">**</bpt>CustomerEntity<ept id="p6">**</ept> 与之关联。最后，该代码对 <bpt id="p7">**</bpt>CloudTable<ept id="p7">**</ept> 对象调用 <bpt id="p8">**</bpt>execute<ept id="p8">**</ept> 方法，并指定了“people”表和新的 <bpt id="p9">**</bpt>TableOperation<ept id="p9">**</ept>，后者随后向存储服务发送将新客户实体插入“people”表或在实体已存在的情况下替换实体的请求。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>如何：插入一批实体</source>
          <target state="new">如何：插入一批实体</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>你可以通过一次写入操作将一批实体插入到表服务。以下代码创建一个 <bpt id="p1">**</bpt>TableBatchOperation<ept id="p1">**</ept> 对象，然后向其中添加三个插入操作。每个插入操作的添加方法如下：创建一个新的实体对象，设置它的值，然后对 <bpt id="p2">**</bpt>TableBatchOperation<ept id="p2">**</ept> 对象调用 <bpt id="p3">**</bpt>insert<ept id="p3">**</ept> 方法以将实体与新的插入操作相关联。然后，该代码对 <bpt id="p4">**</bpt>CloudTable<ept id="p4">**</ept> 调用 <bpt id="p5">**</bpt>execute<ept id="p5">**</ept>，并指定“people”表和 <bpt id="p6">**</bpt>TableBatchOperation<ept id="p6">**</ept> 对象，后者将在一个请求中向存储服务发送一批表操作。</source>
          <target state="new">你可以通过一次写入操作将一批实体插入到表服务。以下代码创建一个 <bpt id="p1">**</bpt>TableBatchOperation<ept id="p1">**</ept> 对象，然后向其中添加三个插入操作。每个插入操作的添加方法如下：创建一个新的实体对象，设置它的值，然后对 <bpt id="p2">**</bpt>TableBatchOperation<ept id="p2">**</ept> 对象调用 <bpt id="p3">**</bpt>insert<ept id="p3">**</ept> 方法以将实体与新的插入操作相关联。然后，该代码对 <bpt id="p4">**</bpt>CloudTable<ept id="p4">**</ept> 调用 <bpt id="p5">**</bpt>execute<ept id="p5">**</ept>，并指定“people”表和 <bpt id="p6">**</bpt>TableBatchOperation<ept id="p6">**</ept> 对象，后者将在一个请求中向存储服务发送一批表操作。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>批处理操作的注意事项如下：</source>
          <target state="new">批处理操作的注意事项如下：</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>您在单次批处理操作中最多可以执行 100 个插入、删除、合并、替换、插入或合并以及插入或替换操作（可以是这些操作的任意组合）。</source>
          <target state="new">您在单次批处理操作中最多可以执行 100 个插入、删除、合并、替换、插入或合并以及插入或替换操作（可以是这些操作的任意组合）。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>批处理操作也可以包含检索操作，但前提是检索操作是批处理中仅有的操作。</source>
          <target state="new">批处理操作也可以包含检索操作，但前提是检索操作是批处理中仅有的操作。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>单次批处理操作中的所有实体都必须具有相同的分区键。</source>
          <target state="new">单次批处理操作中的所有实体都必须具有相同的分区键。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>批处理操作的数据负载限制为 4MB。</source>
          <target state="new">批处理操作的数据负载限制为 4MB。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>如何：检索分区中的所有实体</source>
          <target state="new">如何：检索分区中的所有实体</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>若要从表中查询分区中的实体，可以使用 <bpt id="p1">**</bpt>TableQuery<ept id="p1">**</ept>。调用 <bpt id="p2">**</bpt>TableQuery.from<ept id="p2">**</ept> 可创建一个针对特定表的查询，该查询将返回指定的结果类型。以下代码指定了一个筛选器，用于筛选其中的分区键是“Smith”的实体。<bpt id="p3">**</bpt>TableQuery.generateFilterCondition<ept id="p3">**</ept> 是一个用于创建查询筛选器的帮助器方法。对 <bpt id="p4">**</bpt>TableQuery.from<ept id="p4">**</ept> 方法返回的引用调用 <bpt id="p5">**</bpt>where<ept id="p5">**</ept> 可对查询应用筛选器。当通过对 <bpt id="p6">**</bpt>CloudTable<ept id="p6">**</ept> 对象调用 <bpt id="p7">**</bpt>execute<ept id="p7">**</ept> 来执行查询时，该查询将返回指定了 <bpt id="p8">**</bpt>CustomerEntity<ept id="p8">**</ept> 结果类型的 <bpt id="p9">**</bpt>Iterator<ept id="p9">**</ept>。然后，你可以利用在 for each 循环中返回的 <bpt id="p10">**</bpt>Iterator<ept id="p10">**</ept> 来使用结果。此代码会将查询结果中每个实体的字段打印到控制台。</source>
          <target state="new">若要从表中查询分区中的实体，可以使用 <bpt id="p1">**</bpt>TableQuery<ept id="p1">**</ept>。调用 <bpt id="p2">**</bpt>TableQuery.from<ept id="p2">**</ept> 可创建一个针对特定表的查询，该查询将返回指定的结果类型。以下代码指定了一个筛选器，用于筛选其中的分区键是“Smith”的实体。<bpt id="p3">**</bpt>TableQuery.generateFilterCondition<ept id="p3">**</ept> 是一个用于创建查询筛选器的帮助器方法。对 <bpt id="p4">**</bpt>TableQuery.from<ept id="p4">**</ept> 方法返回的引用调用 <bpt id="p5">**</bpt>where<ept id="p5">**</ept> 可对查询应用筛选器。当通过对 <bpt id="p6">**</bpt>CloudTable<ept id="p6">**</ept> 对象调用 <bpt id="p7">**</bpt>execute<ept id="p7">**</ept> 来执行查询时，该查询将返回指定了 <bpt id="p8">**</bpt>CustomerEntity<ept id="p8">**</ept> 结果类型的 <bpt id="p9">**</bpt>Iterator<ept id="p9">**</ept>。然后，你可以利用在 for each 循环中返回的 <bpt id="p10">**</bpt>Iterator<ept id="p10">**</ept> 来使用结果。此代码会将查询结果中每个实体的字段打印到控制台。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>如何：检索分区中的一部分实体</source>
          <target state="new">如何：检索分区中的一部分实体</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>如果不想查询分区中的所有实体，则可以在筛选器中使用比较运算符来指定一个范围。以下代码组合了两个筛选器来获取分区“Smith”中的、行键（名字）以字母“E”及字母“E”前面的字母开头的所有实体。然后，该代码打印了查询结果。如果使用添加到本指南的批量插入部分的表的实体，则此次只返回两个实体（Ben 和 Denise Smith），而不会包括 Jeff Smith。</source>
          <target state="new">如果不想查询分区中的所有实体，则可以在筛选器中使用比较运算符来指定一个范围。以下代码组合了两个筛选器来获取分区“Smith”中的、行键（名字）以字母“E”及字母“E”前面的字母开头的所有实体。然后，该代码打印了查询结果。如果使用添加到本指南的批量插入部分的表的实体，则此次只返回两个实体（Ben 和 Denise Smith），而不会包括 Jeff Smith。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>如何：检索单个实体</source>
          <target state="new">如何：检索单个实体</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>你可以编写查询以检索单个特定实体。以下代码使用分区键和行键参数调用 <bpt id="p1">**</bpt>TableOperation.retrieve<ept id="p1">**</ept> 来指定客户“Jeff Smith”，而不是创建 <bpt id="p2">**</bpt>TableQuery<ept id="p2">**</ept> 并使用筛选器来执行同一操作。执行的检索操作将只返回一个实体，而不会返回一个集合。<bpt id="p3">**</bpt>getResultAsType<ept id="p3">**</ept> 方法会将结果强制转换为分配目标的类型 - <bpt id="p4">**</bpt>CustomerEntity<ept id="p4">**</ept> 对象。如果此类型与为查询指定的类型不兼容，则会引发异常。如果没有实体具有完全匹配的分区键和行键，则会返回 null 值。在查询中指定分区键和行键是从表服务中检索单个实体的最快方法。</source>
          <target state="new">你可以编写查询以检索单个特定实体。以下代码使用分区键和行键参数调用 <bpt id="p1">**</bpt>TableOperation.retrieve<ept id="p1">**</ept> 来指定客户“Jeff Smith”，而不是创建 <bpt id="p2">**</bpt>TableQuery<ept id="p2">**</ept> 并使用筛选器来执行同一操作。执行的检索操作将只返回一个实体，而不会返回一个集合。<bpt id="p3">**</bpt>getResultAsType<ept id="p3">**</ept> 方法会将结果强制转换为分配目标的类型 - <bpt id="p4">**</bpt>CustomerEntity<ept id="p4">**</ept> 对象。如果此类型与为查询指定的类型不兼容，则会引发异常。如果没有实体具有完全匹配的分区键和行键，则会返回 null 值。在查询中指定分区键和行键是从表服务中检索单个实体的最快方法。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>如何：修改实体</source>
          <target state="new">如何：修改实体</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>若要修改实体，请从表服务中检索它，对实体对象进行更改，然后通过替换或合并操作将更改保存回表服务。以下代码将更改现有客户的电话号码。此代码将调用 <bpt id="p1">**</bpt>TableOperation.replace<ept id="p1">**</ept>，而不是像执行插入时那样调用 <bpt id="p2">**</bpt>TableOperation.insert<ept id="p2">**</ept>。<bpt id="p3">**</bpt>CloudTable.execute<ept id="p3">**</ept> 方法将调用表服务，并替换该实体，除非在此应用程序检索到该实体之后另一个应用程序对它进行了更改。如果出现这种情况，则会引发异常，必须再次检索、修改并保存该实体。此乐观并发重试模式在分布式存储系统中很常见。</source>
          <target state="new">若要修改实体，请从表服务中检索它，对实体对象进行更改，然后通过替换或合并操作将更改保存回表服务。以下代码将更改现有客户的电话号码。此代码将调用 <bpt id="p1">**</bpt>TableOperation.replace<ept id="p1">**</ept>，而不是像执行插入时那样调用 <bpt id="p2">**</bpt>TableOperation.insert<ept id="p2">**</ept>。<bpt id="p3">**</bpt>CloudTable.execute<ept id="p3">**</ept> 方法将调用表服务，并替换该实体，除非在此应用程序检索到该实体之后另一个应用程序对它进行了更改。如果出现这种情况，则会引发异常，必须再次检索、修改并保存该实体。此乐观并发重试模式在分布式存储系统中很常见。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>如何：查询实体属性子集</source>
          <target state="new">如何：查询实体属性子集</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>对表的查询可以只检索实体中的少数几个属性。此方法称为“投影”，可减少带宽并提高查询性能，尤其适用于大型实体。以下代码中的查询使用 <bpt id="p1">**</bpt>select<ept id="p1">**</ept> 方法，仅返回表中实体的电子邮件地址。返回结果在 <bpt id="p2">**</bpt>EntityResolver<ept id="p2">**</ept>（用于对从服务器返回的实体执行类型转换）的帮助下投影到一个 <bpt id="p3">**</bpt>String<ept id="p3">**</ept> 集合中。你可以在此<bpt id="p4">[</bpt>博客文章<ept id="p4">][]</ept>中了解有关投影的详细信息。请注意，本地存储模拟器不支持投影，因此，此代码仅在使用表服务中的帐户时才能运行。</source>
          <target state="new">对表的查询可以只检索实体中的少数几个属性。此方法称为“投影”，可减少带宽并提高查询性能，尤其适用于大型实体。以下代码中的查询使用 <bpt id="p1">**</bpt>select<ept id="p1">**</ept> 方法，仅返回表中实体的电子邮件地址。返回结果在 <bpt id="p2">**</bpt>EntityResolver<ept id="p2">**</ept>（用于对从服务器返回的实体执行类型转换）的帮助下投影到一个 <bpt id="p3">**</bpt>String<ept id="p3">**</ept> 集合中。你可以在此<bpt id="p4">[</bpt>博客文章<ept id="p4">][]</ept>中了解有关投影的详细信息。请注意，本地存储模拟器不支持投影，因此，此代码仅在使用表服务中的帐户时才能运行。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>如何：插入或替换实体</source>
          <target state="new">如何：插入或替换实体</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>你经常需要将某个实体添加到表中，但又不知道该实体是否已存在于表中。利用插入或替换操作，您可以提出一个以下形式的请求：如果实体不存在，则插入一个实体；如果实体存在，则将其替换为现有实体。以下代码基于前面的示例针对“Walter Harp”插入或替换实体。创建新实体后，此代码调用 <bpt id="p1">**</bpt>TableOperation.insertOrReplace<ept id="p1">**</ept> 方法。此代码随后使用表和插入或替换表操作作为参数对 <bpt id="p2">**</bpt>CloudTable<ept id="p2">**</ept> 对象调用 <bpt id="p3">**</bpt>execute<ept id="p3">**</ept>。若要只更新实体的一部分，则可以改用 <bpt id="p4">**</bpt>TableOperation.insertOrMerge<ept id="p4">**</ept> 方法。请注意，本地存储仿真程序不支持插入或替换，因此，此代码仅在使用表服务中的帐户时才能运行。你可以在此<bpt id="p5">[</bpt>博客文章<ept id="p5">][]</ept>中了解有关插入或替换以及插入或合并的更多信息。</source>
          <target state="new">你经常需要将某个实体添加到表中，但又不知道该实体是否已存在于表中。利用插入或替换操作，您可以提出一个以下形式的请求：如果实体不存在，则插入一个实体；如果实体存在，则将其替换为现有实体。以下代码基于前面的示例针对“Walter Harp”插入或替换实体。创建新实体后，此代码调用 <bpt id="p1">**</bpt>TableOperation.insertOrReplace<ept id="p1">**</ept> 方法。此代码随后使用表和插入或替换表操作作为参数对 <bpt id="p2">**</bpt>CloudTable<ept id="p2">**</ept> 对象调用 <bpt id="p3">**</bpt>execute<ept id="p3">**</ept>。若要只更新实体的一部分，则可以改用 <bpt id="p4">**</bpt>TableOperation.insertOrMerge<ept id="p4">**</ept> 方法。请注意，本地存储仿真程序不支持插入或替换，因此，此代码仅在使用表服务中的帐户时才能运行。你可以在此<bpt id="p5">[</bpt>博客文章<ept id="p5">][]</ept>中了解有关插入或替换以及插入或合并的更多信息。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>如何：删除实体</source>
          <target state="new">如何：删除实体</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>你可以在检索到实体后轻松将其删除。检索到实体后，对要删除的实体调用 <bpt id="p1">**</bpt>TableOperation.delete<ept id="p1">**</ept>。然后对 <bpt id="p2">**</bpt>CloudTable<ept id="p2">**</ept> 对象调用 <bpt id="p3">**</bpt>execute<ept id="p3">**</ept>。以下代码检索并删除一个客户实体。</source>
          <target state="new">你可以在检索到实体后轻松将其删除。检索到实体后，对要删除的实体调用 <bpt id="p1">**</bpt>TableOperation.delete<ept id="p1">**</ept>。然后对 <bpt id="p2">**</bpt>CloudTable<ept id="p2">**</ept> 对象调用 <bpt id="p3">**</bpt>execute<ept id="p3">**</ept>。以下代码检索并删除一个客户实体。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>如何：删除表</source>
          <target state="new">如何：删除表</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>最后，以下代码将从存储帐户中删除一个表。表在删除之后的一小段时间（通常小于四十秒）内无法重新创建。</source>
          <target state="new">最后，以下代码将从存储帐户中删除一个表。表在删除之后的一小段时间（通常小于四十秒）内无法重新创建。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>现在，你已了解有关表存储的基础知识，可单击下面的链接来了解如何执行更复杂的存储任务。</source>
          <target state="new">现在，你已了解有关表存储的基础知识，可单击下面的链接来了解如何执行更复杂的存储任务。</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Azure Storage SDK for Java</source>
          <target state="new">Azure Storage SDK for Java</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Azure 存储客户端 SDK 参考</source>
          <target state="new">Azure 存储客户端 SDK 参考</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Azure 存储 REST API</source>
          <target state="new">Azure 存储 REST API</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Azure 存储团队博客</source>
          <target state="new">Azure 存储团队博客</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>