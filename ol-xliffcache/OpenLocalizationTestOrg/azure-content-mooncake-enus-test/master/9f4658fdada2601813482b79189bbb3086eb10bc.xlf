<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9f4658fdada2601813482b79189bbb3086eb10bc</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>在 Azure 中使用 Socket.IO 创建 Node.js 聊天应用程序</source>
          <target state="new">在 Azure 中使用 Socket.IO 创建 Node.js 聊天应用程序</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>此教程演示如何在托管于 Azure 上的 node.js Web 应用中使用 socket.io。</source>
          <target state="new">此教程演示如何在托管于 Azure 上的 node.js Web 应用中使用 socket.io。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>在 Azure 中使用 Socket.IO 创建 Node.js 聊天应用程序</source>
          <target state="new">在 Azure 中使用 Socket.IO 创建 Node.js 聊天应用程序</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Socket.IO 使用 WebSocket 在 node.js 服务器和客户端之间提供实时通信。还支持回退到使用低版本浏览器的其他传输（如长轮询）。本教程将演示如何以 Azure Web 应用的的形式托管基于 Socket.IO 的聊天应用程序，并说明如何通过 <bpt id="p1">[</bpt>Azure Redis 缓存<ept id="p1">](/documentation/services/redis-cache)</ept>来<bpt id="p2">[</bpt>向外扩展<ept id="p2">](#scale-out)</ept>应用程序。有关 Socket.IO 的详细信息，请参阅 <bpt id="p3">[</bpt>http://socket.io/<ept id="p3">][socketio]</ept>。</source>
          <target state="new">Socket.IO 使用 WebSocket 在 node.js 服务器和客户端之间提供实时通信。还支持回退到使用低版本浏览器的其他传输（如长轮询）。本教程将演示如何以 Azure Web 应用的的形式托管基于 Socket.IO 的聊天应用程序，并说明如何通过 <bpt id="p1">[</bpt>Azure Redis 缓存<ept id="p1">](/documentation/services/redis-cache)</ept>来<bpt id="p2">[</bpt>向外扩展<ept id="p2">](#scale-out)</ept>应用程序。有关 Socket.IO 的详细信息，请参阅 <bpt id="p3">[</bpt>http://socket.io/<ept id="p3">][socketio]</ept>。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>此任务中的过程适用于 <bpt id="p1">[</bpt>Azure Web 应用<ept id="p1">](/documentation/services/web-sites/)</ept>；对于云服务，请参阅<ph id="ph2">&lt;a href="/documentation/articles/cloud-services-nodejs-chat-app-socketio/"&gt;</ph>在 Azure 云服务中使用 Socket.IO 构建 Node.js 聊天应用程序<ph id="ph3">&lt;/a&gt;</ph>。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>此任务中的过程适用于 <bpt id="p1">[</bpt>Azure Web 应用<ept id="p1">](/documentation/services/web-sites/)</ept>；对于云服务，请参阅<ph id="ph2">&lt;a href="/documentation/articles/cloud-services-nodejs-chat-app-socketio/"&gt;</ph>在 Azure 云服务中使用 Socket.IO 构建 Node.js 聊天应用程序<ph id="ph3">&lt;/a&gt;</ph>。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>下载聊天示例</source>
          <target state="new">下载聊天示例</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>对于此项目，我们将使用 <bpt id="p1">[</bpt><ept id="p1">Socket.IO GitHub 存储库]</ept>中的聊天示例。执行以下步骤下载该示例并将其添加到您先前创建的项目中。</source>
          <target state="new">对于此项目，我们将使用 <bpt id="p1">[</bpt><ept id="p1">Socket.IO GitHub 存储库]</ept>中的聊天示例。执行以下步骤下载该示例并将其添加到您先前创建的项目中。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>下载 Socket.IO 项目的 <bpt id="p1">[</bpt>ZIP 或 GZ 存档版本<ept id="p1">][release]</ept>（本文档使用版本 1.3.5）</source>
          <target state="new">下载 Socket.IO 项目的 <bpt id="p1">[</bpt>ZIP 或 GZ 存档版本<ept id="p1">][release]</ept>（本文档使用版本 1.3.5）</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>解压缩存档并将 <bpt id="p1">**</bpt>examples\\chat<ept id="p1">**</ept> 目录复制到新位置。例如，<bpt id="p2">**</bpt>\\node\\chat<ept id="p2">**</ept>。</source>
          <target state="new">解压缩存档并将 <bpt id="p1">**</bpt>examples\\chat<ept id="p1">**</ept> 目录复制到新位置。例如，<bpt id="p2">**</bpt>\\node\\chat<ept id="p2">**</ept>。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>修改 App.js 并安装模块</source>
          <target state="new">修改 App.js 并安装模块</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>将 <bpt id="p1">**</bpt>index.js<ept id="p1">**</ept> 文件重命名为 <bpt id="p2">**</bpt>app.js<ept id="p2">**</ept>。这可支持 Azure 检测它是否为 Node.js 应用程序。</source>
          <target state="new">将 <bpt id="p1">**</bpt>index.js<ept id="p1">**</ept> 文件重命名为 <bpt id="p2">**</bpt>app.js<ept id="p2">**</ept>。这可支持 Azure 检测它是否为 Node.js 应用程序。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>在文本编辑器中打开 <bpt id="p1">**</bpt>app.js<ept id="p1">**</ept> 文件。更改包含 <ph id="ph1">`var io = require('../..')(server);`</ph> 的行，如下所示：</source>
          <target state="new">在文本编辑器中打开 <bpt id="p1">**</bpt>app.js<ept id="p1">**</ept> 文件。更改包含 <ph id="ph1">`var io = require('../..')(server);`</ph> 的行，如下所示：</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>打开 <bpt id="p1">**</bpt>package.json<ept id="p1">**</ept> 文件，并在 <ph id="ph1">`dependencies`</ph> 下面添加对 socket.io 的引用，如下所示：</source>
          <target state="new">打开 <bpt id="p1">**</bpt>package.json<ept id="p1">**</ept> 文件，并在 <ph id="ph1">`dependencies`</ph> 下面添加对 socket.io 的引用，如下所示：</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>从命令行中，切换到 <bpt id="p1">**</bpt>\\node\\chat<ept id="p1">**</ept> 目录，然后使用 npm 安装此应用程序所需的模块：</source>
          <target state="new">从命令行中，切换到 <bpt id="p1">**</bpt>\\node\\chat<ept id="p1">**</ept> 目录，然后使用 npm 安装此应用程序所需的模块：</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>这会将模块安装到名为 <bpt id="p1">**</bpt>node_modules<ept id="p1">**</ept> 的子文件夹。</source>
          <target state="new">这会将模块安装到名为 <bpt id="p1">**</bpt>node_modules<ept id="p1">**</ept> 的子文件夹。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>创建 Azure Web 应用</source>
          <target state="new">创建 Azure Web 应用</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>按照以下步骤创建 Azure Web 应用、启用 Git 发布，然后为 Web 应用启用 WebSocket 支持。</source>
          <target state="new">按照以下步骤创建 Azure Web 应用、启用 Git 发布，然后为 Web 应用启用 WebSocket 支持。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>若要完成本教程，你需要一个 Azure 帐户。如果你没有帐户，可以创建一个试用帐户，只需几分钟即可完成。有关详细信息，请参阅 <ph id="ph2">&lt;a href="/pricing/1rmb-trial/?WT.mc_id=A7171371E" target="_blank"&gt;</ph>Azure 试用<ph id="ph3">&lt;/a&gt;</ph>。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>若要完成本教程，你需要一个 Azure 帐户。如果你没有帐户，可以创建一个试用帐户，只需几分钟即可完成。有关详细信息，请参阅 <ph id="ph2">&lt;a href="/pricing/1rmb-trial/?WT.mc_id=A7171371E" target="_blank"&gt;</ph>Azure 试用<ph id="ph3">&lt;/a&gt;</ph>。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>安装 Azure 命令行界面 (Azure CLI) 并连接到 Azure 订阅。请参阅<bpt id="p1">[</bpt>安装和配置 Azure CLI<ept id="p1">](/documentation/articles/xplat-cli-install)</ept>。</source>
          <target state="new">安装 Azure 命令行界面 (Azure CLI) 并连接到 Azure 订阅。请参阅<bpt id="p1">[</bpt>安装和配置 Azure CLI<ept id="p1">](/documentation/articles/xplat-cli-install)</ept>。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>如果这是你第一次在 Azure 中设置存储库，则需要创建登录凭据。从 Azure CLI 输入以下命令：</source>
          <target state="new">如果这是你第一次在 Azure 中设置存储库，则需要创建登录凭据。从 Azure CLI 输入以下命令：</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>切换到 <bpt id="p1">**</bpt>\\node\chat<ept id="p1">**</ept> 目录，然后使用以下命令创建新的 Azure Web 应用和本地 Git 存储库。此命令还会创建名为 'azure' 的 Git 远程连接。</source>
          <target state="new">切换到 <bpt id="p1">**</bpt>\\node\chat<ept id="p1">**</ept> 目录，然后使用以下命令创建新的 Azure Web 应用和本地 Git 存储库。此命令还会创建名为 'azure' 的 Git 远程连接。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>必须将“mysitename”替换为 Web 应用的唯一名称。</source>
          <target state="new">必须将“mysitename”替换为 Web 应用的唯一名称。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>通过使用以下命令将现有文件提交到本地存储库：</source>
          <target state="new">通过使用以下命令将现有文件提交到本地存储库：</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>使用以下命令将这些文件推送到 Azure Web 应用存储库：</source>
          <target state="new">使用以下命令将这些文件推送到 Azure Web 应用存储库：</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>系统出现提示时，请输入步骤 2 中的凭据。在服务器上导入模块时您将收到状态消息。此过程完成后，应用程序将在 Azure Web 应用上托管。</source>
          <target state="new">系统出现提示时，请输入步骤 2 中的凭据。在服务器上导入模块时您将收到状态消息。此过程完成后，应用程序将在 Azure Web 应用上托管。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>在模块安装过程中，您可能会注意到“找不到导入的项目...”错误。这些错误可放心地忽略。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>在模块安装过程中，您可能会注意到“找不到导入的项目...”错误。这些错误可放心地忽略。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Socket.IO 使用的 WebSocket 在 Azure 上默认不启用。若要启用 Web 套接字，请使用以下命令：</source>
          <target state="new">Socket.IO 使用的 WebSocket 在 Azure 上默认不启用。若要启用 Web 套接字，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>如果系统提示，请输入 Web 应用的名称。</source>
          <target state="new">如果系统提示，请输入 Web 应用的名称。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>“azure site set -w”命令仅适用于 Azure 命令行界面 0.7.4 或更高版本。你还可以使用 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](https://manage.windowsazure.cn)</ept>启用 WebSocket 支持。</source>
          <target state="new">“azure site set -w”命令仅适用于 Azure 命令行界面 0.7.4 或更高版本。你还可以使用 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](https://manage.windowsazure.cn)</ept>启用 WebSocket 支持。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>若要使用 <bpt id="p1">[</bpt><ept id="p1">Azure 管理门户](https://manage.windowsazure.cn)</ept>启用 WebSocket，请选择你的 Web 应用的“配置”页，针对 Web 套接字条目选择“ON”，然后单击“保存”。</source>
          <target state="new">若要使用 <bpt id="p1">[</bpt><ept id="p1">Azure 管理门户](https://manage.windowsazure.cn)</ept>启用 WebSocket，请选择你的 Web 应用的“配置”页，针对 Web 套接字条目选择“ON”，然后单击“保存”。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>要查看 Azure 上的 Web 应用，请使用以下命令启动 Web 浏览器并导航到托管的 Web 应用：</source>
          <target state="new">要查看 Azure 上的 Web 应用，请使用以下命令启动 Web 浏览器并导航到托管的 Web 应用：</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>你的应用现在即可在 Azure 上运行，并可使用 Socket.IO 在不同客户端之间中继聊天消息。</source>
          <target state="new">你的应用现在即可在 Azure 上运行，并可使用 Socket.IO 在不同客户端之间中继聊天消息。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="scale-out"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>向外扩展</source>
          <target state="new"><ph id="ph1">&lt;a name="scale-out"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph>向外扩展</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Socket.IO 应用程序可通过<bpt id="p1">__</bpt>适配器<ept id="p1">__</ept>实现向外扩展，以在多个应用程序实例之间发布消息和事件。尽管有几个适配器可用，<bpt id="p2">[</bpt>socket.io redis<ept id="p2">](https://github.com/automattic/socket.io-redis)</ept> 适配器可轻松与 Azure Redis 缓存功能一同使用。</source>
          <target state="new">Socket.IO 应用程序可通过<bpt id="p1">__</bpt>适配器<ept id="p1">__</ept>实现向外扩展，以在多个应用程序实例之间发布消息和事件。尽管有几个适配器可用，<bpt id="p2">[</bpt>socket.io redis<ept id="p2">](https://github.com/automattic/socket.io-redis)</ept> 适配器可轻松与 Azure Redis 缓存功能一同使用。</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>向外扩展 Socket.IO 解决方案还要求支持粘滞会话。默认情况下，可以通过 Azure 请求路由为 Azure Web 应用启用粘滞会话。有关详细信息，请参阅 <bpt id="p1">[</bpt>Azure 中的实例关联<ept id="p1">](http://azure.microsoft.com/blog/2013/11/18/disabling-arrs-instance-affinity-in-windows-azure-web-sites/)</ept></source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>向外扩展 Socket.IO 解决方案还要求支持粘滞会话。默认情况下，可以通过 Azure 请求路由为 Azure Web 应用启用粘滞会话。有关详细信息，请参阅 <bpt id="p1">[</bpt>Azure 中的实例关联<ept id="p1">](http://azure.microsoft.com/blog/2013/11/18/disabling-arrs-instance-affinity-in-windows-azure-web-sites/)</ept></target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>创建 Redis 缓存</source>
          <target state="new">创建 Redis 缓存</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>执行<bpt id="p1">[</bpt>在 Azure Redis 缓存中创建缓存<ept id="p1">](/documentation/articles/cache-dotnet-how-to-use-azure-redis-cache/#create-a-cache)</ept>中的步骤，以创建新的缓存。</source>
          <target state="new">执行<bpt id="p1">[</bpt>在 Azure Redis 缓存中创建缓存<ept id="p1">](/documentation/articles/cache-dotnet-how-to-use-azure-redis-cache/#create-a-cache)</ept>中的步骤，以创建新的缓存。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>保存用于缓存的<bpt id="p1">__</bpt>主机名<ept id="p1">__</ept>和<bpt id="p2">__</bpt>主密钥<ept id="p2">__</ept>，因为接下来的步骤需要这些信息。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>保存用于缓存的<bpt id="p1">__</bpt>主机名<ept id="p1">__</ept>和<bpt id="p2">__</bpt>主密钥<ept id="p2">__</ept>，因为接下来的步骤需要这些信息。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>添加 redis 和 socket.io redis 模块</source>
          <target state="new">添加 redis 和 socket.io redis 模块</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>在命令行中，切换到 <bpt id="p1">__</bpt>\\node\\chat<ept id="p1">__</ept> 目录，然后运行以下命令：</source>
          <target state="new">在命令行中，切换到 <bpt id="p1">__</bpt>\\node\\chat<ept id="p1">__</ept> 目录，然后运行以下命令：</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>此命令中指定的版本是测试本文时使用的版本。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>此命令中指定的版本是测试本文时使用的版本。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>修改 <bpt id="p1">__</bpt>app.js<ept id="p1">__</ept> 文件，紧接在 <ph id="ph1">`var io = require('socket.io')(server);`</ph> 后面添加以下行</source>
          <target state="new">修改 <bpt id="p1">__</bpt>app.js<ept id="p1">__</ept> 文件，紧接在 <ph id="ph1">`var io = require('socket.io')(server);`</ph> 后面添加以下行</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>用你的 Redis 缓存的主机名和密钥替换 <bpt id="p1">__</bpt>redishostname<ept id="p1">__</ept> 和 <bpt id="p2">__</bpt>rediskey<ept id="p2">__</ept>。</source>
          <target state="new">用你的 Redis 缓存的主机名和密钥替换 <bpt id="p1">__</bpt>redishostname<ept id="p1">__</ept> 和 <bpt id="p2">__</bpt>rediskey<ept id="p2">__</ept>。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>这将创建到之前创建的 Redis 缓存的发布和订阅客户端。客户端然后与适配器一同使用，以配置 Socket.IO 将 Redis 缓存用于在应用程序的实例之间传递消息和事件</source>
          <target state="new">这将创建到之前创建的 Redis 缓存的发布和订阅客户端。客户端然后与适配器一同使用，以配置 Socket.IO 将 Redis 缓存用于在应用程序的实例之间传递消息和事件</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>尽管 <bpt id="p1">__</bpt>socket.io redis<ept id="p1">__</ept> 适配器能够与 Redis 直接通信，但当前版本不支持 Azure Redis 缓存所需的身份验证。因此需使用 <bpt id="p2">__</bpt>redis<ept id="p2">__</ept> 模块创建初始连接，将客户端传递给 <bpt id="p3">__</bpt>socket.io redis<ept id="p3">__</ept> 适配器。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>尽管 <bpt id="p1">__</bpt>socket.io redis<ept id="p1">__</ept> 适配器能够与 Redis 直接通信，但当前版本不支持 Azure Redis 缓存所需的身份验证。因此需使用 <bpt id="p2">__</bpt>redis<ept id="p2">__</ept> 模块创建初始连接，将客户端传递给 <bpt id="p3">__</bpt>socket.io redis<ept id="p3">__</ept> 适配器。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>尽管 Azure Redis Cache 支持使用端口 6380 进行安全连接，但此示例中使用的模块不支持自 2014 年 7 月 14 日起的安全连接。上述代码使用默认的 6379 非安全端口。</source>
          <target state="new">尽管 Azure Redis Cache 支持使用端口 6380 进行安全连接，但此示例中使用的模块不支持自 2014 年 7 月 14 日起的安全连接。上述代码使用默认的 6379 非安全端口。</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>保存已修改的 <bpt id="p1">__</bpt>app.js<ept id="p1">__</ept></source>
          <target state="new">保存已修改的 <bpt id="p1">__</bpt>app.js<ept id="p1">__</ept></target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>提交更改并重新部署</source>
          <target state="new">提交更改并重新部署</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>从 <bpt id="p1">__</bpt>\\node\\chat<ept id="p1">__</ept> 目录中的命令行中，使用以下命令提交更改，并重新部署该应用程序。</source>
          <target state="new">从 <bpt id="p1">__</bpt>\\node\\chat<ept id="p1">__</ept> 目录中的命令行中，使用以下命令提交更改，并重新部署该应用程序。</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>将所做的更改推送到服务器后，您可以使用以下命令跨多个实例缩放您的 Web 应用。</source>
          <target state="new">将所做的更改推送到服务器后，您可以使用以下命令跨多个实例缩放您的 Web 应用。</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>其中 <bpt id="p1">__</bpt>#<ept id="p1">__</ept> 是要创建的实例数。</source>
          <target state="new">其中 <bpt id="p1">__</bpt>#<ept id="p1">__</ept> 是要创建的实例数。</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>可以从多个浏览器或计算机连接到你的 Web 应用，以验证消息是否已正确发送给所有客户端。</source>
          <target state="new">可以从多个浏览器或计算机连接到你的 Web 应用，以验证消息是否已正确发送给所有客户端。</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>故障排除</source>
          <target state="new">故障排除</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>连接限制</source>
          <target state="new">连接限制</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Azure Web 应用提供多个 SKU，这些 SKU 用于确定你的站点可用的资源。包括允许的 WebSocket 连接数。有关详细信息，请参阅 <bpt id="p1">[</bpt> Web 应用定价页<ept id="p1">][pricing]</ept>。</source>
          <target state="new">Azure Web 应用提供多个 SKU，这些 SKU 用于确定你的站点可用的资源。包括允许的 WebSocket 连接数。有关详细信息，请参阅 <bpt id="p1">[</bpt> Web 应用定价页<ept id="p1">][pricing]</ept>。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>未使用 WebSocket 发送消息</source>
          <target state="new">未使用 WebSocket 发送消息</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>如果客户端浏览器一直回退到长轮询而不是使用 Websocket，可能有以下几种原因。</source>
          <target state="new">如果客户端浏览器一直回退到长轮询而不是使用 Websocket，可能有以下几种原因。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>尝试限制传输到该 Websocket</source>
          <target state="new">尝试限制传输到该 Websocket</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>为了使 Socket.IO 使用 Websocket 进行消息传输，服务器和客户端必须支持 Websocket。如果其中任一个不支持，则 Socket.IO 将协商其他传输，如长轮询。Socket.IO 使用的默认传输列表为 <ph id="ph1">` websocket, htmlfile, xhr-polling, jsonp-polling`</ph>。你可以在包含 <ph id="ph2">`, nicknames = {};`</ph> 的行后面将以下代码添加到 <bpt id="p1">**</bpt>app.js<ept id="p1">**</ept> 文件，以强制其仅使用 WebSocket。</source>
          <target state="new">为了使 Socket.IO 使用 Websocket 进行消息传输，服务器和客户端必须支持 Websocket。如果其中任一个不支持，则 Socket.IO 将协商其他传输，如长轮询。Socket.IO 使用的默认传输列表为 <ph id="ph1">` websocket, htmlfile, xhr-polling, jsonp-polling`</ph>。你可以在包含 <ph id="ph2">`, nicknames = {};`</ph> 的行后面将以下代码添加到 <bpt id="p1">**</bpt>app.js<ept id="p1">**</ept> 文件，以强制其仅使用 WebSocket。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>注意，上述代码为活动状态时，不支持 Websocket 的低版本浏览器将无法连接到站点，因为此代码将通信限制为仅支持 Websocket 通信。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>注意，上述代码为活动状态时，不支持 Websocket 的低版本浏览器将无法连接到站点，因为此代码将通信限制为仅支持 Websocket 通信。</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>使用 SSL</source>
          <target state="new">使用 SSL</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Websocket 依赖于某些较少使用的 HTTP 标头，如 <bpt id="p1">**</bpt>Upgrade<ept id="p1">**</ept> 标头。某些中间网络设备（例如 Web 代理）可能会删除这些标头。为避免发生此问题，可以建立基于 SSL 的 WebSocket 连接。</source>
          <target state="new">Websocket 依赖于某些较少使用的 HTTP 标头，如 <bpt id="p1">**</bpt>Upgrade<ept id="p1">**</ept> 标头。某些中间网络设备（例如 Web 代理）可能会删除这些标头。为避免发生此问题，可以建立基于 SSL 的 WebSocket 连接。</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>完成此操作的简单方法是将 Socket.IO 配置到 <ph id="ph1">`match origin protocol`</ph>。这会指示 Socket.IO 保护 Websocket 通信，使之和网页原始 HTTP/HTTPS 请求一样。如果浏览器使用 HTTPS URL 访问您的 Web 应用，将基于 SSL 保护通过 Socket.IO 的后续 WebSocket 通信。</source>
          <target state="new">完成此操作的简单方法是将 Socket.IO 配置到 <ph id="ph1">`match origin protocol`</ph>。这会指示 Socket.IO 保护 Websocket 通信，使之和网页原始 HTTP/HTTPS 请求一样。如果浏览器使用 HTTPS URL 访问您的 Web 应用，将基于 SSL 保护通过 Socket.IO 的后续 WebSocket 通信。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>若要将此示例修改为启用此配置，请在 <bpt id="p1">**</bpt>app.js<ept id="p1">**</ept> 文件中包含 <ph id="ph1">`, nicknames = {};`</ph> 的行后面添加以下代码。</source>
          <target state="new">若要将此示例修改为启用此配置，请在 <bpt id="p1">**</bpt>app.js<ept id="p1">**</ept> 文件中包含 <ph id="ph1">`, nicknames = {};`</ph> 的行后面添加以下代码。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>验证 web.config 设置</source>
          <target state="new">验证 web.config 设置</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>托管 Node.js 应用程序的 Azure Web 应用使用 <bpt id="p1">**</bpt>web.config<ept id="p1">**</ept> 文件将传入请求路由到 Node.js 应用程序。为了使 Websocket 对 Node.js 应用程序正常运行，<bpt id="p2">**</bpt>web.config<ept id="p2">**</ept> 必须包含以下条目。</source>
          <target state="new">托管 Node.js 应用程序的 Azure Web 应用使用 <bpt id="p1">**</bpt>web.config<ept id="p1">**</ept> 文件将传入请求路由到 Node.js 应用程序。为了使 Websocket 对 Node.js 应用程序正常运行，<bpt id="p2">**</bpt>web.config<ept id="p2">**</ept> 必须包含以下条目。</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>这将禁用 IIS Websocket 模块，其中包括自身的 Websocket 实施以及与 Node.js 特定 WebSocket 模块（如 Socket.IO）的冲突。如果此行不存在，或者设置为 <ph id="ph1">`true`</ph>，其原因主要是 WebSocket 传输不适用于你的应用程序。</source>
          <target state="new">这将禁用 IIS Websocket 模块，其中包括自身的 Websocket 实施以及与 Node.js 特定 WebSocket 模块（如 Socket.IO）的冲突。如果此行不存在，或者设置为 <ph id="ph1">`true`</ph>，其原因主要是 WebSocket 传输不适用于你的应用程序。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Node.js 应用程序通常不包括 <bpt id="p1">**</bpt>web.config<ept id="p1">**</ept> 文件，因此 Azure Web 应用将在部署 Node.js 应用程序时自动生成一个。由于此文件是在服务器上自动生成的，因此必须使用 Web 应用的 FTP 或 FTPS URL 来查看此文件。你可以通过选择你的 Web 应用，然后选择“仪表板”链接，在 Azure 管理门户中查找 Web 应用的 FTP 和 FTPS URL。URL 将显示在“速览”部分。</source>
          <target state="new">Node.js 应用程序通常不包括 <bpt id="p1">**</bpt>web.config<ept id="p1">**</ept> 文件，因此 Azure Web 应用将在部署 Node.js 应用程序时自动生成一个。由于此文件是在服务器上自动生成的，因此必须使用 Web 应用的 FTP 或 FTPS URL 来查看此文件。你可以通过选择你的 Web 应用，然后选择“仪表板”链接，在 Azure 管理门户中查找 Web 应用的 FTP 和 FTPS URL。URL 将显示在“速览”部分。</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>如果应用程序未提供 <bpt id="p1">**</bpt>web.config<ept id="p1">**</ept> 文件，则该文件将仅由 Azure Web 应用生成。如果在应用程序项目的根目录下提供了 <bpt id="p2">**</bpt>web.config<ept id="p2">**</ept> 文件，则 Azure Web 应用将使用该文件。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>如果应用程序未提供 <bpt id="p1">**</bpt>web.config<ept id="p1">**</ept> 文件，则该文件将仅由 Azure Web 应用生成。如果在应用程序项目的根目录下提供了 <bpt id="p2">**</bpt>web.config<ept id="p2">**</ept> 文件，则 Azure Web 应用将使用该文件。</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>如果该条目不存在，或者已设置为值 <ph id="ph1">`true`</ph>，则你应在 Node.js 应用程序的根目录中创建 <bpt id="p1">**</bpt>web.config<ept id="p1">**</ept> 并指定值 <ph id="ph2">`false`</ph>。例如，使用 <bpt id="p2">**</bpt>app.js<ept id="p2">**</ept> 作为入口点的应用程序的默认 <bpt id="p3">**</bpt>web.config<ept id="p3">**</ept> 如下所示。</source>
          <target state="new">如果该条目不存在，或者已设置为值 <ph id="ph1">`true`</ph>，则你应在 Node.js 应用程序的根目录中创建 <bpt id="p1">**</bpt>web.config<ept id="p1">**</ept> 并指定值 <ph id="ph2">`false`</ph>。例如，使用 <bpt id="p2">**</bpt>app.js<ept id="p2">**</ept> 作为入口点的应用程序的默认 <bpt id="p3">**</bpt>web.config<ept id="p3">**</ept> 如下所示。</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>如果你的应用程序使用的入口点不是 <bpt id="p1">**</bpt>app.js<ept id="p1">**</ept>，你必须将出现的所有 <bpt id="p2">**</bpt>app.js<ept id="p2">**</ept> 替换为正确的入口点。例如，将 <bpt id="p3">**</bpt>app.js<ept id="p3">**</ept> 替换为 <bpt id="p4">**</bpt>server.js<ept id="p4">**</ept>。</source>
          <target state="new">如果你的应用程序使用的入口点不是 <bpt id="p1">**</bpt>app.js<ept id="p1">**</ept>，你必须将出现的所有 <bpt id="p2">**</bpt>app.js<ept id="p2">**</ept> 替换为正确的入口点。例如，将 <bpt id="p3">**</bpt>app.js<ept id="p3">**</ept> 替换为 <bpt id="p4">**</bpt>server.js<ept id="p4">**</ept>。</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>在本教程中，你已学习如何创建一个在 Azure 中托管的聊天应用程序。您还可以将该应用程序作为 Azure 云服务托管。有关如何实现此目的的步骤，请参阅<bpt id="p1">[</bpt>在 Azure 云服务中使用 Socket.IO 构建 Node.js 聊天应用程序<ept id="p1">][cloudservice]</ept>。</source>
          <target state="new">在本教程中，你已学习如何创建一个在 Azure 中托管的聊天应用程序。您还可以将该应用程序作为 Azure 云服务托管。有关如何实现此目的的步骤，请参阅<bpt id="p1">[</bpt>在 Azure 云服务中使用 Socket.IO 构建 Node.js 聊天应用程序<ept id="p1">][cloudservice]</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>