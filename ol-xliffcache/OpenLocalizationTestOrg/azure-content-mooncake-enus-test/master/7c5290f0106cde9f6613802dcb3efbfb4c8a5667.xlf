<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7c5290f0106cde9f6613802dcb3efbfb4c8a5667</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>在 Azure Web 应用中使用 Azure CDN</source>
          <target state="new">在 Azure Web 应用中使用 Azure CDN</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>本教程演示如何将 Web 应用部署到 Azure，以便从集成的 Azure CDN 终结点提供内容</source>
          <target state="new">本教程演示如何将 Web 应用部署到 Azure，以便从集成的 Azure CDN 终结点提供内容</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>在 Azure Web 应用中使用 Azure CDN</source>
          <target state="new">在 Azure Web 应用中使用 Azure CDN</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Azure Web 应用<ept id="p1">](/documentation/services/web-sites/)</ept>可与 <bpt id="p2">[</bpt>Azure CDN<ept id="p2">](/home/features/cdn/)</ept> 集成，增强 <bpt id="p3">[</bpt>Azure Web 应用<ept id="p3">](/documentation/services/web-sites/)</ept>固有的全局缩放功能，在全球通过靠近客户的服务器节点提供 Web 应用内容。在特定情况下（例如提供静态映像），此集成可以大幅提高 Azure Web 应用的性能，在全球显著改善 Web 应用的用户体验。</source>
          <target state="new"><bpt id="p1">[</bpt>Azure Web 应用<ept id="p1">](/documentation/services/web-sites/)</ept>可与 <bpt id="p2">[</bpt>Azure CDN<ept id="p2">](/home/features/cdn/)</ept> 集成，增强 <bpt id="p3">[</bpt>Azure Web 应用<ept id="p3">](/documentation/services/web-sites/)</ept>固有的全局缩放功能，在全球通过靠近客户的服务器节点提供 Web 应用内容。在特定情况下（例如提供静态映像），此集成可以大幅提高 Azure Web 应用的性能，在全球显著改善 Web 应用的用户体验。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>将 Web 应用与 Azure CDN 集成具有以下优点：</source>
          <target state="new">将 Web 应用与 Azure CDN 集成具有以下优点：</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>在 Web 应用的<bpt id="p1">[</bpt>持续部署<ept id="p1">](/documentation/articles/web-sites-publish-source-control)</ept>过程中集成内容部署（映像、脚本和样式表）</source>
          <target state="new">在 Web 应用的<bpt id="p1">[</bpt>持续部署<ept id="p1">](/documentation/articles/web-sites-publish-source-control)</ept>过程中集成内容部署（映像、脚本和样式表）</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>轻松升级 Azure Web 应用中的 NuGet 包，例如 jQuery 或 Bootstrap 版本</source>
          <target state="new">轻松升级 Azure Web 应用中的 NuGet 包，例如 jQuery 或 Bootstrap 版本</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>在同一 Visual Studio 界面中管理 Web 应用和 CDN 提供的内容</source>
          <target state="new">在同一 Visual Studio 界面中管理 Web 应用和 CDN 提供的内容</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>将 ASP.NET 绑定和缩减与 Azure CDN 集成</source>
          <target state="new">将 ASP.NET 绑定和缩减与 Azure CDN 集成</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>要生成的项目</source>
          <target state="new">要生成的项目</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>你需要在 Visual Studio 中使用默认的 ASP.NET MVC 模板将一个 Web 应用部署到 Azure，需要添加代码来处理集成 Azure CDN 所提供的内容（例如映像、控制器操作结果、默认的 JavaScript 和 CSS 文件），还需要编写代码来配置回退机制以处理 CDN 脱机时提供的捆绑包。</source>
          <target state="new">你需要在 Visual Studio 中使用默认的 ASP.NET MVC 模板将一个 Web 应用部署到 Azure，需要添加代码来处理集成 Azure CDN 所提供的内容（例如映像、控制器操作结果、默认的 JavaScript 和 CSS 文件），还需要编写代码来配置回退机制以处理 CDN 脱机时提供的捆绑包。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>所需的项目</source>
          <target state="new">所需的项目</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>本教程设置了以下前提条件：</source>
          <target state="new">本教程设置了以下前提条件：</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>有效的 Azure 帐户</source>
          <target state="new">有效的 Azure 帐户</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Visual Studio 2015 with the <bpt id="p1">[</bpt>Azure SDK for .NET<ept id="p1">](https://www.microsoft.com/web/handlers/webpi.ashx/getinstaller/VWDOrVs2013AzurePack.appids)</ept>。如果你使用 Visual Studio 2013，步骤可能有所不同。</source>
          <target state="new">Visual Studio 2015 with the <bpt id="p1">[</bpt>Azure SDK for .NET<ept id="p1">](https://www.microsoft.com/web/handlers/webpi.ashx/getinstaller/VWDOrVs2013AzurePack.appids)</ept>。如果你使用 Visual Studio 2013，步骤可能有所不同。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>完成本教程需要有一个 Azure 帐户：</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>完成本教程需要有一个 Azure 帐户：</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>你可以<bpt id="p1">[</bpt>免费建立一个 Azure 帐户<ept id="p1">](/pricing/1rmb-trial/)</ept> - 获取可用来试用付费版 Azure 服务的信用额度，甚至在用完信用额度后，你仍可以保留帐户和使用免费的 Azure 服务（如 Web 应用）。</source>
          <target state="new">你可以<bpt id="p1">[</bpt>免费建立一个 Azure 帐户<ept id="p1">](/pricing/1rmb-trial/)</ept> - 获取可用来试用付费版 Azure 服务的信用额度，甚至在用完信用额度后，你仍可以保留帐户和使用免费的 Azure 服务（如 Web 应用）。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="deploy-a-web-app-to-azure-with-an-integrated-cdn-endpoint"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 将 Web 应用部署到具有集成 CDN 终结点的 Azure</source>
          <target state="new"><ph id="ph1">&lt;a name="deploy-a-web-app-to-azure-with-an-integrated-cdn-endpoint"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 将 Web 应用部署到具有集成 CDN 终结点的 Azure</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>在本部分，你需要将 Visual Studio 2013 中的默认 ASP.NET MVC 应用程序模板部署到 Azure Web 应用，然后将其与新的 CDN 终结点相集成。请根据以下说明进行操作：</source>
          <target state="new">在本部分，你需要将 Visual Studio 2013 中的默认 ASP.NET MVC 应用程序模板部署到 Azure Web 应用，然后将其与新的 CDN 终结点相集成。请根据以下说明进行操作：</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>在 Visual Studio 2015 中转到“文件”&gt;“新建”&gt;“项目”&gt;“Web”&gt;“ASP.NET Web 应用”，以便从菜单栏创建新的 ASP.NET Web 应用。为该应用程序提供一个名称，然后单击“确定”。</source>
          <target state="new">在 Visual Studio 2015 中转到“文件”&gt;“新建”&gt;“项目”&gt;“Web”&gt;“ASP.NET Web 应用”，以便从菜单栏创建新的 ASP.NET Web 应用。为该应用程序提供一个名称，然后单击“确定”。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>选择“MVC”，然后单击“确定”。确保取消选中”在云中托管“</source>
          <target state="new">选择“MVC”，然后单击“确定”。确保取消选中”在云中托管“</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Azure 中国区目前不支持在 Visual Studio 中创建或管理 Web 应用。因此，你需要转到<bpt id="p1">[</bpt>管理门户<ept id="p1">](https://manage.windowsazure.cn/)</ept>创建新的 Azure Web 应用</source>
          <target state="new">Azure 中国区目前不支持在 Visual Studio 中创建或管理 Web 应用。因此，你需要转到<bpt id="p1">[</bpt>管理门户<ept id="p1">](https://manage.windowsazure.cn/)</ept>创建新的 Azure Web 应用</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>在管理门户中创建 Web 应用后，单击 Web 应用的“仪表板”。在“速览”下，单击“下载发布配置文件”。</source>
          <target state="new">在管理门户中创建 Web 应用后，单击 Web 应用的“仪表板”。在“速览”下，单击“下载发布配置文件”。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>在 Visual Studio 中，右键单击你的项目并选择“发布”</source>
          <target state="new">在 Visual Studio 中，右键单击你的项目并选择“发布”</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>选择"发布"</source>
          <target state="new">选择"发布"</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>几秒钟后，将显示“发布 Web”向导。</source>
          <target state="new">几秒钟后，将显示“发布 Web”向导。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>在“发布配置文件”中单击“导入”，然后选择前面下载的发布配置文件。</source>
          <target state="new">在“发布配置文件”中单击“导入”，然后选择前面下载的发布配置文件。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Visual Studio 将项目部署到 Azure 所需的设置随即已导入。可以使用该向导查看和更改这些设置。</source>
          <target state="new">Visual Studio 将项目部署到 Azure 所需的设置随即已导入。可以使用该向导查看和更改这些设置。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>在“发布 Web”向导的“连接”选项卡中，单击“下一步”。</source>
          <target state="new">在“发布 Web”向导的“连接”选项卡中，单击“下一步”。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>验证成功的连接</source>
          <target state="new">验证成功的连接</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>在“设置”选项卡中，单击“下一步”。</source>
          <target state="new">在“设置”选项卡中，单击“下一步”。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>你可以接受“配置”和“文件发布选项”的默认值。</source>
          <target state="new">你可以接受“配置”和“文件发布选项”的默认值。</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>你可以通过“配置”下拉列表部署用于远程调试的调试版本。<bpt id="p1">[</bpt>后续步骤<ept id="p1">](#next-steps)</ept>部分链接到了说明如何在调试模式下远程运行 Visual Studio 的教程。</source>
          <target state="new">你可以通过“配置”下拉列表部署用于远程调试的调试版本。<bpt id="p1">[</bpt>后续步骤<ept id="p1">](#next-steps)</ept>部分链接到了说明如何在调试模式下远程运行 Visual Studio 的教程。</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>“设置”选项卡</source>
          <target state="new">“设置”选项卡</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>在“预览”选项卡中，单击“发布”。</source>
          <target state="new">在“预览”选项卡中，单击“发布”。</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>如果你想要查看哪些文件将复制到 Azure，可以单击“开始预览”，然后单击“发布”。</source>
          <target state="new">如果你想要查看哪些文件将复制到 Azure，可以单击“开始预览”，然后单击“发布”。</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>单击“发布”后，Visual Studio 开始执行将文件复制到 Azure 服务器的过程。</source>
          <target state="new">单击“发布”后，Visual Studio 开始执行将文件复制到 Azure 服务器的过程。</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>发布完成后，你会在浏览器中看到发布的 Web 应用。</source>
          <target state="new">发布完成后，你会在浏览器中看到发布的 Web 应用。</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>若要创建 CDN 终结点，请登录到 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](https://manage.windowsazure.cn)</ept>。</source>
          <target state="new">若要创建 CDN 终结点，请登录到 <bpt id="p1">[</bpt>Azure 管理门户<ept id="p1">](https://manage.windowsazure.cn)</ept>。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>单击“新建 &gt; 应用服务 &gt; CDN &gt; 快速创建”。选择 <bpt id="p1">*</bpt><bpt id="p2">*</bpt>http://<ept id="p2">*</ept>&amp;lt;sitename&gt;<ept id="p1">*</ept>.chinacloudsites.cn/**，然后单击“创建”。</source>
          <target state="new">单击“新建 &gt; 应用服务 &gt; CDN &gt; 快速创建”。选择 <bpt id="p1">*</bpt><bpt id="p2">*</bpt>http://<ept id="p2">*</ept>&amp;lt;sitename&gt;<ept id="p1">*</ept>.chinacloudsites.cn/**，然后单击“创建”。</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 创建 CDN 终结点以后，管理门户就会向你显示其 URL 以及所集成的源域。不过，需要一定的时间才能将新 CDN 终结点的配置完全传播到所有 CDN 节点位置。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 创建 CDN 终结点以后，管理门户就会向你显示其 URL 以及所集成的源域。不过，需要一定的时间才能将新 CDN 终结点的配置完全传播到所有 CDN 节点位置。</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>回到管理门户，在“CDN”选项卡中，单击刚创建的 CDN 终结点的名称。</source>
          <target state="new">回到管理门户，在“CDN”选项卡中，单击刚创建的 CDN 终结点的名称。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>单击“启用查询字符串”在 CDN 缓存中启用查询字符串。启用此功能后，通过不同的查询字符串进行访问的同一链接就可以缓存为不同的项。</source>
          <target state="new">单击“启用查询字符串”在 CDN 缓存中启用查询字符串。启用此功能后，通过不同的查询字符串进行访问的同一链接就可以缓存为不同的项。</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph> 虽然启用查询字符串对于教程的此部分来说不是必需的，但为方便起见，最好是尽早启用此功能，因为在这里所做的任何更改都需要一定的时间才能传播到所有 CDN 节点，而你并不想让任何非查询字符串支持的内容充斥 CDN 缓存（稍后将讨论如何更新 CDN 内容）。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph> 虽然启用查询字符串对于教程的此部分来说不是必需的，但为方便起见，最好是尽早启用此功能，因为在这里所做的任何更改都需要一定的时间才能传播到所有 CDN 节点，而你并不想让任何非查询字符串支持的内容充斥 CDN 缓存（稍后将讨论如何更新 CDN 内容）。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>现在，请单击 CDN 终结点地址。如果终结点已准备就绪，你应该会看到显示的 Web 应用。如果收到 <bpt id="p1">**</bpt>HTTP 404<ept id="p1">**</ept> 错误，则说明 CDN 终结点尚未准备好。CDN 配置传播到所有边缘节点可能需要长达 1 小时的等待。</source>
          <target state="new">现在，请单击 CDN 终结点地址。如果终结点已准备就绪，你应该会看到显示的 Web 应用。如果收到 <bpt id="p1">**</bpt>HTTP 404<ept id="p1">**</ept> 错误，则说明 CDN 终结点尚未准备好。CDN 配置传播到所有边缘节点可能需要长达 1 小时的等待。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>接下来，可尝试访问 ASP.NET 项目中的 <bpt id="p1">**</bpt>~/Content/bootstrap.css<ept id="p1">**</ept> 文件。在浏览器窗口中，导航到 <bpt id="p2">*</bpt><bpt id="p3">*</bpt>http://<ept id="p3">*</ept>&amp;lt;cdnName&gt;<ept id="p2">*</ept>.vo.msecnd.net/Content/bootstrap.css**。在我的设置中，此 URL 为：</source>
          <target state="new">接下来，可尝试访问 ASP.NET 项目中的 <bpt id="p1">**</bpt>~/Content/bootstrap.css<ept id="p1">**</ept> 文件。在浏览器窗口中，导航到 <bpt id="p2">*</bpt><bpt id="p3">*</bpt>http://<ept id="p3">*</ept>&amp;lt;cdnName&gt;<ept id="p2">*</ept>.vo.msecnd.net/Content/bootstrap.css**。在我的设置中，此 URL 为：</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>这对应于 CDN 终结点的以下源 URL：</source>
          <target state="new">这对应于 CDN 终结点的以下源 URL：</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>导航到 <bpt id="p1">*</bpt><bpt id="p2">*</bpt>http://<ept id="p2">*</ept>&amp;lt;cdnName&gt;<ept id="p1">*</ept>.vo.msecnd.net/Content/bootstrap.css** 时，系统会提示你下载 bootstrap.css，该文件来自你在 Azure 中的 Web 应用。</source>
          <target state="new">导航到 <bpt id="p1">*</bpt><bpt id="p2">*</bpt>http://<ept id="p2">*</ept>&amp;lt;cdnName&gt;<ept id="p1">*</ept>.vo.msecnd.net/Content/bootstrap.css** 时，系统会提示你下载 bootstrap.css，该文件来自你在 Azure 中的 Web 应用。</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>你可以直接通过 CDN 终结点，采用类似方式访问 <bpt id="p1">*</bpt><bpt id="p2">*</bpt>http://<ept id="p2">*</ept>&amp;lt;serviceName&gt;<ept id="p1">*</ept>.chinacloudapp.cn/** 中提供的任何可公开访问的 URL。例如：</source>
          <target state="new">你可以直接通过 CDN 终结点，采用类似方式访问 <bpt id="p1">*</bpt><bpt id="p2">*</bpt>http://<ept id="p2">*</ept>&amp;lt;serviceName&gt;<ept id="p1">*</ept>.chinacloudapp.cn/** 中提供的任何可公开访问的 URL。例如：</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>/Script 路径中的 .js 文件</source>
          <target state="new">/Script 路径中的 .js 文件</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>/Content 路径中的任何内容文件</source>
          <target state="new">/Content 路径中的任何内容文件</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>任何控制器/操作</source>
          <target state="new">任何控制器/操作</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>任何带查询字符串的 URL（如果在你的 CDN 终结点启用了查询字符串功能）</source>
          <target state="new">任何带查询字符串的 URL（如果在你的 CDN 终结点启用了查询字符串功能）</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>整个 Azure Web 应用（如果所有内容都是公共的）</source>
          <target state="new">整个 Azure Web 应用（如果所有内容都是公共的）</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>请注意，通过 Azure CDN 提供整个 Azure Web 应用可能并不适合所有情况（或者说，可能并不是通用的作法）。部分注意事项如下：</source>
          <target state="new">请注意，通过 Azure CDN 提供整个 Azure Web 应用可能并不适合所有情况（或者说，可能并不是通用的作法）。部分注意事项如下：</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>此方法要求你的整个站点都是公共的，因为 Azure CDN 不能提供任何私有内容。</source>
          <target state="new">此方法要求你的整个站点都是公共的，因为 Azure CDN 不能提供任何私有内容。</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>如果 CDN 终结点因某种原因而脱机（不管是因为计划的维护，还是因为用户错误），你的整个 Web 应用都会脱机，除非可以将客户重定向到源 URL <bpt id="p1">*</bpt><bpt id="p2">*</bpt>http://<ept id="p2">*</ept>&amp;lt;sitename&gt;<ept id="p1">*</ept>.chinacloudsites.cn/**。</source>
          <target state="new">如果 CDN 终结点因某种原因而脱机（不管是因为计划的维护，还是因为用户错误），你的整个 Web 应用都会脱机，除非可以将客户重定向到源 URL <bpt id="p1">*</bpt><bpt id="p2">*</bpt>http://<ept id="p2">*</ept>&amp;lt;sitename&gt;<ept id="p1">*</ept>.chinacloudsites.cn/**。</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>即使使用自定义的缓存-控制设置（参阅<bpt id="p1">[</bpt>在 Azure Web 应用中配置静态文件的缓存选项<ept id="p1">](#configure-caching-options-for-static-files-in-your-azure-web-app)</ept>），CDN 终结点也不会改善活动度极强的动态内容的性能。请注意，如果你尝试从如上所示的 CDN 终结点加载主页，则第一次操作时至少需要 5 秒钟才能加载默认主页，而该主页是相当简单的主页。想象一下，如果此页包含每分钟必须更新的动态内容，则客户端体验会是一种什么样的情景？从 CDN 终结点提供动态内容要求缓存过期时间短，这会造成在 CDN 终结点处频繁出现缓存未命中的情况。这会损害 Azure Web 应用的性能，与 CDN 的初衷背道而驰。</source>
          <target state="new">即使使用自定义的缓存-控制设置（参阅<bpt id="p1">[</bpt>在 Azure Web 应用中配置静态文件的缓存选项<ept id="p1">](#configure-caching-options-for-static-files-in-your-azure-web-app)</ept>），CDN 终结点也不会改善活动度极强的动态内容的性能。请注意，如果你尝试从如上所示的 CDN 终结点加载主页，则第一次操作时至少需要 5 秒钟才能加载默认主页，而该主页是相当简单的主页。想象一下，如果此页包含每分钟必须更新的动态内容，则客户端体验会是一种什么样的情景？从 CDN 终结点提供动态内容要求缓存过期时间短，这会造成在 CDN 终结点处频繁出现缓存未命中的情况。这会损害 Azure Web 应用的性能，与 CDN 的初衷背道而驰。</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>替代方法是在 Azure Web 应用中按每次的具体情况来判断哪些内容可以由 Azure CDN 提供。就这点来说，我们已向你介绍了如何通过 CDN 终结点访问各个内容文件。我会在<bpt id="p1">[</bpt>通过 Azure CDN 的控制器操作提供内容<ept id="p1">](#serve-content-from-controller-actions-through-azure-cdn)</ept>中向你演示如何处理通过 CDN 终结点进行的特定控制器操作。</source>
          <target state="new">替代方法是在 Azure Web 应用中按每次的具体情况来判断哪些内容可以由 Azure CDN 提供。就这点来说，我们已向你介绍了如何通过 CDN 终结点访问各个内容文件。我会在<bpt id="p1">[</bpt>通过 Azure CDN 的控制器操作提供内容<ept id="p1">](#serve-content-from-controller-actions-through-azure-cdn)</ept>中向你演示如何处理通过 CDN 终结点进行的特定控制器操作。</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="configure-caching-options-for-static-files-in-your-azure-web-app"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 在 Azure Web 应用中配置静态文件的缓存选项</source>
          <target state="new"><ph id="ph1">&lt;a name="configure-caching-options-for-static-files-in-your-azure-web-app"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 在 Azure Web 应用中配置静态文件的缓存选项</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>通知在 Azure Web 应用中进行 Azure CDN 集成，你可以指定你所希望的在 CDN 终结点中缓存静态内容的方式。为此，请通过某个 ASP.NET 项目（例如 <bpt id="p1">**</bpt>cdnwebapp<ept id="p1">**</ept>）打开 <bpt id="p2">*</bpt>Web.config<ept id="p2">*</ept>，然后将 <ph id="ph1">`&lt;staticContent&gt;`</ph> 元素添加到 <ph id="ph2">`&lt;system.webServer&gt;`</ph>。以下 XML 将缓存配置为 3 天后过期。</source>
          <target state="new">通知在 Azure Web 应用中进行 Azure CDN 集成，你可以指定你所希望的在 CDN 终结点中缓存静态内容的方式。为此，请通过某个 ASP.NET 项目（例如 <bpt id="p1">**</bpt>cdnwebapp<ept id="p1">**</ept>）打开 <bpt id="p2">*</bpt>Web.config<ept id="p2">*</ept>，然后将 <ph id="ph1">`&lt;staticContent&gt;`</ph> 元素添加到 <ph id="ph2">`&lt;system.webServer&gt;`</ph>。以下 XML 将缓存配置为 3 天后过期。</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>执行完此操作后，Azure Web 应用中的所有静态文件将会遵守 CDN 缓存中的同一规则。若要对缓存设置进行更细致的控制，可将 <bpt id="p1">*</bpt>Web.config<ept id="p1">*</ept> 文件添加到一个文件夹中，然后在该处添加你的设置。例如，可将 <bpt id="p2">*</bpt>Web.config<ept id="p2">*</ept> 文件添加到 <bpt id="p3">*</bpt>\\Content<ept id="p3">*</ept> 文件夹中，然后使用以下 XML 替换其中的内容：</source>
          <target state="new">执行完此操作后，Azure Web 应用中的所有静态文件将会遵守 CDN 缓存中的同一规则。若要对缓存设置进行更细致的控制，可将 <bpt id="p1">*</bpt>Web.config<ept id="p1">*</ept> 文件添加到一个文件夹中，然后在该处添加你的设置。例如，可将 <bpt id="p2">*</bpt>Web.config<ept id="p2">*</ept> 文件添加到 <bpt id="p3">*</bpt>\\Content<ept id="p3">*</ept> 文件夹中，然后使用以下 XML 替换其中的内容：</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>此设置可以让 <bpt id="p1">*</bpt>\\Content<ept id="p1">*</ept> 文件夹中的所有静态文件缓存 15 天。</source>
          <target state="new">此设置可以让 <bpt id="p1">*</bpt>\\Content<ept id="p1">*</ept> 文件夹中的所有静态文件缓存 15 天。</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>有关如何配置 <ph id="ph1">`&lt;clientCache&gt;`</ph> 元素的详细信息，请参阅<bpt id="p1">[</bpt>客户端缓存 &amp;lt;clientCache&gt;<ept id="p1">](http://www.iis.net/configreference/system.webserver/staticcontent/clientcache)</ept>。</source>
          <target state="new">有关如何配置 <ph id="ph1">`&lt;clientCache&gt;`</ph> 元素的详细信息，请参阅<bpt id="p1">[</bpt>客户端缓存 &amp;lt;clientCache&gt;<ept id="p1">](http://www.iis.net/configreference/system.webserver/staticcontent/clientcache)</ept>。</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>在下一部分，我还将向你演示如何针对 CDN 缓存中的控制器操作结果配置缓存设置。</source>
          <target state="new">在下一部分，我还将向你演示如何针对 CDN 缓存中的控制器操作结果配置缓存设置。</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;a name="serve-content-from-controller-actions-through-azure-cdn"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 通过 Azure CDN 的控制器操作提供内容</source>
          <target state="new"><ph id="ph1">&lt;a name="serve-content-from-controller-actions-through-azure-cdn"&gt;</ph><ph id="ph2">&lt;/a&gt;</ph> 通过 Azure CDN 的控制器操作提供内容</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>将 Web 应用与 Azure CDN 集成以后，可以相对轻松地通过 Azure CDN 的控制器操作提供内容。同样，如果你决定通过 CDN 提供整个 Azure Web 应用，则根本不需要执行此操作，因为此时所有控制器操作都已经可以通过 CDN 进行访问。不过，出于我在<bpt id="p1">[</bpt>通过集成 CDN 终结点部署 Azure Web 应用<ept id="p1">](#deploy-a-web-app-to-azure-with-an-integrated-cdn-endpoint)</ept>中指出的原因，你不应该决定执行这样的操作，而应选择需要通过 Azure CDN 来处理的控制器操作。<bpt id="p2">[</bpt>Maarten Balliauw<ept id="p2">](https://twitter.com/maartenballiauw)</ept> 在<bpt id="p3">[</bpt>通过 Azure CDN 减少 Web 延迟<ept id="p3">](http://channel9.msdn.com/events/TechDays/Techdays-2014-the-Netherlands/Reducing-latency-on-the-web-with-the-Windows-Azure-CDN)</ept>中向你演示了如何使用有趣的 MemeGenerator 控制器执行该操作。在这里，我将简单地再现该过程。</source>
          <target state="new">将 Web 应用与 Azure CDN 集成以后，可以相对轻松地通过 Azure CDN 的控制器操作提供内容。同样，如果你决定通过 CDN 提供整个 Azure Web 应用，则根本不需要执行此操作，因为此时所有控制器操作都已经可以通过 CDN 进行访问。不过，出于我在<bpt id="p1">[</bpt>通过集成 CDN 终结点部署 Azure Web 应用<ept id="p1">](#deploy-a-web-app-to-azure-with-an-integrated-cdn-endpoint)</ept>中指出的原因，你不应该决定执行这样的操作，而应选择需要通过 Azure CDN 来处理的控制器操作。<bpt id="p2">[</bpt>Maarten Balliauw<ept id="p2">](https://twitter.com/maartenballiauw)</ept> 在<bpt id="p3">[</bpt>通过 Azure CDN 减少 Web 延迟<ept id="p3">](http://channel9.msdn.com/events/TechDays/Techdays-2014-the-Netherlands/Reducing-latency-on-the-web-with-the-Windows-Azure-CDN)</ept>中向你演示了如何使用有趣的 MemeGenerator 控制器执行该操作。在这里，我将简单地再现该过程。</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>假设在你的 Web 应用中，你希望根据年轻的 Chuck Norris 的照片（由 <bpt id="p1">[</bpt>Alan Light<ept id="p1">](http://www.flickr.com/photos/alan-light/218493788/)</ept> 拍摄）来制作一个搞笑的迷因，如下所示：</source>
          <target state="new">假设在你的 Web 应用中，你希望根据年轻的 Chuck Norris 的照片（由 <bpt id="p1">[</bpt>Alan Light<ept id="p1">](http://www.flickr.com/photos/alan-light/218493788/)</ept> 拍摄）来制作一个搞笑的迷因，如下所示：</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>你提供了一个简单的 <ph id="ph1">`Index`</ph> 操作，让客户能够指定照片中的夸张元素，然后待这些元素发布到操作后制作出迷因。由于这是 Chuck Norris，可以想见该页面会在全球热传。这是通过 Azure CDN 提供半动态内容的一个很好的示例。</source>
          <target state="new">你提供了一个简单的 <ph id="ph1">`Index`</ph> 操作，让客户能够指定照片中的夸张元素，然后待这些元素发布到操作后制作出迷因。由于这是 Chuck Norris，可以想见该页面会在全球热传。这是通过 Azure CDN 提供半动态内容的一个很好的示例。</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>按照上述步骤设置此控制器操作：</source>
          <target state="new">按照上述步骤设置此控制器操作：</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">*</bpt>\\Controllers<ept id="p1">*</ept> 文件夹中，创建一个新的名为 <bpt id="p2">*</bpt>MemeGeneratorController.cs<ept id="p2">*</ept> 的 .cs 文件，然后使用以下代码替换其中的内容。将 <ph id="ph1">`~/Content/chuck.bmp`</ph> 替换为你的文件路径，将 <ph id="ph2">`yourCDNName`</ph> 替换为你的 CDN 名称。</source>
          <target state="new">在 <bpt id="p1">*</bpt>\\Controllers<ept id="p1">*</ept> 文件夹中，创建一个新的名为 <bpt id="p2">*</bpt>MemeGeneratorController.cs<ept id="p2">*</ept> 的 .cs 文件，然后使用以下代码替换其中的内容。将 <ph id="ph1">`~/Content/chuck.bmp`</ph> 替换为你的文件路径，将 <ph id="ph2">`yourCDNName`</ph> 替换为你的 CDN 名称。</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>右键单击默认的 <ph id="ph1">`Index()`</ph> 操作，然后选择“添加视图”。</source>
          <target state="new">右键单击默认的 <ph id="ph1">`Index()`</ph> 操作，然后选择“添加视图”。</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>接受下面的设置，然后单击“添加”。</source>
          <target state="new">接受下面的设置，然后单击“添加”。</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>打开这个新的 <bpt id="p1">*</bpt>Views\\MemeGenerator\\Index.cshtml<ept id="p1">*</ept>，将其中的内容替换为下面这个简单的 HTML，以便提交夸张元素：</source>
          <target state="new">打开这个新的 <bpt id="p1">*</bpt>Views\\MemeGenerator\\Index.cshtml<ept id="p1">*</ept>，将其中的内容替换为下面这个简单的 HTML，以便提交夸张元素：</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>重新发布到 Azure Web 应用，然后在浏览器中导航到 <bpt id="p1">*</bpt><bpt id="p2">*</bpt>http://<ept id="p2">*</ept>&amp;lt;serviceName&gt;<ept id="p1">*</ept>.chinacloudapp.cn/MemeGenerator/Index**。</source>
          <target state="new">重新发布到 Azure Web 应用，然后在浏览器中导航到 <bpt id="p1">*</bpt><bpt id="p2">*</bpt>http://<ept id="p2">*</ept>&amp;lt;serviceName&gt;<ept id="p1">*</ept>.chinacloudapp.cn/MemeGenerator/Index**。</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>当你将窗体值提交到 <ph id="ph1">`/MemeGenerator/Index`</ph> 时，<ph id="ph2">`Index_Post`</ph> 操作方法会返回一个指向 <ph id="ph3">`Show`</ph> 操作方法的链接，其中包含相应的输入标识符。单击该链接即可访问以下代码：</source>
          <target state="new">当你将窗体值提交到 <ph id="ph1">`/MemeGenerator/Index`</ph> 时，<ph id="ph2">`Index_Post`</ph> 操作方法会返回一个指向 <ph id="ph3">`Show`</ph> 操作方法的链接，其中包含相应的输入标识符。单击该链接即可访问以下代码：</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>如果连接了本地调试器，你就可以通过本地重定向获得常规的调试体验。如果是在 Azure Web 应用中运行，则会重定向到：</source>
          <target state="new">如果连接了本地调试器，你就可以通过本地重定向获得常规的调试体验。如果是在 Azure Web 应用中运行，则会重定向到：</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>这对应于 CDN 终结点的以下源 URL：</source>
          <target state="new">这对应于 CDN 终结点的以下源 URL：</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>由于已应用过 URL 重写规则，缓存到 CDN 终结点的实际文件为：</source>
          <target state="new">由于已应用过 URL 重写规则，缓存到 CDN 终结点的实际文件为：</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>然后，你可以使用 <ph id="ph1">`Generate`</ph> 方法的 <ph id="ph2">`OutputCacheAttribute`</ph> 属性来指定 Azure CDN 认可的操作结果缓存方式。以下代码指定缓存在 1 小时（3,600 秒）后过期。</source>
          <target state="new">然后，你可以使用 <ph id="ph1">`Generate`</ph> 方法的 <ph id="ph2">`OutputCacheAttribute`</ph> 属性来指定 Azure CDN 认可的操作结果缓存方式。以下代码指定缓存在 1 小时（3,600 秒）后过期。</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>同样，你可以使用所需的缓存选项，在 Azure Web 应用中通过 Azure CDN 的任何控制器操作提供内容。</source>
          <target state="new">同样，你可以使用所需的缓存选项，在 Azure Web 应用中通过 Azure CDN 的任何控制器操作提供内容。</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>在下一部分，我将向你演示如何通过 Azure CDN 提供绑定型和缩减型脚本和 CSS。</source>
          <target state="new">在下一部分，我将向你演示如何通过 Azure CDN 提供绑定型和缩减型脚本和 CSS。</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>将 ASP.NET 绑定和缩减与 Azure CDN 集成</source>
          <target state="new">将 ASP.NET 绑定和缩减与 Azure CDN 集成</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>脚本和 CSS 样式表很少变化，尤其适合 Azure CDN 缓存。若要将绑定和缩减集成到 Azure CDN，最便捷的方式是通过 Azure CDN 提供整个 Web 应用。不过，出于<bpt id="p1">[</bpt>将 Azure CDN 终结点与 Azure Web 应用集成，通过 Azure CDN 在网页中提供静态内容<ept id="p1">](#deploy-a-web-app-to-azure-with-an-integrated-cdn-endpoint)</ept>中描述的原因，你可能不倾向于选择此方法，因此我会向你演示如何在实现既定目标的同时，保留所需的有关 ASP.NET 绑定和缩减的开发人员体验，例如：</source>
          <target state="new">脚本和 CSS 样式表很少变化，尤其适合 Azure CDN 缓存。若要将绑定和缩减集成到 Azure CDN，最便捷的方式是通过 Azure CDN 提供整个 Web 应用。不过，出于<bpt id="p1">[</bpt>将 Azure CDN 终结点与 Azure Web 应用集成，通过 Azure CDN 在网页中提供静态内容<ept id="p1">](#deploy-a-web-app-to-azure-with-an-integrated-cdn-endpoint)</ept>中描述的原因，你可能不倾向于选择此方法，因此我会向你演示如何在实现既定目标的同时，保留所需的有关 ASP.NET 绑定和缩减的开发人员体验，例如：</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>理想的调试模式体验</source>
          <target state="new">理想的调试模式体验</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>简化的部署</source>
          <target state="new">简化的部署</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>即时更新客户端，进行脚本/CSS 版本升级</source>
          <target state="new">即时更新客户端，进行脚本/CSS 版本升级</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>在 CDN 终结点故障时适用的回退机制</source>
          <target state="new">在 CDN 终结点故障时适用的回退机制</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>最大程度减少代码修改</source>
          <target state="new">最大程度减少代码修改</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>在<bpt id="p1">[</bpt>将 Azure CDN 终结点与 Azure Web 应用集成，通过 Azure CDN 在网页中提供静态内容<ept id="p1">](#deploy-a-web-app-to-azure-with-an-integrated-cdn-endpoint)</ept>部分创建的 ASP.NET 项目中，打开 <bpt id="p2">*</bpt>App\_Start\\BundleConfig.cs<ept id="p2">*</ept>，然后查看 <ph id="ph1">`bundles.Add()`</ph> 方法调用情况。</source>
          <target state="new">在<bpt id="p1">[</bpt>将 Azure CDN 终结点与 Azure Web 应用集成，通过 Azure CDN 在网页中提供静态内容<ept id="p1">](#deploy-a-web-app-to-azure-with-an-integrated-cdn-endpoint)</ept>部分创建的 ASP.NET 项目中，打开 <bpt id="p2">*</bpt>App\_Start\\BundleConfig.cs<ept id="p2">*</ept>，然后查看 <ph id="ph1">`bundles.Add()`</ph> 方法调用情况。</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>第一个 <ph id="ph1">`bundles.Add()`</ph> 语句将脚本捆绑包添加到了虚拟目录 <ph id="ph2">`~/bundles/jquery`</ph>。然后，打开 <bpt id="p1">*</bpt>Views\\Shared\_Layout.cshtml<ept id="p1">*</ept> 以查看脚本捆绑包标记的呈现方式。你应该能够找到以下 Razor 代码行：</source>
          <target state="new">第一个 <ph id="ph1">`bundles.Add()`</ph> 语句将脚本捆绑包添加到了虚拟目录 <ph id="ph2">`~/bundles/jquery`</ph>。然后，打开 <bpt id="p1">*</bpt>Views\\Shared\_Layout.cshtml<ept id="p1">*</ept> 以查看脚本捆绑包标记的呈现方式。你应该能够找到以下 Razor 代码行：</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>当该 Razor 代码在 Azure Web 应用中运行时，它会呈现脚本捆绑包的 <ph id="ph1">`&lt;script&gt;`</ph> 标记，如下所示：</source>
          <target state="new">当该 Razor 代码在 Azure Web 应用中运行时，它会呈现脚本捆绑包的 <ph id="ph1">`&lt;script&gt;`</ph> 标记，如下所示：</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>但是，通过键入 <ph id="ph1">`F5`</ph> 而让其在 Visual Studio 中运行时，它会逐一呈现捆绑包中的每个脚本文件（在上面的示例中，捆绑包中只有一个脚本文件）：</source>
          <target state="new">但是，通过键入 <ph id="ph1">`F5`</ph> 而让其在 Visual Studio 中运行时，它会逐一呈现捆绑包中的每个脚本文件（在上面的示例中，捆绑包中只有一个脚本文件）：</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>这样可以让你在开发环境中调试 JavaScript 代码时，减少生产环境中出现的并发客户端连接（绑定），改进文件下载性能（缩减）。这是一项很适合保留在 Azure CDN 集成中的功能。此外，由于呈现的捆绑包已包含自动生成的版本字符串，因此你希望能够复制该功能，这样当你通过 NuGet 更新 jQuery 版本时，就能够尽快在客户端进行相应的更新。</source>
          <target state="new">这样可以让你在开发环境中调试 JavaScript 代码时，减少生产环境中出现的并发客户端连接（绑定），改进文件下载性能（缩减）。这是一项很适合保留在 Azure CDN 集成中的功能。此外，由于呈现的捆绑包已包含自动生成的版本字符串，因此你希望能够复制该功能，这样当你通过 NuGet 更新 jQuery 版本时，就能够尽快在客户端进行相应的更新。</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>按照以下步骤操作，将 ASP.NET 绑定和缩减功能集成到 CDN 终结点。</source>
          <target state="new">按照以下步骤操作，将 ASP.NET 绑定和缩减功能集成到 CDN 终结点。</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>回到 <bpt id="p1">*</bpt>App\_Start\\BundleConfig.cs<ept id="p1">*</ept>，修改 <ph id="ph1">`bundles.Add()`</ph> 方法以使用其他<bpt id="p2">[</bpt>捆绑包构造函数<ept id="p2">](http://msdn.microsoft.com/zh-cn/library/jj646464.aspx)</ept>来指定 CDN 地址。为此，请使用以下代码替换 <ph id="ph2">`RegisterBundles`</ph> 方法定义：</source>
          <target state="new">回到 <bpt id="p1">*</bpt>App\_Start\\BundleConfig.cs<ept id="p1">*</ept>，修改 <ph id="ph1">`bundles.Add()`</ph> 方法以使用其他<bpt id="p2">[</bpt>捆绑包构造函数<ept id="p2">](http://msdn.microsoft.com/zh-cn/library/jj646464.aspx)</ept>来指定 CDN 地址。为此，请使用以下代码替换 <ph id="ph2">`RegisterBundles`</ph> 方法定义：</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>请确保将 <ph id="ph1">`&lt;yourCDNName&gt;`</ph> 替换为你的 Azure CDN 的名称。</source>
          <target state="new">请确保将 <ph id="ph1">`&lt;yourCDNName&gt;`</ph> 替换为你的 Azure CDN 的名称。</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>你将使用纯单词来设置 <ph id="ph1">`bundles.UseCdn = true`</ph> 并已经将仔细编写的 CDN URL 添加到了每个捆绑包。例如，代码中的第一个构造函数：</source>
          <target state="new">你将使用纯单词来设置 <ph id="ph1">`bundles.UseCdn = true`</ph> 并已经将仔细编写的 CDN URL 添加到了每个捆绑包。例如，代码中的第一个构造函数：</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>相当于：</source>
          <target state="new">相当于：</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>进行本地调试时，此构造函数会指示 ASP.NET 绑定和缩减功能呈现各个脚本文件，但会使用指定的 CDN 地址来访问相关脚本。不过，请注意这个仔细编写的 CDN URL 存在两个重要的特征：</source>
          <target state="new">进行本地调试时，此构造函数会指示 ASP.NET 绑定和缩减功能呈现各个脚本文件，但会使用指定的 CDN 地址来访问相关脚本。不过，请注意这个仔细编写的 CDN URL 存在两个重要的特征：</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>此 CDN URL 的源是 <ph id="ph1">`http://&lt;yourSiteName&gt;.chinacloudsites.cn/bundles/jquery?v=&lt;W.X.Y.Z&gt;`</ph>，这实际上是 Web 应用中脚本捆绑包的虚拟目录。</source>
          <target state="new">此 CDN URL 的源是 <ph id="ph1">`http://&lt;yourSiteName&gt;.chinacloudsites.cn/bundles/jquery?v=&lt;W.X.Y.Z&gt;`</ph>，这实际上是 Web 应用中脚本捆绑包的虚拟目录。</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>由于你使用的是 CDN 构造函数，因此捆绑包的 CDN 脚本标记不再包含在呈现的 URL 中自动生成的版本字符串。每次对脚本捆绑包进行修改而造成 Azure CDN 中出现缓存未命中的情况时，你都必须手动生成唯一的脚本字符串。同时，这个唯一的版本字符串在部署过程中必须保持不变，以便在捆绑包部署完以后，最大程度地提高 Azure CDN 中的缓存命中率。</source>
          <target state="new">由于你使用的是 CDN 构造函数，因此捆绑包的 CDN 脚本标记不再包含在呈现的 URL 中自动生成的版本字符串。每次对脚本捆绑包进行修改而造成 Azure CDN 中出现缓存未命中的情况时，你都必须手动生成唯一的脚本字符串。同时，这个唯一的版本字符串在部署过程中必须保持不变，以便在捆绑包部署完以后，最大程度地提高 Azure CDN 中的缓存命中率。</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>查询字符串 v=&lt;W.X.Y.Z&gt; 的功能是从 ASP.NET 项目中的 <bpt id="p1">*</bpt>Properties\\AssemblyInfo.cs<ept id="p1">*</ept> 进行拉取。你可以建立一个部署工作流，这样当你每次将相关内容发布到 Azure 时，程序集版本就会递增一次。你也可以使用通配符“*”直接修改项目中的 <bpt id="p2">*</bpt>Properties\\AssemblyInfo.cs<ept id="p2">*</ept>，以便每次进行构建时让版本字符串自动递增。例如：</source>
          <target state="new">查询字符串 v=&lt;W.X.Y.Z&gt; 的功能是从 ASP.NET 项目中的 <bpt id="p1">*</bpt>Properties\\AssemblyInfo.cs<ept id="p1">*</ept> 进行拉取。你可以建立一个部署工作流，这样当你每次将相关内容发布到 Azure 时，程序集版本就会递增一次。你也可以使用通配符“*”直接修改项目中的 <bpt id="p2">*</bpt>Properties\\AssemblyInfo.cs<ept id="p2">*</ept>，以便每次进行构建时让版本字符串自动递增。例如：</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>在这里，你可以使用任何其他的策略来简化部署过程中唯一字符串的生成。</source>
          <target state="new">在这里，你可以使用任何其他的策略来简化部署过程中唯一字符串的生成。</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>重新发布 ASP.NET 应用程序并访问主页。</source>
          <target state="new">重新发布 ASP.NET 应用程序并访问主页。</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>查看页面的 HTML 代码。每次重新发布对 Azure Web 应用的更改时，你都应该能够看到所呈现的 CDN URL，其中包含唯一版本字符串。例如：</source>
          <target state="new">查看页面的 HTML 代码。每次重新发布对 Azure Web 应用的更改时，你都应该能够看到所呈现的 CDN URL，其中包含唯一版本字符串。例如：</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>在 Visual Studio 中，键入 <ph id="ph1">`F5`</ph> 即可调试 ASP.NET 应用程序。</source>
          <target state="new">在 Visual Studio 中，键入 <ph id="ph1">`F5`</ph> 即可调试 ASP.NET 应用程序。</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>查看页面的 HTML 代码。你仍然会看到每个脚本文件独立呈现，因此，你在 Visual Studio 中的调试体验是一致的。</source>
          <target state="new">查看页面的 HTML 代码。你仍然会看到每个脚本文件独立呈现，因此，你在 Visual Studio 中的调试体验是一致的。</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>CDN URL 的回退机制</source>
          <target state="new">CDN URL 的回退机制</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>你希望你的网页在 Azure CDN 终结点因某种原因而出现故障时，能够表现出相当的智能，即能够访问作为回退选项的源 Web 服务器，以便加载 JavaScript 或 Bootstrap。因 CDN 不可用而丢失 Web 应用上的图像是很严重的问题，但更为严重的是失去脚本和样式表提供的重要页面功能。</source>
          <target state="new">你希望你的网页在 Azure CDN 终结点因某种原因而出现故障时，能够表现出相当的智能，即能够访问作为回退选项的源 Web 服务器，以便加载 JavaScript 或 Bootstrap。因 CDN 不可用而丢失 Web 应用上的图像是很严重的问题，但更为严重的是失去脚本和样式表提供的重要页面功能。</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>捆绑包<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/system.web.optimization.bundle.aspx)</ept>类包含一个名为 <bpt id="p2">[</bpt>CdnFallbackExpression<ept id="p2">](http://msdn.microsoft.com/zh-cn/library/system.web.optimization.bundle.cdnfallbackexpression.aspx)</ept> 的属性，该属性可以让你配置回退机制以应对 CDN 故障情况。若要使用此属性，请执行以下步骤：</source>
          <target state="new"><bpt id="p1">[</bpt>捆绑包<ept id="p1">](http://msdn.microsoft.com/zh-cn/library/system.web.optimization.bundle.aspx)</ept>类包含一个名为 <bpt id="p2">[</bpt>CdnFallbackExpression<ept id="p2">](http://msdn.microsoft.com/zh-cn/library/system.web.optimization.bundle.cdnfallbackexpression.aspx)</ept> 的属性，该属性可以让你配置回退机制以应对 CDN 故障情况。若要使用此属性，请执行以下步骤：</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>在 ASP.NET 项目中打开 <bpt id="p1">*</bpt>App\_Start\\BundleConfig.cs<ept id="p1">*</ept>（你已在其中将 CDN URL 添加到了每个<bpt id="p2">[</bpt>捆绑包构造函数<ept id="p2">](http://msdn.microsoft.com/zh-cn/library/jj646464.aspx)</ept>），然后将 <ph id="ph1">`CdnFallbackExpression`</ph> 代码添加到所示的四个位置，以便将回退机制添加到默认捆绑包中。</source>
          <target state="new">在 ASP.NET 项目中打开 <bpt id="p1">*</bpt>App\_Start\\BundleConfig.cs<ept id="p1">*</ept>（你已在其中将 CDN URL 添加到了每个<bpt id="p2">[</bpt>捆绑包构造函数<ept id="p2">](http://msdn.microsoft.com/zh-cn/library/jj646464.aspx)</ept>），然后将 <ph id="ph1">`CdnFallbackExpression`</ph> 代码添加到所示的四个位置，以便将回退机制添加到默认捆绑包中。</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>当 <ph id="ph1">`CdnFallbackExpression`</ph> 不为 null 时，会将脚本注入 HTML 中以测试捆绑包是否已成功加载，而如果没有成功加载，则会直接从源 Web 服务器访问捆绑包。需要将此属性设置成一个 JavaScript 表达式，以便测试相应的 CDN 捆绑包是否已正确加载。根据内容的不同，测试每个捆绑包所需的表达式也会有所不同。对于上面的默认捆绑包：</source>
          <target state="new">当 <ph id="ph1">`CdnFallbackExpression`</ph> 不为 null 时，会将脚本注入 HTML 中以测试捆绑包是否已成功加载，而如果没有成功加载，则会直接从源 Web 服务器访问捆绑包。需要将此属性设置成一个 JavaScript 表达式，以便测试相应的 CDN 捆绑包是否已正确加载。根据内容的不同，测试每个捆绑包所需的表达式也会有所不同。对于上面的默认捆绑包：</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`window.jquery`</ph> 在 jquery-{version}.js 中定义</source>
          <target state="new"><ph id="ph1">`window.jquery`</ph> 在 jquery-{version}.js 中定义</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`$.validator`</ph> 在 jquery.validate.js 中定义</source>
          <target state="new"><ph id="ph1">`$.validator`</ph> 在 jquery.validate.js 中定义</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`window.Modernizr`</ph> 在 modernizer-{version}.js 中定义</source>
          <target state="new"><ph id="ph1">`window.Modernizr`</ph> 在 modernizer-{version}.js 中定义</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`$.fn.modal`</ph> 在 bootstrap.js 中定义</source>
          <target state="new"><ph id="ph1">`$.fn.modal`</ph> 在 bootstrap.js 中定义</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>你可能已注意到，我并没有为 <ph id="ph1">`~/Cointent/css`</ph> 捆绑包设置 CdnFallbackExpression。这是因为，目前 <bpt id="p1">[</bpt>System.Web.Optimization 中的 Bug<ept id="p1">](https://aspnetoptimization.codeplex.com/workitem/104)</ept> 会针对回退 CSS 注入 <ph id="ph2">`&lt;script&gt;`</ph> 标记而非预期的 <ph id="ph3">`&lt;link&gt;`</ph> 标记。</source>
          <target state="new">你可能已注意到，我并没有为 <ph id="ph1">`~/Cointent/css`</ph> 捆绑包设置 CdnFallbackExpression。这是因为，目前 <bpt id="p1">[</bpt>System.Web.Optimization 中的 Bug<ept id="p1">](https://aspnetoptimization.codeplex.com/workitem/104)</ept> 会针对回退 CSS 注入 <ph id="ph2">`&lt;script&gt;`</ph> 标记而非预期的 <ph id="ph3">`&lt;link&gt;`</ph> 标记。</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>不过，你可以使用一个不错的<bpt id="p1">[</bpt>样式捆绑包回退<ept id="p1">](https://github.com/EmberConsultingGroup/StyleBundleFallback)</ept>，是由 <bpt id="p2">[</bpt>Ember 咨询组<ept id="p2">](https://github.com/EmberConsultingGroup)</ept> 提供的。</source>
          <target state="new">不过，你可以使用一个不错的<bpt id="p1">[</bpt>样式捆绑包回退<ept id="p1">](https://github.com/EmberConsultingGroup/StyleBundleFallback)</ept>，是由 <bpt id="p2">[</bpt>Ember 咨询组<ept id="p2">](https://github.com/EmberConsultingGroup)</ept> 提供的。</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>若要将此解决方法用于 CSS，可在 ASP.NET 项目的 <bpt id="p1">*</bpt>App\_Start<ept id="p1">*</ept> 文件夹中创建一个新的名为 <bpt id="p2">*</bpt>StyleBundleExtensions.cs<ept id="p2">*</ept> 的 .cs 文件，然后将其内容替换为 <bpt id="p3">[</bpt>GitHub 提供的代码<ept id="p3">](https://github.com/EmberConsultingGroup/StyleBundleFallback/blob/master/Website/App_Start/StyleBundleExtensions.cs)</ept>。</source>
          <target state="new">若要将此解决方法用于 CSS，可在 ASP.NET 项目的 <bpt id="p1">*</bpt>App\_Start<ept id="p1">*</ept> 文件夹中创建一个新的名为 <bpt id="p2">*</bpt>StyleBundleExtensions.cs<ept id="p2">*</ept> 的 .cs 文件，然后将其内容替换为 <bpt id="p3">[</bpt>GitHub 提供的代码<ept id="p3">](https://github.com/EmberConsultingGroup/StyleBundleFallback/blob/master/Website/App_Start/StyleBundleExtensions.cs)</ept>。</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>在 <bpt id="p1">*</bpt>App\_Start\\StyleFundleExtensions.cs<ept id="p1">*</ept> 中，将命名空间重命名为你的 ASP.NET 应用程序的命名空间（例如 <bpt id="p2">**</bpt>cdnwebapp<ept id="p2">**</ept>）。</source>
          <target state="new">在 <bpt id="p1">*</bpt>App\_Start\\StyleFundleExtensions.cs<ept id="p1">*</ept> 中，将命名空间重命名为你的 ASP.NET 应用程序的命名空间（例如 <bpt id="p2">**</bpt>cdnwebapp<ept id="p2">**</ept>）。</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>回到 <ph id="ph1">`App_Start\BundleConfig.cs`</ph>，将最后一个 <ph id="ph2">`bundles.Add`</ph> 语句替换为以下代码：</source>
          <target state="new">回到 <ph id="ph1">`App_Start\BundleConfig.cs`</ph>，将最后一个 <ph id="ph2">`bundles.Add`</ph> 语句替换为以下代码：</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>这个新的扩展方法使用相同的机制将脚本注入 HTML 中，以便查看 DOM 中是否存在匹配的类名、规则名和规则值（在 CSS 捆绑包中定义），如果没有找到匹配项，则会回退到源 Web 服务器。</source>
          <target state="new">这个新的扩展方法使用相同的机制将脚本注入 HTML 中，以便查看 DOM 中是否存在匹配的类名、规则名和规则值（在 CSS 捆绑包中定义），如果没有找到匹配项，则会回退到源 Web 服务器。</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>重新发布到 Azure Web 应用并访问主页。</source>
          <target state="new">重新发布到 Azure Web 应用并访问主页。</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>查看页面的 HTML 代码。你会发现如下所示的已注入脚本：</source>
          <target state="new">查看页面的 HTML 代码。你会发现如下所示的已注入脚本：</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>请注意，CSS 捆绑包的注入脚本仍包含以下行中 <ph id="ph1">`CdnFallbackExpression`</ph> 属性的残存错误：</source>
          <target state="new">请注意，CSS 捆绑包的注入脚本仍包含以下行中 <ph id="ph1">`CdnFallbackExpression`</ph> 属性的残存错误：</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>不过，由于 || 表达式的第一部分始终会返回 true（在紧邻其上的行中），因此始终不会运行 document.write() 函数。</source>
          <target state="new">不过，由于 || 表达式的第一部分始终会返回 true（在紧邻其上的行中），因此始终不会运行 document.write() 函数。</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>若要测试该回退脚本是否可正常运行，请回到 CDN 终结点的仪表板，然后单击“禁用终结点”。</source>
          <target state="new">若要测试该回退脚本是否可正常运行，请回到 CDN 终结点的仪表板，然后单击“禁用终结点”。</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>刷新 Azure Web 应用的浏览器窗口。你现在应该会看到所有脚本和样式表都已正常加载。</source>
          <target state="new">刷新 Azure Web 应用的浏览器窗口。你现在应该会看到所有脚本和样式表都已正常加载。</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>更多信息</source>
          <target state="new">更多信息</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Azure 内容交付网络 (CDN) 概述</source>
          <target state="new">Azure 内容交付网络 (CDN) 概述</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>ASP.NET 绑定和缩减</source>
          <target state="new">ASP.NET 绑定和缩减</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>