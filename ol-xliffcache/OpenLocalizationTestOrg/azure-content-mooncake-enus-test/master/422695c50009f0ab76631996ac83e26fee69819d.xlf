<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="en-us">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht</xliffext:oltranslationpriority>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">422695c50009f0ab76631996ac83e26fee69819d</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-02a95cf" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>如何使用 CoreOS | Azure</source>
          <target state="new">如何使用 CoreOS | Azure</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>介绍 CoreOS、如何在 Azure 上使用经典部署模型创建 CoreOS 虚拟机群集及其基本用法。</source>
          <target state="new">介绍 CoreOS、如何在 Azure 上使用经典部署模型创建 CoreOS 虚拟机群集及其基本用法。</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>如何在 Azure 上使用 CoreOS</source>
          <target state="new">如何在 Azure 上使用 CoreOS</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>本主题介绍 <bpt id="p1">[</bpt><ept id="p1">CoreOS]</ept> 并演示如何在 Azure 上创建三个 CoreOS 虚拟机构成的群集，以帮助你快速了解此操作系统。它使用非常基本的 CoreOS 部署元素和来自 <bpt id="p2">[</bpt><ept id="p2">CoreOS 与 Azure]</ept>、<bpt id="p3">[</bpt><ept id="p3">Tim Park 的 CoreOS 教程]</ept>和 <bpt id="p4">[</bpt><ept id="p4">Patrick Chanezon 的 CoreOS 教程]</ept>中的示例，演示了解 CoreOS 部署的基本结构及成功运行三个虚拟机构成的群集的绝对最低要求。</source>
          <target state="new">本主题介绍 <bpt id="p1">[</bpt><ept id="p1">CoreOS]</ept> 并演示如何在 Azure 上创建三个 CoreOS 虚拟机构成的群集，以帮助你快速了解此操作系统。它使用非常基本的 CoreOS 部署元素和来自 <bpt id="p2">[</bpt><ept id="p2">CoreOS 与 Azure]</ept>、<bpt id="p3">[</bpt><ept id="p3">Tim Park 的 CoreOS 教程]</ept>和 <bpt id="p4">[</bpt><ept id="p4">Patrick Chanezon 的 CoreOS 教程]</ept>中的示例，演示了解 CoreOS 部署的基本结构及成功运行三个虚拟机构成的群集的绝对最低要求。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>[AZURE.INCLUDE <bpt id="p1">[</bpt>了解部署模型<ept id="p1">](../includes/learn-about-deployment-models-classic-include.md)</ept>]</source>
          <target state="new">[AZURE.INCLUDE <bpt id="p1">[</bpt>了解部署模型<ept id="p1">](../includes/learn-about-deployment-models-classic-include.md)</ept>]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>CoreOS、群集和 Linux 容器</source>
          <target state="new">CoreOS、群集和 Linux 容器</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>CoreOS 是 Linux 的轻量级版本，旨在支持快速创建使用 Linux 容器作为唯一打包机制的可能的大型 VM 群集（包括 <bpt id="p1">[</bpt><ept id="p1">Docker]</ept> 容器）。CoreOS 旨在支持：</source>
          <target state="new">CoreOS 是 Linux 的轻量级版本，旨在支持快速创建使用 Linux 容器作为唯一打包机制的可能的大型 VM 群集（包括 <bpt id="p1">[</bpt><ept id="p1">Docker]</ept> 容器）。CoreOS 旨在支持：</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>高度自动化</source>
          <target state="new">高度自动化</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>更轻松且更一致的应用程序部署</source>
          <target state="new">更轻松且更一致的应用程序部署</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>应用程序级别和系统级别的可伸缩性</source>
          <target state="new">应用程序级别和系统级别的可伸缩性</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>概括而言，支持这些目标的 CoreOS 功能包括：</source>
          <target state="new">概括而言，支持这些目标的 CoreOS 功能包括：</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>单一打包系统：CoreOS 仅运行可在 Linux 容器中运行，以取得部署速度、一致性和方便性的 Linux 容器映像</source>
          <target state="new">单一打包系统：CoreOS 仅运行可在 Linux 容器中运行，以取得部署速度、一致性和方便性的 Linux 容器映像</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>系统会自动执行操作系统更新，这样一来，操作系统会作为单个实体进行更新，并且可以轻松回退到已知状态</source>
          <target state="new">系统会自动执行操作系统更新，这样一来，操作系统会作为单个实体进行更新，并且可以轻松回退到已知状态</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>内置用于动态 VM 和群集通信与管理的 <bpt id="p1">[</bpt>etcd<ept id="p1">](https://github.com/coreos/etcd)</ept> 和 <bpt id="p2">[</bpt>fleet<ept id="p2">](https://github.com/coreos/fleet)</ept> 守护程序（服务）</source>
          <target state="new">内置用于动态 VM 和群集通信与管理的 <bpt id="p1">[</bpt>etcd<ept id="p1">](https://github.com/coreos/etcd)</ept> 和 <bpt id="p2">[</bpt>fleet<ept id="p2">](https://github.com/coreos/fleet)</ept> 守护程序（服务）</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>这是对 CoreOS 及其功能的概要说明。有关 CoreOS 更完整的信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">CoreOS 概述]</ept>。</source>
          <target state="new">这是对 CoreOS 及其功能的概要说明。有关 CoreOS 更完整的信息，请参阅 <bpt id="p1">[</bpt><ept id="p1">CoreOS 概述]</ept>。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>安全注意事项</source>
          <target state="new">安全注意事项</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>目前，CoreOS 假定可以通过 SSH 进入群集的人员有权对群集进行管理。因此，在不进行修改的情况下，CoreOS 群集在测试和开发环境中的表现也相当出色，但你应该在所有生产环境中应用更多安全措施。</source>
          <target state="new">目前，CoreOS 假定可以通过 SSH 进入群集的人员有权对群集进行管理。因此，在不进行修改的情况下，CoreOS 群集在测试和开发环境中的表现也相当出色，但你应该在所有生产环境中应用更多安全措施。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>如何在 Azure 上使用 CoreOS</source>
          <target state="new">如何在 Azure 上使用 CoreOS</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>本部分介绍如何使用 <bpt id="p1">[</bpt><ept id="p1">Azure 命令行界面 (Azure CLI)]</ept>，创建拥有三个 CoreOS 虚拟机的 Azure 云服务。基本步骤如下所示：</source>
          <target state="new">本部分介绍如何使用 <bpt id="p1">[</bpt><ept id="p1">Azure 命令行界面 (Azure CLI)]</ept>，创建拥有三个 CoreOS 虚拟机的 Azure 云服务。基本步骤如下所示：</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>创建 SSH 证书和密钥，以保护与 CoreOS 虚拟机的通信安全</source>
          <target state="new">创建 SSH 证书和密钥，以保护与 CoreOS 虚拟机的通信安全</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>获取群集的 etcd id 以互相通信</source>
          <target state="new">获取群集的 etcd id 以互相通信</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>创建 <bpt id="p1">[</bpt><ept id="p1">YAML]</ept> 格式的 cloud-config 文件</source>
          <target state="new">创建 <bpt id="p1">[</bpt><ept id="p1">YAML]</ept> 格式的 cloud-config 文件</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>使用 Azure CLI 创建新的 Azure 云服务和三个 CoreOS VM</source>
          <target state="new">使用 Azure CLI 创建新的 Azure 云服务和三个 CoreOS VM</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>在 Azure VM 中测试你的 CoreOS 群集</source>
          <target state="new">在 Azure VM 中测试你的 CoreOS 群集</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>在 localhost 中测试你的 CoreOS 群集</source>
          <target state="new">在 localhost 中测试你的 CoreOS 群集</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>创建用于通信的公钥和私钥</source>
          <target state="new">创建用于通信的公钥和私钥</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>按照<bpt id="p1">[</bpt>如何在 Azure 上通过 Linux 使用 SSH<ept id="p1">](/documentation/articles/virtual-machines-linux-use-ssh-key)</ept> 中的说明，创建用于 SSH 的公钥和私钥。（可在下面的说明中找到基本步骤。） 你将使用这些密钥连接到群集中的 VM，以验证它们是否可以正常工作并互相通信。</source>
          <target state="new">按照<bpt id="p1">[</bpt>如何在 Azure 上通过 Linux 使用 SSH<ept id="p1">](/documentation/articles/virtual-machines-linux-use-ssh-key)</ept> 中的说明，创建用于 SSH 的公钥和私钥。（可在下面的说明中找到基本步骤。） 你将使用这些密钥连接到群集中的 VM，以验证它们是否可以正常工作并互相通信。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>本主题假定你没有这些密钥，为了让你明了操作过程，将要求你创建 <ph id="ph2">`myPrivateKey.pem`</ph> 和 <ph id="ph3">`myCert.pem`</ph> 文件。如果已将公钥和私钥对保存到 <ph id="ph4">`~/.ssh/id_rsa`</ph>，只需键入 <ph id="ph5">`openssl req -x509 -key ~/.ssh/id_rsa -nodes -days 365 -newkey rsa:2048 -out myCert.pem`</ph> 即可获取需要上载到 Azure 的 .pem 文件。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>本主题假定你没有这些密钥，为了让你明了操作过程，将要求你创建 <ph id="ph2">`myPrivateKey.pem`</ph> 和 <ph id="ph3">`myCert.pem`</ph> 文件。如果已将公钥和私钥对保存到 <ph id="ph4">`~/.ssh/id_rsa`</ph>，只需键入 <ph id="ph5">`openssl req -x509 -key ~/.ssh/id_rsa -nodes -days 365 -newkey rsa:2048 -out myCert.pem`</ph> 即可获取需要上载到 Azure 的 .pem 文件。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>在工作目录中，键入 <ph id="ph1">`openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout myPrivateKey.key -out myCert.pem`</ph> 以创建私钥和与之关联的 X.509 证书。</source>
          <target state="new">在工作目录中，键入 <ph id="ph1">`openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout myPrivateKey.key -out myCert.pem`</ph> 以创建私钥和与之关联的 X.509 证书。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>若要判断私钥的所有者是否可以读取或写入文件，请键入 <ph id="ph1">`chmod 600 myPrivateKey.key`</ph>。</source>
          <target state="new">若要判断私钥的所有者是否可以读取或写入文件，请键入 <ph id="ph1">`chmod 600 myPrivateKey.key`</ph>。</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>你的工作目录中现在应同时包含 <ph id="ph1">`myPrivateKey.key`</ph> 和 <ph id="ph2">`myCert.pem`</ph> 文件。</source>
          <target state="new">你的工作目录中现在应同时包含 <ph id="ph1">`myPrivateKey.key`</ph> 和 <ph id="ph2">`myCert.pem`</ph> 文件。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>获取群集的 etcd id</source>
          <target state="new">获取群集的 etcd id</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>CoreOS 的 <ph id="ph1">`etcd`</ph> 守护程序需要发现 ID，以自动查询群集中的所有节点。若要检索你的发现 ID 并将其保存到 <ph id="ph2">`etcdid`</ph> 文件，请键入</source>
          <target state="new">CoreOS 的 <ph id="ph1">`etcd`</ph> 守护程序需要发现 ID，以自动查询群集中的所有节点。若要检索你的发现 ID 并将其保存到 <ph id="ph2">`etcdid`</ph> 文件，请键入</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>创建 cloud-config 文件</source>
          <target state="new">创建 cloud-config 文件</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>在相同的工作目录中，使用你最喜欢的文本编辑器创建包含以下文本的文件，并将其另存为 <ph id="ph1">`cloud-config.yaml`</ph>。（可以使用你想要的任何文件名将其保存，但在下一步创建 VM 时，必须在 <bpt id="p1">**</bpt>azure vm create<ept id="p1">**</ept> 命令的 <bpt id="p2">**</bpt>--custom-data<ept id="p2">**</ept> 选项中引用此文件的名称。）</source>
          <target state="new">在相同的工作目录中，使用你最喜欢的文本编辑器创建包含以下文本的文件，并将其另存为 <ph id="ph1">`cloud-config.yaml`</ph>。（可以使用你想要的任何文件名将其保存，但在下一步创建 VM 时，必须在 <bpt id="p1">**</bpt>azure vm create<ept id="p1">**</ept> 命令的 <bpt id="p2">**</bpt>--custom-data<ept id="p2">**</ept> 选项中引用此文件的名称。）</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>请记得键入 <ph id="ph2">`cat etcdid`</ph>，以从之前创建的 <ph id="ph3">`etcdid`</ph> 文件中检索 etcd 发现 id，并使用 <ph id="ph4">`etcdid`</ph> 文件生成的数字替换以下 <ph id="ph5">`cloud-config.yaml`</ph> 文件中的 <ph id="ph6">`&lt;token&gt;`</ph>。如果最后无法验证群集，这可能会是你忽略了的其中一个步骤！</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>请记得键入 <ph id="ph2">`cat etcdid`</ph>，以从之前创建的 <ph id="ph3">`etcdid`</ph> 文件中检索 etcd 发现 id，并使用 <ph id="ph4">`etcdid`</ph> 文件生成的数字替换以下 <ph id="ph5">`cloud-config.yaml`</ph> 文件中的 <ph id="ph6">`&lt;token&gt;`</ph>。如果最后无法验证群集，这可能会是你忽略了的其中一个步骤！</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>（有关 cloud-config 文件更完整的信息，请参阅 CoreOS 文档中的<bpt id="p1">[</bpt>使用 Cloud-Config<ept id="p1">](https://coreos.com/docs/cluster-management/setup/cloudinit-cloud-config/)</ept>。）</source>
          <target state="new">（有关 cloud-config 文件更完整的信息，请参阅 CoreOS 文档中的<bpt id="p1">[</bpt>使用 Cloud-Config<ept id="p1">](https://coreos.com/docs/cluster-management/setup/cloudinit-cloud-config/)</ept>。）</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>使用 Azure CLI 创建新的 CoreOS VM</source>
          <target state="new">使用 Azure CLI 创建新的 CoreOS VM</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>如果尚未安装 <bpt id="p1">[</bpt><ept id="p1">Azure 命令行界面 (Azure CLI)]</ept>，请先执行安装并使用工作或学校 ID 登录，或下载 .publishsettings 文件并将其导入你的帐户。</source>
          <target state="new">如果尚未安装 <bpt id="p1">[</bpt><ept id="p1">Azure 命令行界面 (Azure CLI)]</ept>，请先执行安装并使用工作或学校 ID 登录，或下载 .publishsettings 文件并将其导入你的帐户。</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>寻找 CoreOS 映像。若要查找随时可用的映像，请键入 <ph id="ph1">`azure vm image list | grep CoreOS`</ph>，然后就会看到类似于以下内容的结果列表：</source>
          <target state="new">寻找 CoreOS 映像。若要查找随时可用的映像，请键入 <ph id="ph1">`azure vm image list | grep CoreOS`</ph>，然后就会看到类似于以下内容的结果列表：</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>数据: 2b171e93f07c4903bcad35bda10acf22\_\_CoreOS-Stable-522.6.0 Public Linux</source>
          <target state="new">数据: 2b171e93f07c4903bcad35bda10acf22\_\_CoreOS-Stable-522.6.0 Public Linux</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>键入 <ph id="ph1">`azure service create &lt;cloud-service-name&gt;`</ph>（其中的 &lt;<bpt id="p1">*</bpt>cloud-service-name<ept id="p1">*</ept>&gt; 是你的 CoreOS 云服务的名称）可创建用于基本群集的云服务。此示例使用 <bpt id="p2">**</bpt><ph id="ph2">`coreos-cluster`</ph><ept id="p2">**</ept> 作为名称；你将需要重用所选名称来创建云服务内部的 CoreOS VM 实例。</source>
          <target state="new">键入 <ph id="ph1">`azure service create &lt;cloud-service-name&gt;`</ph>（其中的 &lt;<bpt id="p1">*</bpt>cloud-service-name<ept id="p1">*</ept>&gt; 是你的 CoreOS 云服务的名称）可创建用于基本群集的云服务。此示例使用 <bpt id="p2">**</bpt><ph id="ph2">`coreos-cluster`</ph><ept id="p2">**</ept> 作为名称；你将需要重用所选名称来创建云服务内部的 CoreOS VM 实例。</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>使用 <bpt id="p1">**</bpt>azure vm create<ept id="p1">**</ept> 命令可连接到你的云服务，并可在其中创建新的 CoreOS VM。你将在 <bpt id="p2">**</bpt>--ssh-cert<ept id="p2">**</ept> 选项中传递 X.509 证书的位置。通过键入以下命令创建你的第一个 VM 映像，请记得使用你创建的云服务名称替换 <bpt id="p3">**</bpt>coreos-cluster<ept id="p3">**</ept>：</source>
          <target state="new">使用 <bpt id="p1">**</bpt>azure vm create<ept id="p1">**</ept> 命令可连接到你的云服务，并可在其中创建新的 CoreOS VM。你将在 <bpt id="p2">**</bpt>--ssh-cert<ept id="p2">**</ept> 选项中传递 X.509 证书的位置。通过键入以下命令创建你的第一个 VM 映像，请记得使用你创建的云服务名称替换 <bpt id="p3">**</bpt>coreos-cluster<ept id="p3">**</ept>：</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>通过重复步骤 4 中的命令来创建第二个节点，使用 <bpt id="p1">**</bpt>node-2<ept id="p1">**</ept> 替换 <bpt id="p2">**</bpt>--vm-name<ept id="p2">**</ept> 值，并使用 2022 替换 <bpt id="p3">**</bpt>--ssh<ept id="p3">**</ept> 端口值。</source>
          <target state="new">通过重复步骤 4 中的命令来创建第二个节点，使用 <bpt id="p1">**</bpt>node-2<ept id="p1">**</ept> 替换 <bpt id="p2">**</bpt>--vm-name<ept id="p2">**</ept> 值，并使用 2022 替换 <bpt id="p3">**</bpt>--ssh<ept id="p3">**</ept> 端口值。</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>通过重复步骤 4 中的命令来创建第三个节点，使用 <bpt id="p1">**</bpt>node-3<ept id="p1">**</ept> 替换 <bpt id="p2">**</bpt>--vm-name<ept id="p2">**</ept> 值，并使用 3022 替换 <bpt id="p3">**</bpt>--ssh<ept id="p3">**</ept> 端口值。</source>
          <target state="new">通过重复步骤 4 中的命令来创建第三个节点，使用 <bpt id="p1">**</bpt>node-3<ept id="p1">**</ept> 替换 <bpt id="p2">**</bpt>--vm-name<ept id="p2">**</ept> 值，并使用 3022 替换 <bpt id="p3">**</bpt>--ssh<ept id="p3">**</ept> 端口值。</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>在 Azure VM 中测试你的 CoreOS 群集</source>
          <target state="new">在 Azure VM 中测试你的 CoreOS 群集</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>若要测试你的群集，请确保你位于工作目录中，然后使用 <bpt id="p1">**</bpt>ssh<ept id="p1">**</ept> 连接到 <bpt id="p2">**</bpt>node-1<ept id="p2">**</ept>，并通过键入以下命令传递私钥：</source>
          <target state="new">若要测试你的群集，请确保你位于工作目录中，然后使用 <bpt id="p1">**</bpt>ssh<ept id="p1">**</ept> 连接到 <bpt id="p2">**</bpt>node-1<ept id="p2">**</ept>，并通过键入以下命令传递私钥：</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>连接后，键入 <ph id="ph1">`sudo fleetctl list-machines`</ph> 以查看群集是否已识别出群集中的所有 VM。你应会收到类似于下面的响应：</source>
          <target state="new">连接后，键入 <ph id="ph1">`sudo fleetctl list-machines`</ph> 以查看群集是否已识别出群集中的所有 VM。你应会收到类似于下面的响应：</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>在 localhost 中测试你的 CoreOS 群集</source>
          <target state="new">在 localhost 中测试你的 CoreOS 群集</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>最后，让我们测试你本地 Linux 客户端中的 CoreOS 群集。你也许可以使用 <bpt id="p1">**</bpt>npm<ept id="p1">**</ept> 来安装 <bpt id="p2">**</bpt>fleetctl<ept id="p2">**</ept>；或者，你可能希望安装 <bpt id="p3">**</bpt>fleet<ept id="p3">**</ept> 并在本地客户端上自行构建 <bpt id="p4">**</bpt>fleetctl<ept id="p4">**</ept>。<bpt id="p5">**</bpt>fleet<ept id="p5">**</ept> 需要使用 <bpt id="p6">**</bpt>golang<ept id="p6">**</ept>，因此，你可能需要先安装后者，则需键入：</source>
          <target state="new">最后，让我们测试你本地 Linux 客户端中的 CoreOS 群集。你也许可以使用 <bpt id="p1">**</bpt>npm<ept id="p1">**</ept> 来安装 <bpt id="p2">**</bpt>fleetctl<ept id="p2">**</ept>；或者，你可能希望安装 <bpt id="p3">**</bpt>fleet<ept id="p3">**</ept> 并在本地客户端上自行构建 <bpt id="p4">**</bpt>fleetctl<ept id="p4">**</ept>。<bpt id="p5">**</bpt>fleet<ept id="p5">**</ept> 需要使用 <bpt id="p6">**</bpt>golang<ept id="p6">**</ept>，因此，你可能需要先安装后者，则需键入：</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>然后从 github 克隆 <bpt id="p1">**</bpt>fleet<ept id="p1">**</ept> 存储库，方法是键入：</source>
          <target state="new">然后从 github 克隆 <bpt id="p1">**</bpt>fleet<ept id="p1">**</ept> 存储库，方法是键入：</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>生成 <bpt id="p1">**</bpt>fleet<ept id="p1">**</ept>，方法是转到 <ph id="ph1">`fleet`</ph> 目录并键入</source>
          <target state="new">生成 <bpt id="p1">**</bpt>fleet<ept id="p1">**</ept>，方法是转到 <ph id="ph1">`fleet`</ph> 目录并键入</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>最后，添加 <bpt id="p1">**</bpt>fleet<ept id="p1">**</ept> 以便能够轻松使用（你可能需要也可能不需要 <bpt id="p2">**</bpt>sudo<ept id="p2">**</ept>，具体取决于你的配置）：</source>
          <target state="new">最后，添加 <bpt id="p1">**</bpt>fleet<ept id="p1">**</ept> 以便能够轻松使用（你可能需要也可能不需要 <bpt id="p2">**</bpt>sudo<ept id="p2">**</ept>，具体取决于你的配置）：</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>确保 <bpt id="p1">**</bpt>fleet<ept id="p1">**</ept> 能够访问工作目录中的 <ph id="ph1">`myPrivateKey.key`</ph>，方法是键入：</source>
          <target state="new">确保 <bpt id="p1">**</bpt>fleet<ept id="p1">**</ept> 能够访问工作目录中的 <ph id="ph1">`myPrivateKey.key`</ph>，方法是键入：</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[AZURE.NOTE]</ph>如果你已在使用 <ph id="ph2">`~/.ssh/id_rsa`</ph> 密钥，则使用 <ph id="ph3">`ssh-add ~/.ssh/id_rsa`</ph> 进行添加。</source>
          <target state="new"><ph id="ph1">[AZURE.NOTE]</ph>如果你已在使用 <ph id="ph2">`~/.ssh/id_rsa`</ph> 密钥，则使用 <ph id="ph3">`ssh-add ~/.ssh/id_rsa`</ph> 进行添加。</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>现在，你已准备好使用你在 <bpt id="p1">**</bpt>node-1<ept id="p1">**</ept> 中使用的相同 <bpt id="p2">**</bpt>fleetctl<ept id="p2">**</ept> 命令进行远程测试，但需要传递部分远程参数：</source>
          <target state="new">现在，你已准备好使用你在 <bpt id="p1">**</bpt>node-1<ept id="p1">**</ept> 中使用的相同 <bpt id="p2">**</bpt>fleetctl<ept id="p2">**</ept> 命令进行远程测试，但需要传递部分远程参数：</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>结果应完全相同：</source>
          <target state="new">结果应完全相同：</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>后续步骤</source>
          <target state="new">后续步骤</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>在 Azure 上，你现在应该拥有正常运行的三节点 CoreOS 群集。此后，你可以探索如何创建更复杂的群集、使用 Docker 和创建更有趣的应用程序。若要尝试操作几个快速示例，请参阅<bpt id="p1">[</bpt><ept id="p1">在 Azure 上的 CoreOS 上使用 Fleet 入门]</ept>。</source>
          <target state="new">在 Azure 上，你现在应该拥有正常运行的三节点 CoreOS 群集。此后，你可以探索如何创建更复杂的群集、使用 Docker 和创建更有趣的应用程序。若要尝试操作几个快速示例，请参阅<bpt id="p1">[</bpt><ept id="p1">在 Azure 上的 CoreOS 上使用 Fleet 入门]</ept>。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>